!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	srLib/srg/srgColor.h	/^	typedef struct _sRGBA { float R; float G; float B; float A; } SRGBA;$/;"	m	struct:srgColor::_sRGBA
ABx_lx	Eigen/src/Core/util/Constants.h	/^  ABx_lx              = 0x200,$/;"	e	enum:Eigen::DecompositionOptions
ACTTYPE	srLib/srDyn/srJoint.h	/^	enum ACTTYPE { PASSIVE, TORQUE, VELOCITY, HYBRID };$/;"	g	class:srJoint
AInertia	srLib/LieGroup/LieGroup.h	/^class AInertia$/;"	c
ALIVE	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define ALIVE /;"	d
ALLOC_BK	srLib/srDyn/srISLAND.cpp	/^#define ALLOC_BK(/;"	d	file:
AMDOrdering	Eigen/src/OrderingMethods/Ordering.h	/^class AMDOrdering$/;"	c	namespace:Eigen
ARCHITECTURE_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#   define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define ARCHITECTURE_ID$/;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#   define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define ARCHITECTURE_ID$/;"	d	file:
ATTRIBUTE_NAME	tinyxml2/tinyxml2.h	/^        ATTRIBUTE_NAME		            = 0,$/;"	e	enum:tinyxml2::StrPair::__anon478
ATTRIBUTE_VALUE	tinyxml2/tinyxml2.h	/^        ATTRIBUTE_VALUE		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon478
ATTRIBUTE_VALUE_LEAVE_ENTITIES	tinyxml2/tinyxml2.h	/^        ATTRIBUTE_VALUE_LEAVE_ENTITIES  = NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon478
Abs	srMath/Common.h	/^	static Real Abs(const Real& op)$/;"	f	namespace:srMath
AccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef ResPacket AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
AccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::AccPacket AccPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
AccPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type AccPacket;$/;"	t	class:Eigen::internal::gebp_traits
Accept	tinyxml2/tinyxml2.cpp	/^bool XMLComment::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLComment
Accept	tinyxml2/tinyxml2.cpp	/^bool XMLDeclaration::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLDeclaration
Accept	tinyxml2/tinyxml2.cpp	/^bool XMLDocument::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLDocument
Accept	tinyxml2/tinyxml2.cpp	/^bool XMLElement::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLElement
Accept	tinyxml2/tinyxml2.cpp	/^bool XMLText::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLText
Accept	tinyxml2/tinyxml2.cpp	/^bool XMLUnknown::Accept( XMLVisitor* visitor ) const$/;"	f	class:tinyxml2::XMLUnknown
AccessorLevels	Eigen/src/Core/util/Constants.h	/^enum AccessorLevels {$/;"	g	namespace:Eigen
Action	Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	g	namespace:Eigen
Activate	srLib/srDyn/srSpring.cpp	/^void srSpring::Activate(bool b)$/;"	f	class:srSpring
ActualCols	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualCols = Transpose ? MaxRows : MaxCols$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon117
ActualIndex	Eigen/src/Core/BandMatrix.h	/^        ActualIndex = ReturnOpposite ? -Index : Index,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon214
ActualLhsType	Eigen/src/Core/ProductBase.h	/^    typedef typename LhsBlasTraits::DirectLinearAccessType ActualLhsType;$/;"	t	class:Eigen::ProductBase
ActualLhsType	Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::DirectLinearAccessType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualLhsType	Eigen/src/Core/SolveTriangular.h	/^  typedef typename LhsProductTraits::ExtractType ActualLhsType;$/;"	t	struct:Eigen::internal::triangular_solver_selector
ActualPacketAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = 0x0;$/;"	m	namespace:Eigen
ActualPacketAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int ActualPacketAccessBit = PacketAccessBit;$/;"	m	namespace:Eigen
ActualRhsType	Eigen/src/Core/ProductBase.h	/^    typedef typename RhsBlasTraits::DirectLinearAccessType ActualRhsType;$/;"	t	class:Eigen::ProductBase
ActualRows	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      ActualRows = Transpose ? MaxCols : MaxRows,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon117
Ad	srMath/SE3.cpp	/^	Matrix6 SE3::Ad(const SE3& T)$/;"	f	class:srMath::SE3
Ad	srMath/SE3.cpp	/^	se3 SE3::Ad(const SE3& T, const se3& S)$/;"	f	class:srMath::SE3
AdMat	srLib/srExt/srExt_LieGroup.cpp	/^Eigen::Matrix6d srExt::AdMat(const SE3 & _T)$/;"	f	class:srExt
AddCollision	srLib/srDyn/srLink.cpp	/^bool srLink::AddCollision(srCollision* pCollision)$/;"	f	class:srLink
AddCost	Eigen/src/Core/NumTraits.h	/^    AddCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon337
AddObject	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::AddObject(srCollision* object)$/;"	f	class:srIRSensor
AddObject	srLib/srDyn/srObject.cpp	/^void srObject::AddObject(srObject* obj)$/;"	f	class:srObject
AddObject	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::AddObject(srCollision* object)$/;"	f	class:srRangeFinder
AddObject	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::AddObject(srCollision* object)$/;"	f	class:srTouchSensor
AddSensor	srLib/srDyn/srLink.cpp	/^bool srLink::AddSensor(srSensor* pSensor)$/;"	f	class:srLink
AddSpring	srLib/srDyn/srSpace.cpp	/^void srSpace::AddSpring(srSpring * s)$/;"	f	class:srSpace
AddSystem	srLib/srDyn/srSpace.cpp	/^void srSpace::AddSystem(srSystem * v)$/;"	f	class:srSpace
AddUserExternalForce	srLib/srDyn/srLink.cpp	/^void srLink::AddUserExternalForce(dse3 v)$/;"	f	class:srLink
AdjointReturnType	Eigen/src/Core/MatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::MatrixBase
AdjointReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type AdjointReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Affine	Eigen/src/Core/util/Constants.h	/^  Affine        = 0x2,$/;"	e	enum:Eigen::TransformTraits
Affine2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Affine> Affine2d;$/;"	t	namespace:Eigen
Affine2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Affine> Affine2f;$/;"	t	namespace:Eigen
Affine3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Affine> Affine3d;$/;"	t	namespace:Eigen
Affine3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Affine> Affine3f;$/;"	t	namespace:Eigen
AffineCompact	Eigen/src/Core/util/Constants.h	/^  AffineCompact = 0x10 | Affine,$/;"	e	enum:Eigen::TransformTraits
AffineCompact2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,AffineCompact> AffineCompact2d;$/;"	t	namespace:Eigen
AffineCompact2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,AffineCompact> AffineCompact2f;$/;"	t	namespace:Eigen
AffineCompact3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,AffineCompact> AffineCompact3d;$/;"	t	namespace:Eigen
AffineCompact3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,AffineCompact> AffineCompact3f;$/;"	t	namespace:Eigen
AffineFunction	srMath/Function.h	/^		AffineFunction() {}$/;"	f	class:srMath::AffineFunction
AffineFunction	srMath/Function.h	/^		AffineFunction(const MatrixX& A, const VectorX& b) : _A(A), _b(b) {}$/;"	f	class:srMath::AffineFunction
AffineFunction	srMath/Function.h	/^	class AffineFunction : public Function$/;"	c	namespace:srMath
AffinePart	Eigen/src/Geometry/Transform.h	/^                              Block<MatrixType,Dim,HDim> >::type AffinePart;$/;"	t	class:Eigen::Transform
AffinePart	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::AffinePart AffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
AffineTransformType	Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Affine> AffineTransformType;$/;"	t	class:Eigen::Translation
Aligned	Eigen/src/Core/util/Constants.h	/^  Aligned=1 $/;"	e	enum:Eigen::AlignmentType
AlignedBit	Eigen/src/Core/util/Constants.h	/^const unsigned int AlignedBit = 0x80;$/;"	m	namespace:Eigen
AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox()$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox(const VectorType& _min, const VectorType& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const VectorType& p) : m_min(p), m_max(p) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(int _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedBox	Eigen/src/Eigen2Support/Geometry/All.h	/^#define AlignedBox /;"	d
AlignedBox	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AlignedBox$/;"	d
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox()$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox(const OtherVectorType1& _min, const OtherVectorType2& _max) : m_min(_min), m_max(_max) {}$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(Index _dim) : m_min(_dim), m_max(_dim)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const AlignedBox<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  inline explicit AlignedBox(const MatrixBase<Derived>& p) : m_min(p), m_max(m_min)$/;"	f	class:Eigen::AlignedBox
AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^class AlignedBox$/;"	c	namespace:Eigen
AlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Aligned> AlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
AlignedOnScalar	Eigen/src/Core/GenericPacketMath.h	/^    AlignedOnScalar = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon225
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
AlignedOnScalar	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
AlignedOnScalar	Eigen/src/Core/arch/NEON/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
AlignedOnScalar	Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
AlignedOnScalar	Eigen/src/Core/arch/NEON/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
AlignedOnScalar	Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
AlignedOnScalar	Eigen/src/Core/arch/SSE/Complex.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
AlignedOnScalar	Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
AlignedOnScalar	Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon248
AlignedOnScalar	Eigen/src/Core/arch/SSE/PacketMath.h	/^    AlignedOnScalar = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon249
AlignedScaling2d	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,2> AlignedScaling2d;$/;"	t	namespace:Eigen
AlignedScaling2f	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 2> AlignedScaling2f;$/;"	t	namespace:Eigen
AlignedScaling3d	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<double,3> AlignedScaling3d;$/;"	t	namespace:Eigen
AlignedScaling3f	Eigen/src/Geometry/Scaling.h	/^typedef DiagonalMatrix<float, 3> AlignedScaling3f;$/;"	t	namespace:Eigen
AlignmentMask	Eigen/src/Cholesky/LLT.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::LLT::__anon427
AlignmentMask	Eigen/src/Eigen2Support/SVD.h	/^      AlignmentMask = int(PacketSize)-1,$/;"	e	enum:Eigen::SVD::__anon396
AlignmentMatch	Eigen/src/Core/Ref.h	/^      AlignmentMatch = (_Options!=Aligned) || ((PlainObjectType::Flags&AlignedBit)==0) || ((traits<Derived>::Flags&AlignedBit)==AlignedBit),$/;"	e	enum:Eigen::internal::traits::match::__anon323
AlignmentType	Eigen/src/Core/util/Constants.h	/^enum AlignmentType {$/;"	g	namespace:Eigen
AllAtOnceTraversal	Eigen/src/Core/util/Constants.h	/^  AllAtOnceTraversal$/;"	e	enum:Eigen::TraversalType
Alloc	tinyxml2/tinyxml2.h	/^    virtual void* Alloc() {$/;"	f	class:tinyxml2::MemPoolT
AltiVec	Eigen/src/Core/util/Constants.h	/^    AltiVec = 0x2,$/;"	e	enum:Eigen::Architecture::Type
AmbiVector	Eigen/src/SparseCore/AmbiVector.h	/^    AmbiVector(Index size)$/;"	f	class:Eigen::internal::AmbiVector
AmbiVector	Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector$/;"	c	namespace:Eigen::internal
Ambient	srLib/srg/srgColor.h	/^		float Ambient[4];		\/\/ material property for ambient lighting	(°£Á¢)$/;"	m	struct:srgMaterialColor::sMaterialColor
AmbientDimAtCompileTime	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon400
AmbientDimAtCompileTime	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::Hyperplane::__anon399
AmbientDimAtCompileTime	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::ParametrizedLine::__anon405
AmbientDimAtCompileTime	Eigen/src/Geometry/AlignedBox.h	/^  enum { AmbientDimAtCompileTime = _AmbientDim };$/;"	e	enum:Eigen::AlignedBox::__anon442
AmbientDimAtCompileTime	Eigen/src/Geometry/Hyperplane.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::Hyperplane::__anon439
AmbientDimAtCompileTime	Eigen/src/Geometry/ParametrizedLine.h	/^    AmbientDimAtCompileTime = _AmbientDim,$/;"	e	enum:Eigen::ParametrizedLine::__anon457
Ancestor	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_all<Lhs>::type Ancestor;$/;"	t	struct:Eigen::internal::traits
AngleAxis	Eigen/src/Eigen2Support/Geometry/All.h	/^#define AngleAxis /;"	d
AngleAxis	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AngleAxis$/;"	d
AngleAxis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(Scalar angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline AngleAxis(const QuaternionType& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis() {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  inline AngleAxis(const Scalar& angle, const MatrixBase<Derived>& axis) : m_axis(axis), m_angle(angle) {}$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const AngleAxis<OtherScalarType>& other)$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  inline explicit AngleAxis(const MatrixBase<Derived>& m) { *this = m; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^  template<typename QuatDerived> inline explicit AngleAxis(const QuaternionBase<QuatDerived>& q) { *this = q; }$/;"	f	class:Eigen::AngleAxis
AngleAxis	Eigen/src/Geometry/AngleAxis.h	/^class AngleAxis : public RotationBase<AngleAxis<_Scalar>,3>$/;"	c	namespace:Eigen
AngleAxisType	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::Quaternion
AngleAxisType	Eigen/src/Geometry/Quaternion.h	/^  typedef AngleAxis<Scalar> AngleAxisType;$/;"	t	class:Eigen::QuaternionBase
AngleAxisType	Eigen/src/Geometry/Quaternion.h	/^  typedef typename Base::AngleAxisType AngleAxisType;$/;"	t	class:Eigen::Quaternion
AngleAxisd	Eigen/src/Eigen2Support/Geometry/All.h	/^#define AngleAxisd /;"	d
AngleAxisd	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AngleAxisd$/;"	d
AngleAxisd	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisd	Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<double> AngleAxisd;$/;"	t	namespace:Eigen
AngleAxisf	Eigen/src/Eigen2Support/Geometry/All.h	/^#define AngleAxisf /;"	d
AngleAxisf	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef AngleAxisf$/;"	d
AngleAxisf	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
AngleAxisf	Eigen/src/Geometry/AngleAxis.h	/^typedef AngleAxis<float> AngleAxisf;$/;"	t	namespace:Eigen
ApplyImpulse	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::ApplyImpulse(int _idx)$/;"	f	class:ClosedLoop
ApplyImpulse	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::ApplyImpulse(int _idx)$/;"	f	class:ContactConstraint
ApplyImpulse	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::ApplyImpulse(int _idx)$/;"	f	class:JointConstraint
Approach	srLib/srg/srgCamera.cpp	/^void srgCamera::Approach(float fStep)$/;"	f	class:srgCamera
Approach_Smart	srLib/srg/srgCamera.cpp	/^void srgCamera::Approach_Smart(int nStep)$/;"	f	class:srgCamera
Architecture	Eigen/src/Core/util/Constants.h	/^namespace Architecture$/;"	n	namespace:Eigen
Array	Eigen/src/Core/Array.h	/^    Array(Array&& other)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    Array(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array() : Base()$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Array& other)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const Scalar& val0, const Scalar& val1, const Scalar& val2, const Scalar& val3)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array(const T0& val0, const T1& val1)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE explicit Array(Index dim)$/;"	f	class:Eigen::Array
Array	Eigen/src/Core/Array.h	/^class Array$/;"	c	namespace:Eigen
Array	Eigen/src/Core/Map.h	/^  ::Array(const Scalar *data)$/;"	f	class:Eigen::Array
ArrayBase	Eigen/src/Core/ArrayBase.h	/^    ArrayBase() : Base() {}$/;"	f	class:Eigen::ArrayBase
ArrayBase	Eigen/src/Core/ArrayBase.h	/^template<typename Derived> class ArrayBase$/;"	c	namespace:Eigen
ArrayWrapper	Eigen/src/Core/ArrayWrapper.h	/^    inline ArrayWrapper(ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ArrayWrapper
ArrayWrapper	Eigen/src/Core/ArrayWrapper.h	/^class ArrayWrapper : public ArrayBase<ArrayWrapper<ExpressionType> >$/;"	c	namespace:Eigen
ArrayXpr	Eigen/src/Core/util/Constants.h	/^struct ArrayXpr {};$/;"	s	namespace:Eigen
Arrow	srLib/SceneGraph/Leaf.cpp	/^Arrow::Arrow(double _size \/*= 1*\/)$/;"	f	class:Arrow
Arrow	srLib/SceneGraph/Leaf.h	/^class Arrow : public Leaf$/;"	c
Attribute	tinyxml2/tinyxml2.cpp	/^const char* XMLElement::Attribute( const char* name, const char* value ) const$/;"	f	class:tinyxml2::XMLElement
AugmentedFunction	srMath/Function.h	/^		AugmentedFunction() {}$/;"	f	class:srMath::AugmentedFunction
AugmentedFunction	srMath/Function.h	/^	class AugmentedFunction : public Function$/;"	c	namespace:srMath
AutoAlign	Eigen/src/Core/util/Constants.h	/^  AutoAlign = 0,$/;"	e	enum:Eigen::StorageOptions
Ax_lBx	Eigen/src/Core/util/Constants.h	/^  Ax_lBx              = 0x100,$/;"	e	enum:Eigen::DecompositionOptions
Axis	srLib/LieGroup/LieGroup.h	/^class Axis$/;"	c
B	srLib/srg/srgColor.h	/^	typedef struct _sRGBA { float R; float G; float B; float A; } SRGBA;$/;"	m	struct:srgColor::_sRGBA
BALL	srLib/srDyn/srJoint.h	/^	enum JOINTTYPE { REVOLUTE, PRISMATIC, UNIVERSAL, WELD, BALL };$/;"	e	enum:srJoint::JOINTTYPE
BASELINKTYPE	srLib/srDyn/srSystem.h	/^	enum	BASELINKTYPE	{ DYNAMIC, FIXED,  KINEMATIC };$/;"	g	class:srSystem
BAx_lx	Eigen/src/Core/util/Constants.h	/^  BAx_lx              = 0x400,$/;"	e	enum:Eigen::DecompositionOptions
BLASFUNC	Eigen/src/misc/blas.h	/^#define BLASFUNC(/;"	d
BLASLONG	Eigen/src/misc/blas.h	/^typedef long BLASLONG;$/;"	t
BLASLONG	Eigen/src/misc/blas.h	/^typedef long long BLASLONG;$/;"	t
BLASULONG	Eigen/src/misc/blas.h	/^typedef unsigned long BLASULONG;$/;"	t
BLASULONG	Eigen/src/misc/blas.h	/^typedef unsigned long long BLASULONG;$/;"	t
BLAS_H	Eigen/src/misc/blas.h	/^#define BLAS_H$/;"	d
BMPBADINT	srLib/SceneGraph/Bitmap.h	/^#define BMPBADINT	/;"	d
BMPBADINT	srLib/srg/srgBitmap.h	/^#define BMPBADINT	/;"	d
BMPError	srLib/SceneGraph/Bitmap.h	/^#define BMPError	/;"	d
BMPError	srLib/srg/srgBitmap.h	/^#define BMPError	/;"	d
BMPFILEERROR	srLib/SceneGraph/Bitmap.h	/^#define BMPFILEERROR	/;"	d
BMPFILEERROR	srLib/srg/srgBitmap.h	/^#define BMPFILEERROR	/;"	d
BMPLOADER_H	srLib/SceneGraph/Bitmap.h	/^#define BMPLOADER_H$/;"	d
BMPLOADER_H	srLib/srg/srgBitmap.h	/^#define BMPLOADER_H$/;"	d
BMPLoad	srLib/SceneGraph/Bitmap.cpp	/^BMPError _Bitmap::BMPLoad(char* fname)$/;"	f	class:_Bitmap
BMPLoad	srLib/srg/srgBitmap.cpp	/^BMPError _Bitmap::BMPLoad(char* fname)$/;"	f	class:_Bitmap
BMPLoad	srLib/srg/srgBitmap.cpp	/^BMPError _Bitmap::BMPLoad(string fname)$/;"	f	class:_Bitmap
BMPLoadGL	srLib/SceneGraph/Bitmap.cpp	/^BMPError _Bitmap::BMPLoadGL(string fname)$/;"	f	class:_Bitmap
BMPLoadGL	srLib/srg/srgBitmap.cpp	/^BMPError _Bitmap::BMPLoadGL(string fname)$/;"	f	class:_Bitmap
BMPNOERROR	srLib/SceneGraph/Bitmap.h	/^#define BMPNOERROR	/;"	d
BMPNOERROR	srLib/srg/srgBitmap.h	/^#define BMPNOERROR	/;"	d
BMPNOOPEN	srLib/SceneGraph/Bitmap.h	/^#define BMPNOOPEN	/;"	d
BMPNOOPEN	srLib/srg/srgBitmap.h	/^#define BMPNOOPEN	/;"	d
BMPNOTABITMAP	srLib/SceneGraph/Bitmap.h	/^#define BMPNOTABITMAP	/;"	d
BMPNOTABITMAP	srLib/srg/srgBitmap.h	/^#define BMPNOTABITMAP	/;"	d
BMPUNKNOWNFORMAT	srLib/SceneGraph/Bitmap.h	/^#define BMPUNKNOWNFORMAT	/;"	d
BMPUNKNOWNFORMAT	srLib/srg/srgBitmap.h	/^#define BMPUNKNOWNFORMAT	/;"	d
BODY	srLib/srExt/srExt_System.h	/^			BODY$/;"	e	enum:srExt::srExtSystem::REF_FRAME
BODY	srLib/srExt/srExtension.h	/^		BODY$/;"	e	enum:srExt::FRAME
BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER	Eigen/src/Core/util/StaticAssert.h	/^        BOTH_MATRICES_MUST_HAVE_THE_SAME_STORAGE_ORDER,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
BOX	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
BSpline	srMath/Interpolation.h	/^	BSpline<CoefficientN, OrderK, Dimension>::BSpline() {}$/;"	f	class:srMath::BSpline
BSpline	srMath/Interpolation.h	/^	BSpline<CoefficientN, OrderK, Dimension>::BSpline(const VectorX& knots, const Eigen::Matrix<Real, Dimension, -1>& controlPoints)$/;"	f	class:srMath::BSpline
BSpline	srMath/Interpolation.h	/^	class BSpline$/;"	c	namespace:srMath
BSplineFitting	srMath/Interpolation.cpp	/^	BSpline<-1, -1, -1> BSplineFitting(const MatrixX & givenPoints, int order, int N_ctrlPnt, const Real & xi, const Real & xf)$/;"	f	namespace:srMath
BSplineFitting	srMath/Interpolation.cpp	/^	BSpline<-1, -1, -1> BSplineFitting(const MatrixX & givenPoints, int order, int N_ctrlPnt, const VectorX& x_gp)$/;"	f	namespace:srMath
BSplineFittingFixedStartEnd	srMath/Interpolation.cpp	/^	BSpline<-1, -1, -1> BSplineFittingFixedStartEnd(const MatrixX & givenPoints, int order, int N_ctrlPnt, const VectorX& x_gp)$/;"	f	namespace:srMath
BSplineInterpolation	srMath/Interpolation.cpp	/^	BSpline<-1, -1, -1> BSplineInterpolation(const MatrixX& viaPoints, int order, const Real& xi, const Real& xf)$/;"	f	namespace:srMath
BSplineInterpolation	srMath/Interpolation.cpp	/^	BSpline<-1, -1, -1> BSplineInterpolation(const MatrixX& viaPoints, int order, const VectorX& x_vp)$/;"	f	namespace:srMath
BUF_SIZE	tinyxml2/tinyxml2.h	/^        BUF_SIZE = 200$/;"	e	enum:tinyxml2::XMLPrinter::__anon484
BUF_SIZE	tinyxml2/tinyxml2.h	/^    enum { BUF_SIZE = 200 };$/;"	e	enum:tinyxml2::XMLAttribute::__anon481
BUF_SIZE	tinyxml2/tinyxml2.h	/^    enum { BUF_SIZE = 200 };$/;"	e	enum:tinyxml2::XMLElement::__anon483
BYTE	srLib/SceneGraph/Bitmap.h	/^typedef unsigned char BYTE;$/;"	t
BYTE	srLib/srg/srgBitmap.h	/^typedef unsigned char BYTE;$/;"	t
BackupInitState	srLib/srDyn/srLink.cpp	/^void srLink::BackupInitState()$/;"	f	class:srLink
BackupInitState	srLib/srDyn/srState.cpp	/^void srBallState::BackupInitState()$/;"	f	class:srBallState
BackupInitState	srLib/srDyn/srState.cpp	/^void srRevoluteState::BackupInitState()$/;"	f	class:srRevoluteState
BackupInitState	srLib/srDyn/srState.cpp	/^void srUniversalState::BackupInitState()$/;"	f	class:srUniversalState
BackupInitState	srLib/srDyn/srState.h	/^	void BackupInitState() {};$/;"	f	class:srWeldState
BackupInitState	srLib/srDyn/srSystem.cpp	/^void srSystem::BackupInitState()$/;"	f	class:srSystem
BandMatrix	Eigen/src/Core/BandMatrix.h	/^    inline BandMatrix(Index rows=Rows, Index cols=Cols, Index supers=Supers, Index subs=Subs)$/;"	f	class:Eigen::internal::BandMatrix
BandMatrix	Eigen/src/Core/BandMatrix.h	/^class BandMatrix : public BandMatrixBase<BandMatrix<_Scalar,Rows,Cols,Supers,Subs,Options> >$/;"	c	namespace:Eigen::internal
BandMatrixBase	Eigen/src/Core/BandMatrix.h	/^class BandMatrixBase : public EigenBase<Derived>$/;"	c	namespace:Eigen::internal
BandMatrixWrapper	Eigen/src/Core/BandMatrix.h	/^    inline BandMatrixWrapper(const CoefficientsType& coeffs, Index rows=_Rows, Index cols=_Cols, Index supers=_Supers, Index subs=_Subs)$/;"	f	class:Eigen::internal::BandMatrixWrapper
BandMatrixWrapper	Eigen/src/Core/BandMatrix.h	/^class BandMatrixWrapper : public BandMatrixBase<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	c	namespace:Eigen::internal
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodDecomposition> Base;$/;"	t	class:Eigen::CholmodDecomposition
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLDLT
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT> Base;$/;"	t	class:Eigen::CholmodSimplicialLLT
Base	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT> Base;$/;"	t	class:Eigen::CholmodSupernodalLLT
Base	Eigen/src/Core/Array.h	/^    typedef PlainObjectBase<Array> Base;$/;"	t	class:Eigen::Array
Base	Eigen/src/Core/ArrayBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::ArrayBase
Base	Eigen/src/Core/ArrayWrapper.h	/^    typedef ArrayBase<ArrayWrapper> Base;$/;"	t	class:Eigen::ArrayWrapper
Base	Eigen/src/Core/ArrayWrapper.h	/^    typedef MatrixBase<MatrixWrapper<ExpressionType> > Base;$/;"	t	class:Eigen::MatrixWrapper
Base	Eigen/src/Core/BandMatrix.h	/^    typedef BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor> Base;$/;"	t	class:Eigen::internal::TridiagonalMatrix
Base	Eigen/src/Core/BandMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::internal::BandMatrixBase
Base	Eigen/src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::Block
Base	Eigen/src/Core/Block.h	/^    typedef Impl Base;$/;"	t	class:Eigen::BlockImpl
Base	Eigen/src/Core/Block.h	/^    typedef MapBase<BlockType> Base;$/;"	t	class:Eigen::internal::BlockImpl_dense
Base	Eigen/src/Core/Block.h	/^    typedef typename internal::dense_xpr_base<BlockType>::type Base;$/;"	t	class:Eigen::internal::BlockImpl_dense
Base	Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename internal::traits<Rhs>::StorageKind>::ret>::Base Base;$/;"	t	class:Eigen::CwiseBinaryOp
Base	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >::type Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Base	Eigen/src/Core/CwiseNullaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseNullaryOp>::type Base;$/;"	t	class:Eigen::CwiseNullaryOp
Base	Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp, XprType,typename internal::traits<XprType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryOp
Base	Eigen/src/Core/CwiseUnaryOp.h	/^    typedef typename internal::dense_xpr_base<CwiseUnaryOp<UnaryOp, XprType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Base	Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp, MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::CwiseUnaryView
Base	Eigen/src/Core/CwiseUnaryView.h	/^    typedef typename internal::dense_xpr_base< CwiseUnaryView<ViewOp, MatrixType> >::type Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Base	Eigen/src/Core/DenseBase.h	/^    typedef internal::special_scalar_op_base<Derived,Scalar,RealScalar, DenseCoeffsBase<Derived> > Base;$/;"	t	class:Eigen::DenseBase
Base	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef DenseCoeffsBase<Derived, WriteAccessors> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::DenseCoeffsBase
Base	Eigen/src/Core/Diagonal.h	/^    typedef typename internal::dense_xpr_base<Diagonal>::type Base;$/;"	t	class:Eigen::Diagonal
Base	Eigen/src/Core/DiagonalProduct.h	/^    typedef MatrixBase<DiagonalProduct> Base;$/;"	t	class:Eigen::DiagonalProduct
Base	Eigen/src/Core/Flagged.h	/^    typedef MatrixBase<Flagged> Base;$/;"	t	class:Eigen::Flagged
Base	Eigen/src/Core/ForceAlignedAccess.h	/^    typedef typename internal::dense_xpr_base<ForceAlignedAccess>::type Base;$/;"	t	class:Eigen::ForceAlignedAccess
Base	Eigen/src/Core/GeneralProduct.h	/^    typedef Matrix<typename internal::scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType,1,1> Base;$/;"	t	class:Eigen::GeneralProduct
Base	Eigen/src/Core/Map.h	/^    typedef MapBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> Base;$/;"	t	class:Eigen::MapBase
Base	Eigen/src/Core/MapBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::MapBase
Base	Eigen/src/Core/Matrix.h	/^    typedef PlainObjectBase<Matrix> Base;$/;"	t	class:Eigen::Matrix
Base	Eigen/src/Core/MatrixBase.h	/^    typedef DenseBase<Derived> Base;$/;"	t	class:Eigen::MatrixBase
Base	Eigen/src/Core/NestByValue.h	/^    typedef typename internal::dense_xpr_base<NestByValue>::type Base;$/;"	t	class:Eigen::NestByValue
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef EigenBase<Derived> Base;$/;"	t	class:Eigen::PermutationBase
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationMatrix> Base;$/;"	t	class:Eigen::PermutationMatrix
Base	Eigen/src/Core/PermutationMatrix.h	/^    typedef PermutationBase<PermutationWrapper> Base;$/;"	t	class:Eigen::PermutationWrapper
Base	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::dense_xpr_base<Derived>::type Base;$/;"	t	class:Eigen::PlainObjectBase
Base	Eigen/src/Core/ProductBase.h	/^                       typename NestedProduct::_RhsNested> Base;$/;"	t	class:ScaledProduct
Base	Eigen/src/Core/ProductBase.h	/^    typedef MatrixBase<Derived> Base;$/;"	t	class:Eigen::ProductBase
Base	Eigen/src/Core/Ref.h	/^    typedef RefBase<Ref> Base;$/;"	t	class:Eigen::Ref
Base	Eigen/src/Core/Ref.h	/^  typedef MapBase<Derived> Base;$/;"	t	class:Eigen::RefBase
Base	Eigen/src/Core/Replicate.h	/^    typedef typename internal::dense_xpr_base<Replicate>::type Base;$/;"	t	class:Eigen::Replicate
Base	Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::dense_xpr_base<ReturnByValue>::type Base;$/;"	t	class:Eigen::ReturnByValue
Base	Eigen/src/Core/Reverse.h	/^    typedef typename internal::dense_xpr_base<Reverse>::type Base;$/;"	t	class:Eigen::Reverse
Base	Eigen/src/Core/Select.h	/^    typedef typename internal::dense_xpr_base<Select>::type Base;$/;"	t	class:Eigen::Select
Base	Eigen/src/Core/SelfAdjointView.h	/^    typedef TriangularBase<SelfAdjointView> Base;$/;"	t	class:Eigen::SelfAdjointView
Base	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::dense_xpr_base<SelfCwiseBinaryOp>::type Base;$/;"	t	class:Eigen::SelfCwiseBinaryOp
Base	Eigen/src/Core/SolveTriangular.h	/^  typedef ReturnByValue<triangular_solve_retval> Base;$/;"	t	struct:Eigen::internal::triangular_solve_retval
Base	Eigen/src/Core/Stride.h	/^    typedef Stride<0, Value> Base;$/;"	t	class:Eigen::InnerStride
Base	Eigen/src/Core/Stride.h	/^    typedef Stride<Value, 0> Base;$/;"	t	class:Eigen::OuterStride
Base	Eigen/src/Core/Swap.h	/^    typedef typename internal::dense_xpr_base<SwapWrapper>::type Base;$/;"	t	class:Eigen::SwapWrapper
Base	Eigen/src/Core/Transpose.h	/^    typedef typename TransposeImpl<MatrixType,typename internal::traits<MatrixType>::StorageKind>::Base Base;$/;"	t	class:Eigen::Transpose
Base	Eigen/src/Core/Transpose.h	/^    typedef typename internal::TransposeImpl_base<MatrixType>::type Base;$/;"	t	class:Eigen::TransposeImpl
Base	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Map> Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<Transpositions> Base;$/;"	t	class:Eigen::Transpositions
Base	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsBase<TranspositionsWrapper> Base;$/;"	t	class:Eigen::TranspositionsWrapper
Base	Eigen/src/Core/TriangularMatrix.h	/^    typedef TriangularBase<TriangularView> Base;$/;"	t	class:Eigen::TriangularView
Base	Eigen/src/Core/VectorBlock.h	/^                     internal::traits<VectorType>::Flags & RowMajorBit ? Size : 1> Base;$/;"	t	class:Eigen::VectorBlock
Base	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::dense_xpr_base<PartialReduxExpr>::type Base;$/;"	t	class:Eigen::PartialReduxExpr
Base	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef MatrixBase<CoeffBasedProduct> Base;$/;"	t	class:Eigen::CoeffBasedProduct
Base	Eigen/src/Core/util/BlasUtil.h	/^  typedef blas_traits<NestedXpr> Base;$/;"	t	struct:Eigen::internal::blas_traits
Base	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis
Base	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef RotationBase<Quaternion<_Scalar>,3> Base;$/;"	t	class:Eigen::Quaternion
Base	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D
Base	Eigen/src/Eigen2Support/LU.h	/^    typedef FullPivLU<MatrixType> Base;$/;"	t	class:Eigen::LU
Base	Eigen/src/Eigen2Support/Minor.h	/^    typedef MatrixBase<Minor> Base;$/;"	t	class:Eigen::Minor
Base	Eigen/src/Eigen2Support/QR.h	/^    typedef HouseholderQR<MatrixType> Base;$/;"	t	class:Eigen::QR
Base	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef SelfAdjointEigenSolver<_MatrixType> Base;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
Base	Eigen/src/Geometry/AngleAxis.h	/^  typedef RotationBase<AngleAxis<_Scalar>,3> Base;$/;"	t	class:Eigen::AngleAxis
Base	Eigen/src/Geometry/Homogeneous.h	/^    typedef MatrixBase<Homogeneous> Base;$/;"	t	class:Eigen::Homogeneous
Base	Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Geometry/Quaternion.h	/^    typedef QuaternionBase<Map<const Quaternion<_Scalar>, _Options> > Base;$/;"	t	class:Eigen::Map
Base	Eigen/src/Geometry/Quaternion.h	/^  typedef QuaternionBase<Quaternion<_Scalar,_Options> > Base;$/;"	t	class:Eigen::Quaternion
Base	Eigen/src/Geometry/Quaternion.h	/^  typedef RotationBase<Derived, 3> Base;$/;"	t	class:Eigen::QuaternionBase
Base	Eigen/src/Geometry/Rotation2D.h	/^  typedef RotationBase<Rotation2D<_Scalar>,2> Base;$/;"	t	class:Eigen::Rotation2D
Base	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef IterativeSolverBase<BiCGSTAB> Base;$/;"	t	class:Eigen::BiCGSTAB
Base	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef IterativeSolverBase<ConjugateGradient> Base;$/;"	t	class:Eigen::ConjugateGradient
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLDLT<MatrixType, _UpLo> > Base; $/;"	t	class:Eigen::PastixLDLT
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLLT<MatrixType, _UpLo> > Base;$/;"	t	class:Eigen::PastixLLT
Base	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef PastixBase<PastixLU<MatrixType> > Base;$/;"	t	class:Eigen::PastixLU
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLDLT<MatrixType,Options> > Base;$/;"	t	class:Eigen::PardisoLDLT
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLLT<MatrixType,_UpLo> > Base;$/;"	t	class:Eigen::PardisoLLT
Base	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef PardisoImpl< PardisoLU<MatrixType> > Base;$/;"	t	class:Eigen::PardisoLU
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialCholesky> Base;$/;"	t	class:Eigen::SimplicialCholesky
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLDLT> Base;$/;"	t	class:Eigen::SimplicialLDLT
Base	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SimplicialCholeskyBase<SimplicialLLT> Base;$/;"	t	class:Eigen::SimplicialLLT
Base	Eigen/src/SparseCore/SparseBlock.h	/^      typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::BlockImpl::ReverseInnerIterator
Base	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
Base	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^      BinaryOp,Lhs,Rhs, InnerIterator> Base;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator
Base	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator
Base	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
Base	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator
Base	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::MatrixTypeReverseIterator Base;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
Base	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef SparseMatrixBase<SparseDenseOuterProduct> Base;$/;"	t	class:Eigen::SparseDenseOuterProduct
Base	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename _LhsNested::InnerIterator Base;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator
Base	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      const Transpose<const typename Rhs::DiagonalVectorType> >::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      const typename Lhs::DiagonalVectorType>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Lhs::Scalar>,const Rhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename CwiseUnaryOp<scalar_multiple_op<typename Rhs::Scalar>,const Lhs>::InnerIterator Base;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Base	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef internal::special_scalar_op_base<Derived, Scalar, RealScalar, EigenBase<Derived> > Base;$/;"	t	class:Eigen::SparseMatrixBase
Base	Eigen/src/SparseCore/SparseProduct.h	/^    typedef SparseMatrixBase<SparseSparseProduct> Base;$/;"	t	class:Eigen::SparseSparseProduct
Base	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::InnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::InnerIterator
Base	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator Base;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator
Base	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::InnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator
Base	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixTypeNestedCleaned::ReverseInnerIterator Base;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator
Base	Eigen/src/SparseLU/SparseLU.h	/^    typedef internal::SparseLUImpl<Scalar, Index> Base;$/;"	t	class:Eigen::SparseLU
Base	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperILU> Base;$/;"	t	class:Eigen::SuperILU
Base	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SuperLUBase<_MatrixType,SuperLU> Base;$/;"	t	class:Eigen::SuperLU
Base	Eigen/src/misc/Image.h	/^  typedef ReturnByValue<image_retval_base> Base;$/;"	t	struct:Eigen::internal::image_retval_base
Base	Eigen/src/misc/Kernel.h	/^  typedef ReturnByValue<kernel_retval_base> Base;$/;"	t	struct:Eigen::internal::kernel_retval_base
Base	Eigen/src/misc/Solve.h	/^  typedef ReturnByValue<solve_retval_base> Base;$/;"	t	struct:Eigen::internal::solve_retval_base
Base	Eigen/src/misc/SparseSolve.h	/^  typedef ReturnByValue<sparse_solve_retval_base> Base;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
BasePlainObject	Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject BasePlainObject;$/;"	t	class:Eigen::ProductBase
BasisReturnType	Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime> BasisReturnType;$/;"	t	class:Eigen::MatrixBase
BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  BiCGSTAB() : Base() {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  explicit BiCGSTAB(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::BiCGSTAB
BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^class BiCGSTAB : public IterativeSolverBase<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	c	namespace:Eigen
BidiagonalType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef BandMatrix<RealScalar, ColsAtCompileTime, ColsAtCompileTime, 1, 0> BidiagonalType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
BinaryFunc	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef scalar_product_op<T> BinaryFunc;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Blink_Constraints	srLib/srDyn/srDYN.h	/^	ConstraintPtrArray					Blink_Constraints;$/;"	m	class:srDYN
Block	Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index a_startRow, Index a_startCol)$/;"	f	class:Eigen::Block
Block	Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr, Index i) : Impl(xpr,i)$/;"	f	class:Eigen::Block
Block	Eigen/src/Core/Block.h	/^    inline Block(XprType& xpr,$/;"	f	class:Eigen::Block
Block	Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel> class Block$/;"	c	namespace:Eigen
Block	tinyxml2/tinyxml2.h	/^    struct Block {$/;"	s	class:tinyxml2::MemPoolT
BlockImpl	Eigen/src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol) : Impl(xpr, a_startRow, a_startCol) {}$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index a_startRow, Index a_startCol, Index blockRows, Index blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/Core/Block.h	/^    inline BlockImpl(XprType& xpr, Index i) : Impl(xpr,i) {}$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/Core/Block.h	/^class BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, Dense>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const SparseMatrixType& xpr, int i)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const SparseMatrixType& xpr, int startRow, int startCol, int blockRows, int blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const XprType& xpr, int i)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockImpl(const XprType& xpr, int startRow, int startCol, int blockRows, int blockCols)$/;"	f	class:Eigen::BlockImpl
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<SparseMatrix<_Scalar, _Options, _Index>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,InnerPanel,Sparse>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<XprType,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl	Eigen/src/SparseCore/SparseBlock.h	/^class BlockImpl<const SparseMatrix<_Scalar, _Options, _Index>,BlockRows,BlockCols,true,Sparse>$/;"	c	namespace:Eigen
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index a_startRow, Index a_startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index i)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, Index startRow, Index startCol)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr, const Scalar* data, Index blockRows, Index blockCols)$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^    inline BlockImpl_dense(XprType& xpr,$/;"	f	class:Eigen::internal::BlockImpl_dense
BlockImpl_dense	Eigen/src/Core/Block.h	/^class BlockImpl_dense<XprType,BlockRows,BlockCols, InnerPanel,true>$/;"	c	namespace:Eigen::internal
BlockImpl_dense	Eigen/src/Core/Block.h	/^template<typename XprType, int BlockRows, int BlockCols, bool InnerPanel, bool HasDirectAccess> class BlockImpl_dense$/;"	c	namespace:Eigen::internal
BlockIndexVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Index,Dynamic,1> > BlockIndexVector;$/;"	t	class:Eigen::internal::SparseLUImpl
BlockScalarVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Ref<Matrix<Scalar,Dynamic,1> > BlockScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl
BlockSize	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^    BlockSize  = EIGEN_PLAIN_ENUM_MAX(mr,nr)$/;"	e	enum:Eigen::internal::tribb_kernel::__anon121
BlockType	Eigen/src/Core/Block.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::internal::BlockImpl_dense
BlockType	Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MatrixType,Dynamic,Dynamic> BlockType;$/;"	t	struct:Eigen::internal::partial_lu_impl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, InnerPanel> BlockType;$/;"	t	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<XprType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^  typedef Block<SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl
BlockType	Eigen/src/SparseCore/SparseBlock.h	/^  typedef Block<const SparseMatrixType, BlockRows, BlockCols, true> BlockType;$/;"	t	class:Eigen::BlockImpl
BoolAttribute	tinyxml2/tinyxml2.cpp	/^bool XMLElement::BoolAttribute(const char* name, bool defaultValue) const $/;"	f	class:tinyxml2::XMLElement
BoolText	tinyxml2/tinyxml2.cpp	/^bool XMLElement::BoolText(bool defaultValue) const$/;"	f	class:tinyxml2::XMLElement
BoolValue	tinyxml2/tinyxml2.h	/^    bool	 BoolValue() const				{$/;"	f	class:tinyxml2::XMLAttribute
BothDirections	Eigen/src/Core/util/Constants.h	/^  BothDirections $/;"	e	enum:Eigen::DirectionType
BottomLeft	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomLeft	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftCeil	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomLeftFloor	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRight	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
BottomRight	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeft=0, BottomRight=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightCeil	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftCeil=4, BottomRightCeil=5,$/;"	e	enum:Eigen::AlignedBox::CornerType
BottomRightFloor	Eigen/src/Geometry/AlignedBox.h	/^    BottomLeftFloor=0, BottomRightFloor=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Box	srLib/SceneGraph/Leaf.cpp	/^Box::Box(double x, double y, double z)$/;"	f	class:Box
Box	srLib/SceneGraph/Leaf.h	/^class Box : public Leaf{$/;"	c
BoxInertia	srLib/LieGroup/LieGroup.cpp	/^Inertia BoxInertia(SR_REAL density, const Vec3 &size)$/;"	f
Bracket	srMath/SE3.h	/^	static Matrix4 Bracket(const se3& S)$/;"	f	namespace:srMath
Bracket	srMath/SO3.h	/^	static Matrix3 Bracket(const so3 w)$/;"	f	namespace:srMath
BuildColorTexture	srLib/SceneGraph/Texture3DS.cpp	/^void Texture3DS::BuildColorTexture(unsigned char r, unsigned char g, unsigned char b)$/;"	f	class:Texture3DS
BuildGround	Example/DracoP1/Ground.h	/^    srSystem*	 BuildGround() {$/;"	f	class:Ground
BuildGround	Example/MobileRobots/Ground.h	/^	srSystem*	 BuildGround() {$/;"	f	class:Ground
BuildRobot	Example/MobileRobots/MobileRobots.h	/^	srSystem*	BuildRobot(SE3 T = SE3(Vec3(0.0, 0.0, 0.2))) {$/;"	f	class:MobileRobot
BuildType	Eigen/src/Core/BandMatrix.h	/^      typedef Block<CoefficientsType,1, DiagonalSize> BuildType;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
BuiltIn	Eigen/src/Core/util/Constants.h	/^  BuiltIn$/;"	e	enum:Eigen::SpecializedType
CAMERAMODE	srLib/SceneGraph/Camera.h	/^	enum CAMERAMODE{ _NONE = 0, _TRANSLATE, _ROTATE, _ZOOM_IN, _ZOOM_OUT};$/;"	g	class:Camera
CAPSULE	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
CARRIAGE_RETURN	tinyxml2/tinyxml2.cpp	/^static const char CARRIAGE_RETURN		= (char)0x0d;			\/\/ CR gets filtered out$/;"	v	file:
CData	tinyxml2/tinyxml2.h	/^    bool CData() const						{$/;"	f	class:tinyxml2::XMLText
CJMADD	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^#undef CJMADD$/;"	d
CLOSED	tinyxml2/tinyxml2.h	/^        CLOSED,		\/\/ <foo\/>$/;"	e	enum:tinyxml2::XMLElement::__anon482
CLOSING	tinyxml2/tinyxml2.h	/^        CLOSING		\/\/ <\/foo>$/;"	e	enum:tinyxml2::XMLElement::__anon482
CMAKE_BINARY_DIR	build/Example/DracoP1/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/LieGroup/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/SceneGraph/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/common/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/srDyn/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/srExt/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srLib/srg/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/srMath/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_BINARY_DIR	build/tinyxml2/Makefile	/^CMAKE_BINARY_DIR = \/Users\/donghyunkim\/new_srLib\/build$/;"	m
CMAKE_COMMAND	build/Example/DracoP1/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/LieGroup/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/SceneGraph/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/common/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/srDyn/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/srExt/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srLib/srg/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/srMath/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/tinyxml2/Makefile	/^CMAKE_COMMAND = \/usr\/local\/bin\/cmake$/;"	m
CMAKE_SOURCE_DIR	build/Example/DracoP1/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/LieGroup/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/SceneGraph/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/common/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/srDyn/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/srExt/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srLib/srg/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/srMath/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
CMAKE_SOURCE_DIR	build/tinyxml2/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/donghyunkim\/new_srLib$/;"	m
COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED	Eigen/src/Core/util/StaticAssert.h	/^        COEFFICIENT_WRITE_ACCESS_TO_SELFADJOINT_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
COLAMDOrdering	Eigen/src/OrderingMethods/Ordering.h	/^class COLAMDOrdering$/;"	c	namespace:Eigen
COLAMD_ASSERT	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ASSERT(/;"	d
COLAMD_DEBUG0	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DEBUG0(/;"	d
COLAMD_DEBUG1	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DEBUG1(/;"	d
COLAMD_DEBUG2	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DEBUG2(/;"	d
COLAMD_DEBUG3	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DEBUG3(/;"	d
COLAMD_DEBUG4	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DEBUG4(/;"	d
COLAMD_DEFRAG_COUNT	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DEFRAG_COUNT /;"	d
COLAMD_DENSE_COL	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DENSE_COL /;"	d
COLAMD_DENSE_ROW	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_DENSE_ROW /;"	d
COLAMD_EMPTY	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_EMPTY /;"	d
COLAMD_ERROR_A_not_present	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_A_not_present /;"	d
COLAMD_ERROR_A_too_small	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_A_too_small /;"	d
COLAMD_ERROR_col_length_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_col_length_negative /;"	d
COLAMD_ERROR_internal_error	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_internal_error /;"	d
COLAMD_ERROR_ncol_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_ncol_negative /;"	d
COLAMD_ERROR_nnz_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_nnz_negative /;"	d
COLAMD_ERROR_nrow_negative	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_nrow_negative /;"	d
COLAMD_ERROR_out_of_memory	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_out_of_memory /;"	d
COLAMD_ERROR_p0_nonzero	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_p0_nonzero /;"	d
COLAMD_ERROR_p_not_present	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_p_not_present /;"	d
COLAMD_ERROR_row_index_out_of_bounds	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_ERROR_row_index_out_of_bounds /;"	d
COLAMD_INFO1	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_INFO1 /;"	d
COLAMD_INFO2	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_INFO2 /;"	d
COLAMD_INFO3	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_INFO3 /;"	d
COLAMD_KNOBS	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_KNOBS /;"	d
COLAMD_NDEBUG	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_NDEBUG$/;"	d
COLAMD_OK	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_OK /;"	d
COLAMD_OK_BUT_JUMBLED	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_OK_BUT_JUMBLED /;"	d
COLAMD_STATS	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_STATS /;"	d
COLAMD_STATUS	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COLAMD_STATUS /;"	d
COLLAPSE_WHITESPACE	tinyxml2/tinyxml2.h	/^    COLLAPSE_WHITESPACE$/;"	e	enum:tinyxml2::Whitespace
COLOR_RGB	srLib/SceneGraph/Model3DS.cpp	/^#define	COLOR_RGB	/;"	d	file:
COLOR_RGBG	srLib/SceneGraph/Model3DS.cpp	/^#define COLOR_RGBG	/;"	d	file:
COLOR_TRU	srLib/SceneGraph/Model3DS.cpp	/^#define COLOR_TRU	/;"	d	file:
COLOR_TRUG	srLib/SceneGraph/Model3DS.cpp	/^#define COLOR_TRUG	/;"	d	file:
COL_IS_ALIVE	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COL_IS_ALIVE(/;"	d
COL_IS_DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COL_IS_DEAD(/;"	d
COL_IS_DEAD_PRINCIPAL	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define COL_IS_DEAD_PRINCIPAL(/;"	d
COMMENT	tinyxml2/tinyxml2.h	/^        COMMENT							= NEEDS_NEWLINE_NORMALIZATION$/;"	e	enum:tinyxml2::StrPair::__anon478
COMPILER_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_ID /;"	d	file:
COMPILER_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_ID /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^  # define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^  # define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^  # define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^  # define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^  # define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#   define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^  # define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#   define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_TWEAK /;"	d	file:
CONTACT_THRESHOLD	srLib/srDyn/srContactConstraint.h	/^#define CONTACT_THRESHOLD	/;"	d
CONTACT_THRESHOLD_SQR	srLib/srDyn/srContactConstraint.h	/^#define CONTACT_THRESHOLD_SQR	/;"	d
CR	tinyxml2/tinyxml2.cpp	/^static const char CR = CARRIAGE_RETURN;$/;"	v	file:
CStr	tinyxml2/tinyxml2.h	/^    const char* CStr() const {$/;"	f	class:tinyxml2::XMLPrinter
CStrSize	tinyxml2/tinyxml2.h	/^    int CStrSize() const {$/;"	f	class:tinyxml2::XMLPrinter
CYLINDER	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
C_DIALECT	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define C_DIALECT /;"	d	file:
C_DIALECT	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define C_DIALECT$/;"	d	file:
C_DIALECT	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define C_DIALECT /;"	d	file:
CalculateNormals	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::CalculateNormals()$/;"	f	class:Model3DS
Camera	srLib/SceneGraph/Camera.cpp	/^Camera::Camera(double _r, double _phi, double _theta)$/;"	f	class:Camera
Camera	srLib/SceneGraph/Camera.h	/^class Camera :$/;"	c
CanVectorizeInner	Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner =    SameType$/;"	e	enum:Eigen::internal::traits::__anon122
CanVectorizeInner	Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeInner = internal::traits<CoeffBasedProduct>::CanVectorizeInner$/;"	e	enum:Eigen::CoeffBasedProduct::__anon123
CanVectorizeLhs	Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeLhs = (!LhsRowMajor) && (LhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon122
CanVectorizeRhs	Eigen/src/Core/products/CoeffBasedProduct.h	/^      CanVectorizeRhs = RhsRowMajor && (RhsFlags & PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon122
Capacity	tinyxml2/tinyxml2.h	/^    int Capacity() const				{$/;"	f	class:tinyxml2::DynArray
Capsule	srLib/SceneGraph/Leaf.cpp	/^Capsule::Capsule(double radius, double height)$/;"	f	class:Capsule
Capsule	srLib/SceneGraph/Leaf.h	/^class Capsule : public DomeBase$/;"	c
CapsuleInertia	srLib/LieGroup/LieGroup.cpp	/^Inertia	 CapsuleInertia(SR_REAL density, SR_REAL rad, SR_REAL height)$/;"	f
ChangFont	srLib/SceneGraph/Font.cpp	/^void srgString::ChangFont( mode_type NewType, unsigned int FontIndex )$/;"	f	class:srgString
ChangFont	srLib/srg/srgFont.cpp	/^void srgString::ChangFont( mode_type NewType, unsigned int FontIndex )$/;"	f	class:srgString
CholMatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef MatrixType CholMatrixType;$/;"	t	class:Eigen::CholmodBase
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholesky
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLDLT
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> CholMatrixType;$/;"	t	class:Eigen::SimplicialLLT
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>                   CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholMatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseMatrix<Scalar, ColMajor, Index>               CholMatrixType;$/;"	t	struct:Eigen::internal::traits
CholmodAuto	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase()$/;"	f	class:Eigen::CholmodBase
CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodBase(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodBase : internal::noncopyable$/;"	c	namespace:Eigen
CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition() : Base() { init(); }$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodDecomposition(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodDecomposition
CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodDecomposition : public CholmodBase<_MatrixType, _UpLo, CholmodDecomposition<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodLDLt	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodMode	Eigen/src/CholmodSupport/CholmodSupport.h	/^enum CholmodMode {$/;"	g	namespace:Eigen
CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLDLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLDLT
CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLDLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSimplicialLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSimplicialLLT
CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSimplicialLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSimplicialLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSimplicialLLt	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT() : Base() { init(); }$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    CholmodSupernodalLLT(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::CholmodSupernodalLLT
CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^class CholmodSupernodalLLT : public CholmodBase<_MatrixType, _UpLo, CholmodSupernodalLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
CholmodSupernodalLLt	Eigen/src/CholmodSupport/CholmodSupport.h	/^  CholmodAuto, CholmodSimplicialLLt, CholmodSupernodalLLt, CholmodLDLt$/;"	e	enum:Eigen::CholmodMode
ChunkHeader	srLib/SceneGraph/Model3DS.h	/^	struct ChunkHeader {$/;"	s	class:Model3DS
Clear	tinyxml2/tinyxml2.cpp	/^void XMLDocument::Clear()$/;"	f	class:tinyxml2::XMLDocument
Clear	tinyxml2/tinyxml2.h	/^    void Clear() {$/;"	f	class:tinyxml2::DynArray
Clear	tinyxml2/tinyxml2.h	/^    void Clear() {$/;"	f	class:tinyxml2::MemPoolT
ClearBuffer	tinyxml2/tinyxml2.h	/^    void ClearBuffer() {$/;"	f	class:tinyxml2::XMLPrinter
ClearError	tinyxml2/tinyxml2.h	/^    void ClearError() {$/;"	f	class:tinyxml2::XMLDocument
ClearHistory	srLib/srDyn/srLink.cpp	/^void srLink::ClearHistory()$/;"	f	class:srLink
ClearHistory	srLib/srDyn/srState.cpp	/^void srBallState::ClearHistory()$/;"	f	class:srBallState
ClearHistory	srLib/srDyn/srState.cpp	/^void srRevoluteState::ClearHistory()$/;"	f	class:srRevoluteState
ClearHistory	srLib/srDyn/srState.cpp	/^void srUniversalState::ClearHistory()$/;"	f	class:srUniversalState
ClearHistory	srLib/srDyn/srState.h	/^	void ClearHistory() {};$/;"	f	class:srWeldState
ClearObject	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::ClearObject()$/;"	f	class:srIRSensor
ClearObject	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::ClearObject()$/;"	f	class:srRangeFinder
ClearObject	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::ClearObject()$/;"	f	class:srTouchSensor
ClearScene	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::ClearScene()$/;"	f	class:SceneGraphRenderer
CloseElement	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::CloseElement( bool compactMode )$/;"	f	class:tinyxml2::XMLPrinter
ClosedLoop	srLib/srDyn/srClosedLoopConstraint.h	/^	ClosedLoop()$/;"	f	class:ClosedLoop
ClosedLoop	srLib/srDyn/srClosedLoopConstraint.h	/^class ClosedLoop : public Constraint$/;"	c
ClosedLoopArray	srLib/srDyn/srDYN.h	/^typedef _array<ClosedLoop>			ClosedLoopArray;$/;"	t
ClosingType	tinyxml2/tinyxml2.h	/^    int ClosingType() const {$/;"	f	class:tinyxml2::XMLElement
CoeffBasedProduct	Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const CoeffBasedProduct& other)$/;"	f	class:Eigen::CoeffBasedProduct
CoeffBasedProduct	Eigen/src/Core/products/CoeffBasedProduct.h	/^    inline CoeffBasedProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::CoeffBasedProduct
CoeffBasedProduct	Eigen/src/Core/products/CoeffBasedProduct.h	/^class CoeffBasedProduct$/;"	c	namespace:Eigen
CoeffBasedProductMode	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
CoeffReadCost	Eigen/src/Core/BandMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
CoeffReadCost	Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon215
CoeffReadCost	Eigen/src/Core/BandMatrix.h	/^    CoeffReadCost = internal::traits<_CoefficientsType>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon216
CoeffReadCost	Eigen/src/Core/CwiseBinaryOp.h	/^    CoeffReadCost = EIGEN_ADD_COST(Cost0,functor_traits<BinaryOp>::Cost)$/;"	e	enum:Eigen::internal::traits::__anon228
CoeffReadCost	Eigen/src/Core/CwiseNullaryOp.h	/^    CoeffReadCost = functor_traits<NullaryOp>::Cost$/;"	e	enum:Eigen::internal::traits::__anon312
CoeffReadCost	Eigen/src/Core/CwiseUnaryOp.h	/^    CoeffReadCost = EIGEN_ADD_COST(_XprTypeNested::CoeffReadCost, functor_traits<UnaryOp>::Cost)$/;"	e	enum:Eigen::internal::traits::__anon31
CoeffReadCost	Eigen/src/Core/CwiseUnaryView.h	/^    CoeffReadCost = EIGEN_ADD_COST(traits<_MatrixTypeNested>::CoeffReadCost, functor_traits<ViewOp>::Cost),$/;"	e	enum:Eigen::internal::traits::__anon233
CoeffReadCost	Eigen/src/Core/DenseBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::DenseBase::__anon341
CoeffReadCost	Eigen/src/Core/Diagonal.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon339
CoeffReadCost	Eigen/src/Core/DiagonalProduct.h	/^    CoeffReadCost = EIGEN_ADD_COST(Cost0,DiagonalType::DiagonalVectorType::CoeffReadCost)$/;"	e	enum:Eigen::internal::traits::__anon232
CoeffReadCost	Eigen/src/Core/Matrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon221
CoeffReadCost	Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::PermutationBase::__anon20
CoeffReadCost	Eigen/src/Core/PermutationMatrix.h	/^      CoeffReadCost = Traits::CoeffReadCost,$/;"	e	enum:Eigen::Transpose::__anon22
CoeffReadCost	Eigen/src/Core/PermutationMatrix.h	/^    CoeffReadCost = _IndicesType::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon21
CoeffReadCost	Eigen/src/Core/ProductBase.h	/^    CoeffReadCost = 0 \/\/ FIXME why is it needed ?$/;"	e	enum:Eigen::internal::traits::__anon139
CoeffReadCost	Eigen/src/Core/Replicate.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon271
CoeffReadCost	Eigen/src/Core/Reverse.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon18
CoeffReadCost	Eigen/src/Core/Select.h	/^    CoeffReadCost = traits<typename remove_all<ConditionMatrixNested>::type>::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon343
CoeffReadCost	Eigen/src/Core/SelfAdjointView.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon277
CoeffReadCost	Eigen/src/Core/Transpose.h	/^    CoeffReadCost = MatrixTypeNestedPlain::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon324
CoeffReadCost	Eigen/src/Core/TriangularMatrix.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::TriangularBase::__anon238
CoeffReadCost	Eigen/src/Core/TriangularMatrix.h	/^    CoeffReadCost = MatrixTypeNestedCleaned::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon239
CoeffReadCost	Eigen/src/Core/VectorwiseOp.h	/^    CoeffReadCost = TraversalSize==Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon314
CoeffReadCost	Eigen/src/Core/products/CoeffBasedProduct.h	/^      CoeffReadCost = InnerSize == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon122
CoeffReadCost	Eigen/src/Eigen2Support/Minor.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost \/\/ minor is used typically on tiny matrices,$/;"	e	enum:Eigen::internal::traits::__anon406
CoeffReadCost	Eigen/src/Geometry/Homogeneous.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost$/;"	e	enum:Eigen::internal::traits::__anon440
CoeffReadCost	Eigen/src/SparseCore/SparseDenseProduct.h	/^    CoeffReadCost = LhsCoeffReadCost + RhsCoeffReadCost + NumTraits<Scalar>::MulCost$/;"	e	enum:Eigen::internal::traits::__anon374
CoeffReadCost	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon368
CoeffReadCost	Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon361
CoeffReadCost	Eigen/src/SparseCore/SparseMatrix.h	/^    CoeffReadCost = _MatrixTypeNested::CoeffReadCost*10$/;"	e	enum:Eigen::internal::traits::__anon362
CoeffReadCost	Eigen/src/SparseCore/SparseMatrixBase.h	/^      CoeffReadCost = internal::traits<Derived>::CoeffReadCost,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
CoeffReadCost	Eigen/src/SparseCore/SparseProduct.h	/^    CoeffReadCost = Dynamic$/;"	e	enum:Eigen::internal::traits::__anon390
CoeffReadCost	Eigen/src/SparseCore/SparseVector.h	/^    CoeffReadCost = NumTraits<Scalar>::ReadCost,$/;"	e	enum:Eigen::internal::traits::__anon385
CoeffReturnType	Eigen/src/Core/ArrayBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::ArrayBase
CoeffReturnType	Eigen/src/Core/DenseBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::DenseBase
CoeffReturnType	Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type CoeffReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
CoeffReturnType	Eigen/src/Core/MapBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MapBase
CoeffReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::CoeffReturnType CoeffReturnType;$/;"	t	class:Eigen::MatrixBase
CoeffReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::conditional<_HasDirectAccess, const Scalar&, Scalar>::type CoeffReturnType;$/;"	t	class:Eigen::SparseMatrixBase
CoeffVectorType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::HessenbergDecomposition
CoeffVectorType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<Scalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> CoeffVectorType;$/;"	t	class:Eigen::Tridiagonalization
CoeffVectorType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::CoeffVectorType CoeffVectorType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Coefficients	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^                        : int(AmbientDimAtCompileTime)+1,1> Coefficients;$/;"	t	class:Eigen::Hyperplane
Coefficients	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar, 4, 1> Coefficients;$/;"	t	class:Eigen::Quaternion
Coefficients	Eigen/src/Geometry/Hyperplane.h	/^                        : Index(AmbientDimAtCompileTime)+1,1,Options> Coefficients;$/;"	t	class:Eigen::Hyperplane
Coefficients	Eigen/src/Geometry/Quaternion.h	/^    typedef Map<Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	Eigen/src/Geometry/Quaternion.h	/^    typedef Map<const Matrix<_Scalar,4,1>, _Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	Eigen/src/Geometry/Quaternion.h	/^    typedef typename internal::traits<Map>::Coefficients Coefficients;$/;"	t	class:Eigen::Map
Coefficients	Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<_Scalar,4,1,_Options> Coefficients;$/;"	t	struct:Eigen::internal::traits
Coefficients	Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Coefficients Coefficients;$/;"	t	class:Eigen::QuaternionBase
Coefficients	Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Quaternion>::Coefficients Coefficients;$/;"	t	class:Eigen::Quaternion
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrix
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixWrapper
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::CoefficientsType CoefficientsType;$/;"	t	class:Eigen::internal::BandMatrixBase
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^  typedef Matrix<Scalar,DataRowsAtCompileTime,ColsAtCompileTime,Options&RowMajor?RowMajor:ColMajor> CoefficientsType;$/;"	t	struct:Eigen::internal::traits
CoefficientsType	Eigen/src/Core/BandMatrix.h	/^  typedef _CoefficientsType CoefficientsType;$/;"	t	struct:Eigen::internal::traits
CoherentAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int CoherentAccessPattern     = 0x1;$/;"	m	namespace:Eigen
ColMajor	Eigen/src/Core/util/Constants.h	/^  ColMajor = 0,$/;"	e	enum:Eigen::StorageOptions
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR()$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
ColPivHouseholderQR	Eigen/src/QR/ColPivHouseholderQR.h	/^template<typename _MatrixType> class ColPivHouseholderQR$/;"	c	namespace:Eigen
ColPivHouseholderQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  ColPivHouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor> ColSpMatrix;$/;"	t	class:Eigen::PastixBase
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLDLT
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLLT
ColSpMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename Base::ColSpMatrix ColSpMatrix;$/;"	t	class:Eigen::PastixLU
ColType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColType;$/;"	t	class:Eigen::JacobiSVD
ColVector	Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1> ColVector;$/;"	t	class:Eigen::SVD
ColVectorType	Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::LU
ColVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_col_type<MatrixType>::type ColVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
ColVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1> ColVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
ColXpr	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ColXpr ColXpr;$/;"	t	class:Eigen::MatrixBase
ColXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ColXpr;$/;"	t
Colamd_Row	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^struct Colamd_Row$/;"	s	namespace:internal
CollapseWhitespace	tinyxml2/tinyxml2.cpp	/^void StrPair::CollapseWhitespace()$/;"	f	class:tinyxml2::StrPair
CollisionPair	srLib/srDyn/srContactConstraint.h	/^class CollisionPair$/;"	c
CollisionPairArray	srLib/srDyn/srDYN.h	/^typedef _array<CollisionPair>		CollisionPairArray;$/;"	t
Color4i	srLib/SceneGraph/Model3DS.h	/^	struct Color4i {$/;"	s	class:Model3DS
ColorPoint	srLib/SceneGraph/Leaf.cpp	/^ColorPoint::ColorPoint(Vec3 pos, double r \/*= 1*\/, double g \/*= 1 *\/, double b \/*=1*\/)$/;"	f	class:ColorPoint
ColorPoint	srLib/SceneGraph/Leaf.cpp	/^ColorPoint::ColorPoint(double r \/*= 1*\/, double g \/*= 1 *\/, double b \/*=1*\/)$/;"	f	class:ColorPoint
ColorPoint	srLib/SceneGraph/Leaf.h	/^class ColorPoint : public Leaf$/;"	c
ColorPointGroup	srLib/SceneGraph/Leaf.cpp	/^ColorPointGroup::ColorPointGroup(const list<Vec3>& points, double r \/*= 1*\/, double g \/*= 1 *\/, double b \/*=1*\/)$/;"	f	class:ColorPointGroup
ColorPointGroup	srLib/SceneGraph/Leaf.h	/^class ColorPointGroup : public Leaf$/;"	c
Cols	Eigen/src/Core/GeneralProduct.h	/^    Cols  = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon283
ColsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon425
ColsAtCompileTime	Eigen/src/Cholesky/LLT.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon426
ColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
ColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon215
ColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon216
ColsAtCompileTime	Eigen/src/Core/Block.h	/^    ColsAtCompileTime = MatrixCols == 0 ? 0 : BlockCols,$/;"	e	enum:Eigen::internal::traits::__anon273
ColsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    ColsAtCompileTime = traits<Ancestor>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon227
ColsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon341
ColsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon339
ColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon32
ColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    ColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon34
ColsAtCompileTime	Eigen/src/Core/DiagonalProduct.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon232
ColsAtCompileTime	Eigen/src/Core/MapBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon220
ColsAtCompileTime	Eigen/src/Core/Matrix.h	/^    ColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon221
ColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon20
ColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      ColsAtCompileTime = Traits::ColsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon22
ColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    ColsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon21
ColsAtCompileTime	Eigen/src/Core/ProductBase.h	/^    ColsAtCompileTime = traits<Rhs>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon139
ColsAtCompileTime	Eigen/src/Core/Replicate.h	/^    ColsAtCompileTime = ColFactor==Dynamic || int(MatrixType::ColsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon271
ColsAtCompileTime	Eigen/src/Core/Reverse.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon18
ColsAtCompileTime	Eigen/src/Core/Select.h	/^    ColsAtCompileTime = ConditionMatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon343
ColsAtCompileTime	Eigen/src/Core/Transpose.h	/^    ColsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
ColsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon238
ColsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    ColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
ColsAtCompileTime	Eigen/src/Core/products/CoeffBasedProduct.h	/^      ColsAtCompileTime = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon122
ColsAtCompileTime	Eigen/src/Eigen2Support/Minor.h	/^    ColsAtCompileTime = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon406
ColsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon472
ColsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon473
ColsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon468
ColsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon467
ColsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon475
ColsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon469
ColsAtCompileTime	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon474
ColsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    ColsAtCompileTime = Direction==Horizontal ? ColsPlusOne : MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon440
ColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      ColsAtCompileTime = internal::traits<HouseholderSequence>::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon356
ColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    ColsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon355
ColsAtCompileTime	Eigen/src/LU/FullPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon432
ColsAtCompileTime	Eigen/src/LU/PartialPivLU.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon431
ColsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon395
ColsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon393
ColsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon394
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon423
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
ColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon422
ColsAtCompileTime	Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon424
ColsAtCompileTime	Eigen/src/SparseCore/SparseDenseProduct.h	/^    ColsAtCompileTime    = Tr ? int(traits<Lhs>::ColsAtCompileTime)     : int(traits<Rhs>::ColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon374
ColsAtCompileTime	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    ColsAtCompileTime = _Rhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon368
ColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon362
ColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    ColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon361
ColsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      ColsAtCompileTime = internal::traits<Derived>::ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
ColsAtCompileTime	Eigen/src/SparseCore/SparseProduct.h	/^    ColsAtCompileTime    = _RhsNested::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
ColsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    ColsAtCompileTime = IsColVector ? 1 : Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon385
ColsAtCompileTimeMinusOne	Eigen/src/SVD/UpperBidiagonalization.h	/^      ColsAtCompileTimeMinusOne = internal::decrement_size<ColsAtCompileTime>::ret$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon424
ColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ColsBlockXpr;$/;"	t
ColsPlusOne	Eigen/src/Geometry/Homogeneous.h	/^    ColsPlusOne = (MatrixType::ColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon440
ColumnVectorType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::EigenSolver
ColumnVectorType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
ColumnVectorType	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealQZ
ColumnVectorType	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ColumnVectorType;$/;"	t	class:Eigen::RealSchur
ColwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Vertical> ColwiseReturnType;$/;"	t	class:Eigen::DenseBase
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(XprType& xpr, const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline CommaInitializer(const CommaInitializer& o)$/;"	f	struct:Eigen::CommaInitializer
CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^struct CommaInitializer$/;"	s	namespace:Eigen
CompactMode	tinyxml2/tinyxml2.h	/^	virtual bool CompactMode( const XMLElement& )	{ return _compactMode; }$/;"	f	class:tinyxml2::XMLPrinter
ComparisonName	Eigen/src/Core/util/Constants.h	/^  enum ComparisonName {$/;"	g	namespace:Eigen::internal
CompleteUnrolling	Eigen/src/Core/util/Constants.h	/^  CompleteUnrolling$/;"	e	enum:Eigen::UnrollingType
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      ComplexEigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver()$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver(Index size)$/;"	f	class:Eigen::ComplexEigenSolver
ComplexEigenSolver	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^template<typename _MatrixType> class ComplexEigenSolver$/;"	c	namespace:Eigen
ComplexMatrixType	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> ComplexMatrixType;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	struct:Eigen::internal::stem_function
ComplexScalar	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexEigenSolver
ComplexScalar	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::ComplexSchur
ComplexScalar	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::EigenSolver
ComplexScalar	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef std::complex<RealScalar> ComplexScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
ComplexScalar	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealQZ
ComplexScalar	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef std::complex<typename NumTraits<Scalar>::Real> ComplexScalar;$/;"	t	class:Eigen::RealSchur
ComplexSchur	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::ComplexSchur
ComplexSchur	Eigen/src/Eigenvalues/ComplexSchur.h	/^template<typename _MatrixType> class ComplexSchur$/;"	c	namespace:Eigen
ComplexVectorType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> ComplexVectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^class CompressedStorage$/;"	c	namespace:Eigen::internal
ComputationInfo	Eigen/src/Core/util/Constants.h	/^enum ComputationInfo {$/;"	g	namespace:Eigen
ComputeEigenvectors	Eigen/src/Core/util/Constants.h	/^  ComputeEigenvectors = 0x80,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullU	Eigen/src/Core/util/Constants.h	/^  ComputeFullU        = 0x04,$/;"	e	enum:Eigen::DecompositionOptions
ComputeFullV	Eigen/src/Core/util/Constants.h	/^  ComputeFullV        = 0x10,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinU	Eigen/src/Core/util/Constants.h	/^  ComputeThinU        = 0x08,$/;"	e	enum:Eigen::DecompositionOptions
ComputeThinV	Eigen/src/Core/util/Constants.h	/^  ComputeThinV        = 0x20,$/;"	e	enum:Eigen::DecompositionOptions
ConditionMatrixNested	Eigen/src/Core/Select.h	/^  typedef typename ConditionMatrixType::Nested ConditionMatrixNested;$/;"	t	struct:Eigen::internal::traits
Conj	Eigen/src/Core/Functors.h	/^    Conj = NumTraits<LhsScalar>::IsComplex$/;"	e	enum:Eigen::internal::scalar_conj_product_op::__anon38
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = _ConjLhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
ConjLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjLhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = _ConjRhs,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
ConjRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ConjRhs = false,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
Conjugate	Eigen/src/Core/BandMatrix.h	/^        Conjugate = ReturnOpposite && NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon214
ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ConjugateGradient() : Base() {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  explicit ConjugateGradient(const EigenBase<MatrixDerived>& A) : Base(A.derived()) {}$/;"	f	class:Eigen::ConjugateGradient
ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^class ConjugateGradient : public IterativeSolverBase<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	c	namespace:Eigen
ConjugateReturnType	Eigen/src/Householder/HouseholderSequence.h	/^    > ConjugateReturnType;$/;"	t	class:Eigen::HouseholderSequence
ConjugateReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type ConjugateReturnType;$/;"	t
ConstAffinePart	Eigen/src/Geometry/Transform.h	/^                              const Block<const MatrixType,Dim,HDim> >::type ConstAffinePart;$/;"	t	class:Eigen::Transform
ConstAffinePart	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::ConstAffinePart ConstAffinePart;$/;"	t	struct:Eigen::internal::transform_take_affine_part
ConstAlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Aligned> ConstAlignedMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstBlockType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef Block<const SparseMatrixType, BlockRows, BlockCols, true> ConstBlockType;$/;"	t	class:Eigen::BlockImpl
ConstColXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, 1, !IsRowMajor> ConstColXpr;$/;"	t
ConstColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, Dynamic, !IsRowMajor> ConstColsBlockXpr;$/;"	t
ConstColwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Vertical> ConstColwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstDiagonalDynamicIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived,DynamicIndex> >::type ConstDiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase
ConstDiagonalIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
ConstDiagonalReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::add_const<Diagonal<const Derived> >::type ConstDiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
ConstFixedSegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	s
ConstInnerVectorReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true> ConstInnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstInnerVectorsReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<const Derived,Dynamic,Dynamic,true> ConstInnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase
ConstLinearPart	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,Dim> ConstLinearPart;$/;"	t	class:Eigen::Transform
ConstLinearPart	Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> ConstLinearPart;$/;"	t	class:Eigen::Transform
ConstMapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef const Eigen::Map<const Derived, Unaligned> ConstMapType;$/;"	t	class:Eigen::PlainObjectBase
ConstMatrixType	Eigen/src/Geometry/Transform.h	/^  typedef const MatrixType ConstMatrixType;$/;"	t	class:Eigen::Transform
ConstNColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
ConstNRowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
ConstNormalReturnType	Eigen/src/Geometry/Hyperplane.h	/^  typedef const Block<const Coefficients,AmbientDimAtCompileTime,1> ConstNormalReturnType;$/;"	t	class:Eigen::Hyperplane
ConstReverseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef const Reverse<const Derived, BothDirections> ConstReverseReturnType;$/;"	t	class:Eigen::DenseBase
ConstRowXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowXpr;$/;"	t
ConstRowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef const Block<const Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> ConstRowsBlockXpr;$/;"	t
ConstRowwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef const VectorwiseOp<const Derived, Horizontal> ConstRowwiseReturnType;$/;"	t	class:Eigen::DenseBase
ConstSegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^typedef const VectorBlock<const Derived> ConstSegmentReturnType;$/;"	t
ConstSelfAdjointViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
ConstStartMinusOne	Eigen/src/Core/MatrixBase.h	/^                  internal::traits<Derived>::ColsAtCompileTime==1 ? 1 : SizeMinusOne> ConstStartMinusOne;$/;"	t	class:Eigen::MatrixBase
ConstTranslationPart	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef const Block<const MatrixType,Dim,1> ConstTranslationPart;$/;"	t	class:Eigen::Transform
ConstTranslationPart	Eigen/src/Geometry/Transform.h	/^  typedef const Block<ConstMatrixType,Dim,1,int(Mode)==(AffineCompact)> ConstTranslationPart;$/;"	t	class:Eigen::Transform
ConstTransposeReturnType	Eigen/src/Core/DenseBase.h	/^	typedef typename internal::add_const<Transpose<const Derived> >::type ConstTransposeReturnType;$/;"	t	class:Eigen::DenseBase
ConstTransposeReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::ConstTransposeReturnType ConstTransposeReturnType;$/;"	t	class:Eigen::MatrixBase
ConstTriangularViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
Constant	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index nbRows, Index nbCols, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(Index size, const Scalar& value)$/;"	f	class:Eigen::DenseBase
Constant	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Constant(const Scalar& value)$/;"	f	class:Eigen::DenseBase
ConstantReturnType	Eigen/src/Core/ArrayBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::ArrayBase
ConstantReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::DenseBase
ConstantReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Derived> ConstantReturnType;$/;"	t	class:Eigen::MatrixBase
ConstantReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_constant_op<Scalar>,Matrix<Scalar,Dynamic,Dynamic> > ConstantReturnType;$/;"	t	class:Eigen::SparseMatrixBase
Constraint	srLib/srDyn/srConstraint.h	/^class Constraint$/;"	c
ConstraintInfo	srLib/srDyn/srConstraint.h	/^struct ConstraintInfo$/;"	s
ConstraintPtrArray	srLib/srDyn/srConstraint.h	/^typedef _array<Constraint*> ConstraintPtrArray;$/;"	t
Contact	srLib/srDyn/srContactConstraint.h	/^struct Contact$/;"	s
ContactConstraint	srLib/srDyn/srContactConstraint.h	/^	ContactConstraint()$/;"	f	class:ContactConstraint
ContactConstraint	srLib/srDyn/srContactConstraint.h	/^class ContactConstraint : public Constraint$/;"	c
ContactConstraintArray	srLib/srDyn/srDYN.h	/^typedef	_array<ContactConstraint>	ContactConstraintArray;$/;"	t
ContactPtr	srLib/srDyn/srContactConstraint.h	/^typedef Contact* ContactPtr;$/;"	t
ContolFunction	Example/DracoP1/Draco_Dyn_environment.cpp	/^void Draco_Dyn_environment::ContolFunction( void* _data ) {$/;"	f	class:Draco_Dyn_environment
ConvertUTF32ToUTF8	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ConvertUTF32ToUTF8( unsigned long input, char* output, int* length )$/;"	f	class:tinyxml2::XMLUtil
ConvertXrQuadricToOpenglQuadric	srLib/srg/srgGeometryDraw.cpp	/^void ConvertXrQuadricToOpenglQuadric(DWORD dwFlags, GLUquadricObj* obj)$/;"	f
ConvertXrQuadricToOpenglQuadric	srLib/srg/srgGeometryDraw.cpp	/^void ConvertXrQuadricToOpenglQuadric(QuadricState eQuadricState, GLUquadricObj* obj)$/;"	f
Coordinate	srLib/SceneGraph/Leaf.cpp	/^Coordinate::Coordinate(double arrowSize \/*= 24*\/, double sacleFactor \/*= 50*\/, double lineWidth \/*= 1*\/)$/;"	f	class:Coordinate
Coordinate	srLib/SceneGraph/Leaf.h	/^class Coordinate : public Leaf{$/;"	c
CopyMotorParameters	srLib/srExt/srExt_RevoluteJoint.h	/^	void CopyMotorParameters(srExtRevoluteJoint* J)$/;"	f	class:srExtRevoluteJoint
CornerType	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	g	namespace:Eigen
CornerType	Eigen/src/Geometry/AlignedBox.h	/^  enum CornerType$/;"	g	class:Eigen::AlignedBox
Cost	Eigen/src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost), \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon46
Cost	Eigen/src/Core/Functors.h	/^    Cost = (NumTraits<LhsScalar>::MulCost + NumTraits<RhsScalar>::MulCost)\/2, \/\/ rough estimate!$/;"	e	enum:Eigen::internal::functor_traits::__anon37
Cost	Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon74
Cost	Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon75
Cost	Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon76
Cost	Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon77
Cost	Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon78
Cost	Eigen/src/Core/Functors.h	/^    Cost = 5 * NumTraits<Scalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon79
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<LhsScalar>::MulCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon39
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon35
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon40
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon41
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon44
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon49
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon50
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon51
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<Scalar>::IsComplex ? NumTraits<Scalar>::AddCost : 0,$/;"	e	enum:Eigen::internal::functor_traits::__anon53
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon47
Cost	Eigen/src/Core/Functors.h	/^    Cost = NumTraits<bool>::AddCost,$/;"	e	enum:Eigen::internal::functor_traits::__anon48
Cost	Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon43
Cost	Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon42
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon102
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon103
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon104
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon105
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon55
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon56
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon57
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon58
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon100
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon101
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon89
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon90
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon91
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon92
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon93
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon94
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon95
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon96
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon97
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon66
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon64
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon63
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon83
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon80
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon59
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon60
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon62
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon65
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon73
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon52
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon81
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon61
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon82
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon86
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon87
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon88
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon84
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon85
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon107
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon106
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon98
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon99
Cost	Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon54
Cost	Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
Cost	Eigen/src/Core/Redux.h	/^    Cost = (  Derived::SizeAtCompileTime == Dynamic$/;"	e	enum:Eigen::internal::redux_traits::__anon330
Cost	Eigen/src/Core/VectorwiseOp.h	/^  template<typename _Scalar, int Size> struct Cost$/;"	s	struct:Eigen::internal::member_redux
Cost	Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon230
Cost	Eigen/src/Core/Visitor.h	/^    Cost = NumTraits<Scalar>::AddCost$/;"	e	enum:Eigen::internal::functor_traits::__anon231
Cost0	Eigen/src/Core/CwiseBinaryOp.h	/^    Cost0 = EIGEN_ADD_COST(LhsCoeffReadCost,RhsCoeffReadCost),$/;"	e	enum:Eigen::internal::traits::__anon228
Cost0	Eigen/src/Core/DiagonalProduct.h	/^    Cost0 = EIGEN_ADD_COST(NumTraits<Scalar>::MulCost, MatrixType::CoeffReadCost),$/;"	e	enum:Eigen::internal::traits::__anon232
CostOpType	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,TraversalSize> CostOpType;$/;"	t	struct:Eigen::internal::traits
CostOpType	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::template Cost<InputScalar,int(TraversalSize)> CostOpType;$/;"	t	struct:Eigen::internal::traits
CreateAttribute	tinyxml2/tinyxml2.cpp	/^XMLAttribute* XMLElement::CreateAttribute()$/;"	f	class:tinyxml2::XMLElement
CrossReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::PlainObject CrossReturnType;$/;"	t	class:Eigen::VectorwiseOp
CurrentAllocs	tinyxml2/tinyxml2.h	/^    int CurrentAllocs() const		{$/;"	f	class:tinyxml2::MemPoolT
Cwise	Eigen/src/Eigen2Support/Cwise.h	/^    inline Cwise(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Cwise
Cwise	Eigen/src/Eigen2Support/Cwise.h	/^template<typename ExpressionType> class Cwise$/;"	c	namespace:Eigen
CwiseBinaryOp	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE CwiseBinaryOp(const Lhs& aLhs, const Rhs& aRhs, const BinaryOp& func = BinaryOp())$/;"	f	class:Eigen::CwiseBinaryOp
CwiseBinaryOp	Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseBinaryOpImpl	Eigen/src/Core/CwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Dense>$/;"	c	namespace:Eigen
CwiseBinaryOpImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    CwiseBinaryOpImpl()$/;"	f	class:Eigen::CwiseBinaryOpImpl
CwiseBinaryOpImpl	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp, Lhs, Rhs, Sparse>$/;"	c	namespace:Eigen
CwiseBinaryXpr	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryFunc, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
CwiseBinaryXpr	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> CwiseBinaryXpr;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
CwiseNullaryOp	Eigen/src/Core/CwiseNullaryOp.h	/^    CwiseNullaryOp(Index nbRows, Index nbCols, const NullaryOp& func = NullaryOp())$/;"	f	class:Eigen::CwiseNullaryOp
CwiseNullaryOp	Eigen/src/Core/CwiseNullaryOp.h	/^class CwiseNullaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseProductDenseReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    template<typename OtherDerived> struct CwiseProductDenseReturnType {$/;"	s	class:Eigen::SparseMatrixBase
CwiseScalarEqualReturnType	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^typedef CwiseBinaryOp<internal::scalar_cmp_op<Scalar,internal::cmp_EQ>, const Derived, const ConstantReturnType> CwiseScalarEqualReturnType;$/;"	t
CwiseUnaryOp	Eigen/src/Core/CwiseUnaryOp.h	/^    inline CwiseUnaryOp(const XprType& xpr, const UnaryOp& func = UnaryOp())$/;"	f	class:Eigen::CwiseUnaryOp
CwiseUnaryOp	Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOp : internal::no_assignment_operator,$/;"	c	namespace:Eigen
CwiseUnaryOpImpl	Eigen/src/Core/CwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,XprType,Dense>$/;"	c	namespace:Eigen
CwiseUnaryOpImpl	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>$/;"	c	namespace:Eigen
CwiseUnaryView	Eigen/src/Core/CwiseUnaryView.h	/^    inline CwiseUnaryView(const MatrixType& mat, const ViewOp& func = ViewOp())$/;"	f	class:Eigen::CwiseUnaryView
CwiseUnaryView	Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryView : public CwiseUnaryViewImpl<ViewOp, MatrixType, typename internal::traits<MatrixType>::StorageKind>$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	Eigen/src/Core/CwiseUnaryView.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Dense>$/;"	c	namespace:Eigen
CwiseUnaryViewImpl	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>$/;"	c	namespace:Eigen
Cylinder	srLib/SceneGraph/Leaf.cpp	/^Cylinder::Cylinder(double radius, double height)$/;"	f	class:Cylinder
Cylinder	srLib/SceneGraph/Leaf.h	/^class Cylinder : public Leaf$/;"	c
CylinderInertia	srLib/LieGroup/LieGroup.cpp	/^Inertia CylinderInertia(SR_REAL density, SR_REAL rad, SR_REAL height)$/;"	f
DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define DEAD /;"	d
DEAD_NON_PRINCIPAL	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define DEAD_NON_PRINCIPAL /;"	d
DEAD_PRINCIPAL	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define DEAD_PRINCIPAL /;"	d
DEBUG	tinyxml2/tinyxml2.h	/^#       define DEBUG$/;"	d
DEC	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#define DEC(/;"	d	file:
DEC	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define DEC(/;"	d	file:
DECL_GSISX	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define DECL_GSISX(/;"	d
DECL_GSSVX	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define DECL_GSSVX(/;"	d
DEFAULT_ALLOWED_CLOSEDLOOPERROR_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_ALLOWED_CLOSEDLOOPERROR_srDYN	/;"	d
DEFAULT_ALLOWED_JOINTPOSITIONERROR_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_ALLOWED_JOINTPOSITIONERROR_srDYN	/;"	d
DEFAULT_ALLOWED_PENETRATION_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_ALLOWED_PENETRATION_srDYN	/;"	d
DEFAULT_BOUNCING_THRESHOLD_CONTACT_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_BOUNCING_THRESHOLD_CONTACT_srDYN	/;"	d
DEFAULT_BOUNCING_THRESHOLD_JOINTPOSITION_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_BOUNCING_THRESHOLD_JOINTPOSITION_srDYN	/;"	d
DEFAULT_ERP_CLOSEDLOOP_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_ERP_CLOSEDLOOP_srDYN	/;"	d
DEFAULT_ERP_CONTACT_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_ERP_CONTACT_srDYN	/;"	d
DEFAULT_ERP_JOINTPOSITIONLIMIT_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_ERP_JOINTPOSITIONLIMIT_srDYN	/;"	d
DEFAULT_MAXIMUM_BOUNCING_VELOCITY_CONTACT_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_MAXIMUM_BOUNCING_VELOCITY_CONTACT_srDYN	/;"	d
DEFAULT_MAXIMUM_BOUNCING_VELOCITY_JOINTPOSITION_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_MAXIMUM_BOUNCING_VELOCITY_JOINTPOSITION_srDYN	/;"	d
DEFAULT_MAXIMUM_ER_VELOCITY_CLOSEDLOOP_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_MAXIMUM_ER_VELOCITY_CLOSEDLOOP_srDYN	/;"	d
DEFAULT_MAXIMUM_ER_VELOCITY_CONTACT_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_MAXIMUM_ER_VELOCITY_CONTACT_srDYN	/;"	d
DEFAULT_MAXIMUM_ER_VELOCITY_JOINTPOSITION_srDYN	srLib/srDyn/srDYN.h	/^#define DEFAULT_MAXIMUM_ER_VELOCITY_JOINTPOSITION_srDYN	/;"	d
DEFAULT_NUMOFSUBSTEP_RENDER_TEMP	srLib/srDyn/srSpace.h	/^#define	DEFAULT_NUMOFSUBSTEP_RENDER_TEMP	/;"	d
DEG2RAD	srLib/common/types.h	/^inline SR_REAL DEG2RAD(double d){ return (d * SR_RADIAN); }$/;"	f
DEG2RAD	srLib/common/types.h	/^inline SR_REAL DEG2RAD(float d) { return (d * SR_RADIAN); }$/;"	f
DEG2RAD	srLib/common/types.h	/^inline SR_REAL DEG2RAD(int d)	 { return (d * SR_RADIAN); }$/;"	f
DEG2RAD	srMath/Constant.h	/^	static const Real	DEG2RAD = 0.01745329251994329577;				\/\/\/< rad = DEG2RAD * deg$/;"	m	namespace:srMath
DEGREE_TO_RADIAN	srLib/srDyn/srDYN.cpp	/^#define DEGREE_TO_RADIAN	/;"	d	file:
DIFFKIN_Initialize	srLib/srDyn/srSystem.cpp	/^void srSystem::DIFFKIN_Initialize()$/;"	f	class:srSystem
DIFFKIN_IntegratePosition	srLib/srDyn/srSystem.cpp	/^void srSystem::DIFFKIN_IntegratePosition(SR_REAL & _step)$/;"	f	class:srSystem
DIFFKIN_LinkVelocityPropagation	srLib/srDyn/srSystem.cpp	/^void srSystem::DIFFKIN_LinkVelocityPropagation()$/;"	f	class:srSystem
DOUBLE_QUOTE	tinyxml2/tinyxml2.cpp	/^static const char DOUBLE_QUOTE			= '\\"';$/;"	v	file:
DOUBLE_WINDOWS	srLib/SceneGraph/SceneGraphRenderer.h	/^	enum	NUM_WINDOWS	{SINGLE_WINDOWS, DOUBLE_WINDOWS};$/;"	e	enum:SceneGraphRenderer::NUM_WINDOWS
DRACO_H	Example/DracoP1/draco.h	/^#define DRACO_H$/;"	d
DST_CHAN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define DST_CHAN /;"	d
DST_CTRL	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define DST_CTRL(/;"	d
DWORD	srLib/srg/srgL.h	/^	typedef unsigned long DWORD;	$/;"	t
DWORD	srLib/srg/srgL.h	/^	typedef unsigned long DWORD;$/;"	t
DYNAMIC	srLib/srDyn/srLink.h	/^	enum DYNTYPE { DYNAMIC, STATIC, KINEMATIC };$/;"	e	enum:srLink::DYNTYPE
DYNAMIC	srLib/srDyn/srSystem.h	/^	enum	BASELINKTYPE	{ DYNAMIC, FIXED,  KINEMATIC };$/;"	e	enum:srSystem::BASELINKTYPE
DYNTYPE	srLib/srDyn/srLink.h	/^	enum DYNTYPE { DYNAMIC, STATIC, KINEMATIC };$/;"	g	class:srLink
DYN_ENVIRONMENT_DRACO	Example/DracoP1/Draco_Dyn_environment.h	/^#define  DYN_ENVIRONMENT_DRACO$/;"	d
DYN_ForwardDynamics_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::DYN_ForwardDynamics_Set00(SR_REAL & _step)$/;"	f	class:srSystem
DYN_ImpulseDynamics_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::DYN_ImpulseDynamics_Set00(SR_REAL & _fps)$/;"	f	class:srSystem
DYN_Initialize	srLib/srDyn/srSystem.cpp	/^void srSystem::DYN_Initialize()$/;"	f	class:srSystem
DYN_IntegratePosition_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::DYN_IntegratePosition_Set00(SR_REAL & _step)$/;"	f	class:srSystem
DYN_MODE_PRESTEP	srLib/srDyn/srSpace.cpp	/^void srSpace::DYN_MODE_PRESTEP()$/;"	f	class:srSpace
DYN_MODE_RUNTIME_SIMULATION_LOOP	srLib/srDyn/srSpace.cpp	/^void srSpace::DYN_MODE_RUNTIME_SIMULATION_LOOP()$/;"	f	class:srSpace
DataRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic))$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon213
DataRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon215
DataRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    DataRowsAtCompileTime = ((Supers!=Dynamic) && (Subs!=Dynamic)) ? 1 + Supers + Subs : Dynamic$/;"	e	enum:Eigen::internal::traits::__anon216
Dec	Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/CholmodSupport/CholmodSupport.h	/^  typedef CholmodBase<_MatrixType,_UpLo,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  typedef DiagonalPreconditioner<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef BiCGSTAB<_MatrixType, _Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  typedef IncompleteLUT<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef IterativeSolverBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  typedef PastixBase<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/PardisoSupport/PardisoSupport.h	/^  typedef PardisoImpl<_Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef SPQR<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SimplicialCholeskyBase<Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/SparseLU/SparseLU.h	/^  typedef SparseLU<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/SparseLU/SparseLU.h	/^  typedef SparseLU<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/SparseQR/SparseQR.h	/^  typedef SparseQR<_MatrixType, OrderingType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/SparseQR/SparseQR.h	/^  typedef SparseQR<_MatrixType,OrderingType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef SuperLUBase<_MatrixType,Derived> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
Dec	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::solve_retval
Dec	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  typedef UmfPackLU<_MatrixType> Dec;$/;"	t	struct:Eigen::internal::sparse_solve_retval
DecompositionOptions	Eigen/src/Core/util/Constants.h	/^enum DecompositionOptions {$/;"	g	namespace:Eigen
DecompositionType	Eigen/src/misc/Image.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::image_retval_base
DecompositionType	Eigen/src/misc/Kernel.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::kernel_retval_base
DecompositionType	Eigen/src/misc/Solve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::solve_retval_base
DecompositionType	Eigen/src/misc/SparseSolve.h	/^  typedef _DecompositionType DecompositionType;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
Default	Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	e	enum:Eigen::Default_t
DefaultTraversal	Eigen/src/Core/util/Constants.h	/^  DefaultTraversal,$/;"	e	enum:Eigen::TraversalType
Default_t	Eigen/src/Core/util/Constants.h	/^enum Default_t    { Default };$/;"	g	namespace:Eigen
Defined	Eigen/src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon194
Defined	Eigen/src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon195
Defined	Eigen/src/Core/util/Meta.h	/^    Defined = 1$/;"	e	enum:Eigen::scalar_product_traits::__anon196
Defined	Eigen/src/Core/util/Meta.h	/^  enum { Defined = 0 };$/;"	e	enum:Eigen::scalar_product_traits::__anon193
DeleteAttribute	tinyxml2/tinyxml2.cpp	/^void XMLElement::DeleteAttribute( XMLAttribute* attribute )$/;"	f	class:tinyxml2::XMLElement
DeleteAttribute	tinyxml2/tinyxml2.cpp	/^void XMLElement::DeleteAttribute( const char* name )$/;"	f	class:tinyxml2::XMLElement
DeleteChild	tinyxml2/tinyxml2.cpp	/^void XMLNode::DeleteChild( XMLNode* node )$/;"	f	class:tinyxml2::XMLNode
DeleteChildren	tinyxml2/tinyxml2.cpp	/^void XMLNode::DeleteChildren()$/;"	f	class:tinyxml2::XMLNode
DeleteNode	tinyxml2/tinyxml2.cpp	/^void XMLDocument::DeleteNode( XMLNode* node )	{$/;"	f	class:tinyxml2::XMLDocument
DeleteNode	tinyxml2/tinyxml2.cpp	/^void XMLNode::DeleteNode( XMLNode* node )$/;"	f	class:tinyxml2::XMLNode
Dense	Eigen/src/Core/util/Constants.h	/^struct Dense {};$/;"	s	namespace:Eigen
DenseBase	Eigen/src/Core/DenseBase.h	/^    DenseBase()$/;"	f	class:Eigen::DenseBase
DenseBase	Eigen/src/Core/DenseBase.h	/^template<typename Derived> class DenseBase$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, DirectWriteAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived, WriteAccessors> : public DenseCoeffsBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
DenseCoeffsBase	Eigen/src/Core/DenseCoeffsBase.h	/^class DenseCoeffsBase<Derived,ReadOnlyAccessors> : public EigenBase<Derived>$/;"	c	namespace:Eigen
DenseIndex	Eigen/src/Core/util/XprHelper.h	/^typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE DenseIndex;$/;"	t	namespace:Eigen
DenseMatrix	Eigen/src/SparseQR/SparseQR.h	/^  typedef Matrix<Scalar,Dynamic,Dynamic> DenseMatrix;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
DenseMatrixType	Eigen/src/Core/BandMatrix.h	/^    typedef Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::internal::BandMatrixBase
DenseMatrixType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, ColsAtCompileTime, 0, MaxRowsAtCompileTime, MaxColsAtCompileTime> DenseMatrixType;$/;"	t	class:Eigen::DiagonalBase
DenseMatrixType	Eigen/src/Core/PermutationMatrix.h	/^            DenseMatrixType;$/;"	t	class:Eigen::PermutationBase
DenseMatrixType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Derived::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::Transpose
DenseMatrixType	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits
DenseMatrixType	Eigen/src/Core/TriangularMatrix.h	/^      typedef typename TriangularView<MatrixType,Mode>::DenseMatrixType DenseMatrixType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
DenseMatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularBase
DenseMatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::DenseMatrixType DenseMatrixType;$/;"	t	class:Eigen::TriangularView
DenseMatrixType	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename MatrixType::PlainObject DenseMatrixType;$/;"	t	struct:Eigen::internal::traits
DenseSparseProductReturnType	Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct DenseSparseProductReturnType$/;"	s	namespace:Eigen
DenseSparseProductReturnType	Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct DenseSparseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() : m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() : m_data(0), m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() : m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() : m_rows(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage() {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex nbRows, DenseIndex) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_rows(nbRows)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex size, DenseIndex, DenseIndex nbCols) : m_data(internal::conditional_aligned_new_auto<T,(_Options&DontAlign)==0>(size)), m_cols(nbCols)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) : m_rows(nbRows), m_cols(nbCols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex nbRows, DenseIndex) : m_rows(nbRows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex, DenseIndex, DenseIndex nbCols) : m_cols(nbCols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(DenseStorage&& other)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage& other) : m_data(other.m_data), m_rows(other.m_rows), m_cols(other.m_cols) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(const DenseStorage&) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_cols(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) : m_data(0), m_rows(0) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert) {}$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^    DenseStorage(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::DenseStorage
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Cols, int _Options> class DenseStorage<T, Size, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Options> class DenseStorage<T, Size, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Cols, int _Options> class DenseStorage$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size, int _Rows, int _Options> class DenseStorage<T, Size, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, 0, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Cols, int _Options> class DenseStorage<T, Dynamic, Dynamic, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, 0, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Options> class DenseStorage<T, Dynamic, Dynamic, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Cols, int _Options> class DenseStorage<T, 0, _Rows, _Cols, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, 0, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseStorage	Eigen/src/Core/DenseStorage.h	/^template<typename T, int _Rows, int _Options> class DenseStorage<T, Dynamic, _Rows, Dynamic, _Options>$/;"	c	namespace:Eigen
DenseTimeSparseProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^    DenseTimeSparseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseProduct
DenseTimeSparseProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^class DenseTimeSparseProduct$/;"	c	namespace:Eigen
DenseTimeSparseSelfAdjointProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    DenseTimeSparseSelfAdjointProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct
DenseTimeSparseSelfAdjointProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class DenseTimeSparseSelfAdjointProduct$/;"	c	namespace:Eigen
DenseType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::DiagonalBase
DenseType	Eigen/src/Core/PlainObjectBase.h	/^    typedef Derived DenseType;$/;"	t	class:Eigen::PlainObjectBase
DenseType	Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType DenseType;$/;"	t	class:Eigen::TriangularBase
Depth	Eigen/src/Core/GeneralProduct.h	/^    Depth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon283
Derived	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Derived	Eigen/src/Core/CwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, XprType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Derived	Eigen/src/Core/CwiseUnaryView.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Derived	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> Derived;$/;"	t	class:Eigen::CwiseBinaryOpImpl
Derived	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryOp<UnaryOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryOpImpl
Derived	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef CwiseUnaryView<ViewOp, MatrixType> Derived;$/;"	t	class:Eigen::CwiseUnaryViewImpl
Detect	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::Detect()$/;"	f	class:srIRSensor
Detect	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::Detect()$/;"	f	class:srRangeFinder
Detect	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::Detect()$/;"	f	class:srTouchSensor
DiagIndex	Eigen/src/Core/Diagonal.h	/^    enum { DiagIndex = _DiagIndex };$/;"	e	enum:Eigen::Diagonal::__anon340
DiagSizeAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      DiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon423
DiagVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1> DiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Diagonal	Eigen/src/Core/Diagonal.h	/^    inline Diagonal(MatrixType& matrix, Index a_index = DiagIndex) : m_matrix(matrix), m_index(a_index) {}$/;"	f	class:Eigen::Diagonal
Diagonal	Eigen/src/Core/Diagonal.h	/^template<typename MatrixType, int _DiagIndex> class Diagonal$/;"	c	namespace:Eigen
DiagonalBase	Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
DiagonalDynamicIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived,DynamicIndex> DiagonalDynamicIndexReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalIndexReturnType	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	s	class:Eigen::MatrixBase
DiagonalIntReturnType	Eigen/src/Core/BandMatrix.h	/^    template<int Index> struct DiagonalIntReturnType {$/;"	s	class:Eigen::internal::BandMatrixBase
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    explicit inline DiagonalMatrix(const MatrixBase<OtherDerived>& other) : m_diagonal(other)$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix() {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(Index dim) : m_diagonal(dim) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalBase<OtherDerived>& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const DiagonalMatrix& other) : m_diagonal(other.diagonal()) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y) : m_diagonal(x,y) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalMatrix(const Scalar& x, const Scalar& y, const Scalar& z) : m_diagonal(x,y,z) {}$/;"	f	class:Eigen::DiagonalMatrix
DiagonalMatrix	Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalMatrix$/;"	c	namespace:Eigen
DiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner() : m_isInitialized(false) {}$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner(const MatType& mat) : m_invdiag(mat.cols())$/;"	f	class:Eigen::DiagonalPreconditioner
DiagonalPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class DiagonalPreconditioner$/;"	c	namespace:Eigen
DiagonalProduct	Eigen/src/Core/DiagonalProduct.h	/^    inline DiagonalProduct(const MatrixType& matrix, const DiagonalType& diagonal)$/;"	f	class:Eigen::DiagonalProduct
DiagonalProduct	Eigen/src/Core/DiagonalProduct.h	/^class DiagonalProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen
DiagonalReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Diagonal<Derived> DiagonalReturnType;$/;"	t	class:Eigen::MatrixBase
DiagonalReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type DiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalSize	Eigen/src/Core/BandMatrix.h	/^        DiagonalSize = (RowsAtCompileTime==Dynamic || ColsAtCompileTime==Dynamic)$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon214
DiagonalType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type DiagonalType;$/;"	t	class:Eigen::Tridiagonalization
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalWrapper
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalBase
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::DiagonalVectorType DiagonalVectorType;$/;"	t	class:Eigen::DiagonalMatrix
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^  typedef Matrix<_Scalar,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1> DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalVectorType	Eigen/src/Core/DiagonalMatrix.h	/^  typedef _DiagonalVectorType DiagonalVectorType;$/;"	t	struct:Eigen::internal::traits
DiagonalWrapper	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalWrapper(DiagonalVectorType& a_diagonal) : m_diagonal(a_diagonal) {}$/;"	f	class:Eigen::DiagonalWrapper
DiagonalWrapper	Eigen/src/Core/DiagonalMatrix.h	/^class DiagonalWrapper$/;"	c	namespace:Eigen
Diffuse	srLib/srg/srgColor.h	/^		float Diffuse[4];		\/\/ material property for diffuse lighting (ºÐ»ê)$/;"	m	struct:srgMaterialColor::sMaterialColor
DiffuseColorChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::DiffuseColorChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
Dim	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon397
Dim	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon403
Dim	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon398
Dim	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Scaling::__anon402
Dim	Eigen/src/Eigen2Support/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon404
Dim	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon401
Dim	Eigen/src/Geometry/AngleAxis.h	/^  enum { Dim = 3 };$/;"	e	enum:Eigen::AngleAxis::__anon435
Dim	Eigen/src/Geometry/Rotation2D.h	/^  enum { Dim = 2 };$/;"	e	enum:Eigen::Rotation2D::__anon449
Dim	Eigen/src/Geometry/RotationBase.h	/^    enum { Dim = _Dim };$/;"	e	enum:Eigen::RotationBase::__anon436
Dim	Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon437
Dim	Eigen/src/Geometry/RotationBase.h	/^  enum { Dim = RotationDerived::Dim };$/;"	e	enum:Eigen::internal::rotation_base_generic_product_selector::__anon438
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = Transform::Dim,$/;"	e	enum:Eigen::internal::transform_traits::__anon450
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon454
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = TransformType::Dim, $/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon455
Dim	Eigen/src/Geometry/Transform.h	/^    Dim = _Dim,     \/\/\/< space dimension in which the transformation holds$/;"	e	enum:Eigen::Transform::__anon451
Dim	Eigen/src/Geometry/Translation.h	/^  enum { Dim = _Dim };$/;"	e	enum:Eigen::Translation::__anon448
DirectAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int DirectAccessBit = 0x40;$/;"	m	namespace:Eigen
DirectAccessors	Eigen/src/Core/util/Constants.h	/^  DirectAccessors, $/;"	e	enum:Eigen::AccessorLevels
DirectLinearAccessType	Eigen/src/Core/util/BlasUtil.h	/^    >::type DirectLinearAccessType;$/;"	t	struct:Eigen::internal::blas_traits
DirectWriteAccessors	Eigen/src/Core/util/Constants.h	/^  DirectWriteAccessors$/;"	e	enum:Eigen::AccessorLevels
Direction	Eigen/src/Geometry/Homogeneous.h	/^    enum { Direction = _Direction };$/;"	e	enum:Eigen::Homogeneous::__anon441
DirectionType	Eigen/src/Core/util/Constants.h	/^enum DirectionType { $/;"	g	namespace:Eigen
DisUse	srLib/SceneGraph/Texture3DS.cpp	/^void Texture3DS::DisUse()$/;"	f	class:Texture3DS
DomeBase	srLib/SceneGraph/Leaf.cpp	/^DomeBase::DomeBase(double radius)$/;"	f	class:DomeBase
DomeBase	srLib/SceneGraph/Leaf.h	/^class DomeBase : public Leaf$/;"	c
DontAlign	Eigen/src/Core/util/Constants.h	/^  DontAlign = 0x2$/;"	e	enum:Eigen::StorageOptions
DontAlignCols	Eigen/src/Core/IO.h	/^enum { DontAlignCols = 1 };$/;"	e	enum:Eigen::__anon242
DoubleAttribute	tinyxml2/tinyxml2.cpp	/^double XMLElement::DoubleAttribute(const char* name, double defaultValue) const $/;"	f	class:tinyxml2::XMLElement
DoublePacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  struct DoublePacket$/;"	s	class:Eigen::internal::gebp_traits
DoubleText	tinyxml2/tinyxml2.cpp	/^double XMLElement::DoubleText(double defaultValue) const$/;"	f	class:tinyxml2::XMLElement
DoubleValue	tinyxml2/tinyxml2.h	/^    double 	 DoubleValue() const			{$/;"	f	class:tinyxml2::XMLAttribute
Draco_Dyn_environment	Example/DracoP1/Draco_Dyn_environment.cpp	/^Draco_Dyn_environment::Draco_Dyn_environment():$/;"	f	class:Draco_Dyn_environment
Draco_Dyn_environment	Example/DracoP1/Draco_Dyn_environment.h	/^class Draco_Dyn_environment$/;"	c
Draw	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::Draw( double scaleFactor )$/;"	f	class:Model3DS
Draw	srLib/SceneGraph/ModelSTL.cpp	/^void ModelSTL::Draw()$/;"	f	class:ModelSTL
Draw	srLib/srDyn/srEntity.h	/^	virtual void	Draw() {};$/;"	f	class:srEntity
Draw	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::Draw()$/;"	f	class:srIRSensor
DrawStyle	srLib/srg/srgGeometryDraw.h	/^	srgDrawStyle		DrawStyle;$/;"	m	struct:QuadricState
DstHasDirectAccess	Eigen/src/Core/Assign.h	/^    DstHasDirectAccess = Derived::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon23
DstHasDirectAccess	Eigen/src/Core/Assign_MKL.h	/^      DstHasDirectAccess = Dst::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
DstIsAligned	Eigen/src/Core/Assign.h	/^    DstIsAligned = Derived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon23
DynArray	tinyxml2/tinyxml2.h	/^    DynArray() {$/;"	f	class:tinyxml2::DynArray
DynArray	tinyxml2/tinyxml2.h	/^class DynArray$/;"	c	namespace:tinyxml2
DynPlainObject	Eigen/src/Core/ProductBase.h	/^    typedef Matrix<Scalar,RowsAtCompileTime==1?1:Dynamic,ColsAtCompileTime==1?1:Dynamic,BasePlainObject::Options> DynPlainObject;$/;"	t	class:Eigen::ProductBase
Dynamic	Eigen/src/Core/util/Constants.h	/^const int Dynamic = -1;$/;"	m	namespace:Eigen
DynamicIndex	Eigen/src/Core/util/Constants.h	/^const int DynamicIndex = 0xffffff;$/;"	m	namespace:Eigen
EDIT3DS	srLib/SceneGraph/Model3DS.cpp	/^ #define EDIT3DS	/;"	d	file:
EIGEN2_GEOMETRY_MODULE_H	Eigen/src/Eigen2Support/Geometry/All.h	/^#define EIGEN2_GEOMETRY_MODULE_H$/;"	d
EIGEN2_LEASTSQUARES_H	Eigen/src/Eigen2Support/LeastSquares.h	/^#define EIGEN2_LEASTSQUARES_H$/;"	d
EIGEN2_LU_H	Eigen/src/Eigen2Support/LU.h	/^#define EIGEN2_LU_H$/;"	d
EIGEN2_MACROS_H	Eigen/src/Eigen2Support/Macros.h	/^#define EIGEN2_MACROS_H$/;"	d
EIGEN2_MATH_FUNCTIONS_H	Eigen/src/Eigen2Support/MathFunctions.h	/^#define EIGEN2_MATH_FUNCTIONS_H$/;"	d
EIGEN2_MEMORY_H	Eigen/src/Eigen2Support/Memory.h	/^#define EIGEN2_MEMORY_H$/;"	d
EIGEN2_META_H	Eigen/src/Eigen2Support/Meta.h	/^#define EIGEN2_META_H$/;"	d
EIGEN2_QR_H	Eigen/src/Eigen2Support/QR.h	/^#define EIGEN2_QR_H$/;"	d
EIGEN2_SVD_H	Eigen/src/Eigen2Support/SVD.h	/^#define EIGEN2_SVD_H$/;"	d
EIGEN2_VECTORBLOCK_H	Eigen/src/Eigen2Support/VectorBlock.h	/^#define EIGEN2_VECTORBLOCK_H$/;"	d
EIGEN_ADD_COST	Eigen/src/Core/util/Macros.h	/^#define EIGEN_ADD_COST(/;"	d
EIGEN_ALIGN	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ALIGN /;"	d
EIGEN_ALIGN16	Eigen/src/Core/util/Macros.h	/^#define EIGEN_ALIGN16 /;"	d
EIGEN_ALIGN8	Eigen/src/Core/util/Macros.h	/^#define EIGEN_ALIGN8 /;"	d
EIGEN_ALIGNEDBOX_H	Eigen/src/Geometry/AlignedBox.h	/^#define EIGEN_ALIGNEDBOX_H$/;"	d
EIGEN_ALIGNED_ALLOCA	Eigen/src/Core/util/Memory.h	/^    #define EIGEN_ALIGNED_ALLOCA(/;"	d
EIGEN_ALIGNED_ALLOCATOR	Eigen/src/StlSupport/details.h	/^  #define EIGEN_ALIGNED_ALLOCATOR /;"	d
EIGEN_ALIGN_128	Eigen/src/Eigen2Support/Macros.h	/^#define EIGEN_ALIGN_128 /;"	d
EIGEN_ALIGN_STATICALLY	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ALIGN_STATICALLY /;"	d
EIGEN_ALIGN_TO_BOUNDARY	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ALIGN_TO_BOUNDARY(/;"	d
EIGEN_ALLANDANY_H	Eigen/src/Core/BooleanRedux.h	/^#define EIGEN_ALLANDANY_H$/;"	d
EIGEN_ALLOCA	Eigen/src/Core/util/Memory.h	/^    #define EIGEN_ALLOCA /;"	d
EIGEN_ALWAYS_INLINE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_ALWAYS_INLINE /;"	d
EIGEN_AMBIVECTOR_H	Eigen/src/SparseCore/AmbiVector.h	/^#define EIGEN_AMBIVECTOR_H$/;"	d
EIGEN_ANGLEAXIS_H	Eigen/src/Geometry/AngleAxis.h	/^#define EIGEN_ANGLEAXIS_H$/;"	d
EIGEN_ARCH_ARM	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_ARM /;"	d
EIGEN_ARCH_ARM64	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_ARM64 /;"	d
EIGEN_ARCH_ARM_OR_ARM64	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_ARM_OR_ARM64 /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS /;"	d
EIGEN_ARCH_IA64	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_IA64 /;"	d
EIGEN_ARCH_MIPS	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_MIPS /;"	d
EIGEN_ARCH_PPC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_PPC /;"	d
EIGEN_ARCH_SPARC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_SPARC /;"	d
EIGEN_ARCH_WANTS_ALIGNMENT	Eigen/src/Eigen2Support/Macros.h	/^#define EIGEN_ARCH_WANTS_ALIGNMENT /;"	d
EIGEN_ARCH_WANTS_STACK_ALIGNMENT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_WANTS_STACK_ALIGNMENT /;"	d
EIGEN_ARCH_i386	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_i386 /;"	d
EIGEN_ARCH_i386_OR_x86_64	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_i386_OR_x86_64 /;"	d
EIGEN_ARCH_x86_64	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_ARCH_x86_64 /;"	d
EIGEN_ARM_PREFETCH	Eigen/src/Core/arch/NEON/PacketMath.h	/^  #define EIGEN_ARM_PREFETCH(/;"	d
EIGEN_ARRAYBASE_H	Eigen/src/Core/ArrayBase.h	/^#define EIGEN_ARRAYBASE_H$/;"	d
EIGEN_ARRAYWRAPPER_H	Eigen/src/Core/ArrayWrapper.h	/^#define EIGEN_ARRAYWRAPPER_H$/;"	d
EIGEN_ARRAY_CWISE_OPERATORS_H	Eigen/src/Eigen2Support/CwiseOperators.h	/^#define EIGEN_ARRAY_CWISE_OPERATORS_H$/;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY	Eigen/src/Core/GlobalFunctions.h	/^#define EIGEN_ARRAY_DECLARE_GLOBAL_EIGEN_UNARY(/;"	d
EIGEN_ARRAY_DECLARE_GLOBAL_UNARY	Eigen/src/Core/GlobalFunctions.h	/^#define EIGEN_ARRAY_DECLARE_GLOBAL_UNARY(/;"	d
EIGEN_ARRAY_H	Eigen/src/Core/Array.h	/^#define EIGEN_ARRAY_H$/;"	d
EIGEN_ASM_COMMENT	Eigen/src/Core/util/Macros.h	/^    #define EIGEN_ASM_COMMENT(/;"	d
EIGEN_ASSIGN_H	Eigen/src/Core/Assign.h	/^#define EIGEN_ASSIGN_H$/;"	d
EIGEN_ASSIGN_VML_H	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_ASSIGN_VML_H$/;"	d
EIGEN_BANDMATRIX_H	Eigen/src/Core/BandMatrix.h	/^#define EIGEN_BANDMATRIX_H$/;"	d
EIGEN_BASIC_PRECONDITIONERS_H	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^#define EIGEN_BASIC_PRECONDITIONERS_H$/;"	d
EIGEN_BICGSTAB_H	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^#define EIGEN_BICGSTAB_H$/;"	d
EIGEN_BIDIAGONALIZATION_H	Eigen/src/SVD/UpperBidiagonalization.h	/^#define EIGEN_BIDIAGONALIZATION_H$/;"	d
EIGEN_BLASUTIL_H	Eigen/src/Core/util/BlasUtil.h	/^#define EIGEN_BLASUTIL_H$/;"	d
EIGEN_BLOCK2_H	Eigen/src/Eigen2Support/Block.h	/^#define EIGEN_BLOCK2_H$/;"	d
EIGEN_BLOCK_H	Eigen/src/Core/Block.h	/^#define EIGEN_BLOCK_H$/;"	d
EIGEN_BLOCK_HOUSEHOLDER_H	Eigen/src/Householder/BlockHouseholder.h	/^#define EIGEN_BLOCK_HOUSEHOLDER_H$/;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD /;"	d
EIGEN_CAT	Eigen/src/Core/util/Macros.h	/^#define EIGEN_CAT(/;"	d
EIGEN_CAT2	Eigen/src/Core/util/Macros.h	/^#define EIGEN_CAT2(/;"	d
EIGEN_CHECK_BINARY_COMPATIBILIY	Eigen/src/Core/CwiseBinaryOp.h	/^#define EIGEN_CHECK_BINARY_COMPATIBILIY(/;"	d
EIGEN_CHOLMODSUPPORT_H	Eigen/src/CholmodSupport/CholmodSupport.h	/^#define EIGEN_CHOLMODSUPPORT_H$/;"	d
EIGEN_COEFFBASED_PRODUCT_H	Eigen/src/Core/products/CoeffBasedProduct.h	/^#define EIGEN_COEFFBASED_PRODUCT_H$/;"	d
EIGEN_COLAMD_H	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define EIGEN_COLAMD_H$/;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_H	Eigen/src/QR/ColPivHouseholderQR.h	/^#define EIGEN_COLPIVOTINGHOUSEHOLDERQR_H$/;"	d
EIGEN_COLPIVOTINGHOUSEHOLDERQR_MKL_H	Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^#define EIGEN_COLPIVOTINGHOUSEHOLDERQR_MKL_H$/;"	d
EIGEN_COMMAINITIALIZER_H	Eigen/src/Core/CommaInitializer.h	/^#define EIGEN_COMMAINITIALIZER_H$/;"	d
EIGEN_COMPLEX_ALTIVEC_H	Eigen/src/Core/arch/AltiVec/Complex.h	/^#define EIGEN_COMPLEX_ALTIVEC_H$/;"	d
EIGEN_COMPLEX_EIGEN_SOLVER_H	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^#define EIGEN_COMPLEX_EIGEN_SOLVER_H$/;"	d
EIGEN_COMPLEX_NEON_H	Eigen/src/Core/arch/NEON/Complex.h	/^#define EIGEN_COMPLEX_NEON_H$/;"	d
EIGEN_COMPLEX_SCHUR_H	Eigen/src/Eigenvalues/ComplexSchur.h	/^#define EIGEN_COMPLEX_SCHUR_H$/;"	d
EIGEN_COMPLEX_SCHUR_MKL_H	Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^#define EIGEN_COMPLEX_SCHUR_MKL_H$/;"	d
EIGEN_COMPLEX_SSE_H	Eigen/src/Core/arch/SSE/Complex.h	/^#define EIGEN_COMPLEX_SSE_H$/;"	d
EIGEN_COMPRESSED_STORAGE_H	Eigen/src/SparseCore/CompressedStorage.h	/^#define EIGEN_COMPRESSED_STORAGE_H$/;"	d
EIGEN_COMP_ARM	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_ARM /;"	d
EIGEN_COMP_CLANG	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_CLANG /;"	d
EIGEN_COMP_GNUC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_GNUC /;"	d
EIGEN_COMP_GNUC_STRICT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_GNUC_STRICT /;"	d
EIGEN_COMP_IBM	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_IBM /;"	d
EIGEN_COMP_ICC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_ICC /;"	d
EIGEN_COMP_LLVM	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_LLVM /;"	d
EIGEN_COMP_MINGW	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_MINGW /;"	d
EIGEN_COMP_MSVC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_MSVC /;"	d
EIGEN_COMP_MSVC_STRICT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_MSVC_STRICT /;"	d
EIGEN_COMP_PGI	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_PGI /;"	d
EIGEN_COMP_SUNCC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_COMP_SUNCC /;"	d
EIGEN_CONJUGATE_GRADIENT_H	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^#define EIGEN_CONJUGATE_GRADIENT_H$/;"	d
EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^#define EIGEN_CONSERVATIVESPARSESPARSEPRODUCT_H$/;"	d
EIGEN_CONSTANTS_H	Eigen/src/Core/util/Constants.h	/^#define EIGEN_CONSTANTS_H$/;"	d
EIGEN_COREITERATORS_H	Eigen/src/Core/CoreIterators.h	/^#define EIGEN_COREITERATORS_H$/;"	d
EIGEN_CPUID	Eigen/src/Core/util/Memory.h	/^#      define EIGEN_CPUID(/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/ArrayBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/ArrayBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/DenseBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/DenseBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/MatrixBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/Core/MatrixBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/SparseCore/SparseMatrixBase.h	/^#   undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/SparseCore/SparseMatrixBase.h	/^#define EIGEN_CURRENT_STORAGE_BASE_CLASS /;"	d
EIGEN_CURRENT_STORAGE_BASE_CLASS	Eigen/src/SparseCore/SparseMatrixBase.h	/^#undef EIGEN_CURRENT_STORAGE_BASE_CLASS$/;"	d
EIGEN_CWISE_BINARY_OP_H	Eigen/src/Core/CwiseBinaryOp.h	/^#define EIGEN_CWISE_BINARY_OP_H$/;"	d
EIGEN_CWISE_BINOP_RETURN_TYPE	Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_BINOP_RETURN_TYPE(/;"	d
EIGEN_CWISE_COMP_TO_SCALAR_RETURN_TYPE	Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_COMP_TO_SCALAR_RETURN_TYPE(/;"	d
EIGEN_CWISE_H	Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_H$/;"	d
EIGEN_CWISE_NULLARY_OP_H	Eigen/src/Core/CwiseNullaryOp.h	/^#define EIGEN_CWISE_NULLARY_OP_H$/;"	d
EIGEN_CWISE_PRODUCT_RETURN_TYPE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_CWISE_PRODUCT_RETURN_TYPE(/;"	d
EIGEN_CWISE_UNARY_OP_H	Eigen/src/Core/CwiseUnaryOp.h	/^#define EIGEN_CWISE_UNARY_OP_H$/;"	d
EIGEN_CWISE_UNARY_VIEW_H	Eigen/src/Core/CwiseUnaryView.h	/^#define EIGEN_CWISE_UNARY_VIEW_H$/;"	d
EIGEN_CWISE_UNOP_RETURN_TYPE	Eigen/src/Eigen2Support/Cwise.h	/^#define EIGEN_CWISE_UNOP_RETURN_TYPE(/;"	d
EIGEN_DBG_SPARSE	Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_DBG_SPARSE(/;"	d
EIGEN_DEBUG_ALIGNED_LOAD	Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_ALIGNED_LOAD$/;"	d
EIGEN_DEBUG_ALIGNED_STORE	Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_ALIGNED_STORE$/;"	d
EIGEN_DEBUG_UNALIGNED_LOAD	Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_UNALIGNED_LOAD$/;"	d
EIGEN_DEBUG_UNALIGNED_STORE	Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_DEBUG_UNALIGNED_STORE$/;"	d
EIGEN_DEBUG_VAR	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEBUG_VAR(/;"	d
EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DECLARE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS$/;"	d
EIGEN_DEFAULT_DENSE_INDEX_TYPE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFAULT_DENSE_INDEX_TYPE /;"	d
EIGEN_DEFAULT_IO_FORMAT	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFAULT_IO_FORMAT /;"	d
EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFAULT_MATRIX_STORAGE_ORDER_OPTION /;"	d
EIGEN_DEFAULT_SETTINGS_H	Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_DEFAULT_SETTINGS_H$/;"	d
EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DEFINE_FUNCTION_ALLOWING_MULTIPLE_DEFINITIONS /;"	d
EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION	Eigen/src/StlSupport/StdDeque.h	/^#define EIGEN_DEFINE_STL_DEQUE_SPECIALIZATION(/;"	d
EIGEN_DEFINE_STL_LIST_SPECIALIZATION	Eigen/src/StlSupport/StdList.h	/^#define EIGEN_DEFINE_STL_LIST_SPECIALIZATION(/;"	d
EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION	Eigen/src/StlSupport/StdVector.h	/^#define EIGEN_DEFINE_STL_VECTOR_SPECIALIZATION(/;"	d
EIGEN_DENSEBASE_H	Eigen/src/Core/DenseBase.h	/^#define EIGEN_DENSEBASE_H$/;"	d
EIGEN_DENSECOEFFSBASE_H	Eigen/src/Core/DenseCoeffsBase.h	/^#define EIGEN_DENSECOEFFSBASE_H$/;"	d
EIGEN_DENSESTORAGEBASE_H	Eigen/src/Core/PlainObjectBase.h	/^#define EIGEN_DENSESTORAGEBASE_H$/;"	d
EIGEN_DENSE_PUBLIC_INTERFACE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DENSE_PUBLIC_INTERFACE(/;"	d
EIGEN_DEPRECATED	Eigen/src/Core/util/Macros.h	/^    #define EIGEN_DEPRECATED /;"	d
EIGEN_DETERMINANT_H	Eigen/src/LU/Determinant.h	/^#define EIGEN_DETERMINANT_H$/;"	d
EIGEN_DIAGONALMATRIX_H	Eigen/src/Core/DiagonalMatrix.h	/^#define EIGEN_DIAGONALMATRIX_H$/;"	d
EIGEN_DIAGONALPRODUCT_H	Eigen/src/Core/DiagonalProduct.h	/^#define EIGEN_DIAGONALPRODUCT_H$/;"	d
EIGEN_DIAGONAL_H	Eigen/src/Core/Diagonal.h	/^#define EIGEN_DIAGONAL_H$/;"	d
EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT	Eigen/src/Core/util/Macros.h	/^    #define EIGEN_DISABLE_UNALIGNED_ARRAY_ASSERT$/;"	d
EIGEN_DONT_ALIGN_STATICALLY	Eigen/src/Core/util/Macros.h	/^    #define EIGEN_DONT_ALIGN_STATICALLY$/;"	d
EIGEN_DONT_INLINE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DONT_INLINE /;"	d
EIGEN_DONT_INLINE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_DONT_INLINE$/;"	d
EIGEN_DOT_H	Eigen/src/Core/Dot.h	/^#define EIGEN_DOT_H$/;"	d
EIGEN_EIGENBASE_H	Eigen/src/Core/EigenBase.h	/^#define EIGEN_EIGENBASE_H$/;"	d
EIGEN_EIGENSOLVER_H	Eigen/src/Eigenvalues/EigenSolver.h	/^#define EIGEN_EIGENSOLVER_H$/;"	d
EIGEN_EMPTY	Eigen/src/Core/util/Macros.h	/^#define EIGEN_EMPTY$/;"	d
EIGEN_EMPTY_STRUCT_CTOR	Eigen/src/Core/util/XprHelper.h	/^  #define EIGEN_EMPTY_STRUCT_CTOR(/;"	d
EIGEN_EULERANGLES_H	Eigen/src/Geometry/EulerAngles.h	/^#define EIGEN_EULERANGLES_H$/;"	d
EIGEN_FAST_MATH	Eigen/src/Core/util/Macros.h	/^#define EIGEN_FAST_MATH /;"	d
EIGEN_FLAGGED_H	Eigen/src/Core/Flagged.h	/^#define EIGEN_FLAGGED_H$/;"	d
EIGEN_FORCEALIGNEDACCESS_H	Eigen/src/Core/ForceAlignedAccess.h	/^#define EIGEN_FORCEALIGNEDACCESS_H$/;"	d
EIGEN_FORWARDDECLARATIONS_H	Eigen/src/Core/util/ForwardDeclarations.h	/^#define EIGEN_FORWARDDECLARATIONS_H$/;"	d
EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	/^  #define EIGEN_FREEBSD_MALLOC_ALREADY_ALIGNED /;"	d
EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H	Eigen/src/QR/FullPivHouseholderQR.h	/^#define EIGEN_FULLPIVOTINGHOUSEHOLDERQR_H$/;"	d
EIGEN_FUNCTORS_H	Eigen/src/Core/Functors.h	/^#define EIGEN_FUNCTORS_H$/;"	d
EIGEN_FUZZY_H	Eigen/src/Core/Fuzzy.h	/^#define EIGEN_FUZZY_H$/;"	d
EIGEN_GCC3_OR_OLDER	Eigen/src/Core/util/Macros.h	/^#define EIGEN_GCC3_OR_OLDER /;"	d
EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT	Eigen/src/Core/util/Macros.h	/^#define EIGEN_GCC_AND_ARCH_DOESNT_WANT_STACK_ALIGNMENT /;"	d
EIGEN_GENERALIZEDEIGENSOLVER_H	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^#define EIGEN_GENERALIZEDEIGENSOLVER_H$/;"	d
EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^#define EIGEN_GENERALIZEDSELFADJOINTEIGENSOLVER_H$/;"	d
EIGEN_GENERAL_BLOCK_PANEL_H	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^#define EIGEN_GENERAL_BLOCK_PANEL_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_H	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_MKL_H	Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_MKL_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_H$/;"	d
EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_MKL_H	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_GENERAL_MATRIX_MATRIX_TRIANGULAR_MKL_H$/;"	d
EIGEN_GENERAL_MATRIX_VECTOR_H	Eigen/src/Core/products/GeneralMatrixVector.h	/^#define EIGEN_GENERAL_MATRIX_VECTOR_H$/;"	d
EIGEN_GENERAL_MATRIX_VECTOR_MKL_H	Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^#define EIGEN_GENERAL_MATRIX_VECTOR_MKL_H$/;"	d
EIGEN_GENERAL_PRODUCT_H	Eigen/src/Core/GeneralProduct.h	/^#define EIGEN_GENERAL_PRODUCT_H$/;"	d
EIGEN_GENERIC_PACKET_MATH_H	Eigen/src/Core/GenericPacketMath.h	/^#define EIGEN_GENERIC_PACKET_MATH_H$/;"	d
EIGEN_GENERIC_PUBLIC_INTERFACE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_GENERIC_PUBLIC_INTERFACE(/;"	d
EIGEN_GEOMETRY_SSE_H	Eigen/src/Geometry/arch/Geometry_SSE.h	/^#define EIGEN_GEOMETRY_SSE_H$/;"	d
EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	/^  #define EIGEN_GLIBC_MALLOC_ALREADY_ALIGNED /;"	d
EIGEN_GLOBAL_FUNCTIONS_H	Eigen/src/Core/GlobalFunctions.h	/^#define EIGEN_GLOBAL_FUNCTIONS_H$/;"	d
EIGEN_GNUC_AT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_GNUC_AT(/;"	d
EIGEN_GNUC_AT_LEAST	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_GNUC_AT_LEAST(/;"	d
EIGEN_GNUC_AT_MOST	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_GNUC_AT_MOST(/;"	d
EIGEN_HAS_BUILTIN	Eigen/src/Core/util/Macros.h	/^#  define EIGEN_HAS_BUILTIN(/;"	d
EIGEN_HAS_FUSE_CJMADD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_HAS_FUSE_CJMADD /;"	d
EIGEN_HAS_MM_MALLOC	Eigen/src/Core/util/Memory.h	/^  #define EIGEN_HAS_MM_MALLOC /;"	d
EIGEN_HAS_POSIX_MEMALIGN	Eigen/src/Core/util/Memory.h	/^    #define EIGEN_HAS_POSIX_MEMALIGN /;"	d
EIGEN_HAS_POSIX_MEMALIGN	Eigen/src/Core/util/Memory.h	/^  #define EIGEN_HAS_POSIX_MEMALIGN /;"	d
EIGEN_HAVE_RVALUE_REFERENCES	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_HAVE_RVALUE_REFERENCES$/;"	d
EIGEN_HESSENBERGDECOMPOSITION_H	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^#define EIGEN_HESSENBERGDECOMPOSITION_H$/;"	d
EIGEN_HOMOGENEOUS_H	Eigen/src/Geometry/Homogeneous.h	/^#define EIGEN_HOMOGENEOUS_H$/;"	d
EIGEN_HOUSEHOLDER_H	Eigen/src/Householder/Householder.h	/^#define EIGEN_HOUSEHOLDER_H$/;"	d
EIGEN_HOUSEHOLDER_SEQUENCE_H	Eigen/src/Householder/HouseholderSequence.h	/^#define EIGEN_HOUSEHOLDER_SEQUENCE_H$/;"	d
EIGEN_HYPERPLANE_H	Eigen/src/Geometry/Hyperplane.h	/^#define EIGEN_HYPERPLANE_H$/;"	d
EIGEN_IMPLIES	Eigen/src/Core/util/Macros.h	/^#define EIGEN_IMPLIES(/;"	d
EIGEN_INCOMPLETE_LUT_H	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^#define EIGEN_INCOMPLETE_LUT_H$/;"	d
EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR	Eigen/src/Core/util/Macros.h	/^#define EIGEN_INHERIT_ASSIGNMENT_EQUAL_OPERATOR(/;"	d
EIGEN_INHERIT_ASSIGNMENT_OPERATORS	Eigen/src/Core/util/Macros.h	/^#define EIGEN_INHERIT_ASSIGNMENT_OPERATORS(/;"	d
EIGEN_INITIALIZE_COEFFS	Eigen/src/Core/PlainObjectBase.h	/^# define EIGEN_INITIALIZE_COEFFS$/;"	d
EIGEN_INITIALIZE_COEFFS	Eigen/src/Core/PlainObjectBase.h	/^# undef EIGEN_INITIALIZE_COEFFS$/;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	Eigen/src/Core/PlainObjectBase.h	/^# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED /;"	d
EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED	Eigen/src/Core/PlainObjectBase.h	/^# define EIGEN_INITIALIZE_COEFFS_IF_THAT_OPTION_IS_ENABLED$/;"	d
EIGEN_INIT_NEON_PACKET2	Eigen/src/Core/arch/NEON/PacketMath.h	/^  #define EIGEN_INIT_NEON_PACKET2(/;"	d
EIGEN_INIT_NEON_PACKET4	Eigen/src/Core/arch/NEON/PacketMath.h	/^  #define EIGEN_INIT_NEON_PACKET4(/;"	d
EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE	Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_COMPILATION_ERROR_OR_YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	Eigen/src/Core/DenseStorage.h	/^  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN /;"	d
EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN	Eigen/src/Core/DenseStorage.h	/^  #define EIGEN_INTERNAL_DENSE_STORAGE_CTOR_PLUGIN$/;"	d
EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT	Eigen/src/Core/util/StaticAssert.h	/^        EIGEN_INTERNAL_ERROR_PLEASE_FILE_A_BUG_REPORT,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
EIGEN_INVERSE_H	Eigen/src/LU/Inverse.h	/^#define EIGEN_INVERSE_H$/;"	d
EIGEN_INVERSE_SSE_H	Eigen/src/LU/arch/Inverse_SSE.h	/^#define EIGEN_INVERSE_SSE_H$/;"	d
EIGEN_IO_H	Eigen/src/Core/IO.h	/^#define EIGEN_IO_H$/;"	d
EIGEN_ITERATIVE_SOLVER_BASE_H	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^#define EIGEN_ITERATIVE_SOLVER_BASE_H$/;"	d
EIGEN_JACOBISVD_H	Eigen/src/SVD/JacobiSVD.h	/^#define EIGEN_JACOBISVD_H$/;"	d
EIGEN_JACOBISVD_MKL_H	Eigen/src/SVD/JacobiSVD_MKL.h	/^#define EIGEN_JACOBISVD_MKL_H$/;"	d
EIGEN_JACOBI_H	Eigen/src/Jacobi/Jacobi.h	/^#define EIGEN_JACOBI_H$/;"	d
EIGEN_LAZY_H	Eigen/src/Eigen2Support/Lazy.h	/^#define EIGEN_LAZY_H$/;"	d
EIGEN_LDLT_H	Eigen/src/Cholesky/LDLT.h	/^#define EIGEN_LDLT_H$/;"	d
EIGEN_LLT_H	Eigen/src/Cholesky/LLT.h	/^#define EIGEN_LLT_H$/;"	d
EIGEN_LLT_MKL_H	Eigen/src/Cholesky/LLT_MKL.h	/^#define EIGEN_LLT_MKL_H$/;"	d
EIGEN_LOGICAL_XOR	Eigen/src/Core/util/Macros.h	/^#define EIGEN_LOGICAL_XOR(/;"	d
EIGEN_LU_H	Eigen/src/LU/FullPivLU.h	/^#define EIGEN_LU_H$/;"	d
EIGEN_LU_STRUCTS	Eigen/src/SparseLU/SparseLU_Structs.h	/^#define EIGEN_LU_STRUCTS$/;"	d
EIGEN_MACROS_H	Eigen/src/Core/util/Macros.h	/^#define EIGEN_MACROS_H$/;"	d
EIGEN_MAJOR_VERSION	Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAJOR_VERSION /;"	d
EIGEN_MAKESTRING	Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAKESTRING(/;"	d
EIGEN_MAKESTRING2	Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAKESTRING2(/;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW	Eigen/src/Core/util/Memory.h	/^#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW /;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF	Eigen/src/Core/util/Memory.h	/^  #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF(/;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE	Eigen/src/Core/util/Memory.h	/^#define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_IF_VECTORIZABLE_FIXED_SIZE(/;"	d
EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW	Eigen/src/Core/util/Memory.h	/^    #define EIGEN_MAKE_ALIGNED_OPERATOR_NEW_NOTHROW(/;"	d
EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS	Eigen/src/Core/Array.h	/^#define EIGEN_MAKE_ARRAY_FIXED_TYPEDEFS(/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	Eigen/src/Core/Array.h	/^#define EIGEN_MAKE_ARRAY_TYPEDEFS(/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS	Eigen/src/Core/Array.h	/^#undef EIGEN_MAKE_ARRAY_TYPEDEFS$/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Array.h	/^#define EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES(/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Array.h	/^#undef EIGEN_MAKE_ARRAY_TYPEDEFS_ALL_SIZES$/;"	d
EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE	Eigen/src/Core/Array.h	/^#undef EIGEN_MAKE_ARRAY_TYPEDEFS_LARGE$/;"	d
EIGEN_MAKE_CWISE_BINARY_OP	Eigen/src/Core/util/Macros.h	/^#define EIGEN_MAKE_CWISE_BINARY_OP(/;"	d
EIGEN_MAKE_CWISE_COMP_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^#define EIGEN_MAKE_CWISE_COMP_OP(/;"	d
EIGEN_MAKE_CWISE_COMP_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^#undef EIGEN_MAKE_CWISE_COMP_OP$/;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^#define EIGEN_MAKE_CWISE_COMP_R_OP(/;"	d
EIGEN_MAKE_CWISE_COMP_R_OP	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^#undef EIGEN_MAKE_CWISE_COMP_R_OP$/;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	Eigen/src/Core/Matrix.h	/^#define EIGEN_MAKE_FIXED_TYPEDEFS(/;"	d
EIGEN_MAKE_FIXED_TYPEDEFS	Eigen/src/Core/Matrix.h	/^#undef EIGEN_MAKE_FIXED_TYPEDEFS$/;"	d
EIGEN_MAKE_IMAGE_HELPERS	Eigen/src/misc/Image.h	/^#define EIGEN_MAKE_IMAGE_HELPERS(/;"	d
EIGEN_MAKE_KERNEL_HELPERS	Eigen/src/misc/Kernel.h	/^#define EIGEN_MAKE_KERNEL_HELPERS(/;"	d
EIGEN_MAKE_SOLVE_HELPERS	Eigen/src/misc/Solve.h	/^#define EIGEN_MAKE_SOLVE_HELPERS(/;"	d
EIGEN_MAKE_SPARSE_SOLVE_HELPERS	Eigen/src/misc/SparseSolve.h	/^#define EIGEN_MAKE_SPARSE_SOLVE_HELPERS(/;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Core/Matrix.h	/^#define EIGEN_MAKE_TYPEDEFS(/;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Core/Matrix.h	/^#undef EIGEN_MAKE_TYPEDEFS$/;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Geometry/AlignedBox.h	/^#define EIGEN_MAKE_TYPEDEFS(/;"	d
EIGEN_MAKE_TYPEDEFS	Eigen/src/Geometry/AlignedBox.h	/^#undef EIGEN_MAKE_TYPEDEFS$/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Matrix.h	/^#define EIGEN_MAKE_TYPEDEFS_ALL_SIZES(/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Core/Matrix.h	/^#undef EIGEN_MAKE_TYPEDEFS_ALL_SIZES$/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Geometry/AlignedBox.h	/^#define EIGEN_MAKE_TYPEDEFS_ALL_SIZES(/;"	d
EIGEN_MAKE_TYPEDEFS_ALL_SIZES	Eigen/src/Geometry/AlignedBox.h	/^#undef EIGEN_MAKE_TYPEDEFS_ALL_SIZES$/;"	d
EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT	Eigen/src/Core/DenseStorage.h	/^  #define EIGEN_MAKE_UNALIGNED_ARRAY_ASSERT(/;"	d
EIGEN_MALLOC_ALREADY_ALIGNED	Eigen/src/Core/util/Memory.h	/^  #define EIGEN_MALLOC_ALREADY_ALIGNED /;"	d
EIGEN_MAPBASE_H	Eigen/src/Core/MapBase.h	/^#define EIGEN_MAPBASE_H$/;"	d
EIGEN_MAPPED_SPARSEMATRIX_H	Eigen/src/SparseCore/MappedSparseMatrix.h	/^#define EIGEN_MAPPED_SPARSEMATRIX_H$/;"	d
EIGEN_MAP_H	Eigen/src/Core/Map.h	/^#define EIGEN_MAP_H$/;"	d
EIGEN_MATHFUNCTIONS_H	Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNCTIONS_H$/;"	d
EIGEN_MATHFUNC_IMPL	Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNC_IMPL(/;"	d
EIGEN_MATHFUNC_RETVAL	Eigen/src/Core/MathFunctions.h	/^#define EIGEN_MATHFUNC_RETVAL(/;"	d
EIGEN_MATH_FUNCTIONS_SSE_H	Eigen/src/Core/arch/SSE/MathFunctions.h	/^#define EIGEN_MATH_FUNCTIONS_SSE_H$/;"	d
EIGEN_MATRIXBASEEIGENVALUES_H	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^#define EIGEN_MATRIXBASEEIGENVALUES_H$/;"	d
EIGEN_MATRIXBASE_H	Eigen/src/Core/MatrixBase.h	/^#define EIGEN_MATRIXBASE_H$/;"	d
EIGEN_MATRIXSTORAGE_H	Eigen/src/Core/DenseStorage.h	/^#define EIGEN_MATRIXSTORAGE_H$/;"	d
EIGEN_MATRIX_H	Eigen/src/Core/Matrix.h	/^#define EIGEN_MATRIX_H$/;"	d
EIGEN_MEMBER_FUNCTOR	Eigen/src/Core/VectorwiseOp.h	/^#define EIGEN_MEMBER_FUNCTOR(/;"	d
EIGEN_MEMORY_H	Eigen/src/Core/util/Memory.h	/^#define EIGEN_MEMORY_H$/;"	d
EIGEN_META_H	Eigen/src/Core/util/Meta.h	/^#define EIGEN_META_H$/;"	d
EIGEN_MINOR_H	Eigen/src/Eigen2Support/Minor.h	/^#define EIGEN_MINOR_H$/;"	d
EIGEN_MINOR_VERSION	Eigen/src/Core/util/Macros.h	/^#define EIGEN_MINOR_VERSION /;"	d
EIGEN_MISC_IMAGE_H	Eigen/src/misc/Image.h	/^#define EIGEN_MISC_IMAGE_H$/;"	d
EIGEN_MISC_KERNEL_H	Eigen/src/misc/Kernel.h	/^#define EIGEN_MISC_KERNEL_H$/;"	d
EIGEN_MISC_SOLVE_H	Eigen/src/misc/Solve.h	/^#define EIGEN_MISC_SOLVE_H$/;"	d
EIGEN_MKL_DOMAIN_ALL	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_DOMAIN_ALL /;"	d
EIGEN_MKL_DOMAIN_BLAS	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_DOMAIN_BLAS /;"	d
EIGEN_MKL_DOMAIN_FFT	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_DOMAIN_FFT /;"	d
EIGEN_MKL_DOMAIN_PARDISO	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_DOMAIN_PARDISO /;"	d
EIGEN_MKL_DOMAIN_VML	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_DOMAIN_VML /;"	d
EIGEN_MKL_EIG_SELFADJ	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^#define EIGEN_MKL_EIG_SELFADJ(/;"	d
EIGEN_MKL_GEMV_SPECIALIZATION	Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^#define EIGEN_MKL_GEMV_SPECIALIZATION(/;"	d
EIGEN_MKL_GEMV_SPECIALIZE	Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^#define EIGEN_MKL_GEMV_SPECIALIZE(/;"	d
EIGEN_MKL_HEMM_L	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_HEMM_L(/;"	d
EIGEN_MKL_HEMM_R	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_HEMM_R(/;"	d
EIGEN_MKL_LLT	Eigen/src/Cholesky/LLT_MKL.h	/^#define EIGEN_MKL_LLT(/;"	d
EIGEN_MKL_LU_PARTPIV	Eigen/src/LU/PartialPivLU_MKL.h	/^#define EIGEN_MKL_LU_PARTPIV(/;"	d
EIGEN_MKL_QR_COLPIV	Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^#define EIGEN_MKL_QR_COLPIV(/;"	d
EIGEN_MKL_QR_NOPIV	Eigen/src/QR/HouseholderQR_MKL.h	/^#define EIGEN_MKL_QR_NOPIV(/;"	d
EIGEN_MKL_RANKUPDATE_C	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_MKL_RANKUPDATE_C(/;"	d
EIGEN_MKL_RANKUPDATE_R	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_MKL_RANKUPDATE_R(/;"	d
EIGEN_MKL_RANKUPDATE_SPECIALIZE	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^#define EIGEN_MKL_RANKUPDATE_SPECIALIZE(/;"	d
EIGEN_MKL_SCHUR_COMPLEX	Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^#define EIGEN_MKL_SCHUR_COMPLEX(/;"	d
EIGEN_MKL_SCHUR_REAL	Eigen/src/Eigenvalues/RealSchur_MKL.h	/^#define EIGEN_MKL_SCHUR_REAL(/;"	d
EIGEN_MKL_SUPPORT_H	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_SUPPORT_H$/;"	d
EIGEN_MKL_SVD	Eigen/src/SVD/JacobiSVD_MKL.h	/^#define EIGEN_MKL_SVD(/;"	d
EIGEN_MKL_SYMM_L	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_SYMM_L(/;"	d
EIGEN_MKL_SYMM_R	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_MKL_SYMM_R(/;"	d
EIGEN_MKL_SYMV_SPECIALIZATION	Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^#define EIGEN_MKL_SYMV_SPECIALIZATION(/;"	d
EIGEN_MKL_SYMV_SPECIALIZE	Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^#define EIGEN_MKL_SYMV_SPECIALIZE(/;"	d
EIGEN_MKL_TRMM_L	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_MKL_TRMM_L(/;"	d
EIGEN_MKL_TRMM_R	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_MKL_TRMM_R(/;"	d
EIGEN_MKL_TRMM_SPECIALIZE	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_MKL_TRMM_SPECIALIZE(/;"	d
EIGEN_MKL_TRMV_CM	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_MKL_TRMV_CM(/;"	d
EIGEN_MKL_TRMV_RM	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_MKL_TRMV_RM(/;"	d
EIGEN_MKL_TRMV_SPECIALIZE	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_MKL_TRMV_SPECIALIZE(/;"	d
EIGEN_MKL_TRSM_L	Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^#define EIGEN_MKL_TRSM_L(/;"	d
EIGEN_MKL_TRSM_R	Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^#define EIGEN_MKL_TRSM_R(/;"	d
EIGEN_MKL_VML_DECLARE_POW_CALL	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_POW_CALL(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALL(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX_LA	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_COMPLEX_LA(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_LA	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_LA(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL_LA	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALLS_REAL_LA(/;"	d
EIGEN_MKL_VML_DECLARE_UNARY_CALL_LA	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_DECLARE_UNARY_CALL_LA(/;"	d
EIGEN_MKL_VML_MODE	Eigen/src/Core/Assign_MKL.h	/^#define  EIGEN_MKL_VML_MODE /;"	d
EIGEN_MKL_VML_SPECIALIZE_ASSIGN	Eigen/src/Core/Assign_MKL.h	/^#define EIGEN_MKL_VML_SPECIALIZE_ASSIGN(/;"	d
EIGEN_MKL_VML_THRESHOLD	Eigen/src/Core/util/MKL_support.h	/^#define EIGEN_MKL_VML_THRESHOLD /;"	d
EIGEN_NESTBYVALUE_H	Eigen/src/Core/NestByValue.h	/^#define EIGEN_NESTBYVALUE_H$/;"	d
EIGEN_NOALIAS_H	Eigen/src/Core/NoAlias.h	/^#define EIGEN_NOALIAS_H$/;"	d
EIGEN_NO_DEBUG	Eigen/src/Core/util/Macros.h	/^#  define EIGEN_NO_DEBUG$/;"	d
EIGEN_NUMTRAITS_H	Eigen/src/Core/NumTraits.h	/^#define EIGEN_NUMTRAITS_H$/;"	d
EIGEN_ONLY_USED_FOR_DEBUG	Eigen/src/Core/util/Macros.h	/^#define EIGEN_ONLY_USED_FOR_DEBUG(/;"	d
EIGEN_ORDERING_H	Eigen/src/OrderingMethods/Ordering.h	/^#define EIGEN_ORDERING_H$/;"	d
EIGEN_ORTHOMETHODS_H	Eigen/src/Geometry/OrthoMethods.h	/^#define EIGEN_ORTHOMETHODS_H$/;"	d
EIGEN_OS_ANDROID	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_ANDROID /;"	d
EIGEN_OS_BSD	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_BSD /;"	d
EIGEN_OS_CYGWIN	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_CYGWIN /;"	d
EIGEN_OS_GNULINUX	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_GNULINUX /;"	d
EIGEN_OS_LINUX	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_LINUX /;"	d
EIGEN_OS_MAC	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_MAC /;"	d
EIGEN_OS_QNX	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_QNX /;"	d
EIGEN_OS_SOLARIS	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_SOLARIS /;"	d
EIGEN_OS_SUN	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_SUN /;"	d
EIGEN_OS_UNIX	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_UNIX /;"	d
EIGEN_OS_WIN	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_WIN /;"	d
EIGEN_OS_WIN64	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_WIN64 /;"	d
EIGEN_OS_WINCE	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_WINCE /;"	d
EIGEN_OS_WIN_STRICT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_OS_WIN_STRICT /;"	d
EIGEN_PACKET_MATH_ALTIVEC_H	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define EIGEN_PACKET_MATH_ALTIVEC_H$/;"	d
EIGEN_PACKET_MATH_NEON_H	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define EIGEN_PACKET_MATH_NEON_H$/;"	d
EIGEN_PACKET_MATH_SSE_H	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define EIGEN_PACKET_MATH_SSE_H$/;"	d
EIGEN_PARALLELIZER_H	Eigen/src/Core/products/Parallelizer.h	/^#define EIGEN_PARALLELIZER_H$/;"	d
EIGEN_PARAMETRIZEDLINE_H	Eigen/src/Geometry/ParametrizedLine.h	/^#define EIGEN_PARAMETRIZEDLINE_H$/;"	d
EIGEN_PARDISOSUPPORT_H	Eigen/src/PardisoSupport/PardisoSupport.h	/^#define EIGEN_PARDISOSUPPORT_H$/;"	d
EIGEN_PARTIALLU_H	Eigen/src/LU/PartialPivLU.h	/^#define EIGEN_PARTIALLU_H$/;"	d
EIGEN_PARTIALLU_LAPACK_H	Eigen/src/LU/PartialPivLU_MKL.h	/^#define EIGEN_PARTIALLU_LAPACK_H$/;"	d
EIGEN_PARTIAL_REDUX_H	Eigen/src/Core/VectorwiseOp.h	/^#define EIGEN_PARTIAL_REDUX_H$/;"	d
EIGEN_PASTIXSUPPORT_H	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^#define EIGEN_PASTIXSUPPORT_H$/;"	d
EIGEN_PERMISSIVE_EXPR	Eigen/src/Core/util/Macros.h	/^#define EIGEN_PERMISSIVE_EXPR /;"	d
EIGEN_PERMISSIVE_EXPR	Eigen/src/Core/util/Macros.h	/^#define EIGEN_PERMISSIVE_EXPR$/;"	d
EIGEN_PERMUTATIONMATRIX_H	Eigen/src/Core/PermutationMatrix.h	/^#define EIGEN_PERMUTATIONMATRIX_H$/;"	d
EIGEN_PLAIN_ENUM_MAX	Eigen/src/Core/util/Macros.h	/^#define EIGEN_PLAIN_ENUM_MAX(/;"	d
EIGEN_PLAIN_ENUM_MIN	Eigen/src/Core/util/Macros.h	/^#define EIGEN_PLAIN_ENUM_MIN(/;"	d
EIGEN_PREDICATE_SAME_MATRIX_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_PREDICATE_SAME_MATRIX_SIZE(/;"	d
EIGEN_PRODUCTBASE_H	Eigen/src/Core/ProductBase.h	/^#define EIGEN_PRODUCTBASE_H$/;"	d
EIGEN_PRODUCT_PUBLIC_INTERFACE	Eigen/src/Core/ProductBase.h	/^#define EIGEN_PRODUCT_PUBLIC_INTERFACE(/;"	d
EIGEN_QR_H	Eigen/src/QR/HouseholderQR.h	/^#define EIGEN_QR_H$/;"	d
EIGEN_QR_MKL_H	Eigen/src/QR/HouseholderQR_MKL.h	/^#define EIGEN_QR_MKL_H$/;"	d
EIGEN_QUATERNION_H	Eigen/src/Geometry/Quaternion.h	/^#define EIGEN_QUATERNION_H$/;"	d
EIGEN_RANDOM_H	Eigen/src/Core/Random.h	/^#define EIGEN_RANDOM_H$/;"	d
EIGEN_REAL_QZ_H	Eigen/src/Eigenvalues/RealQZ.h	/^#define EIGEN_REAL_QZ_H$/;"	d
EIGEN_REAL_SCHUR_H	Eigen/src/Eigenvalues/RealSchur.h	/^#define EIGEN_REAL_SCHUR_H$/;"	d
EIGEN_REAL_SCHUR_MKL_H	Eigen/src/Eigenvalues/RealSchur_MKL.h	/^#define EIGEN_REAL_SCHUR_MKL_H$/;"	d
EIGEN_REDUX_H	Eigen/src/Core/Redux.h	/^#define EIGEN_REDUX_H$/;"	d
EIGEN_REF_H	Eigen/src/Core/Ref.h	/^#define EIGEN_REF_H$/;"	d
EIGEN_REPLICATE_H	Eigen/src/Core/Replicate.h	/^#define EIGEN_REPLICATE_H$/;"	d
EIGEN_RESTRICT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_RESTRICT /;"	d
EIGEN_RESTRICT	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_RESTRICT$/;"	d
EIGEN_RETURNBYVALUE_H	Eigen/src/Core/ReturnByValue.h	/^#define EIGEN_RETURNBYVALUE_H$/;"	d
EIGEN_REVERSE_H	Eigen/src/Core/Reverse.h	/^#define EIGEN_REVERSE_H$/;"	d
EIGEN_ROTATION2D_H	Eigen/src/Geometry/Rotation2D.h	/^#define EIGEN_ROTATION2D_H$/;"	d
EIGEN_ROTATIONBASE_H	Eigen/src/Geometry/RotationBase.h	/^#define EIGEN_ROTATIONBASE_H$/;"	d
EIGEN_SAEIGENSOLVER_MKL_H	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^#define EIGEN_SAEIGENSOLVER_MKL_H$/;"	d
EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO	Eigen/src/Core/util/Macros.h	/^  #define EIGEN_SAFE_TO_USE_STANDARD_ASSERT_MACRO /;"	d
EIGEN_SCALING_H	Eigen/src/Geometry/Scaling.h	/^#define EIGEN_SCALING_H$/;"	d
EIGEN_SELECT_H	Eigen/src/Core/Select.h	/^#define EIGEN_SELECT_H$/;"	d
EIGEN_SELFADJOINTEIGENSOLVER_H	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^#define EIGEN_SELFADJOINTEIGENSOLVER_H$/;"	d
EIGEN_SELFADJOINTMATRIX_H	Eigen/src/Core/SelfAdjointView.h	/^#define EIGEN_SELFADJOINTMATRIX_H$/;"	d
EIGEN_SELFADJOINTRANK2UPTADE_H	Eigen/src/Core/products/SelfadjointRank2Update.h	/^#define EIGEN_SELFADJOINTRANK2UPTADE_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_H	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^#define EIGEN_SELFADJOINT_MATRIX_MATRIX_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_MATRIX_MKL_H	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^#define EIGEN_SELFADJOINT_MATRIX_MATRIX_MKL_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_H	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^#define EIGEN_SELFADJOINT_MATRIX_VECTOR_H$/;"	d
EIGEN_SELFADJOINT_MATRIX_VECTOR_MKL_H	Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^#define EIGEN_SELFADJOINT_MATRIX_VECTOR_MKL_H$/;"	d
EIGEN_SELFADJOINT_PRODUCT_H	Eigen/src/Core/products/SelfadjointProduct.h	/^#define EIGEN_SELFADJOINT_PRODUCT_H$/;"	d
EIGEN_SELFCWISEBINARYOP_H	Eigen/src/Core/SelfCwiseBinaryOp.h	/^#define EIGEN_SELFCWISEBINARYOP_H$/;"	d
EIGEN_SIMPLICIAL_CHOLESKY_H	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^#define EIGEN_SIMPLICIAL_CHOLESKY_H$/;"	d
EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^#define EIGEN_SIMPLICIAL_CHOLESKY_IMPL_H$/;"	d
EIGEN_SIZE_MAX	Eigen/src/Core/util/Macros.h	/^#define EIGEN_SIZE_MAX(/;"	d
EIGEN_SIZE_MIN_PREFER_DYNAMIC	Eigen/src/Core/util/Macros.h	/^#define EIGEN_SIZE_MIN_PREFER_DYNAMIC(/;"	d
EIGEN_SIZE_MIN_PREFER_FIXED	Eigen/src/Core/util/Macros.h	/^#define EIGEN_SIZE_MIN_PREFER_FIXED(/;"	d
EIGEN_SOLVETRIANGULAR_H	Eigen/src/Core/SolveTriangular.h	/^#define EIGEN_SOLVETRIANGULAR_H$/;"	d
EIGEN_SPARSEDENSEPRODUCT_H	Eigen/src/SparseCore/SparseDenseProduct.h	/^#define EIGEN_SPARSEDENSEPRODUCT_H$/;"	d
EIGEN_SPARSELU_GEMM_KERNEL_H	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^#define EIGEN_SPARSELU_GEMM_KERNEL_H$/;"	d
EIGEN_SPARSELU_MEMORY	Eigen/src/SparseLU/SparseLU_Memory.h	/^#define EIGEN_SPARSELU_MEMORY$/;"	d
EIGEN_SPARSELU_SUPERNODAL_MATRIX_H	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^#define EIGEN_SPARSELU_SUPERNODAL_MATRIX_H$/;"	d
EIGEN_SPARSELU_UTILS_H	Eigen/src/SparseLU/SparseLU_Utils.h	/^#define EIGEN_SPARSELU_UTILS_H$/;"	d
EIGEN_SPARSEMATRIXBASE_H	Eigen/src/SparseCore/SparseMatrixBase.h	/^#define EIGEN_SPARSEMATRIXBASE_H$/;"	d
EIGEN_SPARSEMATRIX_H	Eigen/src/SparseCore/SparseMatrix.h	/^#define EIGEN_SPARSEMATRIX_H$/;"	d
EIGEN_SPARSEPRODUCT_H	Eigen/src/SparseCore/SparseProduct.h	/^#define EIGEN_SPARSEPRODUCT_H$/;"	d
EIGEN_SPARSEREDUX_H	Eigen/src/SparseCore/SparseRedux.h	/^#define EIGEN_SPARSEREDUX_H$/;"	d
EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^#define EIGEN_SPARSESPARSEPRODUCTWITHPRUNING_H$/;"	d
EIGEN_SPARSETRANSPOSE_H	Eigen/src/SparseCore/SparseTranspose.h	/^#define EIGEN_SPARSETRANSPOSE_H$/;"	d
EIGEN_SPARSETRIANGULARSOLVER_H	Eigen/src/SparseCore/TriangularSolver.h	/^#define EIGEN_SPARSETRIANGULARSOLVER_H$/;"	d
EIGEN_SPARSEUTIL_H	Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSEUTIL_H$/;"	d
EIGEN_SPARSEVECTOR_H	Eigen/src/SparseCore/SparseVector.h	/^#define EIGEN_SPARSEVECTOR_H$/;"	d
EIGEN_SPARSEVIEW_H	Eigen/src/SparseCore/SparseView.h	/^#define EIGEN_SPARSEVIEW_H$/;"	d
EIGEN_SPARSE_AMD_H	Eigen/src/OrderingMethods/Amd.h	/^#define EIGEN_SPARSE_AMD_H$/;"	d
EIGEN_SPARSE_BLOCK_H	Eigen/src/SparseCore/SparseBlock.h	/^#define EIGEN_SPARSE_BLOCK_H$/;"	d
EIGEN_SPARSE_CWISE_BINARY_OP_H	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^#define EIGEN_SPARSE_CWISE_BINARY_OP_H$/;"	d
EIGEN_SPARSE_CWISE_UNARY_OP_H	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^#define EIGEN_SPARSE_CWISE_UNARY_OP_H$/;"	d
EIGEN_SPARSE_DIAGONAL_PRODUCT_H	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^#define EIGEN_SPARSE_DIAGONAL_PRODUCT_H$/;"	d
EIGEN_SPARSE_DOT_H	Eigen/src/SparseCore/SparseDot.h	/^#define EIGEN_SPARSE_DOT_H$/;"	d
EIGEN_SPARSE_FUZZY_H	Eigen/src/SparseCore/SparseFuzzy.h	/^#define EIGEN_SPARSE_FUZZY_H$/;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR	Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATOR(/;"	d
EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS	Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_INHERIT_ASSIGNMENT_OPERATORS(/;"	d
EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR	Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_INHERIT_SCALAR_ASSIGNMENT_OPERATOR(/;"	d
EIGEN_SPARSE_LU_H	Eigen/src/SparseLU/SparseLU.h	/^#define EIGEN_SPARSE_LU_H$/;"	d
EIGEN_SPARSE_PERMUTATION_H	Eigen/src/SparseCore/SparsePermutation.h	/^#define EIGEN_SPARSE_PERMUTATION_H$/;"	d
EIGEN_SPARSE_PUBLIC_INTERFACE	Eigen/src/SparseCore/SparseUtil.h	/^#define EIGEN_SPARSE_PUBLIC_INTERFACE(/;"	d
EIGEN_SPARSE_QR_H	Eigen/src/SparseQR/SparseQR.h	/^#define EIGEN_SPARSE_QR_H$/;"	d
EIGEN_SPARSE_SELFADJOINTVIEW_H	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^#define EIGEN_SPARSE_SELFADJOINTVIEW_H$/;"	d
EIGEN_SPARSE_SOLVE_H	Eigen/src/misc/SparseSolve.h	/^#define EIGEN_SPARSE_SOLVE_H$/;"	d
EIGEN_SPARSE_TRIANGULARVIEW_H	Eigen/src/SparseCore/SparseTriangularView.h	/^#define EIGEN_SPARSE_TRIANGULARVIEW_H$/;"	d
EIGEN_STABLENORM_H	Eigen/src/Core/StableNorm.h	/^#define EIGEN_STABLENORM_H$/;"	d
EIGEN_STACK_ALLOCATION_LIMIT	Eigen/src/Core/util/Macros.h	/^#define EIGEN_STACK_ALLOCATION_LIMIT /;"	d
EIGEN_STATIC_ASSERT	Eigen/src/Core/util/StaticAssert.h	/^      #define EIGEN_STATIC_ASSERT(/;"	d
EIGEN_STATIC_ASSERT	Eigen/src/Core/util/StaticAssert.h	/^    #define EIGEN_STATIC_ASSERT(/;"	d
EIGEN_STATIC_ASSERT_ARRAYXPR	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_ARRAYXPR(/;"	d
EIGEN_STATIC_ASSERT_DYNAMIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_DYNAMIC_SIZE(/;"	d
EIGEN_STATIC_ASSERT_FIXED_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_FIXED_SIZE(/;"	d
EIGEN_STATIC_ASSERT_H	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_H$/;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	Eigen/src/Core/MapBase.h	/^#define EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS(/;"	d
EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS	Eigen/src/Core/MapBase.h	/^#undef EIGEN_STATIC_ASSERT_INDEX_BASED_ACCESS$/;"	d
EIGEN_STATIC_ASSERT_LVALUE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_LVALUE(/;"	d
EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_MATRIX_SPECIFIC_SIZE(/;"	d
EIGEN_STATIC_ASSERT_NON_INTEGER	Eigen/src/Core/util/StaticAssert.h	/^  #define EIGEN_STATIC_ASSERT_NON_INTEGER(/;"	d
EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SAME_MATRIX_SIZE(/;"	d
EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SAME_VECTOR_SIZE(/;"	d
EIGEN_STATIC_ASSERT_SAME_XPR_KIND	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SAME_XPR_KIND(/;"	d
EIGEN_STATIC_ASSERT_SIZE_1x1	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_SIZE_1x1(/;"	d
EIGEN_STATIC_ASSERT_VECTOR_ONLY	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_VECTOR_ONLY(/;"	d
EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^#define EIGEN_STATIC_ASSERT_VECTOR_SPECIFIC_SIZE(/;"	d
EIGEN_STDDEQUE_H	Eigen/src/StlSupport/StdDeque.h	/^#define EIGEN_STDDEQUE_H$/;"	d
EIGEN_STDLIST_H	Eigen/src/StlSupport/StdList.h	/^#define EIGEN_STDLIST_H$/;"	d
EIGEN_STDVECTOR_H	Eigen/src/StlSupport/StdVector.h	/^#define EIGEN_STDVECTOR_H$/;"	d
EIGEN_STD_DEQUE_SPECIALIZATION_BODY	Eigen/src/StlSupport/StdDeque.h	/^#define EIGEN_STD_DEQUE_SPECIALIZATION_BODY /;"	d
EIGEN_STD_LIST_SPECIALIZATION_BODY	Eigen/src/StlSupport/StdList.h	/^#define EIGEN_STD_LIST_SPECIALIZATION_BODY /;"	d
EIGEN_STD_VECTOR_SPECIALIZATION_BODY	Eigen/src/StlSupport/StdVector.h	/^#define EIGEN_STD_VECTOR_SPECIALIZATION_BODY /;"	d
EIGEN_STL_DETAILS_H	Eigen/src/StlSupport/details.h	/^#define EIGEN_STL_DETAILS_H$/;"	d
EIGEN_STRIDE_H	Eigen/src/Core/Stride.h	/^#define EIGEN_STRIDE_H$/;"	d
EIGEN_STRONG_INLINE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_STRONG_INLINE /;"	d
EIGEN_SUITESPARSEQRSUPPORT_H	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^#define EIGEN_SUITESPARSEQRSUPPORT_H$/;"	d
EIGEN_SUPERLUSUPPORT_H	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define EIGEN_SUPERLUSUPPORT_H$/;"	d
EIGEN_SUPERLU_HAS_ILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^#define EIGEN_SUPERLU_HAS_ILU$/;"	d
EIGEN_SWAP_H	Eigen/src/Core/Swap.h	/^#define EIGEN_SWAP_H$/;"	d
EIGEN_TRANSFORM_H	Eigen/src/Geometry/Transform.h	/^#define EIGEN_TRANSFORM_H$/;"	d
EIGEN_TRANSLATION_H	Eigen/src/Geometry/Translation.h	/^#define EIGEN_TRANSLATION_H$/;"	d
EIGEN_TRANSPOSE_H	Eigen/src/Core/Transpose.h	/^#define EIGEN_TRANSPOSE_H$/;"	d
EIGEN_TRANSPOSITIONS_H	Eigen/src/Core/Transpositions.h	/^#define EIGEN_TRANSPOSITIONS_H$/;"	d
EIGEN_TRIANGULARMATRIXVECTOR_H	Eigen/src/Core/products/TriangularMatrixVector.h	/^#define EIGEN_TRIANGULARMATRIXVECTOR_H$/;"	d
EIGEN_TRIANGULARMATRIX_H	Eigen/src/Core/TriangularMatrix.h	/^#define EIGEN_TRIANGULARMATRIX_H$/;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_H	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^#define EIGEN_TRIANGULAR_MATRIX_MATRIX_H$/;"	d
EIGEN_TRIANGULAR_MATRIX_MATRIX_MKL_H	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^#define EIGEN_TRIANGULAR_MATRIX_MATRIX_MKL_H$/;"	d
EIGEN_TRIANGULAR_MATRIX_VECTOR_MKL_H	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^#define EIGEN_TRIANGULAR_MATRIX_VECTOR_MKL_H$/;"	d
EIGEN_TRIANGULAR_SOLVER2_H	Eigen/src/Eigen2Support/TriangularSolver.h	/^#define EIGEN_TRIANGULAR_SOLVER2_H$/;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_H	Eigen/src/Core/products/TriangularSolverMatrix.h	/^#define EIGEN_TRIANGULAR_SOLVER_MATRIX_H$/;"	d
EIGEN_TRIANGULAR_SOLVER_MATRIX_MKL_H	Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^#define EIGEN_TRIANGULAR_SOLVER_MATRIX_MKL_H$/;"	d
EIGEN_TRIANGULAR_SOLVER_VECTOR_H	Eigen/src/Core/products/TriangularSolverVector.h	/^#define EIGEN_TRIANGULAR_SOLVER_VECTOR_H$/;"	d
EIGEN_TRIDIAGONALIZATION_H	Eigen/src/Eigenvalues/Tridiagonalization.h	/^#define EIGEN_TRIDIAGONALIZATION_H$/;"	d
EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH	Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_TUNE_TRIANGULAR_PANEL_WIDTH /;"	d
EIGEN_UMEYAMA_H	Eigen/src/Geometry/Umeyama.h	/^#define EIGEN_UMEYAMA_H$/;"	d
EIGEN_UMFPACKSUPPORT_H	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^#define EIGEN_UMFPACKSUPPORT_H$/;"	d
EIGEN_UNROLLING_LIMIT	Eigen/src/Core/arch/Default/Settings.h	/^#define EIGEN_UNROLLING_LIMIT /;"	d
EIGEN_UNUSED	Eigen/src/Core/util/Macros.h	/^#define EIGEN_UNUSED /;"	d
EIGEN_UNUSED_VARIABLE	Eigen/src/Core/util/Macros.h	/^#define EIGEN_UNUSED_VARIABLE(/;"	d
EIGEN_USER_ALIGN16	Eigen/src/Core/util/Macros.h	/^#define EIGEN_USER_ALIGN16 /;"	d
EIGEN_USER_ALIGN_TO_BOUNDARY	Eigen/src/Core/util/Macros.h	/^#define EIGEN_USER_ALIGN_TO_BOUNDARY(/;"	d
EIGEN_USE_BLAS	Eigen/src/Core/util/MKL_support.h	/^    #define EIGEN_USE_BLAS$/;"	d
EIGEN_USE_BLAS	Eigen/src/Core/util/MKL_support.h	/^#       undef   EIGEN_USE_BLAS$/;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	/^    #define EIGEN_USE_LAPACKE$/;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	/^  #define EIGEN_USE_LAPACKE$/;"	d
EIGEN_USE_LAPACKE	Eigen/src/Core/util/MKL_support.h	/^#       undef   EIGEN_USE_LAPACKE$/;"	d
EIGEN_USE_LAPACKE_STRICT	Eigen/src/Core/util/MKL_support.h	/^#       undef   EIGEN_USE_LAPACKE_STRICT$/;"	d
EIGEN_USE_MKL	Eigen/src/Core/util/MKL_support.h	/^  #define EIGEN_USE_MKL$/;"	d
EIGEN_USE_MKL	Eigen/src/Core/util/MKL_support.h	/^#       undef EIGEN_USE_MKL /;"	d
EIGEN_USE_MKL	Eigen/src/Core/util/MKL_support.h	/^#       undef EIGEN_USE_MKL$/;"	d
EIGEN_USE_MKL_ALL	Eigen/src/Core/util/MKL_support.h	/^#       undef   EIGEN_USE_MKL_ALL$/;"	d
EIGEN_USE_MKL_VML	Eigen/src/Core/util/MKL_support.h	/^    #define EIGEN_USE_MKL_VML$/;"	d
EIGEN_USE_MKL_VML	Eigen/src/Core/util/MKL_support.h	/^#       undef   EIGEN_USE_MKL_VML$/;"	d
EIGEN_USING_ARRAY_TYPEDEFS	Eigen/src/Core/Array.h	/^#define EIGEN_USING_ARRAY_TYPEDEFS /;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE	Eigen/src/Core/Array.h	/^#define EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE(/;"	d
EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE	Eigen/src/Core/Array.h	/^#define EIGEN_USING_ARRAY_TYPEDEFS_FOR_TYPE_AND_SIZE(/;"	d
EIGEN_VECTORBLOCK_H	Eigen/src/Core/VectorBlock.h	/^#define EIGEN_VECTORBLOCK_H$/;"	d
EIGEN_VERSION_AT_LEAST	Eigen/src/Core/util/Macros.h	/^#define EIGEN_VERSION_AT_LEAST(/;"	d
EIGEN_VISITOR_H	Eigen/src/Core/Visitor.h	/^#define EIGEN_VISITOR_H$/;"	d
EIGEN_WARNINGS_DISABLED	Eigen/src/Core/util/DisableStupidWarnings.h	/^#define EIGEN_WARNINGS_DISABLED$/;"	d
EIGEN_WARNINGS_DISABLED	Eigen/src/Core/util/ReenableStupidWarnings.h	/^#undef EIGEN_WARNINGS_DISABLED$/;"	d
EIGEN_WORKAROUND_MSVC_STL_SUPPORT	Eigen/src/StlSupport/details.h	/^#define EIGEN_WORKAROUND_MSVC_STL_SUPPORT(/;"	d
EIGEN_WORLD_VERSION	Eigen/src/Core/util/Macros.h	/^#define EIGEN_WORLD_VERSION /;"	d
EIGEN_XPRHELPER_H	Eigen/src/Core/util/XprHelper.h	/^#define EIGEN_XPRHELPER_H$/;"	d
ENTITY_RANGE	tinyxml2/tinyxml2.h	/^        ENTITY_RANGE = 64,$/;"	e	enum:tinyxml2::XMLPrinter::__anon484
ENVIRONMENT_SETUP	Example/DracoP1/Draco_Dyn_environment.cpp	/^#define ENVIRONMENT_SETUP /;"	d	file:
EQUALS	build/Example/DracoP1/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/LieGroup/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/SceneGraph/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/common/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/srDyn/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/srExt/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srLib/srg/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/srMath/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/tinyxml2/Makefile	/^EQUALS = =$/;"	m
EXAMPLE_GROUND	Example/MobileRobots/Ground.h	/^#define EXAMPLE_GROUND$/;"	d
EXAMPLE_MOBILEROBOT	Example/MobileRobots/MobileRobots.h	/^#define EXAMPLE_MOBILEROBOT$/;"	d
EditChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::EditChunkProcessor(long length, long findex)$/;"	f	class:Model3DS
EigVecMask	Eigen/src/Core/util/Constants.h	/^  EigVecMask = EigenvaluesOnly | ComputeEigenvectors,$/;"	e	enum:Eigen::DecompositionOptions
Eigen	Eigen/src/Cholesky/LDLT.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Cholesky/LLT.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Cholesky/LLT_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Array.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/ArrayBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/ArrayWrapper.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Assign.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Assign_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/BandMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Block.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/BooleanRedux.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CommaInitializer.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CoreIterators.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CwiseBinaryOp.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CwiseNullaryOp.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/CwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/CwiseUnaryView.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/DenseBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/DenseCoeffsBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/DenseStorage.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Diagonal.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/DiagonalMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/DiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Dot.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/EigenBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Flagged.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/ForceAlignedAccess.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Functors.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Fuzzy.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/GeneralProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/GenericPacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/GlobalFunctions.h	/^namespace Eigen$/;"	n
Eigen	Eigen/src/Core/IO.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Map.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/MapBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Matrix.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/MatrixBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/NestByValue.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/NoAlias.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/NumTraits.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/PermutationMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/PlainObjectBase.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/ProductBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Random.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Redux.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Ref.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Replicate.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/ReturnByValue.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/Reverse.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Select.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/SelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/SolveTriangular.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/StableNorm.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Stride.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Swap.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Transpose.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Transpositions.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/TriangularMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/VectorwiseOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/Visitor.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/NEON/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/Complex.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/Parallelizer.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/products/TriangularSolverVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Core/util/BlasUtil.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Constants.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/ForwardDeclarations.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/MKL_support.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Macros.h	/^    namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Macros.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Memory.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/Meta.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/StaticAssert.h	/^    namespace Eigen {$/;"	n
Eigen	Eigen/src/Core/util/XprHelper.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Eigen2Support/Block.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Cwise.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/CwiseOperators.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/LU.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Lazy.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/LeastSquares.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/MathFunctions.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Memory.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Meta.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/Minor.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/QR.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/SVD.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Eigen2Support/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigen2Support/VectorBlock.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/ComplexSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/EigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/RealQZ.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/Eigenvalues/RealSchur.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/RealSchur_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/SelfAdjointEigenSolver_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/AlignedBox.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/AngleAxis.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/EulerAngles.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Homogeneous.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Hyperplane.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/OrthoMethods.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/ParametrizedLine.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Quaternion.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Rotation2D.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/RotationBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Scaling.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Transform.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Translation.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/Umeyama.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Householder/BlockHouseholder.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Householder/Householder.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Householder/HouseholderSequence.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/Jacobi/Jacobi.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/Determinant.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/FullPivLU.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/Inverse.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/PartialPivLU.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/PartialPivLU_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/LU/arch/Inverse_SSE.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/MetisSupport/MetisSupport.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/OrderingMethods/Amd.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/OrderingMethods/Ordering.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/ColPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/ColPivHouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/FullPivHouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/HouseholderQR.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/QR/HouseholderQR_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SVD/JacobiSVD.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SVD/JacobiSVD_MKL.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SVD/UpperBidiagonalization.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/AmbiVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/CompressedStorage.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseBlock.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseColEtree.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseDot.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseMatrix.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseMatrixBase.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparsePermutation.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseProduct.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseRedux.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseTranspose.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseTriangularView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseUtil.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseVector.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/SparseView.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseCore/TriangularSolver.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/SparseLU/SparseLU.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLUImpl.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_Memory.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_Structs.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_Utils.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_pivotL.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_pruneL.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SparseQR/SparseQR.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/StlSupport/details.h	/^namespace Eigen {$/;"	n
Eigen	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/misc/Image.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/misc/Kernel.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/misc/Solve.h	/^namespace Eigen { $/;"	n
Eigen	Eigen/src/misc/SparseSolve.h	/^namespace Eigen { $/;"	n
Eigen	srLib/srExt/srExt_Eigen.h	/^namespace Eigen$/;"	n
EigenBase	Eigen/src/Core/EigenBase.h	/^template<typename Derived> struct EigenBase$/;"	s	namespace:Eigen
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(Index size)$/;"	f	class:Eigen::EigenSolver
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver(const MatrixType& matrix, bool computeEigenvectors = true)$/;"	f	class:Eigen::EigenSolver
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^ EigenSolver() : m_eivec(), m_eivalues(), m_isInitialized(false), m_realSchur(), m_matT(), m_tmp() {}$/;"	f	class:Eigen::EigenSolver
EigenSolver	Eigen/src/Eigenvalues/EigenSolver.h	/^template<typename _MatrixType> class EigenSolver$/;"	c	namespace:Eigen
Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl	Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl;$/;"	t	class:Eigen::ArrayBase
EigenvalueType	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options&(~RowMajor), MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvalueType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::EigenSolver
EigenvalueType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef CwiseBinaryOp<internal::scalar_quotient_op<ComplexScalar,Scalar>,ComplexVectorType,VectorType> EigenvalueType;$/;"	t	class:Eigen::GeneralizedEigenSolver
EigenvalueType	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealQZ
EigenvalueType	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<ComplexScalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> EigenvalueType;$/;"	t	class:Eigen::RealSchur
EigenvaluesOnly	Eigen/src/Core/util/Constants.h	/^  EigenvaluesOnly     = 0x40,$/;"	e	enum:Eigen::DecompositionOptions
EigenvaluesReturnType	Eigen/src/Core/DenseBase.h	/^    typedef Matrix<typename NumTraits<typename internal::traits<Derived>::Scalar>::Real, internal::traits<Derived>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::DenseBase
EigenvaluesReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Matrix<std::complex<RealScalar>, internal::traits<Derived>::ColsAtCompileTime, 1, ColMajor> EigenvaluesReturnType;$/;"	t	class:Eigen::MatrixBase
EigenvaluesReturnType	Eigen/src/Core/SelfAdjointView.h	/^    typedef Matrix<RealScalar, internal::traits<MatrixType>::ColsAtCompileTime, 1> EigenvaluesReturnType;$/;"	t	class:Eigen::SelfAdjointView
EigenvectorType	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorType;$/;"	t	class:Eigen::ComplexEigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::EigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<ComplexScalar, RowsAtCompileTime, ColsAtCompileTime, Options, MaxRowsAtCompileTime, MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::GeneralizedEigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Matrix<Scalar,Size,Size,ColMajor,MaxColsAtCompileTime,MaxColsAtCompileTime> EigenvectorsType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
EigenvectorsType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::EigenvectorsType EigenvectorsType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Ellipsoid	srLib/SceneGraph/Leaf.cpp	/^Ellipsoid::Ellipsoid(double _a, double _b, double _c)$/;"	f	class:Ellipsoid
Ellipsoid	srLib/SceneGraph/Leaf.h	/^class Ellipsoid : public Leaf$/;"	c
ElseMatrixNested	Eigen/src/Core/Select.h	/^  typedef typename ElseMatrixType::Nested ElseMatrixNested;$/;"	t	struct:Eigen::internal::traits
Emission	srLib/srg/srgColor.h	/^		float Emission[4];		\/\/ material property for emission lighting (¹ß±¤)$/;"	m	struct:srgMaterialColor::sMaterialColor
Empty	tinyxml2/tinyxml2.h	/^    bool Empty() const					{$/;"	f	class:tinyxml2::DynArray
Empty	tinyxml2/tinyxml2.h	/^    bool Empty() const {$/;"	f	class:tinyxml2::StrPair
EmptyFunction	srMath/Function.h	/^		EmptyFunction() {}$/;"	f	class:srMath::EmptyFunction
EmptyFunction	srMath/Function.h	/^	class EmptyFunction : public Function$/;"	c	namespace:srMath
EnsureCapacity	tinyxml2/tinyxml2.h	/^    void EnsureCapacity( int cap ) {$/;"	f	class:tinyxml2::DynArray
Entity	tinyxml2/tinyxml2.cpp	/^struct Entity {$/;"	s	namespace:tinyxml2	file:
Error	tinyxml2/tinyxml2.h	/^    bool Error() const {$/;"	f	class:tinyxml2::XMLDocument
ErrorID	tinyxml2/tinyxml2.h	/^    XMLError  ErrorID() const {$/;"	f	class:tinyxml2::XMLDocument
ErrorIDToName	tinyxml2/tinyxml2.cpp	/^\/*static*\/ const char* XMLDocument::ErrorIDToName(XMLError errorID)$/;"	f	class:tinyxml2::XMLDocument
ErrorName	tinyxml2/tinyxml2.cpp	/^const char* XMLDocument::ErrorName() const$/;"	f	class:tinyxml2::XMLDocument
EssentialVectorType	Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::hseq_side_dependent_impl<VectorsType,CoeffsType,Side>::EssentialVectorType EssentialVectorType;$/;"	t	class:Eigen::HouseholderSequence
EssentialVectorType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef Block<const VectorsType, Dynamic, 1> EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EssentialVectorType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef Transpose<Block<const VectorsType, 1, Dynamic> > EssentialVectorType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
EulerIntegrator	srMath/EulerIntegrator.h	/^		EulerIntegrator(int num_of_points = 0, Real initialTime = 0, Real finalTime = 1)$/;"	f	class:srMath::EulerIntegrator
EulerIntegrator	srMath/EulerIntegrator.h	/^	class EulerIntegrator : public LinearIntegrator$/;"	c	namespace:srMath
EulerZYX	srMath/SO3.cpp	/^	SO3 SO3::EulerZYX(const Real angle1, const Real angle2, const Real angle3)$/;"	f	class:srMath::SO3
EulerZYZ	srMath/SO3.cpp	/^	SO3 SO3::EulerZYZ(const Real angle1, const Real angle2, const Real angle3)$/;"	f	class:srMath::SO3
EvalBeforeAssigningBit	Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeAssigningBit = 0x4;$/;"	m	namespace:Eigen
EvalBeforeNestingBit	Eigen/src/Core/util/Constants.h	/^const unsigned int EvalBeforeNestingBit = 0x2;$/;"	m	namespace:Eigen
EvalIntegration	srMath/LinearIntegrator.h	/^		const Real		EvalIntegration(const VectorX& functionVal) const { return _w.dot(functionVal); }$/;"	f	class:srMath::LinearIntegrator
EvalReturnType	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::add_const_on_value_type<typename internal::eval<Derived>::type>::type EvalReturnType;$/;"	t	class:Eigen::DenseBase
EvalToRowMajor	Eigen/src/Core/products/CoeffBasedProduct.h	/^      EvalToRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon122
EvalToRowMajor	Eigen/src/SparseCore/SparseProduct.h	/^    EvalToRowMajor = (RhsFlags & LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon390
Excite	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::Excite()$/;"	f	class:ClosedLoop
Excite	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::Excite()$/;"	f	class:ContactConstraint
Excite	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::Excite()$/;"	f	class:JointConstraint
ExciteSystem	srLib/srDyn/srSystem.cpp	/^void srSystem::ExciteSystem()$/;"	f	class:srSystem
Exp	srMath/SE3.cpp	/^	SE3 SE3::Exp(const se3& S, Real angle)$/;"	f	class:srMath::SE3
Exp	srMath/SE3.cpp	/^	SE3 SE3::Exp(so3 w, Vector3 v, Real angle)$/;"	f	class:srMath::SE3
Exp	srMath/SO3.cpp	/^	SO3 SO3::Exp(so3 w, Real angle)$/;"	f	class:srMath::SO3
ExpandMem	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  enum { ExpandMem = true };$/;"	e	enum:Eigen::internal::column_dfs_traits::__anon344
ExpandMem	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  enum { ExpandMem = false };$/;"	e	enum:Eigen::internal::panel_dfs_traits::__anon345
ExpressionType	Eigen/src/Core/SelfAdjointView.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionType	Eigen/src/Core/TriangularMatrix.h	/^  typedef MatrixType ExpressionType;$/;"	t	struct:Eigen::internal::traits
ExpressionTypeNested	Eigen/src/Core/Flagged.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Flagged
ExpressionTypeNested	Eigen/src/Core/VectorwiseOp.h	/^        ExpressionType, ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::VectorwiseOp
ExpressionTypeNested	Eigen/src/Eigen2Support/Cwise.h	/^        ExpressionType, const ExpressionType&>::type ExpressionTypeNested;$/;"	t	class:Eigen::Cwise
ExpressionTypeNestedCleaned	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::remove_all<ExpressionTypeNested>::type ExpressionTypeNestedCleaned;$/;"	t	class:Eigen::VectorwiseOp
ExtendedType	Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct ExtendedType {$/;"	s	class:Eigen::VectorwiseOp
ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType>  ExtractType; \/\/ const to get rid of a compile error; anyway blas traits are only used on the RHS$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef const XprType& ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename Base::ExtractType ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
FACE_DESC	srLib/SceneGraph/Model3DS.cpp	/^    #define FACE_DESC	/;"	d	file:
FACE_MAT	srLib/SceneGraph/Model3DS.cpp	/^     #define FACE_MAT	/;"	d	file:
FALSE	srLib/srg/srgL.h	/^	#define FALSE /;"	d
FIXED	srLib/srDyn/srSystem.h	/^	enum	BASELINKTYPE	{ DYNAMIC, FIXED,  KINEMATIC };$/;"	e	enum:srSystem::BASELINKTYPE
FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED	Eigen/src/Core/util/StaticAssert.h	/^        FLOATING_POINT_ARGUMENT_PASSED__INTEGER_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
FRAME	srLib/srExt/srExtension.h	/^	enum FRAME$/;"	g	namespace:srExt
FRAMES	srLib/SceneGraph/Model3DS.cpp	/^  #define FRAMES	/;"	d	file:
FREE_BK	srLib/srDyn/srISLAND.cpp	/^#define FREE_BK(/;"	d	file:
FRICTIONCOEFF_EPS	srLib/srDyn/srContactConstraint.h	/^#define FRICTIONCOEFF_EPS	/;"	d
FS_GetSE3	srLib/srDyn/srLink.cpp	/^SE3& srLink::FS_GetSE3()$/;"	f	class:srLink
FS_IntegratePosErrVelocity_plus_DelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_IntegratePosErrVelocity_plus_DelVelocity()$/;"	f	class:srSystem
FS_IntegratePosition_PosErrVel_Euler	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_IntegratePosition_PosErrVel_Euler(SR_REAL & _step)$/;"	f	class:srSystem
FS_IntegratePosition_PosErrVel_plus_Velocity_Euler	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_IntegratePosition_PosErrVel_plus_Velocity_Euler(SR_REAL & _step)$/;"	f	class:srSystem
FS_MassPosErrVelocityPropagation	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_MassPosErrVelocityPropagation()$/;"	f	class:srSystem
FS_ResetT	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::FS_ResetT()$/;"	f	class:srBallJoint
FS_ResetT	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::FS_ResetT()$/;"	f	class:srPrismaticJoint
FS_ResetT	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::FS_ResetT()$/;"	f	class:srRevoluteJoint
FS_ResetT	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::FS_ResetT()$/;"	f	class:srUniversalJoint
FS_ResetT	srLib/srDyn/srWeldJoint.cpp	/^void srWeldJoint::FS_ResetT()$/;"	f	class:srWeldJoint
FS_Reset_Bias_T	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_Reset_Bias_T()$/;"	f	class:srSystem
FS_Reset_ConstraintImpulse	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_Reset_ConstraintImpulse()$/;"	f	class:srSystem
FS_SetScrew	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::FS_SetScrew(int i)$/;"	f	class:srBallJoint
FS_SetScrew	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::FS_SetScrew(int i)$/;"	f	class:srPrismaticJoint
FS_SetScrew	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::FS_SetScrew(int i)$/;"	f	class:srRevoluteJoint
FS_SetScrew	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::FS_SetScrew(int i)$/;"	f	class:srUniversalJoint
FS_SetScrew	srLib/srDyn/srWeldJoint.cpp	/^void srWeldJoint::FS_SetScrew(int )$/;"	f	class:srWeldJoint
FS_Transform	srLib/srDyn/srBallJoint.cpp	/^SE3& srBallJoint::FS_Transform()$/;"	f	class:srBallJoint
FS_Transform	srLib/srDyn/srLink.cpp	/^SE3& srLink::FS_Transform()$/;"	f	class:srLink
FS_Transform	srLib/srDyn/srPrismaticJoint.cpp	/^SE3& srPrismaticJoint::FS_Transform()$/;"	f	class:srPrismaticJoint
FS_Transform	srLib/srDyn/srRevoluteJoint.cpp	/^SE3& srRevoluteJoint::FS_Transform()$/;"	f	class:srRevoluteJoint
FS_Transform	srLib/srDyn/srUniversalJoint.cpp	/^SE3& srUniversalJoint::FS_Transform()$/;"	f	class:srUniversalJoint
FS_Transform	srLib/srDyn/srWeldJoint.cpp	/^SE3& srWeldJoint::FS_Transform()$/;"	f	class:srWeldJoint
FS_UpdateAIS_K	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateAIS_K(const AInertia& AI)$/;"	f	class:srBallJoint
FS_UpdateAIS_K	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateAIS_K(AInertia &AIjari)$/;"	f	class:srLink
FS_UpdateAIS_K	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateAIS_K(void)$/;"	f	class:srLink
FS_UpdateAIS_K	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateAIS_K(const AInertia& AI)$/;"	f	class:srPrismaticJoint
FS_UpdateAIS_K	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateAIS_K(const AInertia& AI)$/;"	f	class:srRevoluteJoint
FS_UpdateAIS_K	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateAIS_K(const AInertia& AI)$/;"	f	class:srUniversalJoint
FS_UpdateAIS_K	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateAIS_K(const AInertia& \/*AI*\/)$/;"	f	class:srWeldJoint
FS_UpdateAIS_K_P	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateAIS_K_P(AInertia& __AI, const AInertia& AI)$/;"	f	class:srBallJoint
FS_UpdateAIS_K_P	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateAIS_K_P(AInertia& __AI, const AInertia& AI)$/;"	f	class:srPrismaticJoint
FS_UpdateAIS_K_P	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateAIS_K_P(AInertia& __AI, const AInertia& AI)$/;"	f	class:srRevoluteJoint
FS_UpdateAIS_K_P	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateAIS_K_P(AInertia& __AI, const AInertia& AI)$/;"	f	class:srUniversalJoint
FS_UpdateAIS_K_P	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateAIS_K_P(AInertia& __AI, const AInertia& AI)$/;"	f	class:srWeldJoint
FS_UpdateAcc	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateAcc(se3 &DV)$/;"	f	class:srLink
FS_UpdateBiasImp	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateBiasImp(dse3& Cias, const dse3& Bias)$/;"	f	class:srBallJoint
FS_UpdateBiasImp	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateBiasImp(dse3 &jari)$/;"	f	class:srLink
FS_UpdateBiasImp	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateBiasImp(dse3& Cias, const dse3& Bias)$/;"	f	class:srPrismaticJoint
FS_UpdateBiasImp	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateBiasImp(dse3& Cias, const dse3& Bias)$/;"	f	class:srRevoluteJoint
FS_UpdateBiasImp	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateBiasImp(dse3& Cias, const dse3& Bias)$/;"	f	class:srUniversalJoint
FS_UpdateBiasImp	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateBiasImp(dse3& Cias, const dse3& Bias)$/;"	f	class:srWeldJoint
FS_UpdateBiasImpulse	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_UpdateBiasImpulse(srLink * pMass)$/;"	f	class:srSystem
FS_UpdateBiasImpulse	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_UpdateBiasImpulse(srLink * pMass, const dse3& imp)$/;"	f	class:srSystem
FS_UpdateBiasforce	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateBiasforce(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srBallJoint
FS_UpdateBiasforce	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateBiasforce(dse3 &jari)$/;"	f	class:srLink
FS_UpdateBiasforce	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateBiasforce(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srPrismaticJoint
FS_UpdateBiasforce	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateBiasforce(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srRevoluteJoint
FS_UpdateBiasforce	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateBiasforce(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srUniversalJoint
FS_UpdateBiasforce	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateBiasforce(dse3& Cias, const dse3& Bias, const AInertia& \/*AI*\/, const se3& \/*V*\/)$/;"	f	class:srWeldJoint
FS_UpdateDelVel	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateDelVel(se3 &DV)$/;"	f	class:srLink
FS_UpdateDelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::FS_UpdateDelVelocity()$/;"	f	class:srSystem
FS_UpdateForce	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateForce(const dse3& F)$/;"	f	class:srBallJoint
FS_UpdateForce	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateForce(const dse3& F)$/;"	f	class:srPrismaticJoint
FS_UpdateForce	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateForce(const dse3& F)$/;"	f	class:srRevoluteJoint
FS_UpdateForce	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateForce(const dse3& F)$/;"	f	class:srUniversalJoint
FS_UpdateForce	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateForce(const dse3& \/*F*\/)$/;"	f	class:srWeldJoint
FS_UpdateForce_Link	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateForce_Link()$/;"	f	class:srLink
FS_UpdateImpulse_Link	srLib/srDyn/srLink.cpp	/^void srLink::FS_UpdateImpulse_Link(SR_REAL & _fps)$/;"	f	class:srLink
FS_UpdateLocalAcc	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateLocalAcc(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
FS_UpdateLocalAcc	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateLocalAcc(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
FS_UpdateLocalAcc	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateLocalAcc(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
FS_UpdateLocalAcc	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateLocalAcc(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
FS_UpdateLocalAcc	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateLocalAcc(se3& jari, const se3& DV)$/;"	f	class:srWeldJoint
FS_UpdateLocalDelVel	srLib/srDyn/srBallJoint.cpp	/^inline void srBallJoint::FS_UpdateLocalDelVel(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
FS_UpdateLocalDelVel	srLib/srDyn/srPrismaticJoint.cpp	/^inline void srPrismaticJoint::FS_UpdateLocalDelVel(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
FS_UpdateLocalDelVel	srLib/srDyn/srRevoluteJoint.cpp	/^inline void srRevoluteJoint::FS_UpdateLocalDelVel(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
FS_UpdateLocalDelVel	srLib/srDyn/srUniversalJoint.cpp	/^inline void srUniversalJoint::FS_UpdateLocalDelVel(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
FS_UpdateLocalDelVel	srLib/srDyn/srWeldJoint.cpp	/^inline void srWeldJoint::FS_UpdateLocalDelVel(se3& jari, const se3& DV)$/;"	f	class:srWeldJoint
FS_UpdateLocalVelocity	srLib/srDyn/srBallJoint.cpp	/^se3& srBallJoint::FS_UpdateLocalVelocity()$/;"	f	class:srBallJoint
FS_UpdateLocalVelocity	srLib/srDyn/srPrismaticJoint.cpp	/^se3& srPrismaticJoint::FS_UpdateLocalVelocity()$/;"	f	class:srPrismaticJoint
FS_UpdateLocalVelocity	srLib/srDyn/srRevoluteJoint.cpp	/^se3& srRevoluteJoint::FS_UpdateLocalVelocity()$/;"	f	class:srRevoluteJoint
FS_UpdateLocalVelocity	srLib/srDyn/srUniversalJoint.cpp	/^se3& srUniversalJoint::FS_UpdateLocalVelocity()$/;"	f	class:srUniversalJoint
FS_UpdateLocalVelocity	srLib/srDyn/srWeldJoint.cpp	/^se3& srWeldJoint::FS_UpdateLocalVelocity()$/;"	f	class:srWeldJoint
FS_UpdatePosErrorLocalVelocity	srLib/srDyn/srBallJoint.cpp	/^se3& srBallJoint::FS_UpdatePosErrorLocalVelocity()$/;"	f	class:srBallJoint
FS_UpdatePosErrorLocalVelocity	srLib/srDyn/srPrismaticJoint.cpp	/^se3& srPrismaticJoint::FS_UpdatePosErrorLocalVelocity()$/;"	f	class:srPrismaticJoint
FS_UpdatePosErrorLocalVelocity	srLib/srDyn/srRevoluteJoint.cpp	/^se3& srRevoluteJoint::FS_UpdatePosErrorLocalVelocity()$/;"	f	class:srRevoluteJoint
FS_UpdatePosErrorLocalVelocity	srLib/srDyn/srUniversalJoint.cpp	/^se3& srUniversalJoint::FS_UpdatePosErrorLocalVelocity()$/;"	f	class:srUniversalJoint
FS_UpdatePosErrorLocalVelocity	srLib/srDyn/srWeldJoint.cpp	/^se3& srWeldJoint::FS_UpdatePosErrorLocalVelocity()$/;"	f	class:srWeldJoint
Faces	srLib/SceneGraph/Model3DS.h	/^		unsigned short *Faces;		\/\/ The array of face indices$/;"	m	struct:Model3DS::Object
FacesDescriptionChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::FacesDescriptionChunkProcessor(long length, long findex, int objindex)$/;"	f	class:Model3DS
FacesMaterialsListChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::FacesMaterialsListChunkProcessor(long length, long findex, int objindex, int subfacesindex)$/;"	f	class:Model3DS
Factor	Eigen/src/Core/Replicate.h	/^    Factor = (RowFactor==Dynamic || ColFactor==Dynamic) ? Dynamic : RowFactor*ColFactor$/;"	e	enum:Eigen::internal::traits::__anon270
FactorType	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,RowMajor> FactorType;$/;"	t	class:Eigen::IncompleteLUT
FadeIn	srLib/srg/srgColor.cpp	/^void srgColor::FadeIn(float fValue)$/;"	f	class:srgColor
FadeOut	srLib/srg/srgColor.cpp	/^void srgColor::FadeOut(float fValue)$/;"	f	class:srgColor
Filter_InactiveContactPoints_______________MARK7	srLib/srDyn/srContactConstraint.cpp	/^void		ContactConstraint::Filter_InactiveContactPoints_______________MARK7()$/;"	f	class:ContactConstraint
Filter_InvalidContactPoints_And_Refresh____MARK7	srLib/srDyn/srContactConstraint.cpp	/^void		ContactConstraint::Filter_InvalidContactPoints_And_Refresh____MARK7()$/;"	f	class:ContactConstraint
FindAttribute	tinyxml2/tinyxml2.cpp	/^const XMLAttribute* XMLElement::FindAttribute( const char* name ) const$/;"	f	class:tinyxml2::XMLElement
FindAttribute	tinyxml2/tinyxml2.h	/^    XMLAttribute* FindAttribute( const char* name ) {$/;"	f	class:tinyxml2::XMLElement
FindNearestContactPoint	srLib/srDyn/srContactConstraint.cpp	/^inline int ContactConstraint::FindNearestContactPoint(Vec3& localpoint_Left)$/;"	f	class:ContactConstraint
FindObject	srLib/srDyn/srObject.cpp	/^srObject* srObject::FindObject(char* name)$/;"	f	class:srObject
FindOrCreateAttribute	tinyxml2/tinyxml2.cpp	/^XMLAttribute* XMLElement::FindOrCreateAttribute( const char* name )$/;"	f	class:tinyxml2::XMLElement
FirstAttribute	tinyxml2/tinyxml2.h	/^    const XMLAttribute* FirstAttribute() const {$/;"	f	class:tinyxml2::XMLElement
FirstChild	tinyxml2/tinyxml2.h	/^    XMLHandle FirstChild() 													{$/;"	f	class:tinyxml2::XMLHandle
FirstChild	tinyxml2/tinyxml2.h	/^    XMLNode*		FirstChild()			{$/;"	f	class:tinyxml2::XMLNode
FirstChild	tinyxml2/tinyxml2.h	/^    const XMLConstHandle FirstChild() const											{$/;"	f	class:tinyxml2::XMLConstHandle
FirstChild	tinyxml2/tinyxml2.h	/^    const XMLNode*  FirstChild() const		{$/;"	f	class:tinyxml2::XMLNode
FirstChildElement	tinyxml2/tinyxml2.cpp	/^const XMLElement* XMLNode::FirstChildElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
FirstChildElement	tinyxml2/tinyxml2.h	/^    XMLElement* FirstChildElement( const char* name = 0 )	{$/;"	f	class:tinyxml2::XMLNode
FirstChildElement	tinyxml2/tinyxml2.h	/^    XMLHandle FirstChildElement( const char* name = 0 )						{$/;"	f	class:tinyxml2::XMLHandle
FirstChildElement	tinyxml2/tinyxml2.h	/^    const XMLConstHandle FirstChildElement( const char* name = 0 ) const				{$/;"	f	class:tinyxml2::XMLConstHandle
Fits	tinyxml2/tinyxml2.cpp	/^    static bool Fits( unsigned long )$/;"	f	struct:tinyxml2::LongFitsIntoSizeTMinusOne
FixedSegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	s
Flagged	Eigen/src/Core/Flagged.h	/^    inline Flagged(const ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::Flagged
Flagged	Eigen/src/Core/Flagged.h	/^template<typename ExpressionType, unsigned int Added, unsigned int Removed> class Flagged$/;"	c	namespace:Eigen
Flags	Eigen/src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon318
Flags	Eigen/src/Core/ArrayWrapper.h	/^    Flags = Flags0 & ~NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon319
Flags	Eigen/src/Core/BandMatrix.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
Flags	Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon215
Flags	Eigen/src/Core/BandMatrix.h	/^    Flags = LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon216
Flags	Eigen/src/Core/Block.h	/^    Flags = Flags0 | FlagsLinearAccessBit | FlagsLvalueBit | FlagsRowMajorBit$/;"	e	enum:Eigen::internal::traits::__anon273
Flags	Eigen/src/Core/CwiseBinaryOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (LhsFlags & RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon228
Flags	Eigen/src/Core/CwiseNullaryOp.h	/^    Flags = (traits<PlainObjectType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon312
Flags	Eigen/src/Core/CwiseUnaryOp.h	/^    Flags = _XprTypeNested::Flags & ($/;"	e	enum:Eigen::internal::traits::__anon31
Flags	Eigen/src/Core/CwiseUnaryView.h	/^    Flags = (traits<_MatrixTypeNested>::Flags & (HereditaryBits | LvalueBit | LinearAccessBit | DirectAccessBit)),$/;"	e	enum:Eigen::internal::traits::__anon233
Flags	Eigen/src/Core/DenseBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::DenseBase::__anon341
Flags	Eigen/src/Core/Diagonal.h	/^    Flags = (unsigned int)_MatrixTypeNested::Flags & (HereditaryBits | LinearAccessBit | MaskLvalueBit | DirectAccessBit) & ~RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon339
Flags	Eigen/src/Core/DiagonalMatrix.h	/^      Flags = 0$/;"	e	enum:Eigen::DiagonalBase::__anon32
Flags	Eigen/src/Core/DiagonalMatrix.h	/^    Flags =  traits<DiagonalVectorType>::Flags & LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon34
Flags	Eigen/src/Core/DiagonalMatrix.h	/^    Flags = LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon33
Flags	Eigen/src/Core/DiagonalProduct.h	/^    Flags = ((HereditaryBits|_LinearAccessMask|AlignedBit) & (unsigned int)(MatrixType::Flags)) | (_Vectorizable ? PacketAccessBit : 0),\/\/(int(MatrixType::Flags)&int(DiagonalType::DiagonalVectorType::Flags)&AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon232
Flags	Eigen/src/Core/Flagged.h	/^  enum { Flags = (ExpressionType::Flags | Added) & ~Removed };$/;"	e	enum:Eigen::internal::traits::__anon223
Flags	Eigen/src/Core/Map.h	/^    Flags = KeepsPacketAccess ? int(Flags3) : (int(Flags3) & ~PacketAccessBit)$/;"	e	enum:Eigen::internal::traits::__anon204
Flags	Eigen/src/Core/Matrix.h	/^    Flags = compute_matrix_flags<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>::ret,$/;"	e	enum:Eigen::internal::traits::__anon221
Flags	Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::PermutationBase::__anon20
Flags	Eigen/src/Core/PermutationMatrix.h	/^      Flags = Traits::Flags,$/;"	e	enum:Eigen::Transpose::__anon22
Flags	Eigen/src/Core/PermutationMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon21
Flags	Eigen/src/Core/ProductBase.h	/^    Flags = (MaxRowsAtCompileTime==1 ? RowMajorBit : 0)$/;"	e	enum:Eigen::internal::traits::__anon139
Flags	Eigen/src/Core/Ref.h	/^    Flags = traits<Map<_PlainObjectType, _Options, _StrideType> >::Flags | NestByRefBit$/;"	e	enum:Eigen::internal::traits::__anon322
Flags	Eigen/src/Core/Replicate.h	/^    Flags = (_MatrixTypeNested::Flags & HereditaryBits & ~RowMajorBit) | (IsRowMajor ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon271
Flags	Eigen/src/Core/ReturnByValue.h	/^    Flags = (traits<typename traits<Derived>::ReturnType>::Flags$/;"	e	enum:Eigen::internal::traits::__anon109
Flags	Eigen/src/Core/Reverse.h	/^    Flags = int(_MatrixTypeNested::Flags) & (HereditaryBits | LvalueBit | PacketAccessBit | LinearAccess),$/;"	e	enum:Eigen::internal::traits::__anon18
Flags	Eigen/src/Core/Select.h	/^    Flags = (unsigned int)ThenMatrixType::Flags & ElseMatrixType::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon343
Flags	Eigen/src/Core/SelfAdjointView.h	/^    Flags =  MatrixTypeNestedCleaned::Flags & (HereditaryBits)$/;"	e	enum:Eigen::internal::traits::__anon277
Flags	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Flags = traits<CwiseBinaryOp<BinaryOp,Lhs,Rhs> >::Flags | (Lhs::Flags&DirectAccessBit) | (Lhs::Flags&LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon211
Flags	Eigen/src/Core/Transpose.h	/^    Flags = Flags1 ^ RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon324
Flags	Eigen/src/Core/TriangularMatrix.h	/^    Flags = (MatrixTypeNestedCleaned::Flags & (HereditaryBits) & (~(PacketAccessBit | DirectAccessBit | LinearAccessBit))) | Mode,$/;"	e	enum:Eigen::internal::traits::__anon239
Flags	Eigen/src/Core/VectorwiseOp.h	/^    Flags = (Flags0 & ~RowMajorBit) | (RowsAtCompileTime == 1 ? RowMajorBit : 0),$/;"	e	enum:Eigen::internal::traits::__anon313
Flags	Eigen/src/Core/products/CoeffBasedProduct.h	/^      Flags = ((unsigned int)(LhsFlags | RhsFlags) & HereditaryBits & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon122
Flags	Eigen/src/Eigen2Support/Minor.h	/^    Flags = _MatrixTypeNested::Flags & (HereditaryBits | LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon406
Flags	Eigen/src/Geometry/Homogeneous.h	/^    Flags = ColsAtCompileTime==1 ? (TmpFlags & ~RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon440
Flags	Eigen/src/Geometry/Quaternion.h	/^      Flags = TraitsBase::Flags & ~LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon446
Flags	Eigen/src/Geometry/Quaternion.h	/^    Flags = Eigen::internal::traits<Derived>::Flags$/;"	e	enum:Eigen::QuaternionBase::__anon443
Flags	Eigen/src/Geometry/Quaternion.h	/^    Flags = IsAligned ? (AlignedBit | LvalueBit) : LvalueBit$/;"	e	enum:Eigen::internal::traits::__anon444
Flags	Eigen/src/Householder/HouseholderSequence.h	/^    Flags = 0$/;"	e	enum:Eigen::internal::traits::__anon355
Flags	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Flags = Tr ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon374
Flags	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    Flags = (SparseFlags&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon368
Flags	Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = 0,$/;"	e	enum:Eigen::internal::traits::__anon362
Flags	Eigen/src/SparseCore/SparseMatrix.h	/^    Flags = _Options | NestByRefBit | LvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon361
Flags	Eigen/src/SparseCore/SparseMatrixBase.h	/^      Flags = internal::traits<Derived>::Flags,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
Flags	Eigen/src/SparseCore/SparseProduct.h	/^    Flags = (int(LhsFlags | RhsFlags) & HereditaryBits & RemovedBits)$/;"	e	enum:Eigen::internal::traits::__anon390
Flags	Eigen/src/SparseCore/SparseVector.h	/^    Flags = _Options | NestByRefBit | LvalueBit | (IsColVector ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon385
Flags	Eigen/src/SparseCore/SparseView.h	/^    Flags = int(traits<MatrixType>::Flags) & (RowMajorBit)$/;"	e	enum:Eigen::internal::traits::__anon366
Flags0	Eigen/src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon318
Flags0	Eigen/src/Core/ArrayWrapper.h	/^    Flags0 = traits<typename remove_all<typename ExpressionType::Nested>::type >::Flags,$/;"	e	enum:Eigen::internal::traits::__anon319
Flags0	Eigen/src/Core/Block.h	/^    Flags0 = traits<XprType>::Flags & ( (HereditaryBits & ~RowMajorBit) |$/;"	e	enum:Eigen::internal::traits::__anon273
Flags0	Eigen/src/Core/CwiseBinaryOp.h	/^    Flags0 = (int(LhsFlags) | int(RhsFlags)) & ($/;"	e	enum:Eigen::internal::traits::__anon228
Flags0	Eigen/src/Core/Map.h	/^    Flags0 = TraitsBase::Flags & (~NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon204
Flags0	Eigen/src/Core/Transpose.h	/^    Flags0 = MatrixTypeNestedPlain::Flags & ~(LvalueBit | NestByRefBit),$/;"	e	enum:Eigen::internal::traits::__anon324
Flags0	Eigen/src/Core/VectorwiseOp.h	/^    Flags0 = (unsigned int)_MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon313
Flags1	Eigen/src/Core/Map.h	/^    Flags1 = IsAligned ? (int(Flags0) | AlignedBit) : (int(Flags0) & ~AlignedBit),$/;"	e	enum:Eigen::internal::traits::__anon204
Flags1	Eigen/src/Core/Transpose.h	/^    Flags1 = Flags0 | FlagsLvalueBit,$/;"	e	enum:Eigen::internal::traits::__anon324
Flags2	Eigen/src/Core/Map.h	/^    Flags2 = (bool(HasNoStride) || bool(PlainObjectType::IsVectorAtCompileTime))$/;"	e	enum:Eigen::internal::traits::__anon204
Flags3	Eigen/src/Core/Map.h	/^    Flags3 = is_lvalue<PlainObjectType>::value ? int(Flags2) : (int(Flags2) & ~LvalueBit),$/;"	e	enum:Eigen::internal::traits::__anon204
FlagsLinearAccessBit	Eigen/src/Core/Block.h	/^    FlagsLinearAccessBit = (RowsAtCompileTime == 1 || ColsAtCompileTime == 1 || (InnerPanel && (traits<XprType>::Flags&LinearAccessBit))) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon273
FlagsLvalueBit	Eigen/src/Core/Block.h	/^    FlagsLvalueBit = is_lvalue<XprType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon273
FlagsLvalueBit	Eigen/src/Core/Transpose.h	/^    FlagsLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon324
FlagsRowMajorBit	Eigen/src/Core/Block.h	/^    FlagsRowMajorBit = IsRowMajor ? RowMajorBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon273
FloatAttribute	tinyxml2/tinyxml2.cpp	/^float XMLElement::FloatAttribute(const char* name, float defaultValue) const $/;"	f	class:tinyxml2::XMLElement
FloatColorChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::FloatColorChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
FloatText	tinyxml2/tinyxml2.cpp	/^float XMLElement::FloatText(float defaultValue) const$/;"	f	class:tinyxml2::XMLElement
FloatValue	tinyxml2/tinyxml2.h	/^    float	 FloatValue() const				{$/;"	f	class:tinyxml2::XMLAttribute
Font	srLib/SceneGraph/Leaf.cpp	/^Font::Font()$/;"	f	class:Font
Font	srLib/SceneGraph/Leaf.cpp	/^Font::Font(const string& str)$/;"	f	class:Font
Font	srLib/SceneGraph/Leaf.h	/^class Font : public Leaf$/;"	c
ForceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^    inline ForceAlignedAccess(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::ForceAlignedAccess
ForceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^template<typename ExpressionType> class ForceAlignedAccess$/;"	c	namespace:Eigen
ForceLimit	srLib/srDyn/srJointConstraint.h	/^	SR_REAL	ForceLimit[2];	\/\/ Force Limit [0]:lower, [1]:upper$/;"	m	class:JointConstraint
ForceVector	srLib/SceneGraph/Leaf.cpp	/^ForceVector::ForceVector()$/;"	f	class:ForceVector
ForceVector	srLib/SceneGraph/Leaf.h	/^class ForceVector : public Leaf$/;"	c
Free	srLib/srg/srgCamera.h	/^		Top, Free, Front, Left$/;"	e	enum:srgCamera::ViewDirection
Free	tinyxml2/tinyxml2.h	/^    virtual void Free( void* mem ) {$/;"	f	class:tinyxml2::MemPoolT
FromTwoVectors	Eigen/src/Geometry/Quaternion.h	/^Quaternion<Scalar,Options> Quaternion<Scalar,Options>::FromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion
Front	srLib/srg/srgCamera.h	/^		Top, Free, Front, Left$/;"	e	enum:srgCamera::ViewDirection
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR()$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
FullPivHouseholderQR	Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename _MatrixType> class FullPivHouseholderQR$/;"	c	namespace:Eigen
FullPivHouseholderQRMatrixQReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^  FullPivHouseholderQRMatrixQReturnType(const MatrixType&       qr,$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
FullPivHouseholderQRMatrixQReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^template<typename MatrixType> struct FullPivHouseholderQRMatrixQReturnType$/;"	s	namespace:Eigen::internal
FullPivHouseholderQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  FullPivHouseholderQRPreconditioner$/;"	e	enum:Eigen::QRPreconditioners
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU()$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(Index rows, Index cols)$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>::FullPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU
FullPivLU	Eigen/src/LU/FullPivLU.h	/^template<typename _MatrixType> class FullPivLU$/;"	c	namespace:Eigen
FullPrecision	Eigen/src/Core/IO.h	/^       FullPrecision = -2 };$/;"	e	enum:Eigen::__anon243
FullyLazyCoeffBaseProductType	Eigen/src/Core/ProductBase.h	/^    typedef CoeffBasedProduct<LhsNested, RhsNested, 0> FullyLazyCoeffBaseProductType;$/;"	t	class:Eigen::ProductBase
Function	srMath/Function.h	/^		Function(const Real& eps = (1e-5))$/;"	f	class:srMath::Function
Function	srMath/Function.h	/^	class Function$/;"	c	namespace:srMath
FunctionPtr	srMath/Function.h	/^	typedef std::shared_ptr< Function > FunctionPtr;$/;"	t	namespace:srMath
FunctorType	Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon189
FunctorType	Eigen/src/Core/util/Meta.h	/^    enum {FunctorType = sizeof(testFunctor(static_cast<Func*>(0)))};$/;"	e	enum:Eigen::internal::result_of::__anon190
G	srLib/srg/srgColor.h	/^	typedef struct _sRGBA { float R; float G; float B; float A; } SRGBA;$/;"	m	struct:srgColor::_sRGBA
GEMM_SPECIALIZATION	Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^#define GEMM_SPECIALIZATION(/;"	d
GL2PSDLL_API	srLib/SceneGraph/gl2ps.h	/^#      define GL2PSDLL_API /;"	d
GL2PSDLL_API	srLib/SceneGraph/gl2ps.h	/^#    define GL2PSDLL_API$/;"	d
GL2PSDLL_API	srLib/SceneGraph/gl2ps.h	/^#  define GL2PSDLL_API$/;"	d
GL2PS_BEGIN_BLEND_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_BEGIN_BLEND_TOKEN /;"	d	file:
GL2PS_BEGIN_BOUNDARY_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_BEGIN_BOUNDARY_TOKEN /;"	d	file:
GL2PS_BEGIN_OFFSET_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_BEGIN_OFFSET_TOKEN /;"	d	file:
GL2PS_BEGIN_STIPPLE_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_BEGIN_STIPPLE_TOKEN /;"	d	file:
GL2PS_BEST_ROOT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_BEST_ROOT /;"	d
GL2PS_BLEND	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_BLEND /;"	d
GL2PS_BSP_SORT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_BSP_SORT /;"	d
GL2PS_COINCIDENT	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_COINCIDENT /;"	d	file:
GL2PS_COMPRESS	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_COMPRESS /;"	d
GL2PS_COPYRIGHT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_COPYRIGHT /;"	d
GL2PS_DRAW_BACKGROUND	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_DRAW_BACKGROUND /;"	d
GL2PS_DRAW_PIXELS_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_DRAW_PIXELS_TOKEN /;"	d	file:
GL2PS_DST_BLEND_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_DST_BLEND_TOKEN /;"	d	file:
GL2PS_END_BLEND_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_END_BLEND_TOKEN /;"	d	file:
GL2PS_END_BOUNDARY_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_END_BOUNDARY_TOKEN /;"	d	file:
GL2PS_END_OFFSET_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_END_OFFSET_TOKEN /;"	d	file:
GL2PS_END_STIPPLE_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_END_STIPPLE_TOKEN /;"	d	file:
GL2PS_EPS	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_EPS /;"	d
GL2PS_EPSILON	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_EPSILON /;"	d	file:
GL2PS_ERROR	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_ERROR /;"	d
GL2PS_EXTRA_VERSION	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_EXTRA_VERSION /;"	d
GL2PS_HAVE_LIBPNG	srLib/SceneGraph/gl2ps.h	/^#    define GL2PS_HAVE_LIBPNG$/;"	d
GL2PS_HAVE_NO_VSNPRINTF	srLib/SceneGraph/gl2ps.h	/^#  define GL2PS_HAVE_NO_VSNPRINTF$/;"	d
GL2PS_HAVE_ZLIB	srLib/SceneGraph/gl2ps.h	/^#  define GL2PS_HAVE_ZLIB$/;"	d
GL2PS_IMAGEMAP	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_IMAGEMAP /;"	d	file:
GL2PS_IMAGEMAP_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_IMAGEMAP_TOKEN /;"	d	file:
GL2PS_IMAGEMAP_VISIBLE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_IMAGEMAP_VISIBLE /;"	d	file:
GL2PS_IMAGEMAP_WRITTEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_IMAGEMAP_WRITTEN /;"	d	file:
GL2PS_INFO	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_INFO /;"	d
GL2PS_IN_BACK_OF	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_IN_BACK_OF /;"	d	file:
GL2PS_IN_FRONT_OF	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_IN_FRONT_OF /;"	d	file:
GL2PS_LANDSCAPE	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_LANDSCAPE /;"	d
GL2PS_LINE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_LINE /;"	d	file:
GL2PS_LINE_STIPPLE	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_LINE_STIPPLE /;"	d
GL2PS_LINE_WIDTH_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_LINE_WIDTH_TOKEN /;"	d	file:
GL2PS_MAJOR_VERSION	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_MAJOR_VERSION /;"	d
GL2PS_MINOR_VERSION	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_MINOR_VERSION /;"	d
GL2PS_NONE	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NONE /;"	d
GL2PS_NO_BLENDING	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NO_BLENDING /;"	d
GL2PS_NO_FEEDBACK	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NO_FEEDBACK /;"	d
GL2PS_NO_PIXMAP	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NO_PIXMAP /;"	d
GL2PS_NO_PS3_SHADING	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NO_PS3_SHADING /;"	d
GL2PS_NO_SORT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NO_SORT /;"	d
GL2PS_NO_TEXT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_NO_TEXT /;"	d
GL2PS_NO_TYPE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_NO_TYPE /;"	d	file:
GL2PS_OCCLUSION_CULL	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_OCCLUSION_CULL /;"	d
GL2PS_OVERFLOW	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_OVERFLOW /;"	d
GL2PS_PATCH_VERSION	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_PATCH_VERSION /;"	d
GL2PS_PDF	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_PDF /;"	d
GL2PS_PGF	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_PGF /;"	d
GL2PS_PIXMAP	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_PIXMAP /;"	d	file:
GL2PS_POINT	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_POINT /;"	d	file:
GL2PS_POINT_BACK	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_POINT_BACK /;"	d	file:
GL2PS_POINT_COINCIDENT	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_POINT_COINCIDENT /;"	d	file:
GL2PS_POINT_INFRONT	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_POINT_INFRONT /;"	d	file:
GL2PS_POINT_SIZE_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_POINT_SIZE_TOKEN /;"	d	file:
GL2PS_POLYGON_BOUNDARY	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_POLYGON_BOUNDARY /;"	d
GL2PS_POLYGON_OFFSET_FILL	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_POLYGON_OFFSET_FILL /;"	d
GL2PS_PS	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_PS /;"	d
GL2PS_QUADRANGLE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_QUADRANGLE /;"	d	file:
GL2PS_SILENT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_SILENT /;"	d
GL2PS_SIMPLE_LINE_OFFSET	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_SIMPLE_LINE_OFFSET /;"	d
GL2PS_SIMPLE_SORT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_SIMPLE_SORT /;"	d
GL2PS_SPANNING	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_SPANNING /;"	d	file:
GL2PS_SPECIAL	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_SPECIAL /;"	d	file:
GL2PS_SRC_BLEND_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_SRC_BLEND_TOKEN /;"	d	file:
GL2PS_SUCCESS	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_SUCCESS /;"	d
GL2PS_SVG	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_SVG /;"	d
GL2PS_TEX	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEX /;"	d
GL2PS_TEXT	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_TEXT /;"	d	file:
GL2PS_TEXT_B	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_B /;"	d
GL2PS_TEXT_BL	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_BL /;"	d
GL2PS_TEXT_BR	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_BR /;"	d
GL2PS_TEXT_C	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_C /;"	d
GL2PS_TEXT_CL	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_CL /;"	d
GL2PS_TEXT_CR	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_CR /;"	d
GL2PS_TEXT_T	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_T /;"	d
GL2PS_TEXT_TL	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_TL /;"	d
GL2PS_TEXT_TOKEN	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_TEXT_TOKEN /;"	d	file:
GL2PS_TEXT_TR	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TEXT_TR /;"	d
GL2PS_TIGHT_BOUNDING_BOX	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_TIGHT_BOUNDING_BOX /;"	d
GL2PS_TRIANGLE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_TRIANGLE /;"	d	file:
GL2PS_TRIANGLE_PROPERTY	srLib/SceneGraph/gl2ps.c	/^} GL2PS_TRIANGLE_PROPERTY;$/;"	t	typeref:enum:__anon5	file:
GL2PS_UNINITIALIZED	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_UNINITIALIZED /;"	d
GL2PS_USE_CURRENT_VIEWPORT	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_USE_CURRENT_VIEWPORT /;"	d
GL2PS_VERSION	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_VERSION /;"	d
GL2PS_WARNING	srLib/SceneGraph/gl2ps.h	/^#define GL2PS_WARNING /;"	d
GL2PS_ZERO	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_ZERO(/;"	d	file:
GL2PS_ZOFFSET	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_ZOFFSET /;"	d	file:
GL2PS_ZOFFSET_LARGE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_ZOFFSET_LARGE /;"	d	file:
GL2PS_ZSCALE	srLib/SceneGraph/gl2ps.c	/^#define GL2PS_ZSCALE /;"	d	file:
GL2PSbackend	srLib/SceneGraph/gl2ps.c	/^} GL2PSbackend;$/;"	t	typeref:struct:__anon16	file:
GL2PSbsptree	srLib/SceneGraph/gl2ps.c	/^typedef struct _GL2PSbsptree GL2PSbsptree;$/;"	t	typeref:struct:_GL2PSbsptree	file:
GL2PSbsptree2d	srLib/SceneGraph/gl2ps.c	/^typedef struct _GL2PSbsptree2d GL2PSbsptree2d;$/;"	t	typeref:struct:_GL2PSbsptree2d	file:
GL2PScompress	srLib/SceneGraph/gl2ps.c	/^} GL2PScompress;$/;"	t	typeref:struct:__anon13	file:
GL2PScontext	srLib/SceneGraph/gl2ps.c	/^} GL2PScontext;$/;"	t	typeref:struct:__anon15	file:
GL2PSimage	srLib/SceneGraph/gl2ps.c	/^} GL2PSimage;$/;"	t	typeref:struct:__anon10	file:
GL2PSimagemap	srLib/SceneGraph/gl2ps.c	/^typedef struct _GL2PSimagemap GL2PSimagemap;$/;"	t	typeref:struct:_GL2PSimagemap	file:
GL2PSlist	srLib/SceneGraph/gl2ps.c	/^} GL2PSlist;$/;"	t	typeref:struct:__anon6	file:
GL2PSpdfgroup	srLib/SceneGraph/gl2ps.c	/^} GL2PSpdfgroup;$/;"	t	typeref:struct:__anon14	file:
GL2PSplane	srLib/SceneGraph/gl2ps.c	/^typedef GLfloat GL2PSplane[4];$/;"	t	file:
GL2PSprimitive	srLib/SceneGraph/gl2ps.c	/^} GL2PSprimitive;$/;"	t	typeref:struct:__anon11	file:
GL2PSrgba	srLib/SceneGraph/gl2ps.h	/^typedef GLfloat GL2PSrgba[4];$/;"	t
GL2PSstring	srLib/SceneGraph/gl2ps.c	/^} GL2PSstring;$/;"	t	typeref:struct:__anon9	file:
GL2PStriangle	srLib/SceneGraph/gl2ps.c	/^} GL2PStriangle;$/;"	t	typeref:struct:__anon8	file:
GL2PSvertex	srLib/SceneGraph/gl2ps.c	/^} GL2PSvertex;$/;"	t	typeref:struct:__anon7	file:
GL2PSxyz	srLib/SceneGraph/gl2ps.c	/^typedef GLfloat GL2PSxyz[3];$/;"	t	file:
GLUT_DISABLE_ATEXIT_HACK	srLib/srg/srgL.h	/^	#define GLUT_DISABLE_ATEXIT_HACK$/;"	d
GROUND_Linkage	Example/DracoP1/Ground.h	/^#define GROUND_Linkage$/;"	d
GaussianQuadrature	srMath/GaussianQuadrature.cpp	/^	GaussianQuadrature::GaussianQuadrature(int num_of_points, Real initialTime, Real finalTime)$/;"	f	class:srMath::GaussianQuadrature
GaussianQuadrature	srMath/GaussianQuadrature.h	/^	class GaussianQuadrature : public LinearIntegrator$/;"	c	namespace:srMath
GemmParallelInfo	Eigen/src/Core/products/Parallelizer.h	/^  GemmParallelInfo() : sync(-1), users(0), rhs_start(0), rhs_length(0) {}$/;"	f	struct:Eigen::internal::GemmParallelInfo
GemmParallelInfo	Eigen/src/Core/products/Parallelizer.h	/^template<typename Index> struct GemmParallelInfo$/;"	s	namespace:Eigen::internal
GemmProduct	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
GemvProduct	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
GenEigMask	Eigen/src/Core/util/Constants.h	/^  GenEigMask = Ax_lBx | ABx_lx | BAx_lx$/;"	e	enum:Eigen::DecompositionOptions
GeneralProduct	Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& a_lhs, const Rhs& a_rhs) : Base(a_lhs,a_rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	Eigen/src/Core/GeneralProduct.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, GemvProduct>$/;"	c	namespace:Eigen
GeneralProduct	Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, InnerProduct>$/;"	c	namespace:Eigen
GeneralProduct	Eigen/src/Core/GeneralProduct.h	/^class GeneralProduct<Lhs, Rhs, OuterProduct>$/;"	c	namespace:Eigen
GeneralProduct	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    GeneralProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::GeneralProduct
GeneralProduct	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class GeneralProduct<Lhs, Rhs, GemmProduct>$/;"	c	namespace:Eigen
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver() : m_eivec(), m_alphas(), m_betas(), m_isInitialized(false), m_realQZ(), m_matS(), m_tmp() {}$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver(const MatrixType& A, const MatrixType& B, bool computeEigenvectors = true)$/;"	f	class:Eigen::GeneralizedEigenSolver
GeneralizedEigenSolver	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^template<typename _MatrixType> class GeneralizedEigenSolver$/;"	c	namespace:Eigen
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver() : Base() {}$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    GeneralizedSelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB,$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
GeneralizedSelfAdjointEigenSolver	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^class GeneralizedSelfAdjointEigenSolver : public SelfAdjointEigenSolver<_MatrixType>$/;"	c	namespace:Eigen
Generic	Eigen/src/Core/util/Constants.h	/^    Generic = 0x0,$/;"	e	enum:Eigen::Architecture::Type
GenericNumTraits	Eigen/src/Core/NumTraits.h	/^template<typename T> struct GenericNumTraits$/;"	s	namespace:Eigen
GenericSparseBlockInnerIteratorImpl	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE GenericSparseBlockInnerIteratorImpl(const BlockType& block, Index outer = 0)$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
GenericSparseBlockInnerIteratorImpl	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE GenericSparseBlockInnerIteratorImpl(const BlockType& block, Index outer)$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
GenericSparseBlockInnerIteratorImpl	Eigen/src/SparseCore/SparseBlock.h	/^  class GenericSparseBlockInnerIteratorImpl<XprType,BlockRows,BlockCols,InnerPanel,false> : public internal::remove_all<typename XprType::Nested>::type::InnerIterator$/;"	c	namespace:Eigen::internal
GenericSparseBlockInnerIteratorImpl	Eigen/src/SparseCore/SparseBlock.h	/^  class GenericSparseBlockInnerIteratorImpl<XprType,BlockRows,BlockCols,InnerPanel,true>$/;"	c	namespace:Eigen::internal
GetAcc	srLib/srDyn/srLink.cpp	/^const se3& srLink::GetAcc()$/;"	f	class:srLink
GetAccelerationLowerLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	GetAccelerationLowerLimit()$/;"	f	class:srExtRevoluteJoint
GetAccelerationUpperLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	GetAccelerationUpperLimit()$/;"	f	class:srExtRevoluteJoint
GetActType	srLib/srDyn/srJoint.cpp	/^srJoint::ACTTYPE srJoint::GetActType()$/;"	f	class:srJoint
GetAction	Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
GetAlpha	srLib/srg/srgColor.cpp	/^float srgColor::GetAlpha(void)	{return m_RGBA[3];};$/;"	f	class:srgColor
GetAmbient	srLib/srg/srgColor.cpp	/^const float* const	srgMaterialColor::GetAmbient(void)$/;"	f	class:srgMaterialColor
GetAspectRatio	srLib/srg/srgCamera.cpp	/^double srgCamera::GetAspectRatio() const$/;"	f	class:srgCamera
GetBallJointState	srLib/srDyn/srBallJoint.cpp	/^srBallState& srBallJoint::GetBallJointState()$/;"	f	class:srBallJoint
GetBaseLink	srLib/srDyn/srSystem.cpp	/^srLink* srSystem::GetBaseLink()$/;"	f	class:srSystem
GetBaseLinkType	srLib/srDyn/srSystem.cpp	/^srSystem::BASELINKTYPE srSystem::GetBaseLinkType()$/;"	f	class:srSystem
GetBlue	srLib/srg/srgColor.cpp	/^float srgColor::GetBlue(void)		{return m_RGBA[2];};$/;"	f	class:srgColor
GetBoundingRadius	srLib/srDyn/srCollision.cpp	/^SR_REAL& srCollision::GetBoundingRadius()$/;"	f	class:srCollision
GetBoundingRadius	srLib/srDyn/srGeometryInfo.cpp	/^float& srGeometryInfo::GetBoundingRadius()$/;"	f	class:srGeometryInfo
GetCOM	srLib/srDyn/srSystem.cpp	/^Vec3& srSystem::GetCOM()$/;"	f	class:srSystem
GetCameraFrame	srLib/srg/srgCamera.cpp	/^SE3 srgCamera::GetCameraFrame()$/;"	f	class:srgCamera
GetCenter	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetCenter( const SE3& _CameraFrame, double _Length )$/;"	f	class:srgCamera
GetCenter	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetCenter( void )$/;"	f	class:srgCamera
GetCharacterRef	tinyxml2/tinyxml2.cpp	/^const char* XMLUtil::GetCharacterRef( const char* p, char* value, int* length )$/;"	f	class:tinyxml2::XMLUtil
GetChildLinkFrame	srLib/srDyn/srJoint.cpp	/^SE3& srJoint::GetChildLinkFrame()$/;"	f	class:srJoint
GetCollisionShape	srLib/srDyn/srCollision.cpp	/^srGeometryInfo::SHAPETYPE srCollision::GetCollisionShape()$/;"	f	class:srCollision
GetColor	srLib/srDyn/srGeometryInfo.cpp	/^float* srGeometryInfo::GetColor()$/;"	f	class:srGeometryInfo
GetColor	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::GetColor(float& r, float& g, float& b, float& a)$/;"	f	class:srGeometryInfo
GetColor	srLib/srg/srgColor.cpp	/^const float* const srgMaterialColor::GetColor(void)$/;"	f	class:srgMaterialColor
GetCoulombCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetCoulombCoeff() const$/;"	f	class:srExtRevoluteJoint
GetDamping	srLib/srDyn/srLink.cpp	/^SR_REAL srLink::GetDamping()$/;"	f	class:srLink
GetDampingCoeff	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetDampingCoeff()$/;"	f	class:srPrismaticJoint
GetDampingCoeff	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetDampingCoeff()$/;"	f	class:srRevoluteJoint
GetDampingCoeff	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetDampingCoeff(int idx)$/;"	f	class:srUniversalJoint
GetData	srLib/SceneGraph/Bitmap.cpp	/^BYTE* _Bitmap::GetData()$/;"	f	class:_Bitmap
GetData	srLib/srg/srgBitmap.cpp	/^BYTE* _Bitmap::GetData()$/;"	f	class:_Bitmap
GetDelVelocity	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::GetDelVelocity(SR_REAL * sjari)$/;"	f	class:ClosedLoop
GetDelVelocity	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::GetDelVelocity(SR_REAL * sjari)$/;"	f	class:ContactConstraint
GetDelVelocity	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::GetDelVelocity(SR_REAL * sjari)$/;"	f	class:JointConstraint
GetDetectedValue	srLib/srDyn/srIRSensor.cpp	/^SR_REAL& srIRSensor::GetDetectedValue()$/;"	f	class:srIRSensor
GetDetectedValue	srLib/srDyn/srRangeFinder.cpp	/^SR_REAL* srRangeFinder::GetDetectedValue()$/;"	f	class:srRangeFinder
GetDetectedValue	srLib/srDyn/srTouchSensor.cpp	/^bool srTouchSensor::GetDetectedValue()$/;"	f	class:srTouchSensor
GetDiffuse	srLib/srg/srgColor.cpp	/^const float* const	srgMaterialColor::GetDiffuse(void)$/;"	f	class:srgMaterialColor
GetDimension	srLib/srDyn/srCollision.cpp	/^Vec3& srCollision::GetDimension()$/;"	f	class:srCollision
GetDimension	srLib/srDyn/srGeometryInfo.cpp	/^Vec3& srGeometryInfo::GetDimension()$/;"	f	class:srGeometryInfo
GetDimension	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::GetDimension(SR_REAL& a, SR_REAL& b, SR_REAL& c)$/;"	f	class:srGeometryInfo
GetDimension	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::GetDimension(float& a, float& b, float& c)$/;"	f	class:srGeometryInfo
GetDocument	tinyxml2/tinyxml2.h	/^    XMLDocument* GetDocument()				{$/;"	f	class:tinyxml2::XMLNode
GetDocument	tinyxml2/tinyxml2.h	/^    const XMLDocument* GetDocument() const	{$/;"	f	class:tinyxml2::XMLNode
GetEmission	srLib/srg/srgColor.cpp	/^const float* const	srgMaterialColor::GetEmission(void)$/;"	f	class:srgMaterialColor
GetError	srLib/srDyn/srClosedLoopConstraint.cpp	/^inline void ClosedLoop::GetError(SR_REAL _recip_timestep)$/;"	f	class:ClosedLoop
GetErrorLineNum	tinyxml2/tinyxml2.h	/^    int GetErrorLineNum() const$/;"	f	class:tinyxml2::XMLDocument
GetErrorStr1	tinyxml2/tinyxml2.h	/^    const char* GetErrorStr1() const {$/;"	f	class:tinyxml2::XMLDocument
GetErrorStr2	tinyxml2/tinyxml2.h	/^    const char* GetErrorStr2() const {$/;"	f	class:tinyxml2::XMLDocument
GetEulerAngle	srLib/srDyn/srEntity.cpp	/^InvVec3& srEntity::GetEulerAngle()$/;"	f	class:srEntity
GetExtForce	srLib/srDyn/srLink.cpp	/^const dse3& srLink::GetExtForce()$/;"	f	class:srLink
GetEye	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetEye( const SE3& _CameraFrame )$/;"	f	class:srgCamera
GetEye	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetEye( void )$/;"	f	class:srgCamera
GetFOVy	srLib/srg/srgCamera.cpp	/^double srgCamera::GetFOVy() const$/;"	f	class:srgCamera
GetFT	srLib/srDyn/srJoint.cpp	/^dse3 srJoint::GetFT()$/;"	f	class:srJoint
GetFar	srLib/srg/srgCamera.cpp	/^double srgCamera::GetFar() const$/;"	f	class:srgCamera
GetFileName	srLib/srDyn/srGeometryInfo.cpp	/^char* srGeometryInfo::GetFileName()$/;"	f	class:srGeometryInfo
GetFinalTime	srMath/LinearIntegrator.h	/^		double			GetFinalTime() const { return _tf; }$/;"	f	class:srMath::LinearIntegrator
GetFocusLength	srLib/srg/srgCamera.cpp	/^double srgCamera::GetFocusLength( void )$/;"	f	class:srgCamera
GetForceOnLeft	srLib/srDyn/srLinearSpring.cpp	/^dse3 srLinearSpring::GetForceOnLeft()$/;"	f	class:srLinearSpring
GetForceOnRight	srLib/srDyn/srLinearSpring.cpp	/^dse3 srLinearSpring::GetForceOnRight()$/;"	f	class:srLinearSpring
GetFrame	srLib/srDyn/srEntity.cpp	/^SE3& srEntity::GetFrame()$/;"	f	class:srEntity
GetFriction	srLib/srDyn/srLink.cpp	/^SR_REAL srLink::GetFriction()$/;"	f	class:srLink
GetGLCameraFrame	srLib/srg/srgCamera.cpp	/^const double* srgCamera::GetGLCameraFrame()$/;"	f	class:srgCamera
GetGearRatio	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetGearRatio() const$/;"	f	class:srExtRevoluteJoint
GetGeomInfo	srLib/srDyn/srEntity.cpp	/^srGeometryInfo& srEntity::GetGeomInfo()$/;"	f	class:srEntity
GetGreen	srLib/srg/srgColor.cpp	/^float srgColor::GetGreen(void)	{return m_RGBA[1];};$/;"	f	class:srgColor
GetHeight	srLib/SceneGraph/Bitmap.cpp	/^int	_Bitmap::GetHeight()$/;"	f	class:_Bitmap
GetHeight	srLib/srg/srgBitmap.cpp	/^int	_Bitmap::GetHeight()$/;"	f	class:_Bitmap
GetHeightOfScene	srLib/srg/srgCamera.cpp	/^float srgCamera::GetHeightOfScene( SE3 se3LocalFrame )$/;"	f	class:srgCamera
GetHeightOfScene	srLib/srg/srgCamera.cpp	/^float srgCamera::GetHeightOfScene( void )$/;"	f	class:srgCamera
GetInertiaRef	srLib/srDyn/srLink.cpp	/^Inertia& srLink::GetInertiaRef()$/;"	f	class:srLink
GetInformation	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::GetInformation(ConstraintInfo * info)$/;"	f	class:ClosedLoop
GetInformation	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::GetInformation(ConstraintInfo * info)$/;"	f	class:ContactConstraint
GetInformation	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::GetInformation(ConstraintInfo * info)$/;"	f	class:JointConstraint
GetInitialTime	srMath/LinearIntegrator.h	/^		double			GetInitialTime() const { return _t0; }$/;"	f	class:srMath::LinearIntegrator
GetLeftEnd	srLib/srDyn/srSpring.cpp	/^Vec3 srSpring::GetLeftEnd()$/;"	f	class:srSpring
GetLeftLink	srLib/srDyn/srSpring.cpp	/^srLink* srSpring::GetLeftLink()$/;"	f	class:srSpring
GetLength	srLib/srDyn/srLinearSpring.cpp	/^SR_REAL& srLinearSpring::GetLength()$/;"	f	class:srLinearSpring
GetLineNum	tinyxml2/tinyxml2.h	/^    int GetLineNum() const { return _parseLineNum; }$/;"	f	class:tinyxml2::XMLAttribute
GetLineNum	tinyxml2/tinyxml2.h	/^    int GetLineNum() const { return _parseLineNum; }$/;"	f	class:tinyxml2::XMLNode
GetLinearAcc	srLib/srDyn/srLink.cpp	/^Vec3 srLink::GetLinearAcc(Vec3 p)$/;"	f	class:srLink
GetLinearVel	srLib/srDyn/srLink.cpp	/^Vec3 srLink::GetLinearVel(Vec3 p)$/;"	f	class:srLink
GetLocalFrame	srLib/srDyn/srCollision.cpp	/^SE3& srCollision::GetLocalFrame()$/;"	f	class:srCollision
GetLocalFrame	srLib/srDyn/srGeometryInfo.cpp	/^SE3& srGeometryInfo::GetLocalFrame()$/;"	f	class:srGeometryInfo
GetLocalFrame	srLib/srDyn/srSensor.cpp	/^SE3& srSensor::GetLocalFrame()$/;"	f	class:srSensor
GetMass	srLib/srDyn/srLink.cpp	/^SR_REAL srLink::GetMass()$/;"	f	class:srLink
GetMassCenter	srLib/srDyn/srLink.cpp	/^Vec3 srLink::GetMassCenter()$/;"	f	class:srLink
GetMaxRPM	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetMaxRPM() const$/;"	f	class:srExtRevoluteJoint
GetMaxRange	srLib/srDyn/srIRSensor.cpp	/^SR_REAL srIRSensor::GetMaxRange()$/;"	f	class:srIRSensor
GetMaxRange	srLib/srDyn/srRangeFinder.cpp	/^SR_REAL srRangeFinder::GetMaxRange()$/;"	f	class:srRangeFinder
GetMinRange	srLib/srDyn/srIRSensor.cpp	/^SR_REAL srIRSensor::GetMinRange()$/;"	f	class:srIRSensor
GetMinRange	srLib/srDyn/srRangeFinder.cpp	/^SR_REAL srRangeFinder::GetMinRange()$/;"	f	class:srRangeFinder
GetName	srLib/srDyn/srObject.cpp	/^char* srObject::GetName()$/;"	f	class:srObject
GetName	srLib/srDyn/srObject.cpp	/^std::wstring& srObject::GetName()$/;"	f	class:srObject
GetNear	srLib/srg/srgCamera.cpp	/^double srgCamera::GetNear() const$/;"	f	class:srgCamera
GetNumSpots	srLib/srDyn/srRangeFinder.cpp	/^int srRangeFinder::GetNumSpots()$/;"	f	class:srRangeFinder
GetNumberOfPoints	srMath/LinearIntegrator.h	/^		int				GetNumberOfPoints() const { return _N; }$/;"	f	class:srMath::LinearIntegrator
GetOffset	srLib/srDyn/srLink.cpp	/^Vec3 srLink::GetOffset()$/;"	f	class:srLink
GetOffset	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetOffset()$/;"	f	class:srPrismaticJoint
GetOffset	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetOffset()$/;"	f	class:srRevoluteJoint
GetOffset	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetOffset(int idx)$/;"	f	class:srUniversalJoint
GetOrientation	srLib/srDyn/srEntity.cpp	/^SO3& srEntity::GetOrientation()$/;"	f	class:srEntity
GetParentLinkFrame	srLib/srDyn/srJoint.cpp	/^SE3& srJoint::GetParentLinkFrame()$/;"	f	class:srJoint
GetPoints	srMath/LinearIntegrator.h	/^		const VectorX&	GetPoints() const { return _t; }$/;"	f	class:srMath::LinearIntegrator
GetPosition	Example/MobileRobots/MobileRobots.h	/^	Vec3		GetPosition() {$/;"	f	class:MobileRobot
GetPosition	srLib/srDyn/srEntity.cpp	/^Vec3& srEntity::GetPosition()$/;"	f	class:srEntity
GetPositionLowerLimit	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetPositionLowerLimit()$/;"	f	class:srPrismaticJoint
GetPositionLowerLimit	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetPositionLowerLimit()$/;"	f	class:srRevoluteJoint
GetPositionLowerLimit	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetPositionLowerLimit(int idx \/*= 0*\/)$/;"	f	class:srUniversalJoint
GetPositionUpperLimit	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetPositionUpperLimit()$/;"	f	class:srPrismaticJoint
GetPositionUpperLimit	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetPositionUpperLimit()$/;"	f	class:srRevoluteJoint
GetPositionUpperLimit	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetPositionUpperLimit(int idx \/*= 0*\/)$/;"	f	class:srUniversalJoint
GetPrismaticJointState	srLib/srDyn/srPrismaticJoint.cpp	/^srPrismaticState& srPrismaticJoint::GetPrismaticJointState()$/;"	f	class:srPrismaticJoint
GetProjMat	srLib/srg/srgCamera.cpp	/^SE3 srgCamera::GetProjMat() const$/;"	f	class:srgCamera
GetProjectionMode	srLib/srg/srgCamera.cpp	/^srgCamera::ProjectionType srgCamera::GetProjectionMode() const$/;"	f	class:srgCamera
GetRGBA	srLib/srg/srgColor.cpp	/^const float* const srgColor::GetRGBA(void)	{return m_RGBA;};$/;"	f	class:srgColor
GetRange	srLib/srDyn/srTouchSensor.cpp	/^SR_REAL srTouchSensor::GetRange()$/;"	f	class:srTouchSensor
GetRed	srLib/srg/srgColor.cpp	/^float srgColor::GetRed(void)		{return m_RGBA[0];};$/;"	f	class:srgColor
GetRelVelocity	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::GetRelVelocity(SR_REAL * sjari)$/;"	f	class:ContactConstraint
GetResistance	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetResistance() const$/;"	f	class:srExtRevoluteJoint
GetResolution	srLib/srDyn/srRangeFinder.cpp	/^SR_REAL srRangeFinder::GetResolution()$/;"	f	class:srRangeFinder
GetRestitution	srLib/srDyn/srLink.cpp	/^SR_REAL srLink::GetRestitution()$/;"	f	class:srLink
GetRevoluteJointState	srLib/srDyn/srRevoluteJoint.cpp	/^srRevoluteState& srRevoluteJoint::GetRevoluteJointState()$/;"	f	class:srRevoluteJoint
GetRightEnd	srLib/srDyn/srSpring.cpp	/^Vec3 srSpring::GetRightEnd()$/;"	f	class:srSpring
GetRightLink	srLib/srDyn/srSpring.cpp	/^srLink* srSpring::GetRightLink()$/;"	f	class:srSpring
GetRotorInertia	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetRotorInertia() const$/;"	f	class:srExtRevoluteJoint
GetShape	srLib/srDyn/srGeometryInfo.cpp	/^srGeometryInfo::SHAPETYPE srGeometryInfo::GetShape()$/;"	f	class:srGeometryInfo
GetShininess	srLib/srg/srgColor.cpp	/^float	srgMaterialColor::GetShininess(void)$/;"	f	class:srgMaterialColor
GetSimulationTime	srLib/srDyn/srSpace.cpp	/^const SR_REAL srSpace::GetSimulationTime() const$/;"	f	class:srSpace
GetSpecular	srLib/srg/srgColor.cpp	/^const float* const	srgMaterialColor::GetSpecular(void)$/;"	f	class:srgMaterialColor
GetSpread	srLib/srDyn/srRangeFinder.cpp	/^int srRangeFinder::GetSpread()$/;"	f	class:srRangeFinder
GetSpringCoeff	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetSpringCoeff()$/;"	f	class:srPrismaticJoint
GetSpringCoeff	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetSpringCoeff()$/;"	f	class:srRevoluteJoint
GetSpringCoeff	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetSpringCoeff(int idx)$/;"	f	class:srUniversalJoint
GetStatePtr	srLib/srDyn/srBallJoint.cpp	/^srState* srBallJoint::GetStatePtr()$/;"	f	class:srBallJoint
GetStatePtr	srLib/srDyn/srPrismaticJoint.cpp	/^srState* srPrismaticJoint::GetStatePtr()$/;"	f	class:srPrismaticJoint
GetStatePtr	srLib/srDyn/srRevoluteJoint.cpp	/^srState* srRevoluteJoint::GetStatePtr()$/;"	f	class:srRevoluteJoint
GetStatePtr	srLib/srDyn/srUniversalJoint.cpp	/^srState* srUniversalJoint::GetStatePtr()$/;"	f	class:srUniversalJoint
GetStatePtr	srLib/srDyn/srWeldJoint.cpp	/^srState* srWeldJoint::GetStatePtr()$/;"	f	class:srWeldJoint
GetStr	tinyxml2/tinyxml2.cpp	/^const char* StrPair::GetStr()$/;"	f	class:tinyxml2::StrPair
GetText	tinyxml2/tinyxml2.cpp	/^const char* XMLElement::GetText() const$/;"	f	class:tinyxml2::XMLElement
GetTorqueConstant	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetTorqueConstant() const$/;"	f	class:srExtRevoluteJoint
GetTorqueLowerLimit	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetTorqueLowerLimit()$/;"	f	class:srPrismaticJoint
GetTorqueLowerLimit	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetTorqueLowerLimit()$/;"	f	class:srRevoluteJoint
GetTorqueLowerLimit	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetTorqueLowerLimit(int idx \/*= 0*\/)$/;"	f	class:srUniversalJoint
GetTorqueUpperLimit	srLib/srDyn/srPrismaticJoint.cpp	/^SR_REAL srPrismaticJoint::GetTorqueUpperLimit()$/;"	f	class:srPrismaticJoint
GetTorqueUpperLimit	srLib/srDyn/srRevoluteJoint.cpp	/^SR_REAL srRevoluteJoint::GetTorqueUpperLimit()$/;"	f	class:srRevoluteJoint
GetTorqueUpperLimit	srLib/srDyn/srUniversalJoint.cpp	/^SR_REAL srUniversalJoint::GetTorqueUpperLimit(int idx \/*= 0*\/)$/;"	f	class:srUniversalJoint
GetTotalNumObj	srLib/srDyn/srObject.cpp	/^unsigned int srObject::GetTotalNumObj()$/;"	f	class:srObject
GetTransp	srLib/srg/srgColor.cpp	/^float srgMaterialColor::GetTransp(void)$/;"	f	class:srgMaterialColor
GetType	srLib/srDyn/srJoint.cpp	/^srJoint::JOINTTYPE srJoint::GetType()$/;"	f	class:srJoint
GetUniversalJointState	srLib/srDyn/srUniversalJoint.cpp	/^srUniversalState& srUniversalJoint::GetUniversalJointState()$/;"	f	class:srUniversalJoint
GetUp	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetUp( const SE3& _CameraFrame )$/;"	f	class:srgCamera
GetUp	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetUp( void )$/;"	f	class:srgCamera
GetUserData	tinyxml2/tinyxml2.h	/^	void* GetUserData() const			{ return _userData; }$/;"	f	class:tinyxml2::XMLNode
GetVel	srLib/srDyn/srLink.cpp	/^const se3& srLink::GetVel()$/;"	f	class:srLink
GetVelocityLowerLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	GetVelocityLowerLimit()$/;"	f	class:srExtRevoluteJoint
GetVelocityUpperLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	GetVelocityUpperLimit()$/;"	f	class:srExtRevoluteJoint
GetViewDirection	srLib/srg/srgCamera.cpp	/^srgCamera::ViewDirection srgCamera::GetViewDirection() const$/;"	f	class:srgCamera
GetViscousCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	const SR_REAL	GetViscousCoeff() const$/;"	f	class:srExtRevoluteJoint
GetWeights	srMath/LinearIntegrator.h	/^		const VectorX&	GetWeights() const { return _w; }$/;"	f	class:srMath::LinearIntegrator
GetWidth	srLib/SceneGraph/Bitmap.cpp	/^int	_Bitmap::GetWidth()$/;"	f	class:_Bitmap
GetWidth	srLib/srg/srgBitmap.cpp	/^int	_Bitmap::GetWidth()$/;"	f	class:_Bitmap
GetXAxis	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetXAxis( void )$/;"	f	class:srgCamera
GetYAxis	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetYAxis( void )$/;"	f	class:srgCamera
GetZAxis	srLib/srg/srgCamera.cpp	/^Vec3 srgCamera::GetZAxis( void )$/;"	f	class:srgCamera
GetZMP	srLib/srDyn/srSystem.cpp	/^Vec3& srSystem::GetZMP()$/;"	f	class:srSystem
GlobalLU_t	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef LU_GlobalLU_t<IndexVector, ScalarVector> GlobalLU_t; $/;"	t	class:Eigen::internal::SparseLUImpl
Grid	srLib/SceneGraph/Leaf.cpp	/^Grid::Grid()$/;"	f	class:Grid
Grid	srLib/SceneGraph/Leaf.cpp	/^Grid::Grid(double range, double step \/*= 10*\/)$/;"	f	class:Grid
Grid	srLib/SceneGraph/Leaf.h	/^class Grid : public Leaf$/;"	c
Ground	Example/DracoP1/Ground.h	/^    Ground(): m_Ground(NULL), m_Plane(NULL) {};$/;"	f	class:Ground
Ground	Example/DracoP1/Ground.h	/^class Ground : public srSystem$/;"	c
Ground	Example/MobileRobots/Ground.h	/^				 Ground(): m_Ground(NULL), m_Plane(NULL) {};$/;"	f	class:Ground
Ground	Example/MobileRobots/Ground.h	/^class Ground : public srSystem$/;"	c
Group	srLib/SceneGraph/Group.cpp	/^Group::Group( SE3 trasform, double scale )$/;"	f	class:Group
Group	srLib/SceneGraph/Group.h	/^class Group :  public Node, public Transformation$/;"	c
HCoeffsType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::ColPivHouseholderQR
HCoeffsType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::FullPivHouseholderQR
HCoeffsType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
HCoeffsType	Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_diag_type<MatrixType>::type HCoeffsType;$/;"	t	class:Eigen::HouseholderQR
HDim	Eigen/src/Eigen2Support/Geometry/Transform.h	/^    HDim = _Dim+1   \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon404
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = Transform::HDim,$/;"	e	enum:Eigen::internal::transform_traits::__anon450
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon454
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = TransformType::HDim,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon455
HDim	Eigen/src/Geometry/Transform.h	/^    HDim = _Dim+1,  \/\/\/< size of a respective homogeneous vector$/;"	e	enum:Eigen::Transform::__anon451
HEX	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#define HEX(/;"	d	file:
HEX	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define HEX(/;"	d	file:
HIER_FATHER	srLib/SceneGraph/Model3DS.cpp	/^   #define HIER_FATHER	/;"	d	file:
HIER_POS	srLib/SceneGraph/Model3DS.cpp	/^   #define HIER_POS	/;"	d	file:
HNormalizedReturnType	Eigen/src/Core/MatrixBase.h	/^                const ConstStartMinusOne > HNormalizedReturnType;$/;"	t	class:Eigen::MatrixBase
HNormalizedReturnType	Eigen/src/Core/VectorwiseOp.h	/^            HNormalizedReturnType;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Block	Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Block;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Factors	Eigen/src/Core/VectorwiseOp.h	/^            HNormalized_Factors;$/;"	t	class:Eigen::VectorwiseOp
HNormalized_Size	Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_Size = Direction==Vertical ? internal::traits<ExpressionType>::RowsAtCompileTime$/;"	e	enum:Eigen::VectorwiseOp::__anon317
HNormalized_SizeMinusOne	Eigen/src/Core/VectorwiseOp.h	/^      HNormalized_SizeMinusOne = HNormalized_Size==Dynamic ? Dynamic : HNormalized_Size-1$/;"	e	enum:Eigen::VectorwiseOp::__anon317
HYBRID	srLib/srDyn/srJoint.h	/^	enum ACTTYPE { PASSIVE, TORQUE, VELOCITY, HYBRID };$/;"	e	enum:srJoint::ACTTYPE
HalfDepth	srLib/SceneGraph/Leaf.h	/^	double HalfDepth;$/;"	m	class:Box
HalfHeight	srLib/SceneGraph/Leaf.h	/^	double HalfHeight;$/;"	m	class:Box
HalfLength	Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon332
HalfLength	Eigen/src/Core/Redux.h	/^    HalfLength = Length\/2$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon334
HalfSphere	srLib/SceneGraph/Leaf.cpp	/^HalfSphere::HalfSphere(double radius, bool bUpper)$/;"	f	class:HalfSphere
HalfSphere	srLib/SceneGraph/Leaf.h	/^class HalfSphere : public DomeBase$/;"	c
HalfWidth	srLib/SceneGraph/Leaf.h	/^	double HalfWidth;$/;"	m	class:Box
HasACos	Eigen/src/Core/GenericPacketMath.h	/^    HasACos   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasASin	Eigen/src/Core/GenericPacketMath.h	/^    HasASin   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasATan	Eigen/src/Core/GenericPacketMath.h	/^    HasATan   = 0$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasAbs	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasAbs	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasAbs	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasAbs	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasAbs	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasAbs	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasAbs2	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasAbs2	Eigen/src/Core/GenericPacketMath.h	/^    HasAbs2   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasAbs2	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasAbs2	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasAbs2	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasAbs2	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAbs2   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasAdd	Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasAdd	Eigen/src/Core/GenericPacketMath.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasAdd	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasAdd	Eigen/src/Core/arch/NEON/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasAdd	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasAdd	Eigen/src/Core/arch/SSE/Complex.h	/^    HasAdd    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasBOM	tinyxml2/tinyxml2.h	/^    bool HasBOM() const {$/;"	f	class:tinyxml2::XMLDocument
HasConj	Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasConj	Eigen/src/Core/GenericPacketMath.h	/^    HasConj   = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasCos	Eigen/src/Core/GenericPacketMath.h	/^    HasCos    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasCos	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasCos	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasCos  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
HasCos	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasCos  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
HasDirectAccess	Eigen/src/Core/Ref.h	/^      HasDirectAccess = internal::has_direct_access<Derived>::ret,$/;"	e	enum:Eigen::internal::traits::match::__anon323
HasDiv	Eigen/src/Core/GenericPacketMath.h	/^    HasDiv    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasDiv	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasDiv	Eigen/src/Core/arch/NEON/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasDiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
HasDiv	Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasDiv	Eigen/src/Core/arch/SSE/Complex.h	/^    HasDiv    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasDiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
HasDiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasDiv  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon248
HasExp	Eigen/src/Core/GenericPacketMath.h	/^    HasExp    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasExp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasExp	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasExp  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
HasExp	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
HasExp	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasExp  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon248
HasLog	Eigen/src/Core/GenericPacketMath.h	/^    HasLog    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasLog	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasLog	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasLog  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
HasLog	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasLog  = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
HasMax	Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasMax	Eigen/src/Core/GenericPacketMath.h	/^    HasMax    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasMax	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasMax	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasMax	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasMax	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMax    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasMin	Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasMin	Eigen/src/Core/GenericPacketMath.h	/^    HasMin    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasMin	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasMin	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasMin	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasMin	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMin    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasMul	Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasMul	Eigen/src/Core/GenericPacketMath.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasMul	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasMul	Eigen/src/Core/arch/NEON/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasMul	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasMul	Eigen/src/Core/arch/SSE/Complex.h	/^    HasMul    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasNegate	Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasNegate	Eigen/src/Core/GenericPacketMath.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasNegate	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasNegate	Eigen/src/Core/arch/NEON/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasNegate	Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasNegate	Eigen/src/Core/arch/SSE/Complex.h	/^    HasNegate = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasNoInnerStride	Eigen/src/Core/Map.h	/^    HasNoInnerStride = InnerStrideAtCompileTime == 1,$/;"	e	enum:Eigen::internal::traits::__anon204
HasNoOuterStride	Eigen/src/Core/Map.h	/^    HasNoOuterStride = StrideType::OuterStrideAtCompileTime == 0,$/;"	e	enum:Eigen::internal::traits::__anon204
HasNoStride	Eigen/src/Core/Map.h	/^    HasNoStride = HasNoInnerStride && HasNoOuterStride,$/;"	e	enum:Eigen::internal::traits::__anon204
HasPow	Eigen/src/Core/GenericPacketMath.h	/^    HasPow    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasSameStorageOrderAsXprType	Eigen/src/Core/Block.h	/^    HasSameStorageOrderAsXprType = (IsRowMajor == XprTypeIsRowMajor),$/;"	e	enum:Eigen::internal::traits::__anon273
HasSetLinear	Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasSetLinear	Eigen/src/Core/GenericPacketMath.h	/^    HasSetLinear = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasSetLinear	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasSetLinear	Eigen/src/Core/arch/NEON/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasSetLinear	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasSetLinear	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSetLinear = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasSin	Eigen/src/Core/GenericPacketMath.h	/^    HasSin    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasSin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasSin	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSin  = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
HasSin	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSin  = EIGEN_FAST_MATH,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
HasSqrt	Eigen/src/Core/GenericPacketMath.h	/^    HasSqrt   = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasSqrt	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon263
HasSqrt	Eigen/src/Core/arch/NEON/PacketMath.h	/^    HasSqrt = 0$/;"	e	enum:Eigen::internal::packet_traits::__anon257
HasSqrt	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon247
HasSqrt	Eigen/src/Core/arch/SSE/PacketMath.h	/^    HasSqrt = 1$/;"	e	enum:Eigen::internal::packet_traits::__anon248
HasSub	Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon226
HasSub	Eigen/src/Core/GenericPacketMath.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasSub	Eigen/src/Core/arch/AltiVec/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
HasSub	Eigen/src/Core/arch/NEON/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
HasSub	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
HasSub	Eigen/src/Core/arch/SSE/Complex.h	/^    HasSub    = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
HasTan	Eigen/src/Core/GenericPacketMath.h	/^    HasTan    = 0,$/;"	e	enum:Eigen::internal::default_packet_traits::__anon224
HasTexture	srLib/srg/srgGeometryDraw.h	/^	bool				HasTexture;$/;"	m	struct:QuadricState
HasUnitDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon126
HasUnitDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasUnitDiag = (Mode & UnitDiag)==UnitDiag,$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon127
HasUnitDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^           HasUnitDiag = (Mode&UnitDiag) ? 1 : 0$/;"	e	enum:Eigen::SparseTriangularView::__anon371
HasUsableDirectAccess	Eigen/src/Core/util/BlasUtil.h	/^    HasUsableDirectAccess = (    (int(XprType::Flags)&DirectAccessBit)$/;"	e	enum:Eigen::internal::blas_traits::__anon140
HasZeroDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon126
HasZeroDiag	Eigen/src/Core/products/TriangularMatrixVector.h	/^    HasZeroDiag = (Mode & ZeroDiag)==ZeroDiag$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon127
HereditaryBits	Eigen/src/Core/util/Constants.h	/^const unsigned int HereditaryBits = RowMajorBit$/;"	m	namespace:Eigen
HessenbergDecomposition	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
HessenbergDecomposition	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename _MatrixType> class HessenbergDecomposition$/;"	c	namespace:Eigen
HessenbergDecompositionMatrixHReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecompositionMatrixHReturnType(const HessenbergDecomposition<MatrixType>& hess) : m_hess(hess) { }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
HessenbergDecompositionMatrixHReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^template<typename MatrixType> struct HessenbergDecompositionMatrixHReturnType$/;"	s	namespace:Eigen::internal
Hessian	srMath/Function.cpp	/^	std::vector< MatrixX > AugmentedFunction::Hessian(const VectorX& x) const$/;"	f	class:srMath::AugmentedFunction
Hessian	srMath/Function.cpp	/^	std::vector<MatrixX> AffineFunction::Hessian(const VectorX & x) const$/;"	f	class:srMath::AffineFunction
Hessian	srMath/Function.cpp	/^	std::vector<MatrixX> Function::Hessian(const VectorX & x) const$/;"	f	class:srMath::Function
Hessian	srMath/Function.cpp	/^	std::vector<MatrixX> MultiplyConstFunction::Hessian(const VectorX & x) const$/;"	f	class:srMath::MultiplyConstFunction
Hessian	srMath/Function.cpp	/^	std::vector<MatrixX> QuadraticFunction::Hessian(const VectorX & x) const$/;"	f	class:srMath::QuadraticFunction
Hessian	srMath/Function.h	/^		std::vector< MatrixX > Hessian(const VectorX& x) const { return std::vector< MatrixX >(0); }$/;"	f	class:srMath::EmptyFunction
HomeRelativeFrame	srLib/srDyn/srClosedLoopConstraint.h	/^	SE3		HomeRelativeFrame;$/;"	m	class:ClosedLoop
Homogeneous	Eigen/src/Geometry/Homogeneous.h	/^    inline Homogeneous(const MatrixType& matrix)$/;"	f	class:Eigen::Homogeneous
Homogeneous	Eigen/src/Geometry/Homogeneous.h	/^template<typename MatrixType,int _Direction> class Homogeneous$/;"	c	namespace:Eigen
HomogeneousDimension	Eigen/src/Geometry/Umeyama.h	/^    HomogeneousDimension = int(MinRowsAtCompileTime) == Dynamic ? Dynamic : int(MinRowsAtCompileTime)+1$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon447
HomogeneousReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef Homogeneous<Derived, HomogeneousReturnTypeDirection> HomogeneousReturnType;$/;"	t	class:Eigen::MatrixBase
HomogeneousReturnTypeDirection	Eigen/src/Core/MatrixBase.h	/^    enum { HomogeneousReturnTypeDirection = ColsAtCompileTime==1?Vertical:Horizontal };$/;"	e	enum:Eigen::MatrixBase::__anon201
Horizontal	Eigen/src/Core/util/Constants.h	/^  Horizontal, $/;"	e	enum:Eigen::DirectionType
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR() : m_qr(), m_hCoeffs(), m_temp(), m_isInitialized(false) {}$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(Index rows, Index cols)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^    HouseholderQR(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR
HouseholderQR	Eigen/src/QR/HouseholderQR.h	/^template<typename _MatrixType> class HouseholderQR$/;"	c	namespace:Eigen
HouseholderQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  HouseholderQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
HouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const HouseholderSequence& other)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	class:Eigen::HouseholderSequence
HouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^template<typename VectorsType, typename CoeffsType, int Side> class HouseholderSequence$/;"	c	namespace:Eigen
HouseholderSequenceType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HessenbergDecomposition
HouseholderSequenceType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename CoeffVectorType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::Tridiagonalization
HouseholderSequenceType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename Tridiagonalization<MatrixType>::HouseholderSequenceType HouseholderSequenceType;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
HouseholderSequenceType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheLeft> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	Eigen/src/Householder/HouseholderSequence.h	/^  typedef HouseholderSequence<VectorsType, CoeffsType, OnTheRight> HouseholderSequenceType;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
HouseholderSequenceType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::ColPivHouseholderQR
HouseholderSequenceType	Eigen/src/QR/HouseholderQR.h	/^    typedef HouseholderSequence<MatrixType,typename internal::remove_all<typename HCoeffsType::ConjugateReturnType>::type> HouseholderSequenceType;$/;"	t	class:Eigen::HouseholderQR
HouseholderUSequenceType	Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderUSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HouseholderVSequenceType	Eigen/src/SVD/UpperBidiagonalization.h	/^            > HouseholderVSequenceType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
HowAboutThisPoint	srLib/srDyn/srContactConstraint.cpp	/^void			ContactConstraint::HowAboutThisPoint(Vec3& point , Vec3& normal , SR_REAL & penetration)$/;"	f	class:ContactConstraint
Hyperplane	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Hyperplane /;"	d
Hyperplane	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Hyperplane$/;"	d
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, Scalar d)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(int _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  Hyperplane(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  explicit Hyperplane(const ParametrizedLine<Scalar, AmbientDimAtCompileTime>& parametrized)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const Scalar& d)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane(const VectorType& n, const VectorType& e)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(Index _dim) : m_coeffs(_dim+1) {}$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  inline explicit Hyperplane(const Hyperplane<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::Hyperplane
Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^class Hyperplane$/;"	c	namespace:Eigen
ID_VOID_MAIN	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define ID_VOID_MAIN$/;"	d	file:
IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        IMPLICIT_CONVERSION_TO_SCALAR_IS_FOR_INNER_PRODUCT_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
INITIAL_SELFCOLLISIONPAIR_EJECTION	srLib/srDyn/srDYN.h	/^#define	INITIAL_SELFCOLLISIONPAIR_EJECTION	/;"	d
INVALID_MATRIXBASE_TEMPLATE_PARAMETERS	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIXBASE_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
INVALID_MATRIX_PRODUCT	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_PRODUCT__IF_YOU_WANTED_A_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTION,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
INVALID_MATRIX_TEMPLATE_PARAMETERS	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_MATRIX_TEMPLATE_PARAMETERS,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_STORAGE_ORDER_FOR_THIS_VECTOR_EXPRESSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS	Eigen/src/Core/util/StaticAssert.h	/^        INVALID_VECTOR_VECTOR_PRODUCT__IF_YOU_WANTED_A_DOT_OR_COEFF_WISE_PRODUCT_YOU_MUST_USE_THE_EXPLICIT_FUNCTIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
IOFormat	Eigen/src/Core/IO.h	/^  IOFormat(int _precision = StreamPrecision, int _flags = 0,$/;"	f	struct:Eigen::IOFormat
IOFormat	Eigen/src/Core/IO.h	/^struct IOFormat$/;"	s	namespace:Eigen
IRSENSOR	srLib/srDyn/srSensor.h	/^	enum SENSORTYPE { IRSENSOR, RANGEFINDER, TOUCHSENSOR };$/;"	e	enum:srSensor::SENSORTYPE
ISLAND	srLib/srDyn/srISLAND.h	/^class ISLAND$/;"	c
ISLANDArray	srLib/srDyn/srDYN.h	/^typedef _array<ISLAND>				ISLANDArray;$/;"	t
ITEMS_PER_BLOCK	tinyxml2/tinyxml2.h	/^    enum { ITEMS_PER_BLOCK = (4 * 1024) \/ ITEM_SIZE };$/;"	e	enum:tinyxml2::MemPoolT::__anon480
Identify	tinyxml2/tinyxml2.cpp	/^char* XMLDocument::Identify( char* p, XMLNode** node )$/;"	f	class:tinyxml2::XMLDocument
Identity	Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity()$/;"	f	class:Eigen::MatrixBase
Identity	Eigen/src/Core/CwiseNullaryOp.h	/^MatrixBase<Derived>::Identity(Index nbRows, Index nbCols)$/;"	f	class:Eigen::MatrixBase
Identity	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline Quaternion Identity() { return Quaternion(1, 0, 0, 0); }$/;"	f	class:Eigen::Quaternion
Identity	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static const typename MatrixType::IdentityReturnType Identity()$/;"	f	class:Eigen::Transform
Identity	Eigen/src/Geometry/AngleAxis.h	/^  static inline const AngleAxis Identity() { return AngleAxis(Scalar(0), Vector3::UnitX()); }$/;"	f	class:Eigen::AngleAxis
Identity	Eigen/src/Geometry/Quaternion.h	/^  static inline Quaternion<Scalar> Identity() { return Quaternion<Scalar>(Scalar(1), Scalar(0), Scalar(0), Scalar(0)); }$/;"	f	class:Eigen::QuaternionBase
Identity	Eigen/src/Geometry/Rotation2D.h	/^  static inline Rotation2D Identity() { return Rotation2D(0); }$/;"	f	class:Eigen::Rotation2D
Identity	Eigen/src/Geometry/Transform.h	/^  static const Transform Identity()$/;"	f	class:Eigen::Transform
Identity	Eigen/src/Geometry/Translation.h	/^  static const Translation Identity() { return Translation(VectorType::Zero()); }$/;"	f	class:Eigen::Translation
IdentityPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner() {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner(const MatrixType& ) {}$/;"	f	class:Eigen::IdentityPreconditioner
IdentityPreconditioner	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^class IdentityPreconditioner$/;"	c	namespace:Eigen
IdentityReturnType	Eigen/src/Core/MatrixBase.h	/^    typedef CwiseNullaryOp<internal::scalar_identity_op<Scalar>,Derived> IdentityReturnType;$/;"	t	class:Eigen::MatrixBase
ImagReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_imag_op<Scalar>, const Derived> ImagReturnType;$/;"	t
ImageResultType	Eigen/src/Eigen2Support/LU.h	/^    > ImageResultType;$/;"	t	class:Eigen::LU
Impl	Eigen/src/Core/Block.h	/^    typedef BlockImpl<XprType, BlockRows, BlockCols, InnerPanel, typename internal::traits<XprType>::StorageKind> Impl;$/;"	t	class:Eigen::Block
Impl	Eigen/src/Core/Block.h	/^    typedef internal::BlockImpl_dense<XprType, BlockRows, BlockCols, InnerPanel> Impl;$/;"	t	class:Eigen::BlockImpl
IncompleteLUT	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT()$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT(const MatrixType& mat, const RealScalar& droptol=NumTraits<Scalar>::dummy_precision(), int fillfactor = 10)$/;"	f	class:Eigen::IncompleteLUT
IncompleteLUT	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^class IncompleteLUT : internal::noncopyable$/;"	c	namespace:Eigen
Indefinite	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Index	Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LDLT
Index	Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::LLT
Index	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::CholmodBase
Index	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::ArrayBase
Index	Eigen/src/Core/Assign.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::assign_impl
Index	Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::vml_assign_impl
Index	Eigen/src/Core/BandMatrix.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::internal::TridiagonalMatrix
Index	Eigen/src/Core/BandMatrix.h	/^    typedef typename DenseMatrixType::Index Index;$/;"	t	class:Eigen::internal::BandMatrixBase
Index	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Index Index;$/;"	t	class:Eigen::internal::BandMatrix
Index	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Index Index;$/;"	t	class:Eigen::internal::BandMatrixWrapper
Index	Eigen/src/Core/BandMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/Block.h	/^    typedef typename XprType::Index Index;$/;"	t	class:Eigen::BlockImpl
Index	Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Index Index;$/;"	t	struct:Eigen::CommaInitializer
Index	Eigen/src/Core/CoreIterators.h	/^    typedef typename Derived::Index Index;$/;"	t	class:Eigen::DenseBase::InnerIterator
Index	Eigen/src/Core/CwiseBinaryOp.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/CwiseNullaryOp.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::setIdentity_impl
Index	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Index Index; $/;"	t	class:Eigen::DenseBase
Index	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DenseCoeffsBase
Index	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::DiagonalBase
Index	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::Index Index;$/;"	t	class:Eigen::DiagonalMatrix
Index	Eigen/src/Core/DiagonalMatrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::Index Index;$/;"	t	struct:Eigen::EigenBase
Index	Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/MapBase.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::MapBase
Index	Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MapBase
Index	Eigen/src/Core/Matrix.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::MatrixBase
Index	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map
Index	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval
Index	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PermutationBase
Index	Eigen/src/Core/PermutationMatrix.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::PlainObjectBase
Index	Eigen/src/Core/PlainObjectBase.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::conservative_resize_like_impl
Index	Eigen/src/Core/ProductBase.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::redux_impl
Index	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointView
Index	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector
Index	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::triangular_solve_retval
Index	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Index Index;$/;"	t	struct:Eigen::internal::triangular_solver_selector
Index	Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::InnerStride
Index	Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::OuterStride
Index	Eigen/src/Core/Stride.h	/^    typedef DenseIndex Index;$/;"	t	class:Eigen::Stride
Index	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Map
Index	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::Transpositions
Index	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsBase
Index	Eigen/src/Core/Transpositions.h	/^    typedef typename IndicesType::Scalar Index;$/;"	t	class:Eigen::TranspositionsWrapper
Index	Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::Index Index;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval
Index	Eigen/src/Core/Transpositions.h	/^  typedef IndexType Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/Transpositions.h	/^  typedef typename _IndicesType::Scalar Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::TriangularBase
Index	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Index Index;$/;"	t	class:Eigen::TriangularView
Index	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Index Index;$/;"	t	struct:Eigen::internal::triangular_assignment_selector
Index	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Index Index;$/;"	t	class:Eigen::VectorwiseOp
Index	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::coeff_visitor
Index	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::max_coeff_visitor
Index	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::min_coeff_visitor
Index	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::visitor_impl
Index	Eigen/src/Core/products/CoeffBasedProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_impl
Index	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
Index	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_coeff_vectorized_unroller
Index	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::product_packet_impl
Index	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexEigenSolver
Index	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ComplexSchur
Index	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::EigenSolver
Index	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::GeneralizedEigenSolver
Index	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
Index	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HessenbergDecomposition
Index	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
Index	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealQZ
Index	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::RealSchur
Index	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Index	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Index	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::Tridiagonalization
Index	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
Index	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Index	Eigen/src/Geometry/AlignedBox.h	/^  typedef DenseIndex                                Index;$/;"	t	class:Eigen::AlignedBox
Index	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
Index	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl
Index	Eigen/src/Geometry/Hyperplane.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Hyperplane
Index	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename Derived::Index Index;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Index	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::ParametrizedLine
Index	Eigen/src/Geometry/Quaternion.h	/^  typedef DenseIndex Index;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl
Index	Eigen/src/Geometry/Transform.h	/^  typedef DenseIndex Index;$/;"	t	class:Eigen::Transform
Index	Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename VectorsType::Index Index;$/;"	t	class:Eigen::HouseholderSequence
Index	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::hseq_side_dependent_impl
Index	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef typename Vector::Index Index;$/;"	t	class:Eigen::DiagonalPreconditioner
Index	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::BiCGSTAB
Index	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ConjugateGradient
Index	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename FactorType::Index Index;$/;"	t	class:Eigen::IncompleteLUT
Index	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::IterativeSolverBase
Index	Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivLU
Index	Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::inverse_impl
Index	Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PartialPivLU
Index	Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::partial_lu_impl
Index	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixBase
Index	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::PastixLU
Index	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pastix_traits
Index	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef long long int Index;$/;"	t	struct:Eigen::internal::pardiso_run_selector
Index	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLDLT
Index	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::PardisoLLT
Index	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Index Index;$/;"	t	class:Eigen::PardisoImpl
Index	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;    $/;"	t	struct:Eigen::internal::pardiso_traits
Index	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Index Index;$/;"	t	struct:Eigen::internal::pardiso_traits
Index	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::ColPivHouseholderQR
Index	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::FullPivHouseholderQR
Index	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
Index	Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::HouseholderQR
Index	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SuiteSparse_long Index ;$/;"	t	class:Eigen::SPQR
Index	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Index Index;$/;"	t	struct:Eigen::SPQR_QProduct
Index	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::JacobiSVD
Index	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Index	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename SVD::Index Index;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
Index	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Index	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholesky
Index	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialCholeskyBase
Index	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLDLT
Index	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SimplicialLLT
Index	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                              Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Index                          Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::AmbiVector
Index	Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::CompressedStorage
Index	Eigen/src/SparseCore/SparseBlock.h	/^        typedef typename BlockImpl::Index Index;$/;"	t	class:Eigen::BlockImpl::InnerIterator
Index	Eigen/src/SparseCore/SparseBlock.h	/^        typedef typename BlockImpl::Index Index;$/;"	t	class:Eigen::BlockImpl::ReverseInnerIterator
Index	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename BlockType::Index Index;$/;"	t	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
Index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::CwiseBinaryOpImpl::InnerIterator
Index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Index	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename SparseDenseOuterProduct::Index Index;$/;"	t	class:Eigen::SparseDenseOuterProduct::InnerIterator
Index	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
Index	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Index Index;$/;"	t	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
Index	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index Index;$/;"	t	class:Eigen::SparseMatrixBase
Index	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval
Index	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseProduct.h	/^                                         typename traits<_RhsNested>::Index>::type Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Index Index;$/;"	t	struct:Eigen::SparseSparseProductReturnType
Index	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSelfAdjointView
Index	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
Index	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename TransposeImpl::Index Index;$/;"	t	class:Eigen::TransposeImpl::InnerIterator
Index	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename TransposeImpl::Index Index;$/;"	t	class:Eigen::TransposeImpl::ReverseInnerIterator
Index	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename SparseTriangularView::Index Index;$/;"	t	class:Eigen::SparseTriangularView::InnerIterator
Index	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename SparseTriangularView::Index Index;$/;"	t	class:Eigen::SparseTriangularView::ReverseInnerIterator
Index	Eigen/src/SparseCore/SparseVector.h	/^  typedef _Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseCore/SparseView.h	/^  typedef typename SparseView::Index Index;$/;"	t	class:Eigen::SparseView::InnerIterator
Index	Eigen/src/SparseCore/TriangularSolver.h	/^                                         typename traits<Rhs>::Index>::type Index;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
Index	Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Index Index; $/;"	t	class:Eigen::SparseLU
Index	Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Index Index;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType
Index	Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Index Index;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType
Index	Eigen/src/SparseLU/SparseLU_Structs.h	/^  typedef typename IndexVector::Scalar Index; $/;"	t	struct:Eigen::internal::LU_GlobalLU_t
Index	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Index Index;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
Index	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename IndexVector::Scalar Index;$/;"	t	struct:Eigen::internal::column_dfs_traits
Index	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  typedef typename IndexVector::Scalar Index;$/;"	t	struct:Eigen::internal::panel_dfs_traits
Index	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SparseQR
Index	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::Index Index;$/;"	t	struct:Eigen::internal::traits
Index	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Index Index;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
Index	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Index Index;$/;"	t	struct:Eigen::SparseQR_QProduct
Index	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperILU
Index	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Index Index;$/;"	t	class:Eigen::SuperLU
Index	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::SuperLUBase
Index	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Index Index;$/;"	t	class:Eigen::UmfPackLU
Index	Eigen/src/misc/Image.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::image_retval_base
Index	Eigen/src/misc/Kernel.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::kernel_retval_base
Index	Eigen/src/misc/Solve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_base
Index	Eigen/src/misc/SparseSolve.h	/^  typedef typename Base::Index Index;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
Index	Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::Index Index;$/;"	t	struct:Eigen::internal::solve_retval_with_guess
IndexVector	Eigen/src/MetisSupport/MetisSupport.h	/^  typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::MetisOrdering
IndexVector	Eigen/src/OrderingMethods/Ordering.h	/^    typedef Matrix<Index, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::COLAMDOrdering
IndexVector	Eigen/src/SparseLU/SparseLU.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector;$/;"	t	class:Eigen::SparseLU
IndexVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::SparseLUImpl
IndexVector	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Index,Dynamic,1> IndexVector; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
IndexVector	Eigen/src/SparseQR/SparseQR.h	/^    typedef Matrix<Index, Dynamic, 1> IndexVector;$/;"	t	class:Eigen::SparseQR
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationBase
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationMatrix
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::PermutationWrapper
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^  typedef Map<const Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^  typedef Matrix<IndexType, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/PermutationMatrix.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Map
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::Transpositions
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsBase
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename Traits::IndicesType IndicesType;$/;"	t	class:Eigen::TranspositionsWrapper
IndicesType	Eigen/src/Core/Transpositions.h	/^    typedef typename TranspositionType::IndicesType IndicesType;$/;"	t	class:Eigen::Transpose
IndicesType	Eigen/src/Core/Transpositions.h	/^  typedef Map<const Matrix<Index,SizeAtCompileTime,1,0,MaxSizeAtCompileTime,1>, _PacketAccess> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/Transpositions.h	/^  typedef Matrix<Index, SizeAtCompileTime, 1, 0, MaxSizeAtCompileTime, 1> IndicesType;$/;"	t	struct:Eigen::internal::traits
IndicesType	Eigen/src/Core/Transpositions.h	/^  typedef _IndicesType IndicesType;$/;"	t	struct:Eigen::internal::traits
Inertia	srLib/LieGroup/LieGroup.h	/^class Inertia$/;"	c
Inertia	srMath/Inertia.cpp	/^	Inertia::Inertia(const Matrix3& I, const Real& m)$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.cpp	/^	Inertia::Inertia(const Matrix3& I, const Vector3& p, const Real& m)$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.cpp	/^	Inertia::Inertia(const Matrix6& I)$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.cpp	/^	Inertia::Inertia(const Real& Ixx, const Real& Iyy, const Real& Izz, const Real& m)$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.cpp	/^	Inertia::Inertia(const Vector6& I, const Vector3& p, const Real& m)$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.h	/^		Inertia() : Matrix6(Matrix6::Identity()) {}$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.h	/^		Inertia(const Inertia& I) : Matrix6(I) {}$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.h	/^		Inertia(const Real m) : Matrix6(Matrix6::Identity() * m) {}$/;"	f	class:srMath::Inertia
Inertia	srMath/Inertia.h	/^	class Inertia : public Matrix6$/;"	c	namespace:srMath
Infinity	Eigen/src/Core/util/Constants.h	/^const int Infinity = -1;$/;"	m	namespace:Eigen
Initial	Example/DracoP1/simulation_draco.cpp	/^void Initial()$/;"	f
Initialize	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::Initialize()$/;"	f	class:srBallJoint
Initialize	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::Initialize()$/;"	f	class:srIRSensor
Initialize	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::Initialize()$/;"	f	class:srLinearSpring
Initialize	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::Initialize()$/;"	f	class:srPrismaticJoint
Initialize	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::Initialize()$/;"	f	class:srRangeFinder
Initialize	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::Initialize()$/;"	f	class:srRevoluteJoint
Initialize	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::Initialize()$/;"	f	class:srTouchSensor
Initialize	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::Initialize()$/;"	f	class:srUniversalJoint
Initialize	srLib/srDyn/srWeldJoint.cpp	/^void srWeldJoint::Initialize()$/;"	f	class:srWeldJoint
InitializeNode	srLib/SceneGraph/srSpaceRenderer.h	/^	void InitializeNode(srSpace* pSapce, double r = 3.0, double phi = 0.5, double theta = 0.5)$/;"	f	class:srSpaceRenderer
InitializeRenderer	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::InitializeRenderer( int argc, char *argv[], NUM_WINDOWS numWindow, bool bSingleBuffer )$/;"	f	class:SceneGraphRenderer
Inner	srLib/srDyn/srCollisionPair.cpp	/^inline SR_REAL Inner (const SR_REAL *a, const SR_REAL *b)$/;"	f
Inner14	srLib/srDyn/srCollisionPair.cpp	/^inline SR_REAL Inner14(const SR_REAL *a, const SR_REAL *b)$/;"	f
Inner41	srLib/srDyn/srCollisionPair.cpp	/^inline SR_REAL Inner41(const SR_REAL *a, const SR_REAL *b)$/;"	f
Inner44	srLib/srDyn/srCollisionPair.cpp	/^inline SR_REAL Inner44(const SR_REAL *a, const SR_REAL *b)$/;"	f
InnerIterator	Eigen/src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator(const Derived& expr, Index outer)$/;"	f	class:Eigen::DenseBase::InnerIterator
InnerIterator	Eigen/src/Core/CoreIterators.h	/^template<typename Derived> class DenseBase<Derived>::InnerIterator$/;"	c	class:Eigen::DenseBase
InnerIterator	Eigen/src/Core/Flagged.h	/^    typedef typename ExpressionType::InnerIterator InnerIterator;$/;"	t	class:Eigen::Flagged
InnerIterator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    InnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
InnerIterator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::InnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
InnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const Block<XprType, BlockRows, BlockCols, true>& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^        inline InnerIterator(const BlockType& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    class InnerIterator: public SparseMatrixType::InnerIterator$/;"	c	class:Eigen::BlockImpl
InnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    class InnerIterator: public XprType::InnerIterator$/;"	c	class:Eigen::BlockImpl
InnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    typedef internal::GenericSparseBlockInnerIteratorImpl<XprType,BlockRows,BlockCols,InnerPanel> InnerIterator;$/;"	t	class:Eigen::BlockImpl
InnerIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseBinaryOpImpl& binOp, typename Lhs::Index outer)$/;"	f	class:Eigen::CwiseBinaryOpImpl::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class CwiseBinaryOpImpl<BinaryOp,Lhs,Rhs,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseBinaryOpImpl
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl
InnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl
InnerIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseDenseOuterProduct& prod, Index outer)$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct<Lhs,Rhs,Transpose>::InnerIterator : public _LhsNested::InnerIterator$/;"	c	class:Eigen::SparseDenseOuterProduct
InnerIterator	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^                      <_LhsNested,_RhsNested,SparseDiagonalProduct,LhsMode,RhsMode> InnerIterator;$/;"	t	class:Eigen::SparseDiagonalProduct
InnerIterator	Eigen/src/SparseCore/SparseMatrix.h	/^    InnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseMatrix
InnerIterator	Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE InnerIterator(const TransposeImpl& trans, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::InnerIterator$/;"	c	class:Eigen::TransposeImpl
InnerIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::InnerIterator : public MatrixTypeNestedCleaned::InnerIterator$/;"	c	class:Eigen::SparseTriangularView
InnerIterator	Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseVector.h	/^    InnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::InnerIterator$/;"	c	class:Eigen::SparseVector
InnerIterator	Eigen/src/SparseCore/SparseView.h	/^  InnerIterator(const SparseView& view, Index outer) :$/;"	f	class:Eigen::SparseView::InnerIterator
InnerIterator	Eigen/src/SparseCore/SparseView.h	/^class SparseView<MatrixType>::InnerIterator : public _MatrixTypeNested::InnerIterator$/;"	c	class:Eigen::SparseView
InnerIterator	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^     InnerIterator(const MappedSuperNodalMatrix& mat, Index outer)$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
InnerIterator	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix<Scalar,Index>::InnerIterator$/;"	c	class:Eigen::internal::MappedSuperNodalMatrix
InnerMaxSize	Eigen/src/Core/Assign.h	/^    InnerMaxSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon24
InnerMaxSize	Eigen/src/Core/Assign_MKL.h	/^      InnerMaxSize  = int(Dst::IsVectorAtCompileTime) ? int(Dst::MaxSizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
InnerMaxSize	Eigen/src/Core/Redux.h	/^    InnerMaxSize = int(Derived::IsRowMajor)$/;"	e	enum:Eigen::internal::redux_traits::__anon327
InnerProduct	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
InnerRandomAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int InnerRandomAccessPattern  = 0x2 | CoherentAccessPattern;$/;"	m	namespace:Eigen
InnerSize	Eigen/src/Core/Assign.h	/^    InnerSize = int(Derived::IsVectorAtCompileTime) ? int(Derived::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::assign_traits::__anon24
InnerSize	Eigen/src/Core/Assign_MKL.h	/^      InnerSize = int(Dst::IsVectorAtCompileTime) ? int(Dst::SizeAtCompileTime)$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
InnerSize	Eigen/src/Core/Block.h	/^    InnerSize = IsRowMajor ? int(ColsAtCompileTime) : int(RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon273
InnerSize	Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize  = internal::traits<CoeffBasedProduct>::InnerSize,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon123
InnerSize	Eigen/src/Core/products/CoeffBasedProduct.h	/^      InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon122
InnerSize	Eigen/src/SparseCore/SparseProduct.h	/^    InnerSize = EIGEN_SIZE_MIN_PREFER_FIXED(_LhsNested::ColsAtCompileTime, _RhsNested::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon390
InnerSizeAtCompileTime	Eigen/src/Core/DenseBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::DenseBase::__anon341
InnerSizeAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      InnerSizeAtCompileTime = int(IsVectorAtCompileTime) ? int(SizeAtCompileTime)$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
InnerStride	Eigen/src/Core/Stride.h	/^    InnerStride() : Base() {}$/;"	f	class:Eigen::InnerStride
InnerStride	Eigen/src/Core/Stride.h	/^    InnerStride(Index v) : Base(0, v) {}$/;"	f	class:Eigen::InnerStride
InnerStride	Eigen/src/Core/Stride.h	/^class InnerStride : public Stride<0, Value>$/;"	c	namespace:Eigen
InnerStrideAtCompileTime	Eigen/src/Core/Block.h	/^    InnerStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon273
InnerStrideAtCompileTime	Eigen/src/Core/CwiseUnaryView.h	/^    InnerStrideAtCompileTime = MatrixTypeInnerStride == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon233
InnerStrideAtCompileTime	Eigen/src/Core/DenseBase.h	/^      InnerStrideAtCompileTime = internal::inner_stride_at_compile_time<Derived>::ret,$/;"	e	enum:Eigen::DenseBase::__anon341
InnerStrideAtCompileTime	Eigen/src/Core/Diagonal.h	/^    InnerStrideAtCompileTime = MatrixTypeOuterStride == Dynamic ? Dynamic : MatrixTypeOuterStride+1,$/;"	e	enum:Eigen::internal::traits::__anon339
InnerStrideAtCompileTime	Eigen/src/Core/Map.h	/^    InnerStrideAtCompileTime = StrideType::InnerStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon204
InnerStrideAtCompileTime	Eigen/src/Core/Matrix.h	/^    InnerStrideAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon221
InnerStrideAtCompileTime	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    InnerStrideAtCompileTime = Lhs::InnerStrideAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon211
InnerStrideAtCompileTime	Eigen/src/Core/Stride.h	/^      InnerStrideAtCompileTime = _InnerStrideAtCompileTime,$/;"	e	enum:Eigen::Stride::__anon203
InnerStrideAtCompileTime	Eigen/src/Core/Transpose.h	/^    InnerStrideAtCompileTime = inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon324
InnerStrideMatch	Eigen/src/Core/Ref.h	/^      InnerStrideMatch = int(StrideType::InnerStrideAtCompileTime)==int(Dynamic)$/;"	e	enum:Eigen::internal::traits::match::__anon323
InnerUnrolling	Eigen/src/Core/util/Constants.h	/^  InnerUnrolling,$/;"	e	enum:Eigen::UnrollingType
InnerVectorReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,IsRowMajor?1:Dynamic,IsRowMajor?Dynamic:1,true>       InnerVectorReturnType;$/;"	t	class:Eigen::SparseMatrixBase
InnerVectorizedTraversal	Eigen/src/Core/util/Constants.h	/^  InnerVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
InnerVectorsReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef Block<Derived,Dynamic,Dynamic,true> InnerVectorsReturnType;$/;"	t	class:Eigen::SparseMatrixBase
InputScalar	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MatrixType::Scalar InputScalar;$/;"	t	struct:Eigen::internal::traits
InsertAfterChild	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLNode::InsertAfterChild( XMLNode* afterThis, XMLNode* addThis )$/;"	f	class:tinyxml2::XMLNode
InsertChildPreamble	tinyxml2/tinyxml2.cpp	/^void XMLNode::InsertChildPreamble( XMLNode* insertThis ) const$/;"	f	class:tinyxml2::XMLNode
InsertContactPointAt	srLib/srDyn/srContactConstraint.cpp	/^inline void ContactConstraint::InsertContactPointAt(Vec3 & point, Vec3 & normal, SR_REAL & penetration, Vec3& localpoint_Left, int insertIdx)$/;"	f	class:ContactConstraint
InsertEndChild	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLNode::InsertEndChild( XMLNode* addThis )$/;"	f	class:tinyxml2::XMLNode
InsertFirstChild	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLNode::InsertFirstChild( XMLNode* addThis )$/;"	f	class:tinyxml2::XMLNode
Inspect_JointState	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::Inspect_JointState()$/;"	f	class:JointConstraint
Int16	srLib/common/types.h	/^typedef	short int			Int16;		\/\/< 2 bytes integer -32768 ~ 32767$/;"	t
Int32	srLib/common/types.h	/^typedef int					Int32;		\/\/< 4 bytes integer -2147483648 ~ 2147483647$/;"	t
Int64Attribute	tinyxml2/tinyxml2.cpp	/^int64_t XMLElement::Int64Attribute(const char* name, int64_t defaultValue) const $/;"	f	class:tinyxml2::XMLElement
Int64Text	tinyxml2/tinyxml2.cpp	/^int64_t XMLElement::Int64Text(int64_t defaultValue) const$/;"	f	class:tinyxml2::XMLElement
Int64Value	tinyxml2/tinyxml2.h	/^	int64_t Int64Value() const {$/;"	f	class:tinyxml2::XMLAttribute
IntAttribute	tinyxml2/tinyxml2.cpp	/^int XMLElement::IntAttribute(const char* name, int defaultValue) const $/;"	f	class:tinyxml2::XMLElement
IntColVectorType	Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1, MatrixType::Options, MatrixType::MaxRowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::LU
IntColVectorType	Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_col_type<MatrixType, Index>::type IntColVectorType;$/;"	t	class:Eigen::FullPivLU
IntColVectorType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::PardisoImpl
IntColVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;    $/;"	t	class:Eigen::SuperLUBase
IntColVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntColVectorType IntColVectorType;    $/;"	t	class:Eigen::SuperLU
IntColVectorType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, MatrixType::RowsAtCompileTime, 1> IntColVectorType;$/;"	t	class:Eigen::UmfPackLU
IntColorChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::IntColorChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
IntDiagSizeVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^                   EIGEN_SIZE_MIN_PREFER_FIXED(MaxColsAtCompileTime,MaxRowsAtCompileTime)> IntDiagSizeVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
IntDiagSizeVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename FullPivHouseholderQR<MatrixType>::IntDiagSizeVectorType IntDiagSizeVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
IntRowVectorType	Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::LU
IntRowVectorType	Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::FullPivLU
IntRowVectorType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Index, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::PardisoImpl
IntRowVectorType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, Index>::type IntRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
IntRowVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::SuperLUBase
IntRowVectorType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::IntRowVectorType IntRowVectorType;$/;"	t	class:Eigen::SuperLU
IntRowVectorType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<int, 1, MatrixType::ColsAtCompileTime> IntRowVectorType;$/;"	t	class:Eigen::UmfPackLU
IntText	tinyxml2/tinyxml2.cpp	/^int XMLElement::IntText(int defaultValue) const$/;"	f	class:tinyxml2::XMLElement
IntValue	tinyxml2/tinyxml2.h	/^	int	IntValue() const {$/;"	f	class:tinyxml2::XMLAttribute
Inv3by3	srLib/srDyn/srCollision.cpp	/^void Inv3by3(SR_REAL* x, SR_REAL* b)	\/\/ x * b = I$/;"	f
Inv3by3_In_BallJoint	srLib/srDyn/srBallJoint.cpp	/^void Inv3by3_In_BallJoint(SR_REAL* x, SR_REAL* b)	\/\/ x * b = I$/;"	f
InvAd	srMath/SE3.cpp	/^	Matrix6 SE3::InvAd(const SE3& T)$/;"	f	class:srMath::SE3
InvAd	srMath/SE3.cpp	/^	se3 SE3::InvAd(const SE3& T, const se3& S)$/;"	f	class:srMath::SE3
InvVec3	srLib/LieGroup/LieGroup.h	/^typedef	Vec3	InvVec3;$/;"	t
Inv_PI_DOUBLE	srMath/Constant.h	/^	static const Real	Inv_PI_DOUBLE = 0.15915494309189533576901767873386;	\/\/\/< \\frac{1}{\\pi*2}$/;"	m	namespace:srMath
InvalidInput	Eigen/src/Core/util/Constants.h	/^  InvalidInput = 3$/;"	e	enum:Eigen::ComputationInfo
InvalidTraversal	Eigen/src/Core/util/Constants.h	/^  InvalidTraversal,$/;"	e	enum:Eigen::TraversalType
InverseJacobian	srMath/Function.cpp	/^	MatrixX Function::InverseJacobian(const VectorX& x) const$/;"	f	class:srMath::Function
InverseKinematicsExitCondition	srMath/Constant.h	/^	static const Real	InverseKinematicsExitCondition = 1e-11;$/;"	m	namespace:srMath
IsAccelerationLimited	srLib/srExt/srExt_RevoluteJoint.h	/^	bool	IsAccelerationLimited()$/;"	f	class:srExtRevoluteJoint
IsActive	srLib/srDyn/srSpring.cpp	/^bool srSpring::IsActive()$/;"	f	class:srSpring
IsAligned	Eigen/src/Core/Map.h	/^    IsAligned = bool(EIGEN_ALIGN) && ((int(MapOptions)&Aligned)==Aligned),$/;"	e	enum:Eigen::internal::traits::__anon204
IsAligned	Eigen/src/Geometry/Quaternion.h	/^    IsAligned = internal::traits<Coefficients>::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::traits::__anon444
IsAligned	Eigen/src/Geometry/Quaternion.h	/^  enum { IsAligned = internal::traits<Quaternion>::IsAligned };$/;"	e	enum:Eigen::Quaternion::__anon445
IsColMajor	Eigen/src/Core/Reverse.h	/^      IsColMajor = !IsRowMajor,$/;"	e	enum:Eigen::Reverse::__anon19
IsColVector	Eigen/src/Core/VectorBlock.h	/^      IsColVector = !(internal::traits<VectorType>::Flags & RowMajorBit)$/;"	e	enum:Eigen::VectorBlock::__anon108
IsColVector	Eigen/src/SparseCore/SparseVector.h	/^    IsColVector = (_Options & RowMajorBit) ? 0 : 1,$/;"	e	enum:Eigen::internal::traits::__anon385
IsColVector	Eigen/src/SparseCore/SparseVector.h	/^    enum { IsColVector = internal::traits<SparseVector>::IsColVector };$/;"	e	enum:Eigen::SparseVector::__anon387
IsComplex	Eigen/src/Core/NumTraits.h	/^    IsComplex = 0,$/;"	e	enum:Eigen::GenericNumTraits::__anon337
IsComplex	Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon140
IsComplex	Eigen/src/Core/util/BlasUtil.h	/^    IsComplex = NumTraits<Scalar>::IsComplex,$/;"	e	enum:Eigen::internal::blas_traits::__anon141
IsDense	Eigen/src/Core/util/Constants.h	/^  IsDense         = 0,$/;"	e	enum:Eigen::__anon144
IsDeviceOn	srLib/srDyn/srJoint.cpp	/^bool srJoint::IsDeviceOn()$/;"	f	class:srJoint
IsDynamicSize	Eigen/src/Core/Map.h	/^    IsDynamicSize = PlainObjectType::SizeAtCompileTime==Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon204
IsHorizontal	Eigen/src/Core/VectorwiseOp.h	/^      IsHorizontal = (Direction==Horizontal) ? 1 : 0$/;"	e	enum:Eigen::VectorwiseOp::__anon316
IsInteger	Eigen/src/Core/NumTraits.h	/^    IsInteger = std::numeric_limits<T>::is_integer,$/;"	e	enum:Eigen::GenericNumTraits::__anon337
IsLower	Eigen/src/Core/SolveTriangular.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon311
IsLower	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon134
IsLower	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    IsLower = (Mode&Lower) == Lower,$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon135
IsLower	Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon126
IsLower	Eigen/src/Core/products/TriangularMatrixVector.h	/^    IsLower = ((Mode&Lower)==Lower),$/;"	e	enum:Eigen::internal::triangular_matrix_vector_product::__anon127
IsLower	Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon132
IsLower	Eigen/src/Core/products/TriangularSolverVector.h	/^    IsLower = ((Mode&Lower)==Lower)$/;"	e	enum:Eigen::internal::triangular_solve_vector::__anon133
IsMotorParameters	srLib/srExt/srExt_RevoluteJoint.h	/^	bool	IsMotorParameters()$/;"	f	class:srExtRevoluteJoint
IsNameChar	tinyxml2/tinyxml2.h	/^    inline static bool IsNameChar( unsigned char ch ) {$/;"	f	class:tinyxml2::XMLUtil
IsNameStartChar	tinyxml2/tinyxml2.h	/^    inline static bool IsNameStartChar( unsigned char ch ) {$/;"	f	class:tinyxml2::XMLUtil
IsPostionLimited	srLib/srDyn/srPrismaticJoint.cpp	/^bool srPrismaticJoint::IsPostionLimited()$/;"	f	class:srPrismaticJoint
IsPostionLimited	srLib/srDyn/srRevoluteJoint.cpp	/^bool srRevoluteJoint::IsPostionLimited()$/;"	f	class:srRevoluteJoint
IsPostionLimited	srLib/srDyn/srUniversalJoint.cpp	/^bool srUniversalJoint::IsPostionLimited(int idx \/*= 0*\/)$/;"	f	class:srUniversalJoint
IsProjective	Eigen/src/Geometry/Transform.h	/^    IsProjective = (int(Mode)==int(Projective))$/;"	e	enum:Eigen::internal::transform_traits::__anon450
IsRepeatable	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon66
IsRepeatable	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon64
IsRepeatable	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon65
IsRepeatable	Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
IsRowMajor	Eigen/src/Core/Block.h	/^    IsRowMajor = (MaxRowsAtCompileTime==1&&MaxColsAtCompileTime!=1) ? 1$/;"	e	enum:Eigen::internal::traits::__anon273
IsRowMajor	Eigen/src/Core/CoreIterators.h	/^    enum { IsRowMajor = (Derived::Flags&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::DenseBase::InnerIterator::__anon272
IsRowMajor	Eigen/src/Core/DenseBase.h	/^      IsRowMajor = int(Flags) & RowMajorBit, \/**< True if this expression has row-major storage order. *\/$/;"	e	enum:Eigen::DenseBase::__anon341
IsRowMajor	Eigen/src/Core/Replicate.h	/^    IsRowMajor = MaxRowsAtCompileTime==1 && MaxColsAtCompileTime!=1 ? 1$/;"	e	enum:Eigen::internal::traits::__anon271
IsRowMajor	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    enum { IsRowMajor = Base::IsRowMajor };$/;"	e	enum:Eigen::MappedSparseMatrix::__anon375
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^      IsRowMajor = BlockType::IsRowMajor$/;"	e	enum:Eigen::internal::GenericSparseBlockInnerIteratorImpl::__anon383
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^      IsRowMajor = BlockType::IsRowMajor$/;"	e	enum:Eigen::internal::GenericSparseBlockInnerIteratorImpl::__anon384
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon376
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon378
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon380
IsRowMajor	Eigen/src/SparseCore/SparseBlock.h	/^    enum { IsRowMajor = internal::traits<BlockType>::IsRowMajor };$/;"	e	enum:Eigen::BlockImpl::__anon382
IsRowMajor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Lhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon364
IsRowMajor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    enum { IsRowMajor = (int(Rhs::Flags)&RowMajorBit)==RowMajorBit };$/;"	e	enum:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector::__anon365
IsRowMajor	Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsRowMajor = Flags&RowMajorBit ? 1 : 0,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
IsSelfCollision	srLib/srDyn/srSystem.cpp	/^bool srSystem::IsSelfCollision()$/;"	f	class:srSystem
IsSigned	Eigen/src/Core/NumTraits.h	/^    IsSigned = std::numeric_limits<T>::is_signed,$/;"	e	enum:Eigen::GenericNumTraits::__anon337
IsSparse	Eigen/src/Core/util/Constants.h	/^  IsSparse$/;"	e	enum:Eigen::__anon144
IsSupported	Eigen/src/Core/Assign_MKL.h	/^{ enum { IsSupported = 0 }; };$/;"	e	enum:Eigen::internal::vml_call::__anon217
IsTransposed	Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = Base::IsTransposed ? 0 : 1$/;"	e	enum:Eigen::internal::blas_traits::__anon142
IsTransposed	Eigen/src/Core/util/BlasUtil.h	/^    IsTransposed = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon140
IsUTF8Continuation	tinyxml2/tinyxml2.h	/^    inline static bool IsUTF8Continuation( char p ) {$/;"	f	class:tinyxml2::XMLUtil
IsVectorAtCompileTime	Eigen/src/Core/DenseBase.h	/^      IsVectorAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime == 1$/;"	e	enum:Eigen::DenseBase::__anon341
IsVectorAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      IsVectorAtCompileTime = 0,$/;"	e	enum:Eigen::DiagonalBase::__anon32
IsVectorAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      IsVectorAtCompileTime = RowsAtCompileTime == 1 || ColsAtCompileTime == 1,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
IsVelocityLimited	srLib/srExt/srExt_RevoluteJoint.h	/^	bool	IsVelocityLimited()$/;"	f	class:srExtRevoluteJoint
IsVertical	Eigen/src/Core/VectorwiseOp.h	/^      IsVertical   = (Direction==Vertical) ? 1 : 0,$/;"	e	enum:Eigen::VectorwiseOp::__anon316
IsWhiteSpace	tinyxml2/tinyxml2.h	/^    static bool IsWhiteSpace( char p )					{$/;"	f	class:tinyxml2::XMLUtil
Isometry	Eigen/src/Core/util/Constants.h	/^  Isometry      = 0x1,$/;"	e	enum:Eigen::TransformTraits
Isometry2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Isometry> Isometry2d;$/;"	t	namespace:Eigen
Isometry2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Isometry> Isometry2f;$/;"	t	namespace:Eigen
Isometry3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Isometry> Isometry3d;$/;"	t	namespace:Eigen
Isometry3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Isometry> Isometry3f;$/;"	t	namespace:Eigen
IsometryTransformType	Eigen/src/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim,Isometry> IsometryTransformType;$/;"	t	class:Eigen::Translation
Item	tinyxml2/tinyxml2.h	/^    union Item {$/;"	u	class:tinyxml2::MemPoolT
ItemSize	tinyxml2/tinyxml2.h	/^    virtual int ItemSize() const	{$/;"	f	class:tinyxml2::MemPoolT
IterBase	Eigen/src/SparseCore/SparseView.h	/^  typedef typename _MatrixTypeNested::InnerIterator IterBase;$/;"	t	class:Eigen::SparseView::InnerIterator
IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase()$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  IterativeSolverBase(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^class IterativeSolverBase : internal::noncopyable$/;"	c	namespace:Eigen
Iterator	Eigen/src/SparseCore/AmbiVector.h	/^    Iterator(const AmbiVector& vec, const RealScalar& epsilon = 0)$/;"	f	class:Eigen::internal::AmbiVector::Iterator
Iterator	Eigen/src/SparseCore/AmbiVector.h	/^class AmbiVector<_Scalar,_Index>::Iterator$/;"	c	class:Eigen::internal::AmbiVector
JOINTTYPE	srLib/srDyn/srJoint.h	/^	enum JOINTTYPE { REVOLUTE, PRISMATIC, UNIVERSAL, WELD, BALL };$/;"	g	class:srJoint
JRs	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef JacobiRotation<Scalar> JRs;$/;"	t	class:Eigen::RealQZ
JacobiRotation	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation() {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation(const Scalar& c, const Scalar& s) : m_c(c), m_s(s) {}$/;"	f	class:Eigen::JacobiRotation
JacobiRotation	Eigen/src/Jacobi/Jacobi.h	/^template<typename Scalar> class JacobiRotation$/;"	c	namespace:Eigen
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD()$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(Index rows, Index cols, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD(const MatrixType& matrix, unsigned int computationOptions = 0)$/;"	f	class:Eigen::JacobiSVD
JacobiSVD	Eigen/src/SVD/JacobiSVD.h	/^template<typename _MatrixType, int QRPreconditioner> class JacobiSVD$/;"	c	namespace:Eigen
JacobiSVDType	Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<_MatrixType, QRPreconditioner> JacobiSVDType;$/;"	t	struct:Eigen::internal::solve_retval
Jacobian	srLib/srExt/srExt_System.cpp	/^Eigen::Matrix6Xd srExt::srExtSystem::Jacobian(REF_FRAME _refFrame, srLink * const _EndEffector, srLink * const _baseLink, const SE3 * const _offset) const$/;"	f	class:srExt::srExtSystem
Jacobian	srLib/srExt/srExtension.cpp	/^Matrix6Xd srExt::Jacobian(FRAME _refFrame, srLink * const _EndEffector, srLink * const _baseLink, const SE3 * const _offset)$/;"	f	class:srExt
Jacobian	srMath/Function.cpp	/^	MatrixX AffineFunction::Jacobian(const VectorX & x) const$/;"	f	class:srMath::AffineFunction
Jacobian	srMath/Function.cpp	/^	MatrixX AugmentedFunction::Jacobian(const VectorX& x) const$/;"	f	class:srMath::AugmentedFunction
Jacobian	srMath/Function.cpp	/^	MatrixX Function::Jacobian(const VectorX & x) const$/;"	f	class:srMath::Function
Jacobian	srMath/Function.cpp	/^	MatrixX MultiplyConstFunction::Jacobian(const VectorX & x) const$/;"	f	class:srMath::MultiplyConstFunction
Jacobian	srMath/Function.cpp	/^	MatrixX QuadraticFunction::Jacobian(const VectorX & x) const$/;"	f	class:srMath::QuadraticFunction
Jacobian	srMath/Function.h	/^		MatrixX Jacobian(const VectorX& x) const { return MatrixX(); }$/;"	f	class:srMath::EmptyFunction
JacobianLeft	srLib/srDyn/srContactConstraint.h	/^	dse3			JacobianLeft[MAX_NUM_OF_CONTACTJACOBIAN];$/;"	m	class:ContactConstraint
JacobianRight	srLib/srDyn/srContactConstraint.h	/^	dse3			JacobianRight[MAX_NUM_OF_CONTACTJACOBIAN];$/;"	m	class:ContactConstraint
JointAlignment	Eigen/src/Core/Assign.h	/^    JointAlignment = assign_traits<Derived1,Derived2>::JointAlignment$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon30
JointAlignment	Eigen/src/Core/Assign.h	/^    JointAlignment = bool(DstIsAligned) && bool(SrcIsAligned) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::assign_traits::__anon23
JointConstraint	srLib/srDyn/srJointConstraint.h	/^	JointConstraint()$/;"	f	class:JointConstraint
JointConstraint	srLib/srDyn/srJointConstraint.h	/^class JointConstraint: public Constraint$/;"	c
JointConstraintArray	srLib/srDyn/srDYN.h	/^typedef _array<JointConstraint>		JointConstraintArray;$/;"	t
JointPtrArray	srLib/srDyn/srDYN.h	/^typedef _array<srJoint*>			JointPtrArray;$/;"	t
KEYF3DS	srLib/SceneGraph/Model3DS.cpp	/^ #define KEYF3DS	/;"	d	file:
KILL_NON_PRINCIPAL_COL	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define KILL_NON_PRINCIPAL_COL(/;"	d
KILL_PRINCIPAL_COL	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define KILL_PRINCIPAL_COL(/;"	d
KILL_ROW	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define KILL_ROW(/;"	d
KINEMATIC	srLib/srDyn/srLink.h	/^	enum DYNTYPE { DYNAMIC, STATIC, KINEMATIC };$/;"	e	enum:srLink::DYNTYPE
KINEMATIC	srLib/srDyn/srSystem.h	/^	enum	BASELINKTYPE	{ DYNAMIC, FIXED,  KINEMATIC };$/;"	e	enum:srSystem::BASELINKTYPE
KIN_Initialize	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_Initialize()$/;"	f	class:srSystem
KIN_LinkFramePropagation	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_LinkFramePropagation()$/;"	f	class:srSystem
KIN_MODE_PRESTEP	srLib/srDyn/srSpace.cpp	/^void srSpace::KIN_MODE_PRESTEP()$/;"	f	class:srSpace
KIN_MODE_RUNTIME_FORWARD_KINEMATICS	srLib/srDyn/srSpace.cpp	/^void srSpace::KIN_MODE_RUNTIME_FORWARD_KINEMATICS()$/;"	f	class:srSpace
KIN_UpdateFrame_All_The_Entity	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_UpdateFrame_All_The_Entity()$/;"	f	class:srSystem
KIN_UpdateFrame_All_The_Entity_Light	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_UpdateFrame_All_The_Entity_Light()$/;"	f	class:srSystem
KIN_UpdateFrame_CollsionEntity	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_UpdateFrame_CollsionEntity()$/;"	f	class:srSystem
KIN_UpdateFrame_JointEntity	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_UpdateFrame_JointEntity()$/;"	f	class:srSystem
KIN_UpdateFrame_SensorEntity	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_UpdateFrame_SensorEntity()$/;"	f	class:srSystem
KIN_ValidateSystem	srLib/srDyn/srSystem.cpp	/^void srSystem::KIN_ValidateSystem()$/;"	f	class:srSystem
KIN_ValidateSystem	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::KIN_ValidateSystem()$/;"	f	class:srExt::srExtSystem
KMADD	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^#define KMADD(/;"	d
KMADD	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^#undef KMADD$/;"	d
KeepsPacketAccess	Eigen/src/Core/Map.h	/^    KeepsPacketAccess = bool(HasNoInnerStride)$/;"	e	enum:Eigen::internal::traits::__anon204
KernelResultType	Eigen/src/Eigen2Support/LU.h	/^    > KernelResultType;$/;"	t	class:Eigen::LU
KnotAllocation	srMath/Interpolation.cpp	/^	VectorX KnotAllocation(const VectorX & x_arr, int order, int N_cp)$/;"	f	namespace:srMath
LCPSolver_PGS____MARK3	srLib/srDyn/srISLAND.cpp	/^bool	LCPSolver_PGS____MARK3(int n, int nskip, int nub, SR_REAL * A, SR_REAL * x, SR_REAL * b, $/;"	f
LCPSolver_PGS____MARK4	srLib/srDyn/srISLAND.cpp	/^bool	LCPSolver_PGS____MARK4(int n, int nskip, int \/*nub*\/, SR_REAL * A, SR_REAL * x, SR_REAL * b, $/;"	f
LCPSolver_SPARSE_PGS____MARK1	srLib/srDyn/srISLAND.cpp	/^bool	LCPSolver_SPARSE_PGS____MARK1(int n, int * r, int * c, int * rowofs, SR_REAL * A,$/;"	f
LCP_PGS_OPTION_DEFAULT_EPS_DIVIDE	srLib/srDyn/srISLAND.h	/^#define LCP_PGS_OPTION_DEFAULT_EPS_DIVIDE	/;"	d
LCP_PGS_OPTION_DEFAULT_EPS_EA	srLib/srDyn/srISLAND.h	/^#define LCP_PGS_OPTION_DEFAULT_EPS_EA	/;"	d
LCP_PGS_OPTION_DEFAULT_EPS_RESIDUAL	srLib/srDyn/srISLAND.h	/^#define LCP_PGS_OPTION_DEFAULT_EPS_RESIDUAL	/;"	d
LCP_PGS_OPTION_DEFAULT_ITERMAX	srLib/srDyn/srISLAND.h	/^#define LCP_PGS_OPTION_DEFAULT_ITERMAX	/;"	d
LCP_PGS_OPTION_DEFAULT_SOR_W	srLib/srDyn/srISLAND.h	/^#define LCP_PGS_OPTION_DEFAULT_SOR_W	/;"	d
LCP_PGS_RANDOMLY_REORDER_CONSTRAINTS	srLib/srDyn/srISLAND.h	/^#define LCP_PGS_RANDOMLY_REORDER_CONSTRAINTS	/;"	d
LDLT	Eigen/src/Cholesky/LDLT.h	/^    LDLT() $/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^    LDLT(Index size)$/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^    LDLT(const MatrixType& matrix)$/;"	f	class:Eigen::LDLT
LDLT	Eigen/src/Cholesky/LDLT.h	/^template<typename _MatrixType, int _UpLo> class LDLT$/;"	c	namespace:Eigen
LDLTTraits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT<MatrixType,UpLo> > LDLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LDLTType	Eigen/src/Cholesky/LDLT.h	/^  typedef LDLT<_MatrixType,_UpLo> LDLTType;$/;"	t	struct:Eigen::internal::solve_retval
LDLT_Traits	Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LDLT_Traits	Eigen/src/Cholesky/LDLT.h	/^template<typename MatrixType> struct LDLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LF	tinyxml2/tinyxml2.cpp	/^static const char LF = LINE_FEED;$/;"	v	file:
LINE_FEED	tinyxml2/tinyxml2.cpp	/^static const char LINE_FEED				= (char)0x0a;			\/\/ all line endings are normalized to LF$/;"	v	file:
LINE_STIPPLE_FACTOR	srLib/srg/srgGeometryDraw.h	/^#define LINE_STIPPLE_FACTOR	/;"	d
LINE_STIPPLE_PATTER	srLib/srg/srgGeometryDraw.h	/^#define LINE_STIPPLE_PATTER	/;"	d
LLT	Eigen/src/Cholesky/LLT.h	/^    LLT() : m_matrix(), m_isInitialized(false) {}$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^    LLT(Index size) : m_matrix(size, size),$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^    LLT(const MatrixType& matrix)$/;"	f	class:Eigen::LLT
LLT	Eigen/src/Cholesky/LLT.h	/^template<typename _MatrixType, int _UpLo> class LLT$/;"	c	namespace:Eigen
LLTTraits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT<MatrixType,UpLo>  > LLTTraits;$/;"	t	class:Eigen::SimplicialCholesky
LLTType	Eigen/src/Cholesky/LLT.h	/^  typedef LLT<_MatrixType,UpLo> LLTType;$/;"	t	struct:Eigen::internal::solve_retval
LLT_Traits	Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Lower>$/;"	s	namespace:Eigen::internal
LLT_Traits	Eigen/src/Cholesky/LLT.h	/^template<typename MatrixType> struct LLT_Traits<MatrixType,Upper>$/;"	s	namespace:Eigen::internal
LLVL	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon346
LMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType, Lower|UnitDiag>  LMatrixType;$/;"	t	class:Eigen::SuperLU
LOCAL_COORDS	srLib/SceneGraph/Model3DS.cpp	/^    #define LOCAL_COORDS	/;"	d	file:
LOG	srMath/Diagnostic.h	/^#define LOG(/;"	d
LOGIF	srMath/Diagnostic.h	/^#define LOGIF(/;"	d
LOG_VALUE	srMath/Diagnostic.h	/^#define LOG_VALUE(/;"	d
LSUB	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon346
LU	Eigen/src/Eigen2Support/LU.h	/^    explicit LU(const T& t) : Base(t), m_originalMatrix(t) {}$/;"	f	class:Eigen::LU
LU	Eigen/src/Eigen2Support/LU.h	/^class LU : public FullPivLU<MatrixType>$/;"	c	namespace:Eigen
LUMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::SuperLUBase
LUMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::LUMatrixType LUMatrixType;$/;"	t	class:Eigen::SuperLU
LUMatrixType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar> LUMatrixType;$/;"	t	class:Eigen::UmfPackLU
LUNoMarker	Eigen/src/SparseLU/SparseLU_Memory.h	/^enum { LUNoMarker = 3 };$/;"	e	enum:Eigen::internal::__anon347
LUSUP	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon346
LUTempSpace	Eigen/src/SparseLU/SparseLU_Memory.h	/^inline Index LUTempSpace(Index&m, Index& w)$/;"	f	namespace:Eigen::internal
LU_GlobalLU_t	Eigen/src/SparseLU/SparseLU_Structs.h	/^struct LU_GlobalLU_t {$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^template <> struct LU_kernel_bmod<1>$/;"	s	namespace:Eigen::internal
LU_kernel_bmod	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^template <int SegSizeAtCompileTime> struct LU_kernel_bmod$/;"	s	namespace:Eigen::internal
LUnumTempV	Eigen/src/SparseLU/SparseLU_Memory.h	/^inline Index LUnumTempV(Index& m, Index& w, Index& t, Index& b)$/;"	f	namespace:Eigen::internal
L_Reset_ConstraintImpulse	srLib/srDyn/srSystem.cpp	/^void srSystem::L_Reset_ConstraintImpulse()$/;"	f	class:srSystem
L_UpdateDelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::L_UpdateDelVelocity(const dse3& imp)$/;"	f	class:srSystem
Large	Eigen/src/Core/GeneralProduct.h	/^  Large = 2,$/;"	e	enum:Eigen::__anon281
LargeEnough	Eigen/src/Core/Assign_MKL.h	/^      LargeEnough = VmlSize==Dynamic || VmlSize>=EIGEN_MKL_VML_THRESHOLD,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
LargeThreshold	Eigen/src/Core/GeneralProduct.h	/^    LargeThreshold = EIGEN_CACHEFRIENDLY_PRODUCT_THRESHOLD$/;"	e	enum:Eigen::internal::product_type::__anon283
LastChild	tinyxml2/tinyxml2.h	/^    XMLHandle LastChild()													{$/;"	f	class:tinyxml2::XMLHandle
LastChild	tinyxml2/tinyxml2.h	/^    XMLNode*		LastChild()								{$/;"	f	class:tinyxml2::XMLNode
LastChild	tinyxml2/tinyxml2.h	/^    const XMLConstHandle LastChild()	const										{$/;"	f	class:tinyxml2::XMLConstHandle
LastChild	tinyxml2/tinyxml2.h	/^    const XMLNode*	LastChild() const						{$/;"	f	class:tinyxml2::XMLNode
LastChildElement	tinyxml2/tinyxml2.cpp	/^const XMLElement* XMLNode::LastChildElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
LastChildElement	tinyxml2/tinyxml2.h	/^    XMLElement* LastChildElement( const char* name = 0 )	{$/;"	f	class:tinyxml2::XMLNode
LastChildElement	tinyxml2/tinyxml2.h	/^    XMLHandle LastChildElement( const char* name = 0 )						{$/;"	f	class:tinyxml2::XMLHandle
LastChildElement	tinyxml2/tinyxml2.h	/^    const XMLConstHandle LastChildElement( const char* name = 0 ) const				{$/;"	f	class:tinyxml2::XMLConstHandle
LazyCoeffBasedProductMode	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
LazyCoeffBasedProductType	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef CoeffBasedProduct<LhsNested,RhsNested,NestByRefBit> LazyCoeffBasedProductType;$/;"	t	class:Eigen::CoeffBasedProduct
LazyProductReturnType	Eigen/src/Core/GeneralProduct.h	/^struct LazyProductReturnType : public ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
Leaf	srLib/SceneGraph/Leaf.cpp	/^Leaf::Leaf(void)$/;"	f	class:Leaf
Leaf	srLib/SceneGraph/Leaf.h	/^class Leaf : public Node, public Transformation$/;"	c
Left	srLib/srg/srgCamera.h	/^		Top, Free, Front, Left$/;"	e	enum:srgCamera::ViewDirection
LeftLink	srLib/srDyn/srSystem.h	/^		srLink * LeftLink;$/;"	m	struct:srSystem::linkpair_for_closedloop
Lhs	Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Lhs>::type Lhs;$/;"	t	struct:Eigen::internal::traits
Lhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,LhsMode,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,LhsOptions> Lhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Lhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<SparseLhsType>::type Lhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsBlasTraits	Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_LhsNested> LhsBlasTraits;$/;"	t	class:Eigen::ProductBase
LhsCleaned	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename remove_all<Lhs>::type LhsCleaned;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
LhsCoeffReadCost	Eigen/src/Core/CwiseBinaryOp.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon228
LhsCoeffReadCost	Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon122
LhsCoeffReadCost	Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsCoeffReadCost = traits<_LhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon374
LhsCoeffReadCost	Eigen/src/SparseCore/SparseProduct.h	/^    LhsCoeffReadCost = _LhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon390
LhsFlags	Eigen/src/Core/CwiseBinaryOp.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon228
LhsFlags	Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon122
LhsFlags	Eigen/src/SparseCore/SparseProduct.h	/^    LhsFlags = _LhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon390
LhsInnerIterator	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::InnerIterator LhsInnerIterator;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
LhsIsSelfAdjoint	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsSelfAdjoint = (LhsMode&SelfAdjoint)==SelfAdjoint,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon137
LhsIsUpper	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    LhsIsUpper = (LhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon137
LhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _LhsNested::InnerIterator LhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
LhsMatrixType	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename take_matrix_for_product<Lhs>::type LhsMatrixType;$/;"	t	struct:Eigen::internal::traits
LhsMatrixType	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<homogeneous_left_product_impl>::LhsMatrixType LhsMatrixType;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMatrixTypeCleaned	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<LhsMatrixType>::type LhsMatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
LhsMatrixTypeNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename LhsMatrixTypeCleaned::Nested>::type LhsMatrixTypeNested;$/;"	t	struct:Eigen::internal::homogeneous_left_product_impl
LhsMode	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      LhsMode = internal::is_diagonal<_LhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon370
LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Lhs>::type LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Lhs, Rhs::ColsAtCompileTime, typename internal::plain_matrix_type<Lhs>::type >::type LhsNested;$/;"	t	struct:Eigen::ProductReturnType
LhsNested	Eigen/src/Core/ProductBase.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::ProductBase
LhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::LhsNested LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
LhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Lhs::Nested LhsNested;$/;"	t	struct:Eigen::internal::traits
LhsNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Lhs::Nested LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
LhsNested	Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Lhs,Rhs::RowsAtCompileTime>::type>::type LhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType
LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::LhsPacket LhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,RealPacket,  Scalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
LhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_LhsPacket,LhsScalar>::type LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
LhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
LhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon130
LhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  LhsPacketSize = Vectorizable ? packet_traits<LhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon131
LhsProductTraits	Eigen/src/Core/SolveTriangular.h	/^  typedef blas_traits<Lhs> LhsProductTraits;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress   = Traits::LhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon114
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
LhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    LhsProgress = ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
LhsRowMajor	Eigen/src/Core/products/CoeffBasedProduct.h	/^      LhsRowMajor = LhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon122
LhsRowMajor	Eigen/src/SparseCore/SparseProduct.h	/^    LhsRowMajor = internal::traits<Lhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon389
LhsScalar	Eigen/src/Core/GeneralProduct.h	/^    typedef typename Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct
LhsScalar	Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Lhs>::Scalar LhsScalar;$/;"	t	class:Eigen::ProductBase
LhsScalar	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Lhs::Scalar LhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar> LhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
LhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _LhsScalar LhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
LhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Lhs::Scalar LhsScalar;$/;"	t	class:Eigen::GeneralProduct
LhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_RhsScalar,_LhsScalar>::type LhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
LhsUpLo	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    LhsUpLo = LhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon128
Light	srLib/SceneGraph/Light.cpp	/^Light::Light(void)$/;"	f	class:Light
Light	srLib/SceneGraph/Light.h	/^class Light : public Node$/;"	c
LightNumber	srLib/SceneGraph/Light.h	/^	unsigned int	LightNumber;$/;"	m	class:Light
Limit	srLib/srDyn/srJointConstraint.h	/^	SR_REAL	Limit[2];		\/\/ Position Limit  [0]:lower, [1]:upper$/;"	m	class:JointConstraint
LimitError	srLib/srDyn/srJointConstraint.h	/^	SR_REAL	LimitError;$/;"	m	class:JointConstraint
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, Index size, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(Sequential_t, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
LinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::LinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
Line	srLib/SceneGraph/Leaf.cpp	/^Line::Line()$/;"	f	class:Line
Line	srLib/SceneGraph/Leaf.h	/^class Line : public Leaf$/;"	c
LineState	srLib/srg/srgGeometryDraw.h	/^struct LineState $/;"	s
LinearAccess	Eigen/src/Core/Reverse.h	/^    LinearAccess = ( (Direction==BothDirections) && (int(_MatrixTypeNested::Flags)&PacketAccessBit) )$/;"	e	enum:Eigen::internal::traits::__anon18
LinearAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int LinearAccessBit = 0x10;$/;"	m	namespace:Eigen
LinearIntegrator	srMath/LinearIntegrator.h	/^		LinearIntegrator(int num_of_points = 0, Real initialTime = 0.0, Real finalTime = 1.0)$/;"	f	class:srMath::LinearIntegrator
LinearIntegrator	srMath/LinearIntegrator.h	/^	class LinearIntegrator$/;"	c	namespace:srMath
LinearMatrixType	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Scaling
LinearMatrixType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Transform
LinearMatrixType	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation
LinearMatrixType	Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,Dim,Options> LinearMatrixType;$/;"	t	class:Eigen::Transform
LinearMatrixType	Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,Dim> LinearMatrixType;$/;"	t	class:Eigen::Translation
LinearPart	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim> LinearPart;$/;"	t	class:Eigen::Transform
LinearPart	Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,Dim,int(Mode)==(AffineCompact) && (Options&RowMajor)==0> LinearPart;$/;"	t	class:Eigen::Transform
LinearTraversal	Eigen/src/Core/util/Constants.h	/^  LinearTraversal,$/;"	e	enum:Eigen::TraversalType
LinearVectorizedTraversal	Eigen/src/Core/util/Constants.h	/^  LinearVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
Lines	srLib/SceneGraph/Leaf.cpp	/^Lines::Lines(double lineWidth \/*= 2*\/)$/;"	f	class:Lines
Lines	srLib/SceneGraph/Leaf.h	/^class Lines : public Leaf$/;"	c
LinkEndChild	tinyxml2/tinyxml2.h	/^    XMLNode* LinkEndChild( XMLNode* addThis )	{$/;"	f	class:tinyxml2::XMLNode
LinkPtrArray	srLib/srDyn/srDYN.h	/^typedef _array<srLink*>				LinkPtrArray;$/;"	t
ListEl	Eigen/src/SparseCore/AmbiVector.h	/^    struct ListEl$/;"	s	class:Eigen::internal::AmbiVector
Load	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::Load(char *name)$/;"	f	class:Model3DS
Load	srLib/SceneGraph/ModelSTL.cpp	/^void ModelSTL::Load(string filename)$/;"	f	class:ModelSTL
Load	srLib/SceneGraph/Texture3DS.cpp	/^void Texture3DS::Load(char *name)$/;"	f	class:Texture3DS
LoadBMP	srLib/SceneGraph/Texture3DS.cpp	/^void Texture3DS::LoadBMP(char *name)$/;"	f	class:Texture3DS
LoadFile	tinyxml2/tinyxml2.cpp	/^XMLError XMLDocument::LoadFile( FILE* fp )$/;"	f	class:tinyxml2::XMLDocument
LoadFile	tinyxml2/tinyxml2.cpp	/^XMLError XMLDocument::LoadFile( const char* filename )$/;"	f	class:tinyxml2::XMLDocument
LoadTGA	srLib/SceneGraph/Texture3DS.cpp	/^void Texture3DS::LoadTGA(char *name)$/;"	f	class:Texture3DS
Log	srMath/SE3.cpp	/^	se3 SE3::Log(const SE3& T)$/;"	f	class:srMath::SE3
Log	srMath/SO3.cpp	/^	so3 SO3::Log(const SO3& R)$/;"	f	class:srMath::SO3
LongFitsIntoSizeTMinusOne	tinyxml2/tinyxml2.cpp	/^struct LongFitsIntoSizeTMinusOne<false> {$/;"	s	namespace:tinyxml2	file:
Lower	Eigen/src/Core/util/Constants.h	/^  Lower=0x1,                      $/;"	e	enum:Eigen::UpLoType
LowerTriangular	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangular = Lower;$/;"	m	namespace:Eigen
LowerTriangularBit	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int LowerTriangularBit = Lower;$/;"	m	namespace:Eigen
LvalueBit	Eigen/src/Core/util/Constants.h	/^const unsigned int LvalueBit = 0x20;$/;"	m	namespace:Eigen
MADD	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  #define MADD(/;"	d
MAIN3DS	srLib/SceneGraph/Model3DS.cpp	/^#define MAIN3DS	/;"	d	file:
MAIN_VERS	srLib/SceneGraph/Model3DS.cpp	/^ #define MAIN_VERS	/;"	d	file:
MATERIAL	srLib/SceneGraph/Model3DS.cpp	/^  #define MATERIAL	/;"	d	file:
MAT_AMBIENT	srLib/SceneGraph/Model3DS.cpp	/^   #define MAT_AMBIENT	/;"	d	file:
MAT_DIFFUSE	srLib/SceneGraph/Model3DS.cpp	/^   #define MAT_DIFFUSE	/;"	d	file:
MAT_MAPNAME	srLib/SceneGraph/Model3DS.cpp	/^    #define MAT_MAPNAME	/;"	d	file:
MAT_NAME	srLib/SceneGraph/Model3DS.cpp	/^   #define MAT_NAME	/;"	d	file:
MAT_SELF_ILPCT	srLib/SceneGraph/Model3DS.cpp	/^   #define MAT_SELF_ILPCT	/;"	d	file:
MAT_SPECULAR	srLib/SceneGraph/Model3DS.cpp	/^   #define MAT_SPECULAR	/;"	d	file:
MAT_TEXMAP	srLib/SceneGraph/Model3DS.cpp	/^   #define MAT_TEXMAP	/;"	d	file:
MAX_NUM_OF_CONTACTJACOBIAN	srLib/srDyn/srContactConstraint.h	/^#define MAX_NUM_OF_CONTACTJACOBIAN	/;"	d
MAX_NUM_OF_CONTACTPOINT_PER_MASSPAIR	srLib/srDyn/srContactConstraint.h	/^#define MAX_NUM_OF_CONTACTPOINT_PER_MASSPAIR	/;"	d
MAX_SPOT	srLib/srDyn/srRangeFinder.h	/^#define	MAX_SPOT	/;"	d
MESH_INFO	srLib/SceneGraph/Model3DS.cpp	/^  #define MESH_INFO	/;"	d	file:
MESH_VERS	srLib/SceneGraph/Model3DS.cpp	/^  #define MESH_VERS	/;"	d	file:
METIS_SUPPORT_H	Eigen/src/MetisSupport/MetisSupport.h	/^#define METIS_SUPPORT_H$/;"	d
MODE_BITMAP	srLib/SceneGraph/Font.h	/^		MODE_BITMAP,$/;"	e	enum:srgString::__anon4
MODE_BITMAP	srLib/srg/srgFont.h	/^		MODE_BITMAP,$/;"	e	enum:srgString::__anon2
M_DEGREE	srLib/SceneGraph/Leaf.cpp	/^#define M_DEGREE	/;"	d	file:
M_PI	Eigen/src/Eigen2Support/Geometry/All.h	/^#define M_PI /;"	d
M_RADIAN	srLib/SceneGraph/Leaf.cpp	/^#define M_RADIAN	/;"	d	file:
MainChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::MainChunkProcessor(long length, long findex)$/;"	f	class:Model3DS
MakeAccelerationLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	MakeAccelerationLimit(bool v = true)$/;"	f	class:srExtRevoluteJoint
MakeClosedLoop	srLib/srDyn/srSystem.cpp	/^void srSystem::MakeClosedLoop(srLink * pLeftLink, srLink * pRightLink, SE3 RelativeFrame)$/;"	f	class:srSystem
MakeMotorParameters	srLib/srExt/srExt_RevoluteJoint.h	/^	void	MakeMotorParameters(bool v = true)$/;"	f	class:srExtRevoluteJoint
MakePositionLimit	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::MakePositionLimit(bool v)$/;"	f	class:srPrismaticJoint
MakePositionLimit	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::MakePositionLimit(bool v)$/;"	f	class:srRevoluteJoint
MakePositionLimit	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::MakePositionLimit(bool v \/*= true*\/, int idx \/*= 3*\/)$/;"	f	class:srUniversalJoint
MakeVelocityLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	MakeVelocityLimit(bool v = true)$/;"	f	class:srExtRevoluteJoint
Map	Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index a_size, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, Index nbRows, Index nbCols, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Map.h	/^    inline Map(PointerArgType dataPtr, const StrideType& a_stride = StrideType())$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Map.h	/^template<typename PlainObjectType, int MapOptions, typename StrideType> class Map$/;"	c	namespace:Eigen
Map	Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indicesPtr)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/PermutationMatrix.h	/^    inline Map(const Index* indicesPtr, Index size)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/PermutationMatrix.h	/^class Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess>$/;"	c	namespace:Eigen
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstMapType Map(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline MapType Map(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstMapType<Stride<Outer, Inner> >::type Map(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedMapType<Stride<Outer, Inner> >::type Map(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
Map	Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indicesPtr)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Transpositions.h	/^    inline Map(const Index* indicesPtr, Index size)$/;"	f	class:Eigen::Map
Map	Eigen/src/Core/Transpositions.h	/^class Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,PacketAccess>$/;"	c	namespace:Eigen
Map	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	Eigen/src/Geometry/Quaternion.h	/^    EIGEN_STRONG_INLINE Map(const Scalar* coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Map
Map	Eigen/src/Geometry/Quaternion.h	/^class Map<Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	Eigen/src/Geometry/Quaternion.h	/^class Map<const Quaternion<_Scalar>, _Options >$/;"	c	namespace:Eigen
Map	Eigen/src/SparseCore/CompressedStorage.h	/^    static CompressedStorage Map(Index* indices, Scalar* values, size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
Map	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef MappedSparseMatrix<Scalar,Flags> Map;$/;"	t	class:Eigen::SparseMatrix
Map	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(MatrixBase<MatrixType>& _mat)$/;"	f	struct:Eigen::SluMatrix
Map	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static SluMatrix Map(SparseMatrixBase<MatrixType>& mat)$/;"	f	struct:Eigen::SluMatrix
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline AlignedMapType MapAligned(Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index rows, Index cols)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline ConstAlignedMapType MapAligned(const Scalar* data, Index size)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedAlignedMapType<Stride<Outer, Inner> >::type MapAligned(Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index rows, Index cols, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, Index size, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapAligned	Eigen/src/Core/PlainObjectBase.h	/^    static inline typename StridedConstAlignedMapType<Stride<Outer, Inner> >::type MapAligned(const Scalar* data, const Stride<Outer, Inner>& stride)$/;"	f	class:Eigen::PlainObjectBase
MapBase	Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : Base(dataPtr) {}$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    explicit inline MapBase(PointerType dataPtr) : m_data(dataPtr), m_rows(RowsAtCompileTime), m_cols(ColsAtCompileTime)$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols) : Base(dataPtr, nbRows, nbCols) {}$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index nbRows, Index nbCols)$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize) : Base(dataPtr, vecSize) {}$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^    inline MapBase(PointerType dataPtr, Index vecSize)$/;"	f	class:Eigen::MapBase
MapBase	Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, ReadOnlyAccessors>$/;"	c	namespace:Eigen
MapBase	Eigen/src/Core/MapBase.h	/^template<typename Derived> class MapBase<Derived, WriteAccessors>$/;"	c	namespace:Eigen
MapLU	Eigen/src/LU/PartialPivLU.h	/^  typedef Map<Matrix<Scalar, Dynamic, Dynamic, StorageOrder> > MapLU;$/;"	t	struct:Eigen::internal::partial_lu_impl
MapNameChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::MapNameChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
MapType	Eigen/src/Core/PlainObjectBase.h	/^    typedef Eigen::Map<Derived, Unaligned>  MapType;$/;"	t	class:Eigen::PlainObjectBase
MappedMatrixBlock	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Map<ScalarMatrix, 0,  OuterStride<> > MappedMatrixBlock;$/;"	t	class:Eigen::internal::SparseLUImpl
MappedRhs	Eigen/src/Core/SolveTriangular.h	/^  typedef Map<Matrix<RhsScalar,Dynamic,1>, Aligned> MappedRhs;$/;"	t	struct:Eigen::internal::triangular_solver_selector
MappedSparseMatrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline MappedSparseMatrix(Index rows, Index cols, Index nnz, Index* outerIndexPtr, Index* innerIndexPtr, Scalar* valuePtr)$/;"	f	class:Eigen::MappedSparseMatrix
MappedSparseMatrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix$/;"	c	namespace:Eigen
MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    MappedSuperNodalMatrix(Index m, Index n,  ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^class MappedSuperNodalMatrix$/;"	c	namespace:Eigen::internal
MaskAlignedBit	Eigen/src/Core/Block.h	/^    MaskAlignedBit = (InnerPanel && (OuterStrideAtCompileTime!=Dynamic) && (((OuterStrideAtCompileTime * int(sizeof(Scalar))) % 16) == 0)) ? AlignedBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon273
MaskLvalueBit	Eigen/src/Core/Diagonal.h	/^    MaskLvalueBit = is_lvalue<MatrixType>::value ? LvalueBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon339
MaskPacketAccessBit	Eigen/src/Core/Block.h	/^    MaskPacketAccessBit = (InnerSize == Dynamic || (InnerSize % packet_traits<Scalar>::size) == 0)$/;"	e	enum:Eigen::internal::traits::__anon273
MassPair	srLib/srDyn/srContactConstraint.h	/^struct MassPair$/;"	s
MassPairArray	srLib/srDyn/srDYN.h	/^typedef	_array<MassPair>			MassPairArray;$/;"	t
MatFaces	srLib/SceneGraph/Model3DS.h	/^		MaterialFaces *MatFaces;	\/\/ The faces are divided by materials$/;"	m	struct:Model3DS::Object
MatIndex	srLib/SceneGraph/Model3DS.h	/^		int MatIndex;				\/\/ An index to our materials$/;"	m	struct:Model3DS::MaterialFaces
MatchAtCompileTime	Eigen/src/Core/Ref.h	/^      MatchAtCompileTime = HasDirectAccess && StorageOrderMatch && InnerStrideMatch && OuterStrideMatch && AlignmentMatch && ScalarTypeMatch$/;"	e	enum:Eigen::internal::traits::match::__anon323
Material	srLib/SceneGraph/Model3DS.h	/^	struct Material {$/;"	s	class:Model3DS
MaterialChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::MaterialChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
MaterialFaces	srLib/SceneGraph/Model3DS.h	/^	struct MaterialFaces {$/;"	s	class:Model3DS
MaterialNameChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::MaterialNameChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
Materials	srLib/SceneGraph/Model3DS.h	/^	Material *Materials;		\/\/ The array of materials$/;"	m	class:Model3DS
Matrix	Eigen/src/Core/Map.h	/^  ::Matrix(const Scalar *data)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix() : Base()$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Matrix& other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const Scalar& x, const Scalar& y, const Scalar& z, const Scalar& w)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix(const T0& x, const T1& y)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE explicit Matrix(Index dim)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    Matrix(Matrix&& other)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^    Matrix(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Core/Matrix.h	/^class Matrix$/;"	c	namespace:Eigen
Matrix	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
Matrix	Eigen/src/Geometry/RotationBase.h	/^::Matrix(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
Matrix2	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D
Matrix2	Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,2> Matrix2;$/;"	t	class:Eigen::Rotation2D
Matrix2s	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,2> Matrix2s;$/;"	t	class:Eigen::RealQZ
Matrix3	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis
Matrix3	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::Quaternion
Matrix3	Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::AngleAxis
Matrix3	Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,3> Matrix3;$/;"	t	class:Eigen::QuaternionBase
Matrix3	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 3, 3>		Matrix3;$/;"	t	namespace:srMath
Matrix4	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 4, 4>		Matrix4;$/;"	t	namespace:srMath
Matrix6	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 6, 6>		Matrix6;$/;"	t	namespace:srMath
Matrix6X	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 6, -1>		Matrix6X;$/;"	t	namespace:srMath
Matrix6Xd	srLib/srExt/srExt_Eigen.h	/^	typedef Eigen::Matrix<double, 6, Eigen::Dynamic>	Matrix6Xd;$/;"	t	namespace:Eigen
Matrix6d	srLib/srExt/srExt_Eigen.h	/^	typedef Eigen::Matrix<double, 6, 6>	Matrix6d;$/;"	t	namespace:Eigen
MatrixAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment     = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon429
MatrixAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    MatrixAlignment = bool(MatrixType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon430
MatrixBase	Eigen/src/Core/MatrixBase.h	/^    MatrixBase() : Base() {}$/;"	f	class:Eigen::MatrixBase
MatrixBase	Eigen/src/Core/MatrixBase.h	/^template<typename Derived> class MatrixBase$/;"	c	namespace:Eigen
MatrixCols	Eigen/src/Core/Block.h	/^    MatrixCols = traits<XprType>::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon273
MatrixConjugateReturnType	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::remove_all<typename MatrixType::ConjugateReturnType>::type MatrixConjugateReturnType;$/;"	t	class:Eigen::TriangularView
MatrixHReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef internal::HessenbergDecompositionMatrixHReturnType<MatrixType> MatrixHReturnType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixL	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitLower> MatrixL;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixL	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Lower> MatrixL;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLDLT
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixL  MatrixL;$/;"	t	class:Eigen::SimplicialLLT
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::Lower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<CholMatrixType, Eigen::UnitLower>  MatrixL;$/;"	t	struct:Eigen::internal::traits
MatrixOptions	Eigen/src/SVD/JacobiSVD.h	/^      MatrixOptions = MatrixType::Options$/;"	e	enum:Eigen::JacobiSVD::__anon423
MatrixQReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef internal::FullPivHouseholderQRMatrixQReturnType<MatrixType> MatrixQReturnType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixQType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, Options, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::ColPivHouseholderQR
MatrixQType	Eigen/src/QR/HouseholderQR.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, RowsAtCompileTime, (MatrixType::Flags&RowMajorBit) ? RowMajor : ColMajor, MaxRowsAtCompileTime, MaxRowsAtCompileTime> MatrixQType;$/;"	t	class:Eigen::HouseholderQR
MatrixRBlockType	Eigen/src/Eigen2Support/QR.h	/^    typedef Block<const MatrixType, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixRBlockType;$/;"	t	class:Eigen::QR
MatrixRows	Eigen/src/Core/Block.h	/^    MatrixRows = traits<XprType>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon273
MatrixTReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef internal::TridiagonalizationMatrixTReturnType<MatrixTypeRealView> MatrixTReturnType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	Eigen/src/Cholesky/LDLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LDLT
MatrixType	Eigen/src/Cholesky/LLT.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::LLT
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodBase
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodDecomposition
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLDLT
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSimplicialLLT
MatrixType	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::CholmodSupernodalLLT
MatrixType	Eigen/src/Core/GeneralProduct.h	/^    typedef typename internal::conditional<int(Side)==OnTheRight,_LhsNested,_RhsNested>::type MatrixType;$/;"	t	class:Eigen::GeneralProduct
MatrixType	Eigen/src/Core/TriangularMatrix.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::TriangularView
MatrixType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,HDim,HDim> MatrixType;$/;"	t	class:Eigen::Transform
MatrixType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::ei_transform_product_impl
MatrixType	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexEigenSolver
MatrixType	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ComplexSchur
MatrixType	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::EigenSolver
MatrixType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedEigenSolver
MatrixType	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::GeneralizedSelfAdjointEigenSolver
MatrixType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HessenbergDecomposition
MatrixType	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealQZ
MatrixType	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::RealSchur
MatrixType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
MatrixType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
MatrixType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::Tridiagonalization
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename Transform<Scalar,Dim,AffineCompact,Options>::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename TransformType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::transform_take_affine_part
MatrixType	Eigen/src/Geometry/Transform.h	/^  typedef typename internal::make_proper_matrix_type<Scalar,Rows,HDim,Options>::type MatrixType;$/;"	t	class:Eigen::Transform
MatrixType	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::DiagonalPreconditioner
MatrixType	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::BiCGSTAB
MatrixType	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ConjugateGradient
MatrixType	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic> MatrixType;$/;"	t	class:Eigen::IncompleteLUT
MatrixType	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::IterativeSolverBase
MatrixType	Eigen/src/LU/FullPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivLU
MatrixType	Eigen/src/LU/PartialPivLU.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PartialPivLU
MatrixType	Eigen/src/LU/PartialPivLU.h	/^  typedef Block<MapLU, Dynamic, Dynamic> MatrixType;$/;"	t	struct:Eigen::internal::partial_lu_impl
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixBase
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLDLT
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLLT
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::PastixLU
MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pastix_traits
MatrixType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::pardiso_traits
MatrixType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::MatrixType MatrixType;$/;"	t	class:Eigen::PardisoImpl
MatrixType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::ColPivHouseholderQR
MatrixType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::FullPivHouseholderQR
MatrixType	Eigen/src/QR/HouseholderQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::HouseholderQR
MatrixType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef SparseMatrix<Scalar, ColMajor, Index> MatrixType;$/;"	t	class:Eigen::SPQR
MatrixType	Eigen/src/SVD/JacobiSVD.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::JacobiSVD
MatrixType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholesky
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLDLT
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialLLT
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::MatrixType MatrixType;$/;"	t	class:Eigen::SimplicialCholeskyBase
MatrixType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef SparseMatrix<_Scalar, _Options, _Index> MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/SparseLU/SparseLU.h	/^    typedef _MatrixType MatrixType; $/;"	t	class:Eigen::SparseLU
MatrixType	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> MatrixType; $/;"	t	class:Eigen::internal::SparseLUImpl
MatrixType	Eigen/src/SparseQR/SparseQR.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SparseQR
MatrixType	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::QRMatrixType MatrixType;$/;"	t	struct:Eigen::SparseQR_QProduct
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperILU
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLU
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::SuperLUBase
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Derived MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  typedef Matrix<Scalar,Rows,Cols,Options,MRows,MCols> MatrixType;$/;"	t	struct:Eigen::SluMatrixMapHelper
MatrixType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef _MatrixType MatrixType;$/;"	t	class:Eigen::UmfPackLU
MatrixType	Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::image_retval_base
MatrixType	Eigen/src/misc/Image.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/misc/Kernel.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/misc/Solve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixType	Eigen/src/misc/SparseSolve.h	/^  typedef typename DecompositionType::MatrixType MatrixType;$/;"	t	struct:Eigen::internal::traits
MatrixTypeCleaned	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<MatrixType>::type MatrixTypeCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeInnerStride	Eigen/src/Core/CwiseUnaryView.h	/^    MatrixTypeInnerStride =  inner_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon233
MatrixTypeIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl
MatrixTypeIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::InnerIterator MatrixTypeIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl
MatrixTypeNested	Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Diagonal.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::Replicate
MatrixTypeNested	Eigen/src/Core/Replicate.h	/^  typedef typename nested<MatrixType,Factor>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Reverse.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNested	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/Transpose.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::TriangularView
MatrixTypeNested	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::MatrixTypeNested MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr
MatrixTypeNested	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Eigen2Support/Minor.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/LU/Inverse.h	/^  typedef typename internal::eval<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::inverse_impl
MatrixTypeNested	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename nested<MatrixType>::type MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
MatrixTypeNested	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseTriangularView
MatrixTypeNested	Eigen/src/SparseCore/SparseView.h	/^  typedef typename MatrixType::Nested MatrixTypeNested;$/;"	t	class:Eigen::SparseView
MatrixTypeNestedCleaned	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_matrix_product_retval
MatrixTypeNestedCleaned	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SelfAdjointView
MatrixTypeNestedCleaned	Eigen/src/Core/SelfAdjointView.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	Eigen/src/Core/Transpositions.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::transposition_matrix_product_retval
MatrixTypeNestedCleaned	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedCleaned MatrixTypeNestedCleaned;$/;"	t	class:Eigen::TriangularView
MatrixTypeNestedCleaned	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	Eigen/src/LU/Inverse.h	/^  typedef typename remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::inverse_impl
MatrixTypeNestedCleaned	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval
MatrixTypeNestedCleaned	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename remove_all<typename MatrixType::Nested>::type MatrixTypeNestedCleaned;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedCleaned	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type MatrixTypeNestedCleaned;$/;"	t	class:Eigen::SparseTriangularView
MatrixTypeNestedNonRef	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::MatrixTypeNestedNonRef MatrixTypeNestedNonRef;$/;"	t	class:Eigen::TriangularView
MatrixTypeNestedNonRef	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	struct:Eigen::internal::traits
MatrixTypeNestedNonRef	Eigen/src/SparseCore/SparseTriangularView.h	/^    typedef typename internal::remove_reference<MatrixTypeNested>::type MatrixTypeNestedNonRef;$/;"	t	class:Eigen::SparseTriangularView
MatrixTypeNestedPlain	Eigen/src/Core/Transpose.h	/^  typedef typename remove_reference<MatrixTypeNested>::type MatrixTypeNestedPlain;$/;"	t	struct:Eigen::internal::traits
MatrixTypeOuterStride	Eigen/src/Core/Diagonal.h	/^    MatrixTypeOuterStride = outer_stride_at_compile_time<MatrixType>::ret,$/;"	e	enum:Eigen::internal::traits::__anon339
MatrixTypeRealView	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename internal::remove_all<typename MatrixType::RealReturnType>::type MatrixTypeRealView;$/;"	t	class:Eigen::Tridiagonalization
MatrixTypeReverseIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryOpImpl
MatrixTypeReverseIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename _MatrixTypeNested::ReverseInnerIterator MatrixTypeReverseIterator;$/;"	t	class:Eigen::CwiseUnaryViewImpl
MatrixU	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const MatrixType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	Eigen/src/Cholesky/LDLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::LDLT_Traits
MatrixU	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const MatrixType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	Eigen/src/Cholesky/LLT.h	/^  typedef const TriangularView<const typename MatrixType::AdjointReturnType, Upper> MatrixU;$/;"	t	struct:Eigen::internal::LLT_Traits
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLDLT
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename Traits::MatrixU  MatrixU;$/;"	t	class:Eigen::SimplicialLLT
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::UnitUpper> MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef SparseTriangularView<typename CholMatrixType::AdjointReturnType, Eigen::Upper>   MatrixU;$/;"	t	struct:Eigen::internal::traits
MatrixUType	Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::RowsAtCompileTime, MinSize> MatrixUType;$/;"	t	class:Eigen::SVD
MatrixUType	Eigen/src/SVD/JacobiSVD.h	/^            MatrixUType;$/;"	t	class:Eigen::JacobiSVD
MatrixVType	Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, MatrixType::ColsAtCompileTime> MatrixVType;$/;"	t	class:Eigen::SVD
MatrixVType	Eigen/src/SVD/JacobiSVD.h	/^            MatrixVType;$/;"	t	class:Eigen::JacobiSVD
MatrixWrapper	Eigen/src/Core/ArrayWrapper.h	/^    inline MatrixWrapper(ExpressionType& a_matrix) : m_expression(a_matrix) {}$/;"	f	class:Eigen::MatrixWrapper
MatrixWrapper	Eigen/src/Core/ArrayWrapper.h	/^class MatrixWrapper : public MatrixBase<MatrixWrapper<ExpressionType> >$/;"	c	namespace:Eigen
MatrixX	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, -1, -1>		MatrixX;$/;"	t	namespace:srMath
MatrixXpr	Eigen/src/Core/util/Constants.h	/^struct MatrixXpr {};$/;"	s	namespace:Eigen
Max	Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Max	srMath/Common.h	/^	static Real Max(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
MaxCols	Eigen/src/Core/GeneralProduct.h	/^    MaxCols  = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon283
MaxColsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon425
MaxColsAtCompileTime	Eigen/src/Cholesky/LLT.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::LLT::__anon426
MaxColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
MaxColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon215
MaxColsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxColsAtCompileTime = _Cols,$/;"	e	enum:Eigen::internal::traits::__anon216
MaxColsAtCompileTime	Eigen/src/Core/Block.h	/^    MaxColsAtCompileTime = BlockCols==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon273
MaxColsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    MaxColsAtCompileTime = traits<Ancestor>::MaxColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon227
MaxColsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon341
MaxColsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon339
MaxColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      MaxColsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon32
MaxColsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    MaxColsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon34
MaxColsAtCompileTime	Eigen/src/Core/DiagonalProduct.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon232
MaxColsAtCompileTime	Eigen/src/Core/Matrix.h	/^    MaxColsAtCompileTime = _MaxCols,$/;"	e	enum:Eigen::internal::traits::__anon221
MaxColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::PermutationBase::__anon20
MaxColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxColsAtCompileTime = Traits::MaxColsAtCompileTime$/;"	e	enum:Eigen::Transpose::__anon22
MaxColsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    MaxColsAtCompileTime = IndicesType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon21
MaxColsAtCompileTime	Eigen/src/Core/ProductBase.h	/^    MaxColsAtCompileTime = traits<Rhs>::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon139
MaxColsAtCompileTime	Eigen/src/Core/Replicate.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon271
MaxColsAtCompileTime	Eigen/src/Core/Reverse.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon18
MaxColsAtCompileTime	Eigen/src/Core/Select.h	/^    MaxColsAtCompileTime = ConditionMatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon343
MaxColsAtCompileTime	Eigen/src/Core/Transpose.h	/^    MaxColsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
MaxColsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      MaxColsAtCompileTime = internal::traits<Derived>::MaxColsAtCompileTime$/;"	e	enum:Eigen::TriangularBase::__anon238
MaxColsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    MaxColsAtCompileTime = Direction==Horizontal ? 1 : MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
MaxColsAtCompileTime	Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon122
MaxColsAtCompileTime	Eigen/src/Eigen2Support/Minor.h	/^    MaxColsAtCompileTime = (MatrixType::MaxColsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon406
MaxColsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexEigenSolver::__anon472
MaxColsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ComplexSchur::__anon473
MaxColsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::EigenSolver::__anon468
MaxColsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon467
MaxColsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealQZ::__anon475
MaxColsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::RealSchur::__anon469
MaxColsAtCompileTime	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon474
MaxColsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon440
MaxColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      MaxColsAtCompileTime = internal::traits<HouseholderSequence>::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderSequence::__anon356
MaxColsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    MaxColsAtCompileTime = MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon355
MaxColsAtCompileTime	Eigen/src/LU/FullPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivLU::__anon432
MaxColsAtCompileTime	Eigen/src/LU/PartialPivLU.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::PartialPivLU::__anon431
MaxColsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon395
MaxColsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon393
MaxColsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime$/;"	e	enum:Eigen::HouseholderQR::__anon394
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon423
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
MaxColsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxColsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon422
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxColsAtCompileTime = Tr ? int(traits<Lhs>::MaxColsAtCompileTime)  : int(traits<Rhs>::MaxColsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon374
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxColsAtCompileTime = _Rhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon368
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = 1,$/;"	e	enum:Eigen::internal::traits::__anon362
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxColsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon361
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseProduct.h	/^    MaxColsAtCompileTime = _RhsNested::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
MaxColsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    MaxColsAtCompileTime = ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon385
MaxDepth	Eigen/src/Core/GeneralProduct.h	/^    MaxDepth = EIGEN_SIZE_MIN_PREFER_FIXED(_Lhs::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon283
MaxDepthAtCompileTime	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      MaxDepthAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(Lhs::MaxColsAtCompileTime,Rhs::MaxRowsAtCompileTime)$/;"	e	enum:Eigen::GeneralProduct::__anon120
MaxDiagSizeAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      MaxDiagSizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED(MaxRowsAtCompileTime,MaxColsAtCompileTime),$/;"	e	enum:Eigen::JacobiSVD::__anon423
MaxRows	Eigen/src/Core/GeneralProduct.h	/^    MaxRows  = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon283
MaxRowsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon425
MaxRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
MaxRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon215
MaxRowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    MaxRowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon216
MaxRowsAtCompileTime	Eigen/src/Core/Block.h	/^    MaxRowsAtCompileTime = BlockRows==0 ? 0$/;"	e	enum:Eigen::internal::traits::__anon273
MaxRowsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    MaxRowsAtCompileTime = traits<Ancestor>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon227
MaxRowsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon341
MaxRowsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    MaxRowsAtCompileTime = int(MatrixType::MaxSizeAtCompileTime) == Dynamic ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon339
MaxRowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      MaxRowsAtCompileTime = DiagonalVectorType::MaxSizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon32
MaxRowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    MaxRowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon34
MaxRowsAtCompileTime	Eigen/src/Core/DiagonalProduct.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon232
MaxRowsAtCompileTime	Eigen/src/Core/Matrix.h	/^    MaxRowsAtCompileTime = _MaxRows,$/;"	e	enum:Eigen::internal::traits::__anon221
MaxRowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon20
MaxRowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      MaxRowsAtCompileTime = Traits::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon22
MaxRowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    MaxRowsAtCompileTime = IndicesType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon21
MaxRowsAtCompileTime	Eigen/src/Core/ProductBase.h	/^    MaxRowsAtCompileTime = traits<Lhs>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon139
MaxRowsAtCompileTime	Eigen/src/Core/Replicate.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon271
MaxRowsAtCompileTime	Eigen/src/Core/Reverse.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon18
MaxRowsAtCompileTime	Eigen/src/Core/Select.h	/^    MaxRowsAtCompileTime = ConditionMatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon343
MaxRowsAtCompileTime	Eigen/src/Core/Transpose.h	/^    MaxRowsAtCompileTime = MatrixType::MaxColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
MaxRowsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      MaxRowsAtCompileTime = internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon238
MaxRowsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    MaxRowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
MaxRowsAtCompileTime	Eigen/src/Core/products/CoeffBasedProduct.h	/^      MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon122
MaxRowsAtCompileTime	Eigen/src/Eigen2Support/Minor.h	/^    MaxRowsAtCompileTime = (MatrixType::MaxRowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon406
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon472
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon473
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon468
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon467
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon475
MaxRowsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon469
MaxRowsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon440
MaxRowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      MaxRowsAtCompileTime = internal::traits<HouseholderSequence>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon356
MaxRowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    MaxRowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon355
MaxRowsAtCompileTime	Eigen/src/LU/FullPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon432
MaxRowsAtCompileTime	Eigen/src/LU/PartialPivLU.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon431
MaxRowsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon395
MaxRowsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon393
MaxRowsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon394
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon423
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
MaxRowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    MaxRowsAtCompileTime = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon422
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseDenseProduct.h	/^    MaxRowsAtCompileTime = Tr ? int(traits<Rhs>::MaxRowsAtCompileTime)  : int(traits<Lhs>::MaxRowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon374
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    MaxRowsAtCompileTime = _Lhs::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon368
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon361
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    MaxRowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon362
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseProduct.h	/^    MaxRowsAtCompileTime = _LhsNested::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
MaxRowsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    MaxRowsAtCompileTime = RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon385
MaxSize	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon471
MaxSize	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSize = MatrixType::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon470
MaxSizeAtCompileTime	Eigen/src/Core/Assign.h	/^    MaxSizeAtCompileTime = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_traits::__anon24
MaxSizeAtCompileTime	Eigen/src/Core/Assign_MKL.h	/^      MaxSizeAtCompileTime = Dst::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
MaxSizeAtCompileTime	Eigen/src/Core/DenseBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::MaxRowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon341
MaxSizeAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      MaxSizeAtCompileTime = (internal::size_at_compile_time<MaxRowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
MaxSizeMinusOne	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : MaxSize - 1$/;"	e	enum:Eigen::HessenbergDecomposition::__anon471
MaxSizeMinusOne	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      MaxSizeMinusOne = MaxSize == Dynamic ? Dynamic : (MaxSize > 1 ? MaxSize - 1 : 1)$/;"	e	enum:Eigen::Tridiagonalization::__anon470
MaxSmallDimAtCompileTime	Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::image_retval::__anon434
MaxSmallDimAtCompileTime	Eigen/src/LU/FullPivLU.h	/^  enum { MaxSmallDimAtCompileTime = EIGEN_SIZE_MIN_PREFER_FIXED($/;"	e	enum:Eigen::internal::kernel_retval::__anon433
MayEnableVml	Eigen/src/Core/Assign_MKL.h	/^      MayEnableVml = MightEnableVml && LargeEnough,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
MayInnerVectorize	Eigen/src/Core/Assign.h	/^    MayInnerVectorize  = MightVectorize && int(InnerSize)!=Dynamic && int(InnerSize)%int(PacketSize)==0$/;"	e	enum:Eigen::internal::assign_traits::__anon25
MayLinearVectorize	Eigen/src/Core/Assign.h	/^    MayLinearVectorize = MightVectorize && MayLinearize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon25
MayLinearVectorize	Eigen/src/Core/Redux.h	/^    MayLinearVectorize = MightVectorize && (int(Derived::Flags)&LinearAccessBit),$/;"	e	enum:Eigen::internal::redux_traits::__anon328
MayLinearize	Eigen/src/Core/Assign.h	/^    MayLinearize = StorageOrdersAgree && (int(Derived::Flags) & int(OtherDerived::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::assign_traits::__anon25
MayLinearize	Eigen/src/Core/Assign_MKL.h	/^      MayLinearize = MayEnableVml && MightLinearize$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
MaySliceVectorize	Eigen/src/Core/Assign.h	/^    MaySliceVectorize  = MightVectorize && DstHasDirectAccess$/;"	e	enum:Eigen::internal::assign_traits::__anon25
MaySliceVectorize	Eigen/src/Core/Redux.h	/^    MaySliceVectorize  = MightVectorize && int(InnerMaxSize)>=3*PacketSize$/;"	e	enum:Eigen::internal::redux_traits::__anon328
MayUnrollCompletely	Eigen/src/Core/Assign.h	/^    MayUnrollCompletely = int(Derived::SizeAtCompileTime) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon27
MayUnrollInner	Eigen/src/Core/Assign.h	/^    MayUnrollInner      = int(InnerSize) != Dynamic$/;"	e	enum:Eigen::internal::assign_traits::__anon27
Mem	tinyxml2/tinyxml2.h	/^    T* Mem()							{$/;"	f	class:tinyxml2::DynArray
Mem	tinyxml2/tinyxml2.h	/^    const T* Mem() const				{$/;"	f	class:tinyxml2::DynArray
MemPool	tinyxml2/tinyxml2.h	/^    MemPool() {}$/;"	f	class:tinyxml2::MemPool
MemPool	tinyxml2/tinyxml2.h	/^class MemPool$/;"	c	namespace:tinyxml2
MemPoolT	tinyxml2/tinyxml2.h	/^    MemPoolT() : _root(0), _currentAllocs(0), _nAllocs(0), _maxAllocs(0), _nUntracked(0)	{}$/;"	f	class:tinyxml2::MemPoolT
MemPoolT	tinyxml2/tinyxml2.h	/^class MemPoolT : public MemPool$/;"	c	namespace:tinyxml2
MemType	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	t	namespace:Eigen::internal	typeref:enum:Eigen::internal::__anon346
MetisOrdering	Eigen/src/MetisSupport/MetisSupport.h	/^class MetisOrdering$/;"	c	namespace:Eigen
MightEnableVml	Eigen/src/Core/Assign_MKL.h	/^      MightEnableVml =  vml_call<UnaryOp>::IsSupported && StorageOrdersAgree && DstHasDirectAccess && SrcHasDirectAccess$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
MightLinearize	Eigen/src/Core/Assign_MKL.h	/^      MightLinearize = MightEnableVml && (int(Dst::Flags) & int(Src::Flags) & LinearAccessBit),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
MightVectorize	Eigen/src/Core/Assign.h	/^    MightVectorize = StorageOrdersAgree$/;"	e	enum:Eigen::internal::assign_traits::__anon25
MightVectorize	Eigen/src/Core/Redux.h	/^    MightVectorize = (int(Derived::Flags)&ActualPacketAccessBit)$/;"	e	enum:Eigen::internal::redux_traits::__anon328
Min	Eigen/src/Geometry/AlignedBox.h	/^    Min=0, Max=1,$/;"	e	enum:Eigen::AlignedBox::CornerType
Min	srMath/Common.h	/^	static Real Min(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
MinRowsAtCompileTime	Eigen/src/Geometry/Umeyama.h	/^    MinRowsAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, OtherMatrixType::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::umeyama_transform_matrix_type::__anon447
MinSize	Eigen/src/Eigen2Support/SVD.h	/^      MinSize = EIGEN_SIZE_MIN_PREFER_DYNAMIC(MatrixType::RowsAtCompileTime, MatrixType::ColsAtCompileTime)$/;"	e	enum:Eigen::SVD::__anon396
Minor	Eigen/src/Eigen2Support/Minor.h	/^    inline Minor(const MatrixType& matrix,$/;"	f	class:Eigen::Minor
Minor	Eigen/src/Eigen2Support/Minor.h	/^template<typename MatrixType> class Minor$/;"	c	namespace:Eigen
MobileRobot	Example/MobileRobots/MobileRobots.h	/^class MobileRobot : public srSystem$/;"	c
Mode	Eigen/src/Core/SelfAdjointView.h	/^      Mode = internal::traits<SelfAdjointView>::Mode$/;"	e	enum:Eigen::SelfAdjointView::__anon278
Mode	Eigen/src/Core/SelfAdjointView.h	/^    Mode = UpLo | SelfAdjoint,$/;"	e	enum:Eigen::internal::traits::__anon277
Mode	Eigen/src/Core/TriangularMatrix.h	/^      Mode = _Mode,$/;"	e	enum:Eigen::TriangularView::__anon240
Mode	Eigen/src/Core/TriangularMatrix.h	/^      Mode = internal::traits<Derived>::Mode,$/;"	e	enum:Eigen::TriangularBase::__anon238
Mode	Eigen/src/Core/TriangularMatrix.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::internal::traits::__anon239
Mode	Eigen/src/Geometry/Transform.h	/^    Mode = Transform::Mode,$/;"	e	enum:Eigen::internal::transform_traits::__anon450
Mode	Eigen/src/Geometry/Transform.h	/^    Mode = _Mode,$/;"	e	enum:Eigen::Transform::__anon451
Mode	Eigen/src/Geometry/Transform.h	/^    Mode =$/;"	e	enum:Eigen::internal::transform_product_result::__anon453
Model3DS	srLib/SceneGraph/Model3DS.cpp	/^Model3DS::Model3DS()$/;"	f	class:Model3DS
Model3DS	srLib/SceneGraph/Model3DS.h	/^class Model3DS  $/;"	c
Model3DS_H	srLib/SceneGraph/Model3DS.h	/^#define Model3DS_H$/;"	d
ModelPath	Example/DracoP1/draco.cpp	/^#define ModelPath /;"	d	file:
ModelSTL	srLib/SceneGraph/ModelSTL.h	/^    ModelSTL(){ m_stl_content.clear(); }$/;"	f	class:ModelSTL
ModelSTL	srLib/SceneGraph/ModelSTL.h	/^    ModelSTL(string name){$/;"	f	class:ModelSTL
ModelSTL	srLib/SceneGraph/ModelSTL.h	/^class ModelSTL$/;"	c
MoveOuter	Eigen/src/SparseCore/SparsePermutation.h	/^      MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon373
MoveOuter	Eigen/src/SparseCore/SparsePermutation.h	/^    MoveOuter = SrcStorageOrder==RowMajor ? Side==OnTheLeft : Side==OnTheRight$/;"	e	enum:Eigen::internal::traits::__anon372
MulCost	Eigen/src/Core/NumTraits.h	/^    MulCost = 1$/;"	e	enum:Eigen::GenericNumTraits::__anon337
Mult3by3	srLib/srDyn/srCollision.cpp	/^void Mult3by3(SR_REAL* a, SR_REAL* b, SR_REAL* r)	\/\/ a*b=r, a,b,r: 3 by 3 matrix$/;"	f
MultMV3by3	srLib/srDyn/srCollision.cpp	/^void MultMV3by3(SR_REAL*a, SR_REAL*v, SR_REAL*r)		\/\/ a*v=r, a: 3 by 3 matrix, v: 3-dim vector, r:3-dim vector$/;"	f
MultMV3by3_In_BallJoint	srLib/srDyn/srBallJoint.cpp	/^void MultMV3by3_In_BallJoint(SR_REAL*a, SR_REAL*v, SR_REAL*r)		\/\/ a*v=r, a: 3 by 3 matrix, v: 3-dim vector, r:3-dim vector$/;"	f
MultiplyConst	srMath/Function.cpp	/^	FunctionPtr AffineFunction::MultiplyConst(const Real& w) const$/;"	f	class:srMath::AffineFunction
MultiplyConst	srMath/Function.cpp	/^	FunctionPtr Function::MultiplyConst(const Real& w) const$/;"	f	class:srMath::Function
MultiplyConst	srMath/Function.cpp	/^	FunctionPtr MultiplyConstFunction::MultiplyConst(const Real& w) const$/;"	f	class:srMath::MultiplyConstFunction
MultiplyConst	srMath/Function.cpp	/^	FunctionPtr QuadraticFunction::MultiplyConst(const Real& w) const$/;"	f	class:srMath::QuadraticFunction
MultiplyConst	srMath/Function.h	/^		FunctionPtr MultiplyConst(const Real& w) const { return FunctionPtr(new EmptyFunction); }$/;"	f	class:srMath::EmptyFunction
MultiplyConstFunction	srMath/Function.h	/^		MultiplyConstFunction() : _w(1.0) {}$/;"	f	class:srMath::MultiplyConstFunction
MultiplyConstFunction	srMath/Function.h	/^	class MultiplyConstFunction : public Function$/;"	c	namespace:srMath
NCMatrix	Eigen/src/SparseLU/SparseLU.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> NCMatrix;$/;"	t	class:Eigen::SparseLU
NColsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	s
NEEDS_DELETE	tinyxml2/tinyxml2.h	/^        NEEDS_DELETE = 0x200$/;"	e	enum:tinyxml2::StrPair::__anon479
NEEDS_ENTITY_PROCESSING	tinyxml2/tinyxml2.h	/^        NEEDS_ENTITY_PROCESSING			= 0x01,$/;"	e	enum:tinyxml2::StrPair::__anon478
NEEDS_FLUSH	tinyxml2/tinyxml2.h	/^        NEEDS_FLUSH = 0x100,$/;"	e	enum:tinyxml2::StrPair::__anon479
NEEDS_NEWLINE_NORMALIZATION	tinyxml2/tinyxml2.h	/^        NEEDS_NEWLINE_NORMALIZATION		= 0x02,$/;"	e	enum:tinyxml2::StrPair::__anon478
NEEDS_WHITESPACE_COLLAPSING	tinyxml2/tinyxml2.h	/^        NEEDS_WHITESPACE_COLLAPSING     = 0x04,$/;"	e	enum:tinyxml2::StrPair::__anon478
NINFINITY_BK	srLib/srDyn/srConstraint.h	/^#define	NINFINITY_BK	/;"	d
NRowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	s
NULL	srLib/LieGroup/_array.h	/^#define NULL /;"	d
NUMERIC_TYPE_MUST_BE_REAL	Eigen/src/Core/util/StaticAssert.h	/^        NUMERIC_TYPE_MUST_BE_REAL,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
NUM_ENTITIES	tinyxml2/tinyxml2.cpp	/^static const int NUM_ENTITIES = 5;$/;"	m	namespace:tinyxml2	file:
NUM_WINDOWS	srLib/SceneGraph/SceneGraphRenderer.h	/^	enum	NUM_WINDOWS	{SINGLE_WINDOWS, DOUBLE_WINDOWS};$/;"	g	class:SceneGraphRenderer
Name	tinyxml2/tinyxml2.cpp	/^const char* XMLAttribute::Name() const $/;"	f	class:tinyxml2::XMLAttribute
Name	tinyxml2/tinyxml2.h	/^    const char* Name() const		{$/;"	f	class:tinyxml2::XMLElement
NarrowPhase_Algorithm_________________________MARK7	srLib/srDyn/srContactConstraint.cpp	/^int	CollisionPair::NarrowPhase_Algorithm_________________________MARK7()$/;"	f	class:CollisionPair
NaturalOrdering	Eigen/src/OrderingMethods/Ordering.h	/^class NaturalOrdering$/;"	c	namespace:Eigen
NeedToConjugate	Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = Base::NeedToConjugate ? 0 : IsComplex$/;"	e	enum:Eigen::internal::blas_traits::__anon141
NeedToConjugate	Eigen/src/Core/util/BlasUtil.h	/^    NeedToConjugate = false,$/;"	e	enum:Eigen::internal::blas_traits::__anon140
NeedsToAlign	Eigen/src/Core/PlainObjectBase.h	/^    enum { NeedsToAlign = SizeAtCompileTime != Dynamic && (internal::traits<Derived>::Flags & AlignedBit) != 0 };$/;"	e	enum:Eigen::PlainObjectBase::__anon275
NegativeSemiDef	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
Negative_Velocity	srLib/srDyn/srJointConstraint.h	/^	SR_REAL	Negative_Velocity;$/;"	m	class:JointConstraint
NestByRefBit	Eigen/src/Core/util/Constants.h	/^const unsigned int NestByRefBit = 0x100;$/;"	m	namespace:Eigen
NestByValue	Eigen/src/Core/NestByValue.h	/^    inline NestByValue(const ExpressionType& matrix) : m_expression(matrix) {}$/;"	f	class:Eigen::NestByValue
NestByValue	Eigen/src/Core/NestByValue.h	/^template<typename ExpressionType> class NestByValue$/;"	c	namespace:Eigen
Nested	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalWrapper Nested;$/;"	t	class:Eigen::DiagonalWrapper
Nested	Eigen/src/Core/DiagonalMatrix.h	/^    typedef const DiagonalMatrix& Nested;$/;"	t	class:Eigen::DiagonalMatrix
NestedExpressionType	Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::ArrayWrapper
NestedExpressionType	Eigen/src/Core/ArrayWrapper.h	/^    typedef typename internal::nested<ExpressionType>::type NestedExpressionType;$/;"	t	class:Eigen::MatrixWrapper
NestedXpr	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename internal::remove_all<typename Xpr::Nested>::type NestedXpr;$/;"	t	struct:Eigen::internal::blas_traits
NewComment	tinyxml2/tinyxml2.cpp	/^XMLComment* XMLDocument::NewComment( const char* str )$/;"	f	class:tinyxml2::XMLDocument
NewDeclaration	tinyxml2/tinyxml2.cpp	/^XMLDeclaration* XMLDocument::NewDeclaration( const char* str )$/;"	f	class:tinyxml2::XMLDocument
NewElement	tinyxml2/tinyxml2.cpp	/^XMLElement* XMLDocument::NewElement( const char* name )$/;"	f	class:tinyxml2::XMLDocument
NewInf	Eigen/src/Core/util/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen::internal
NewInf	Eigen/src/Eigen2Support/Meta.h	/^      NewInf = int(TakeInf) ? InfX : int(MidX),$/;"	m	namespace:Eigen
NewSup	Eigen/src/Core/util/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen::internal
NewSup	Eigen/src/Eigen2Support/Meta.h	/^      NewSup = int(TakeInf) ? int(MidX) : SupX$/;"	m	namespace:Eigen
NewText	tinyxml2/tinyxml2.cpp	/^XMLText* XMLDocument::NewText( const char* str )$/;"	f	class:tinyxml2::XMLDocument
NewUnknown	tinyxml2/tinyxml2.cpp	/^XMLUnknown* XMLDocument::NewUnknown( const char* str )$/;"	f	class:tinyxml2::XMLDocument
Next	tinyxml2/tinyxml2.h	/^    const XMLAttribute* Next() const {$/;"	f	class:tinyxml2::XMLAttribute
NextSibling	tinyxml2/tinyxml2.h	/^    XMLHandle NextSibling()													{$/;"	f	class:tinyxml2::XMLHandle
NextSibling	tinyxml2/tinyxml2.h	/^    XMLNode*	NextSibling()								{$/;"	f	class:tinyxml2::XMLNode
NextSibling	tinyxml2/tinyxml2.h	/^    const XMLConstHandle NextSibling() const										{$/;"	f	class:tinyxml2::XMLConstHandle
NextSibling	tinyxml2/tinyxml2.h	/^    const XMLNode*	NextSibling() const						{$/;"	f	class:tinyxml2::XMLNode
NextSiblingElement	tinyxml2/tinyxml2.cpp	/^const XMLElement* XMLNode::NextSiblingElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
NextSiblingElement	tinyxml2/tinyxml2.h	/^    XMLElement*	NextSiblingElement( const char* name = 0 )	{$/;"	f	class:tinyxml2::XMLNode
NextSiblingElement	tinyxml2/tinyxml2.h	/^    XMLHandle NextSiblingElement( const char* name = 0 )					{$/;"	f	class:tinyxml2::XMLHandle
NextSiblingElement	tinyxml2/tinyxml2.h	/^    const XMLConstHandle NextSiblingElement( const char* name = 0 ) const			{$/;"	f	class:tinyxml2::XMLConstHandle
NoAlias	Eigen/src/Core/NoAlias.h	/^    NoAlias(ExpressionType& expression) : m_expression(expression) {}$/;"	f	class:Eigen::NoAlias
NoAlias	Eigen/src/Core/NoAlias.h	/^class NoAlias$/;"	c	namespace:Eigen
NoChange	Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	e	enum:Eigen::NoChange_t
NoChange_t	Eigen/src/Core/util/Constants.h	/^enum NoChange_t   { NoChange };$/;"	g	namespace:Eigen
NoChildren	tinyxml2/tinyxml2.h	/^    bool NoChildren() const					{$/;"	f	class:tinyxml2::XMLNode
NoConvergence	Eigen/src/Core/util/Constants.h	/^  NoConvergence = 2,$/;"	e	enum:Eigen::ComputationInfo
NoPivoting	Eigen/src/Core/util/Constants.h	/^  NoPivoting          = 0x02, $/;"	e	enum:Eigen::DecompositionOptions
NoQRPreconditioner	Eigen/src/Core/util/Constants.h	/^  NoQRPreconditioner,$/;"	e	enum:Eigen::QRPreconditioners
NoUnrolling	Eigen/src/Core/util/Constants.h	/^  NoUnrolling,$/;"	e	enum:Eigen::UnrollingType
Node	srLib/SceneGraph/Node.cpp	/^Node::Node(void)$/;"	f	class:Node
Node	srLib/SceneGraph/node.h	/^class Node$/;"	c
NonConstImagReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryView<internal::scalar_imag_ref_op<Scalar>, Derived> NonConstImagReturnType;$/;"	t
NonConstRealReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type NonConstRealReturnType;$/;"	t
NonInteger	Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::NonInteger      NonInteger;$/;"	t	class:Eigen::AlignedBox
NormalReturnType	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane
NormalReturnType	Eigen/src/Geometry/Hyperplane.h	/^  typedef Block<Coefficients,AmbientDimAtCompileTime,1> NormalReturnType;$/;"	t	class:Eigen::Hyperplane
NormalVec	srLib/srDyn/srContactConstraint.h	/^	Vec3	NormalVec;$/;"	m	struct:Contact
Normals	srLib/SceneGraph/Model3DS.h	/^		float	*Normals;			\/\/ The array of the normals for the vertexes$/;"	m	struct:Model3DS::Object
NothingRenderLeaf	srLib/SceneGraph/Leaf.h	/^class  NothingRenderLeaf : public Leaf$/;"	c
NotifyDetected	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::NotifyDetected()$/;"	f	class:srTouchSensor
NullaryExpr	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index rows, Index cols, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(Index size, const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NullaryExpr	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::NullaryExpr(const CustomNullaryOp& func)$/;"	f	class:Eigen::DenseBase
NumberOfRegisters	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
NumberOfRegisters	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
NumberOfRegisters	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    NumberOfRegisters = EIGEN_ARCH_DEFAULT_NUMBER_OF_REGISTERS,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
NumericalIssue	Eigen/src/Core/util/Constants.h	/^  NumericalIssue = 1, $/;"	e	enum:Eigen::ComputationInfo
OBJECT	srLib/SceneGraph/Model3DS.cpp	/^  #define OBJECT	/;"	d	file:
OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG	Eigen/src/Core/util/StaticAssert.h	/^        OBJECT_ALLOCATED_ON_STACK_IS_TOO_BIG,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
ONES_COMPLEMENT	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define ONES_COMPLEMENT(/;"	d
ONE_UNIT	srLib/SceneGraph/Model3DS.cpp	/^  #define ONE_UNIT	/;"	d	file:
OPEN	tinyxml2/tinyxml2.h	/^        OPEN,		\/\/ <foo>$/;"	e	enum:tinyxml2::XMLElement::__anon482
Object	srLib/SceneGraph/Model3DS.h	/^	struct Object {$/;"	s	class:Model3DS
ObjectChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::ObjectChunkProcessor(long length, long findex, int objindex)$/;"	f	class:Model3DS
Objects	srLib/SceneGraph/Model3DS.h	/^	Object	*Objects;			\/\/ The array of objects in the model$/;"	m	class:Model3DS
OffsetCol	Eigen/src/Core/Reverse.h	/^      OffsetCol  = ReverseCol && IsRowMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon19
OffsetRow	Eigen/src/Core/Reverse.h	/^      OffsetRow  = ReverseRow && IsColMajor ? PacketSize : 1,$/;"	e	enum:Eigen::Reverse::__anon19
OnTheLeft	Eigen/src/Core/util/Constants.h	/^  OnTheLeft = 1,  $/;"	e	enum:Eigen::SideType
OnTheRight	Eigen/src/Core/util/Constants.h	/^  OnTheRight = 2  $/;"	e	enum:Eigen::SideType
Ones	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones()$/;"	f	class:Eigen::DenseBase
Ones	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase
Ones	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Ones(Index newSize)$/;"	f	class:Eigen::DenseBase
OpenElement	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::OpenElement( const char* name, bool compactMode )$/;"	f	class:tinyxml2::XMLPrinter
OppositeExtendedType	Eigen/src/Core/VectorwiseOp.h	/^    template<typename OtherDerived> struct OppositeExtendedType {$/;"	s	class:Eigen::VectorwiseOp
Options	Eigen/src/Cholesky/LDLT.h	/^      Options = MatrixType::Options & ~RowMajorBit, \/\/ these are the options for the TmpMatrixType, we need a ColMajor matrix here!$/;"	e	enum:Eigen::LDLT::__anon425
Options	Eigen/src/Cholesky/LLT.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::LLT::__anon426
Options	Eigen/src/Core/Array.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Array::__anon269
Options	Eigen/src/Core/BandMatrix.h	/^      Options = internal::traits<Derived>::Options$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
Options	Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon215
Options	Eigen/src/Core/BandMatrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon216
Options	Eigen/src/Core/Map.h	/^  enum { Options }; \/\/ Expressions don't have Options$/;"	e	enum:Eigen::internal::traits::__anon205
Options	Eigen/src/Core/Matrix.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon221
Options	Eigen/src/Core/Matrix.h	/^    enum { Options = _Options };$/;"	e	enum:Eigen::Matrix::__anon222
Options	Eigen/src/Core/PlainObjectBase.h	/^    enum { Options = internal::traits<Derived>::Options };$/;"	e	enum:Eigen::PlainObjectBase::__anon274
Options	Eigen/src/Core/Ref.h	/^    Options = _Options,$/;"	e	enum:Eigen::internal::traits::__anon322
Options	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon472
Options	Eigen/src/Eigenvalues/ComplexSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ComplexSchur::__anon473
Options	Eigen/src/Eigenvalues/EigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::EigenSolver::__anon468
Options	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon467
Options	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon471
Options	Eigen/src/Eigenvalues/RealQZ.h	/^        Options = MatrixType::Options,$/;"	e	enum:Eigen::RealQZ::__anon475
Options	Eigen/src/Eigenvalues/RealSchur.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::RealSchur::__anon469
Options	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon474
Options	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::Tridiagonalization::__anon470
Options	Eigen/src/Geometry/Hyperplane.h	/^    Options = _Options$/;"	e	enum:Eigen::Hyperplane::__anon439
Options	Eigen/src/Geometry/ParametrizedLine.h	/^    Options = _Options$/;"	e	enum:Eigen::ParametrizedLine::__anon457
Options	Eigen/src/Geometry/Transform.h	/^    Options = _Options,$/;"	e	enum:Eigen::Transform::__anon451
Options	Eigen/src/LU/FullPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivLU::__anon432
Options	Eigen/src/LU/PartialPivLU.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::PartialPivLU::__anon431
Options	Eigen/src/QR/ColPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon395
Options	Eigen/src/QR/FullPivHouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon393
Options	Eigen/src/QR/HouseholderQR.h	/^      Options = MatrixType::Options,$/;"	e	enum:Eigen::HouseholderQR::__anon394
Options	Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
Options	Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
Options	Eigen/src/SVD/JacobiSVD.h	/^    Options = MatrixType::Options$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon422
Options	Eigen/src/SparseCore/SparseMatrix.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseMatrix::__anon363
Options	Eigen/src/SparseCore/SparseVector.h	/^      Options = _Options$/;"	e	enum:Eigen::SparseVector::__anon388
OrderingType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename internal::traits<Derived>::OrderingType OrderingType;$/;"	t	class:Eigen::SimplicialCholeskyBase
OrderingType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef _Ordering OrderingType;$/;"	t	struct:Eigen::internal::traits
OrderingType	Eigen/src/SparseLU/SparseLU.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseLU
OrderingType	Eigen/src/SparseQR/SparseQR.h	/^    typedef _OrderingType OrderingType;$/;"	t	class:Eigen::SparseQR
Orthogonal	srLib/srg/srgCamera.h	/^		Orthogonal, Perspective$/;"	e	enum:srgCamera::ProjectionType
OtherCols	Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon454
OtherCols	Eigen/src/Geometry/Transform.h	/^    OtherCols = MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon455
OtherPlainObject	Eigen/src/Core/TriangularMatrix.h	/^      typedef typename OtherDerived::PlainObject::DenseType OtherPlainObject;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
OtherRows	Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon454
OtherRows	Eigen/src/Geometry/Transform.h	/^    OtherRows = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::transform_right_product_impl::__anon455
OuterProduct	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	e	enum:Eigen::ProductImplType
OuterRandomAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int OuterRandomAccessPattern  = 0x4 | CoherentAccessPattern;$/;"	m	namespace:Eigen
OuterSize	Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon377
OuterSize	Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon379
OuterSize	Eigen/src/SparseCore/SparseBlock.h	/^    enum { OuterSize = IsRowMajor ? BlockRows : BlockCols };$/;"	e	enum:Eigen::BlockImpl::__anon381
OuterStride	Eigen/src/Core/Stride.h	/^    OuterStride() : Base() {}$/;"	f	class:Eigen::OuterStride
OuterStride	Eigen/src/Core/Stride.h	/^    OuterStride(Index v) : Base(v,0) {}$/;"	f	class:Eigen::OuterStride
OuterStride	Eigen/src/Core/Stride.h	/^class OuterStride : public Stride<Value, 0>$/;"	c	namespace:Eigen
OuterStrideAtCompileTime	Eigen/src/Core/Block.h	/^    OuterStrideAtCompileTime = HasSameStorageOrderAsXprType$/;"	e	enum:Eigen::internal::traits::__anon273
OuterStrideAtCompileTime	Eigen/src/Core/CwiseUnaryView.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret == Dynamic$/;"	e	enum:Eigen::internal::traits::__anon233
OuterStrideAtCompileTime	Eigen/src/Core/DenseBase.h	/^      OuterStrideAtCompileTime = internal::outer_stride_at_compile_time<Derived>::ret$/;"	e	enum:Eigen::DenseBase::__anon341
OuterStrideAtCompileTime	Eigen/src/Core/Diagonal.h	/^    OuterStrideAtCompileTime = 0$/;"	e	enum:Eigen::internal::traits::__anon339
OuterStrideAtCompileTime	Eigen/src/Core/Map.h	/^    OuterStrideAtCompileTime = StrideType::OuterStrideAtCompileTime == 0$/;"	e	enum:Eigen::internal::traits::__anon204
OuterStrideAtCompileTime	Eigen/src/Core/Matrix.h	/^    OuterStrideAtCompileTime = (Options&RowMajor) ? ColsAtCompileTime : RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon221
OuterStrideAtCompileTime	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    OuterStrideAtCompileTime = Lhs::OuterStrideAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon211
OuterStrideAtCompileTime	Eigen/src/Core/Stride.h	/^      OuterStrideAtCompileTime = _OuterStrideAtCompileTime$/;"	e	enum:Eigen::Stride::__anon203
OuterStrideAtCompileTime	Eigen/src/Core/Transpose.h	/^    OuterStrideAtCompileTime = outer_stride_at_compile_time<MatrixType>::ret$/;"	e	enum:Eigen::internal::traits::__anon324
OuterStrideMatch	Eigen/src/Core/Ref.h	/^      OuterStrideMatch = Derived::IsVectorAtCompileTime$/;"	e	enum:Eigen::internal::traits::match::__anon323
PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1	Eigen/src/Core/util/StaticAssert.h	/^        PACKET_ACCESS_REQUIRES_TO_HAVE_INNER_STRIDE_FIXED_TO_1,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
PALIGN_NEON	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define PALIGN_NEON(/;"	d
PALIGN_NEON	Eigen/src/Core/arch/NEON/PacketMath.h	/^#undef PALIGN_NEON$/;"	d
PASSIVE	srLib/srDyn/srJoint.h	/^	enum ACTTYPE { PASSIVE, TORQUE, VELOCITY, HYBRID };$/;"	e	enum:srJoint::ACTTYPE
PASTIX_COMPLEX	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  #define PASTIX_COMPLEX /;"	d
PASTIX_DCOMPLEX	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  #define PASTIX_DCOMPLEX /;"	d
PATH_LENGTH	srLib/SceneGraph/Model3DS.h	/^	static const int PATH_LENGTH = 2000;$/;"	m	class:Model3DS
PERC_FLOAT	srLib/SceneGraph/Model3DS.cpp	/^#define PERC_FLOAT	/;"	d	file:
PERC_INT	srLib/SceneGraph/Model3DS.cpp	/^#define PERC_INT	/;"	d	file:
PERFORM_TEST	srMath/Diagnostic.h	/^#define PERFORM_TEST(/;"	d
PGSOption	srLib/srDyn/srISLAND.h	/^struct PGSOption$/;"	s
PI	srMath/Constant.h	/^	static const Real	PI = 3.14159265358979323846;				\/\/\/< \\pi$/;"	m	namespace:srMath
PINFINITY_BK	srLib/srDyn/srConstraint.h	/^#define	PINFINITY_BK	/;"	d
PIVOT_PT	srLib/SceneGraph/Model3DS.cpp	/^   #define PIVOT_PT	/;"	d	file:
PI_DIVIDED_BY_SQRT2	srMath/Constant.h	/^	static const Real	PI_DIVIDED_BY_SQRT2 = 2.2214414690791831235079404950303;	\/\/\/< \\frac{\\pi}{\\sqrt{2}}$/;"	m	namespace:srMath
PI_DOUBLE	srMath/Constant.h	/^	static const Real	PI_DOUBLE = 6.28318530717958647692;				\/\/\/< \\pi*2$/;"	m	namespace:srMath
PI_HALF	srMath/Constant.h	/^	static const Real	PI_HALF = 1.57079632679489661923;				\/\/\/< \\frac{\\pi}{2}$/;"	m	namespace:srMath
PI_SQUARE	srMath/Constant.h	/^	static const Real	PI_SQUARE = 9.8696044010893586188344909998762;	\/\/\/< \\pi^2$/;"	m	namespace:srMath
PLANE	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define PLATFORM_ID$/;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define PLATFORM_ID$/;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define PLATFORM_ID$/;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define PLATFORM_ID$/;"	d	file:
PRESERVE_WHITESPACE	tinyxml2/tinyxml2.h	/^    PRESERVE_WHITESPACE,$/;"	e	enum:tinyxml2::Whitespace
PRESTEP_Find_NarrowPhase_Algorithm	srLib/srDyn/srContactConstraint.cpp	/^bool CollisionPair::PRESTEP_Find_NarrowPhase_Algorithm()$/;"	f	class:CollisionPair
PRESTEP_Find_RoughCheck__Algorithm	srLib/srDyn/srContactConstraint.cpp	/^bool CollisionPair::PRESTEP_Find_RoughCheck__Algorithm()$/;"	f	class:CollisionPair
PRESTEP_MARK9	srLib/srDyn/srDYN.cpp	/^void srDYN::PRESTEP_MARK9(SystemPtrArray & _systemptrarray, LinkPtrArray & _linkptrarray, JointPtrArray & _jointptrarray, SR_REAL & _timestep, SR_REAL & _fps)$/;"	f	class:srDYN
PRESTEP_Set_MassPair_______________________MARK9	srLib/srDyn/srContactConstraint.cpp	/^void	ContactConstraint::PRESTEP_Set_MassPair_______________________MARK9(MassPair* pmasspair)$/;"	f	class:ContactConstraint
PRESTEP_Test_Collision_____________________MARK7	srLib/srDyn/srContactConstraint.cpp	/^bool ContactConstraint::PRESTEP_Test_Collision_____________________MARK7()$/;"	f	class:ContactConstraint
PRISMATIC	srLib/srDyn/srJoint.h	/^	enum JOINTTYPE { REVOLUTE, PRISMATIC, UNIVERSAL, WELD, BALL };$/;"	e	enum:srJoint::JOINTTYPE
PTY	srLib/SceneGraph/Leaf.h	/^	struct PTY{$/;"	s	class:Lines
PTY	srLib/SceneGraph/Leaf.h	/^	struct PTY{$/;"	s	class:Strip
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::linspaced_op_impl
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_acos_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_add_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_asin_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_constant_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_cos_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_exp_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_log_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_multiple_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_quotient1_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sin_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_sqrt_op
Packet	Eigen/src/Core/Functors.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::scalar_tan_op
Packet	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SelfCwiseBinaryOp
Packet	Eigen/src/Core/Swap.h	/^    typedef typename internal::packet_traits<Scalar>::type Packet;$/;"	t	class:Eigen::SwapWrapper
Packet	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename Lhs::PacketScalar Packet;$/;"	t	struct:Eigen::internal::product_coeff_impl
Packet	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type Packet;$/;"	t	struct:Eigen::internal::gemm_pack_rhs
Packet16uc	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned char  Packet16uc;$/;"	t	namespace:Eigen::internal
Packet1cd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd() {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet1cd(const __m128d& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet1cd
Packet1cd	Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet1cd$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/AltiVec/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const Packet4f& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/NEON/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2cf	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf() {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE explicit Packet2cf(const __m128& a) : v(a) {}$/;"	f	struct:Eigen::internal::Packet2cf
Packet2cf	Eigen/src/Core/arch/SSE/Complex.h	/^struct Packet2cf$/;"	s	namespace:Eigen::internal
Packet2d	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128d Packet2d;$/;"	t	namespace:Eigen::internal
Packet4bi	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector __bool int     Packet4bi;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector float          Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef float32x4_t Packet4f;$/;"	t	namespace:Eigen::internal
Packet4f	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128  Packet4f;$/;"	t	namespace:Eigen::internal
Packet4i	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector int            Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef int32x4_t   Packet4i;$/;"	t	namespace:Eigen::internal
Packet4i	Eigen/src/Core/arch/SSE/PacketMath.h	/^typedef __m128i Packet4i;$/;"	t	namespace:Eigen::internal
Packet4ui	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector unsigned int   Packet4ui;$/;"	t	namespace:Eigen::internal
Packet4ui	Eigen/src/Core/arch/NEON/PacketMath.h	/^typedef uint32x4_t  Packet4ui;$/;"	t	namespace:Eigen::internal
Packet8i	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^typedef __vector short int      Packet8i;$/;"	t	namespace:Eigen::internal
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon47
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon48
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = false$/;"	e	enum:Eigen::internal::functor_traits::__anon49
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = internal::is_same<LhsScalar, RhsScalar>::value && packet_traits<LhsScalar>::HasMul$/;"	e	enum:Eigen::internal::functor_traits::__anon39
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasACos$/;"	e	enum:Eigen::internal::functor_traits::__anon78
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasASin$/;"	e	enum:Eigen::internal::functor_traits::__anon79
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAbs$/;"	e	enum:Eigen::internal::functor_traits::__anon51
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasAdd$/;"	e	enum:Eigen::internal::functor_traits::__anon35
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasConj$/;"	e	enum:Eigen::internal::functor_traits::__anon53
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasCos$/;"	e	enum:Eigen::internal::functor_traits::__anon75
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMax$/;"	e	enum:Eigen::internal::functor_traits::__anon41
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasMin$/;"	e	enum:Eigen::internal::functor_traits::__anon40
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasNegate };$/;"	e	enum:Eigen::internal::functor_traits::__anon50
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSin$/;"	e	enum:Eigen::internal::functor_traits::__anon76
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSqrt$/;"	e	enum:Eigen::internal::functor_traits::__anon74
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasSub$/;"	e	enum:Eigen::internal::functor_traits::__anon44
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = packet_traits<Scalar>::HasTan$/;"	e	enum:Eigen::internal::functor_traits::__anon77
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = scalar_product_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon37
PacketAccess	Eigen/src/Core/Functors.h	/^    PacketAccess = scalar_quotient_op<LhsScalar,RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::functor_traits::__anon46
PacketAccess	Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false };$/;"	e	enum:Eigen::internal::functor_traits::__anon43
PacketAccess	Eigen/src/Core/Functors.h	/^  enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess=0 };$/;"	e	enum:Eigen::internal::functor_traits::__anon42
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon102
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon103
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon104
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon105
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon55
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon56
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon57
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 0, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon58
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon100
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1 + functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon101
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon89
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon90
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon91
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon92
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon93
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon94
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon95
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon96
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon97
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::HasSetLinear, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon66
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 1, PacketAccess = packet_traits<Scalar>::Vectorizable, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon64
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 2 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon63
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 2*NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon83
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon80
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasExp }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon59
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasLog }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon60
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar1>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon62
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = false, IsRepeatable = true }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon65
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::AddCost, PacketAccess = packet_traits<Scalar>::HasAdd }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon73
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasAbs2 }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon52
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasDiv }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon81
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon61
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<Scalar>::MulCost, PacketAccess = packet_traits<Scalar>::HasMul }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon82
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon86
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon87
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon88
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon84
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = NumTraits<T>::MulCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon85
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost + functor_traits<T2>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon107
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T0>::Cost + functor_traits<T1>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon106
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon98
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = functor_traits<T>::Cost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon99
PacketAccess	Eigen/src/Core/Functors.h	/^{ enum { Cost = is_same<Scalar, NewType>::value ? 0 : NumTraits<NewType>::AddCost, PacketAccess = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon54
PacketAccess	Eigen/src/Core/Random.h	/^{ enum { Cost = 5 * NumTraits<Scalar>::MulCost, PacketAccess = false, IsRepeatable = false }; };$/;"	e	enum:Eigen::internal::functor_traits::__anon338
PacketAccessBit	Eigen/src/Core/util/Constants.h	/^const unsigned int PacketAccessBit = 0x8;$/;"	m	namespace:Eigen
PacketReturnType	Eigen/src/Core/DenseCoeffsBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::DenseCoeffsBase
PacketReturnType	Eigen/src/SparseCore/SparseMatrixBase.h	/^                     >::type PacketReturnType;$/;"	t	class:Eigen::SparseMatrixBase
PacketScalar	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::ArrayBase
PacketScalar	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseBase
PacketScalar	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::DenseCoeffsBase
PacketScalar	Eigen/src/Core/MapBase.h	/^    typedef typename Base::PacketScalar PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	Eigen/src/Core/MapBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MapBase
PacketScalar	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::MatrixBase
PacketScalar	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::PlainObjectBase
PacketScalar	Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_impl
PacketScalar	Eigen/src/Core/Redux.h	/^  typedef typename packet_traits<Scalar>::type PacketScalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
PacketScalar	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::packet_traits<Scalar>::type PacketScalar;$/;"	t	class:Eigen::SparseMatrixBase
PacketSize	Eigen/src/Cholesky/LLT.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::LLT::__anon427
PacketSize	Eigen/src/Core/Assign.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size$/;"	e	enum:Eigen::internal::assign_traits::__anon24
PacketSize	Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<Scalar>::size,$/;"	e	enum:Eigen::internal::redux_impl::__anon336
PacketSize	Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_traits::__anon327
PacketSize	Eigen/src/Core/Redux.h	/^    PacketSize = packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon334
PacketSize	Eigen/src/Core/Reverse.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::Reverse::__anon19
PacketSize	Eigen/src/Core/products/CoeffBasedProduct.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon123
PacketSize	Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_impl::__anon125
PacketSize	Eigen/src/Core/products/CoeffBasedProduct.h	/^  enum { PacketSize = packet_traits<typename Lhs::Scalar>::size };$/;"	e	enum:Eigen::internal::product_coeff_vectorized_unroller::__anon124
PacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon115
PacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::gemm_pack_rhs::__anon116
PacketSize	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  enum { PacketSize = packet_traits<Scalar>::size };$/;"	e	enum:Eigen::internal::symm_pack_rhs::__anon136
PacketSize	Eigen/src/Eigen2Support/SVD.h	/^      PacketSize = internal::packet_traits<Scalar>::size,$/;"	e	enum:Eigen::SVD::__anon396
ParameterAllocation	srMath/Interpolation.cpp	/^	VectorX ParameterAllocation(const MatrixX & points, const Real & xi, const Real & xf)$/;"	f	namespace:srMath
ParameterType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Array<Index,64,1,DontAlign> ParameterType;$/;"	t	class:Eigen::PardisoImpl
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/All.h	/^#define ParametrizedLine /;"	d
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ParametrizedLine$/;"	d
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(int _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const ParametrizedLine<Scalar,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  ParametrizedLine(const VectorType& origin, const VectorType& direction)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  inline ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(Index _dim) : m_origin(_dim), m_direction(_dim) {}$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  inline explicit ParametrizedLine(const ParametrizedLine<OtherScalarType,AmbientDimAtCompileTime,OtherOptions>& other)$/;"	f	class:Eigen::ParametrizedLine
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^class ParametrizedLine$/;"	c	namespace:Eigen
ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^inline ParametrizedLine<_Scalar, _AmbientDim,_Options>::ParametrizedLine(const Hyperplane<_Scalar, _AmbientDim,OtherOptions>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoImpl(PardisoImpl &) {}$/;"	f	class:Eigen::PardisoImpl
PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoImpl$/;"	c	namespace:Eigen
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT()$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(PardisoLDLT& ) {}$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
PardisoLDLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLDLT : public PardisoImpl< PardisoLDLT<MatrixType,Options> >$/;"	c	namespace:Eigen
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT()$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(PardisoLLT& ) {}$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLLT(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
PardisoLLT	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLLT : public PardisoImpl< PardisoLLT<MatrixType,_UpLo> >$/;"	c	namespace:Eigen
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU()$/;"	f	class:Eigen::PardisoLU
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(PardisoLU& ) {}$/;"	f	class:Eigen::PardisoLU
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^    PardisoLU(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
PardisoLU	Eigen/src/PardisoSupport/PardisoSupport.h	/^class PardisoLU : public PardisoImpl< PardisoLU<MatrixType> >$/;"	c	namespace:Eigen
Parent	tinyxml2/tinyxml2.h	/^    XMLNode* Parent()						{$/;"	f	class:tinyxml2::XMLNode
Parent	tinyxml2/tinyxml2.h	/^    const XMLNode*	Parent() const			{$/;"	f	class:tinyxml2::XMLNode
Parse	tinyxml2/tinyxml2.cpp	/^XMLError XMLDocument::Parse( const char* p, size_t len )$/;"	f	class:tinyxml2::XMLDocument
Parse	tinyxml2/tinyxml2.cpp	/^void XMLDocument::Parse()$/;"	f	class:tinyxml2::XMLDocument
ParseAttributes	tinyxml2/tinyxml2.cpp	/^char* XMLElement::ParseAttributes( char* p, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLElement
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLAttribute::ParseDeep( char* p, bool processEntities, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLAttribute
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLComment::ParseDeep( char* p, StrPair*, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLComment
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLDeclaration::ParseDeep( char* p, StrPair*, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLDeclaration
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLElement::ParseDeep( char* p, StrPair* strPair, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLElement
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLNode::ParseDeep( char* p, StrPair* parentEnd, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLNode
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLText::ParseDeep( char* p, StrPair*, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLText
ParseDeep	tinyxml2/tinyxml2.cpp	/^char* XMLUnknown::ParseDeep( char* p, StrPair*, int* curLineNumPtr )$/;"	f	class:tinyxml2::XMLUnknown
ParseName	tinyxml2/tinyxml2.cpp	/^char* StrPair::ParseName( char* p )$/;"	f	class:tinyxml2::StrPair
ParseText	tinyxml2/tinyxml2.cpp	/^char* StrPair::ParseText( char* p, const char* endTag, int strFlags, int* curLineNumPtr )$/;"	f	class:tinyxml2::StrPair
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU()$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(Index size)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>::PartialPivLU(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU
PartialPivLU	Eigen/src/LU/PartialPivLU.h	/^template<typename _MatrixType> class PartialPivLU$/;"	c	namespace:Eigen
PartialReduxExpr	Eigen/src/Core/VectorwiseOp.h	/^    PartialReduxExpr(const MatrixType& mat, const MemberOp& func = MemberOp())$/;"	f	class:Eigen::PartialReduxExpr
PartialReduxExpr	Eigen/src/Core/VectorwiseOp.h	/^class PartialReduxExpr : internal::no_assignment_operator,$/;"	c	namespace:Eigen
PastixBase	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixBase() : m_initisOk(false), m_analysisIsOk(false), m_factorizationIsOk(false), m_isInitialized(false), m_pastixdata(0), m_size(0)$/;"	f	class:Eigen::PastixBase
PastixBase	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixBase : internal::noncopyable$/;"	c	namespace:Eigen
PastixLDLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT():Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLDLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLDLT
PastixLDLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLDLT : public PastixBase< PastixLDLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT() : Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLLT(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLLT
PastixLLT	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLLT : public PastixBase< PastixLLT<_MatrixType, _UpLo> >$/;"	c	namespace:Eigen
PastixLU	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU() : Base()$/;"	f	class:Eigen::PastixLU
PastixLU	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    PastixLU(const MatrixType& matrix):Base()$/;"	f	class:Eigen::PastixLU
PastixLU	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^class PastixLU : public PastixBase< PastixLU<_MatrixType> >$/;"	c	namespace:Eigen
PeekTop	tinyxml2/tinyxml2.h	/^    const T& PeekTop() const            {$/;"	f	class:tinyxml2::DynArray
Penetration	srLib/srDyn/srContactConstraint.h	/^	SR_REAL	Penetration;$/;"	m	struct:Contact
Perm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef PermutationMatrix<Dynamic,Dynamic,Index> Perm;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
PermIndexType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename PermutationType::Index PermIndexType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermPermProduct	Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	e	enum:Eigen::internal::PermPermProduct_t
PermPermProduct_t	Eigen/src/Core/PermutationMatrix.h	/^enum PermPermProduct_t {PermPermProduct};$/;"	g	namespace:Eigen::internal
PermutType	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef SparseMatrix<Scalar,ColMajor> PermutType;$/;"	t	class:Eigen::IncompleteLUT
PermutationBase	Eigen/src/Core/PermutationMatrix.h	/^class PermutationBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(const Transpose<PermutationBase<Other> >& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix(internal::PermPermProduct_t, const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    explicit PermutationMatrix(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    explicit inline PermutationMatrix(const MatrixBase<Other>& a_indices) : m_indices(a_indices)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix()$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(const PermutationMatrix& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationMatrix(int size) : m_indices(size)$/;"	f	class:Eigen::PermutationMatrix
PermutationMatrix	Eigen/src/Core/PermutationMatrix.h	/^class PermutationMatrix : public PermutationBase<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	c	namespace:Eigen
PermutationPType	Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationPType;$/;"	t	class:Eigen::FullPivLU
PermutationQType	Eigen/src/LU/FullPivLU.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationQType;$/;"	t	class:Eigen::FullPivLU
PermutationStorage	Eigen/src/Core/PermutationMatrix.h	/^struct PermutationStorage {};$/;"	s	namespace:Eigen
PermutationType	Eigen/src/Cholesky/LDLT.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::LDLT
PermutationType	Eigen/src/Core/PermutationMatrix.h	/^    typedef Derived PermutationType;$/;"	t	class:Eigen::Transpose
PermutationType	Eigen/src/LU/PartialPivLU.h	/^    typedef PermutationMatrix<RowsAtCompileTime, MaxRowsAtCompileTime> PermutationType;$/;"	t	class:Eigen::PartialPivLU
PermutationType	Eigen/src/MetisSupport/MetisSupport.h	/^  typedef PermutationMatrix<Dynamic,Dynamic,Index> PermutationType;$/;"	t	class:Eigen::MetisOrdering
PermutationType	Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType; $/;"	t	class:Eigen::COLAMDOrdering
PermutationType	Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::AMDOrdering
PermutationType	Eigen/src/OrderingMethods/Ordering.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::NaturalOrdering
PermutationType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::ColPivHouseholderQR
PermutationType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef PermutationMatrix<ColsAtCompileTime, MaxColsAtCompileTime> PermutationType;$/;"	t	class:Eigen::FullPivHouseholderQR
PermutationType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef PermutationMatrix<Dynamic, Dynamic> PermutationType;$/;"	t	class:Eigen::SPQR
PermutationType	Eigen/src/SparseLU/SparseLU.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::SparseLU
PermutationType	Eigen/src/SparseQR/SparseQR.h	/^    typedef PermutationMatrix<Dynamic, Dynamic, Index> PermutationType;$/;"	t	class:Eigen::SparseQR
PermutationWrapper	Eigen/src/Core/PermutationMatrix.h	/^    inline PermutationWrapper(const IndicesType& a_indices)$/;"	f	class:Eigen::PermutationWrapper
PermutationWrapper	Eigen/src/Core/PermutationMatrix.h	/^class PermutationWrapper : public PermutationBase<PermutationWrapper<_IndicesType> >$/;"	c	namespace:Eigen
Perspective	srLib/srg/srgCamera.h	/^		Orthogonal, Perspective$/;"	e	enum:srgCamera::ProjectionType
Pivoting	Eigen/src/Core/util/Constants.h	/^  Pivoting            = 0x01, $/;"	e	enum:Eigen::DecompositionOptions
PlainObject	Eigen/src/Core/Array.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Array
PlainObject	Eigen/src/Core/ArrayBase.h	/^          > PlainObject;$/;"	t	class:Eigen::ArrayBase
PlainObject	Eigen/src/Core/DiagonalMatrix.h	/^    typedef DiagonalMatrix<Scalar,DiagonalVectorType::SizeAtCompileTime,DiagonalVectorType::MaxSizeAtCompileTime> PlainObject;$/;"	t	class:Eigen::DiagonalBase
PlainObject	Eigen/src/Core/Matrix.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::Matrix
PlainObject	Eigen/src/Core/MatrixBase.h	/^          > PlainObject;$/;"	t	class:Eigen::MatrixBase
PlainObject	Eigen/src/Core/ProductBase.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:ScaledProduct
PlainObject	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename MatrixType::PlainObject PlainObject;$/;"	t	class:Eigen::SelfAdjointView
PlainObject	Eigen/src/Core/TriangularMatrix.h	/^    typedef DenseMatrixType PlainObject;$/;"	t	class:Eigen::TriangularView
PlainObject	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename Base::PlainObject PlainObject;$/;"	t	class:Eigen::CoeffBasedProduct
PlainObject	Eigen/src/Geometry/Quaternion.h	/^  typedef Quaternion<_Scalar,_Options> PlainObject;$/;"	t	struct:Eigen::internal::traits
PlainObject	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrix<Scalar, Flags&RowMajorBit ? RowMajor : ColMajor, Index> PlainObject;$/;"	t	class:Eigen::SparseMatrixBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase() : m_storage()$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(Index a_size, Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const DenseBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PlainObjectBase(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    PlainObjectBase(PlainObjectBase&& other)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    PlainObjectBase(internal::constructor_without_unaligned_array_assert)$/;"	f	class:Eigen::PlainObjectBase
PlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^class PlainObjectBase : public internal::dense_xpr_base_dispatcher_for_doxygen<Derived>$/;"	c	namespace:Eigen
PlainObjectType	Eigen/src/Core/Ref.h	/^  typedef _PlainObjectType PlainObjectType;$/;"	t	struct:Eigen::internal::traits
PlainObjectType	Eigen/src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::PlainObjectType PlainObjectType;$/;"	t	class:Eigen::RefBase
PlainPermutationType	Eigen/src/Core/PermutationMatrix.h	/^            PlainPermutationType;$/;"	t	class:Eigen::PermutationBase
PlainPermutationType	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename PermutationType::PlainPermutationType PlainPermutationType;$/;"	t	class:Eigen::Transpose
PointState	srLib/srg/srgGeometryDraw.h	/^struct PointState$/;"	s
PointerArgType	Eigen/src/Core/Map.h	/^    typedef PointerType PointerArgType;$/;"	t	class:Eigen::Map
PointerArgType	Eigen/src/Core/Map.h	/^    typedef const Scalar* PointerArgType;$/;"	t	class:Eigen::Map
PointerType	Eigen/src/Core/Map.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::Map
PointerType	Eigen/src/Core/MapBase.h	/^                     PointerType;$/;"	t	class:Eigen::MapBase
PointerType	Eigen/src/Core/MapBase.h	/^    typedef typename Base::PointerType PointerType;$/;"	t	class:Eigen::MapBase
Polygon	srLib/SceneGraph/Leaf.cpp	/^Polygon::Polygon(double r \/*= 1*\/, double g \/*= 1 *\/, double b \/*=1*\/, double alpha)$/;"	f	class:Polygon
Polygon	srLib/SceneGraph/Leaf.h	/^class Polygon : public Leaf$/;"	c
Pop	tinyxml2/tinyxml2.h	/^    T Pop() {$/;"	f	class:tinyxml2::DynArray
PopArr	tinyxml2/tinyxml2.h	/^    void PopArr( int count ) {$/;"	f	class:tinyxml2::DynArray
PopAttrib	srLib/srg/srgColor.cpp	/^void srgColor::PopAttrib(void) const$/;"	f	class:srgColor
PopAttrib	srLib/srg/srgColor.cpp	/^void srgMaterialColor::PopAttrib(void) const$/;"	f	class:srgMaterialColor
PopAttrib_OnlyColor4	srLib/srg/srgColor.cpp	/^void srgMaterialColor::PopAttrib_OnlyColor4(void) const$/;"	f	class:srgMaterialColor
PopState	srLib/srDyn/srLink.cpp	/^void srLink::PopState(int index)$/;"	f	class:srLink
PopState	srLib/srDyn/srState.cpp	/^void srBallState::PopState(int index)$/;"	f	class:srBallState
PopState	srLib/srDyn/srState.cpp	/^void srRevoluteState::PopState(int index)$/;"	f	class:srRevoluteState
PopState	srLib/srDyn/srState.cpp	/^void srUniversalState::PopState(int index)$/;"	f	class:srUniversalState
PopState	srLib/srDyn/srState.h	/^	void PopState(int ) {};$/;"	f	class:srWeldState
PosDefMatrixInverse	srMath/Common.h	/^	static void PosDefMatrixInverse(const MatrixX& inmat, int dim, MatrixX& outmat)$/;"	f	namespace:srMath
PositiveSemiDef	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
PreconditionIfMoreColsThanRows	Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon417
PreconditionIfMoreRowsThanCols	Eigen/src/SVD/JacobiSVD.h	/^enum { PreconditionIfMoreColsThanRows, PreconditionIfMoreRowsThanCols };$/;"	e	enum:Eigen::internal::__anon417
Preconditioner	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::BiCGSTAB
Preconditioner	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	class:Eigen::ConjugateGradient
Preconditioner	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef _Preconditioner Preconditioner;$/;"	t	struct:Eigen::internal::traits
Preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename internal::traits<Derived>::Preconditioner Preconditioner;$/;"	t	class:Eigen::IterativeSolverBase
Prepare_for_Solver_________________________MARK7	srLib/srDyn/srContactConstraint.cpp	/^void		ContactConstraint::Prepare_for_Solver_________________________MARK7()$/;"	f	class:ContactConstraint
PreviousSibling	tinyxml2/tinyxml2.h	/^    XMLHandle PreviousSibling()												{$/;"	f	class:tinyxml2::XMLHandle
PreviousSibling	tinyxml2/tinyxml2.h	/^    XMLNode*	PreviousSibling()							{$/;"	f	class:tinyxml2::XMLNode
PreviousSibling	tinyxml2/tinyxml2.h	/^    const XMLConstHandle PreviousSibling() const									{$/;"	f	class:tinyxml2::XMLConstHandle
PreviousSibling	tinyxml2/tinyxml2.h	/^    const XMLNode*	PreviousSibling() const					{$/;"	f	class:tinyxml2::XMLNode
PreviousSiblingElement	tinyxml2/tinyxml2.cpp	/^const XMLElement* XMLNode::PreviousSiblingElement( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
PreviousSiblingElement	tinyxml2/tinyxml2.h	/^    XMLElement*	PreviousSiblingElement( const char* name = 0 ) {$/;"	f	class:tinyxml2::XMLNode
PreviousSiblingElement	tinyxml2/tinyxml2.h	/^    XMLHandle PreviousSiblingElement( const char* name = 0 )				{$/;"	f	class:tinyxml2::XMLHandle
PreviousSiblingElement	tinyxml2/tinyxml2.h	/^    const XMLConstHandle PreviousSiblingElement( const char* name = 0 ) const		{$/;"	f	class:tinyxml2::XMLConstHandle
Print	srLib/SceneGraph/Font.cpp	/^void srgString::Print( int x, int y, const char* string, ... )$/;"	f	class:srgString
Print	srLib/srg/srgFont.cpp	/^void srgString::Print( int x, int y, const char* string, ... )$/;"	f	class:srgString
Print	tinyxml2/tinyxml2.cpp	/^void XMLDocument::Print( XMLPrinter* streamer ) const$/;"	f	class:tinyxml2::XMLDocument
Print	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::Print( const char* format, ... )$/;"	f	class:tinyxml2::XMLPrinter
PrintError	tinyxml2/tinyxml2.cpp	/^void XMLDocument::PrintError() const$/;"	f	class:tinyxml2::XMLDocument
PrintSpace	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PrintSpace( int depth )$/;"	f	class:tinyxml2::XMLPrinter
PrintString	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PrintString( const char* p, bool restricted )$/;"	f	class:tinyxml2::XMLPrinter
ProcessEntities	tinyxml2/tinyxml2.h	/^    bool ProcessEntities() const		{$/;"	f	class:tinyxml2::XMLDocument
ProdRetType	Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProductReturnType<DenseMatrixType, OtherPlainObject>::Type ProdRetType;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
ProductBase	Eigen/src/Core/ProductBase.h	/^class ProductBase : public MatrixBase<Derived>$/;"	c	namespace:Eigen
ProductImplType	Eigen/src/Core/util/Constants.h	/^enum ProductImplType { CoeffBasedProductMode, LazyCoeffBasedProductMode, OuterProduct, InnerProduct, GemvProduct, GemmProduct };$/;"	g	namespace:Eigen
ProductReturnType	Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType$/;"	s	namespace:Eigen
ProductReturnType	Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,CoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductReturnType	Eigen/src/Core/GeneralProduct.h	/^struct ProductReturnType<Lhs,Rhs,LazyCoeffBasedProductMode>$/;"	s	namespace:Eigen
ProductType	Eigen/src/Geometry/Transform.h	/^    typedef internal::transform_transform_product_impl<Transform,Transform<Scalar,Dim,OtherMode,OtherOptions> > ProductType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
Projection	srMath/SO3.cpp	/^	SO3 SO3::Projection(const Matrix3& R)$/;"	f	class:srMath::SO3
ProjectionType	srLib/srg/srgCamera.h	/^	enum ProjectionType$/;"	g	class:srgCamera
Projective	Eigen/src/Core/util/Constants.h	/^  Projective    = 0x20$/;"	e	enum:Eigen::TransformTraits
Projective2d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,2,Projective> Projective2d;$/;"	t	namespace:Eigen
Projective2f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,2,Projective> Projective2f;$/;"	t	namespace:Eigen
Projective3d	Eigen/src/Geometry/Transform.h	/^typedef Transform<double,3,Projective> Projective3d;$/;"	t	namespace:Eigen
Projective3f	Eigen/src/Geometry/Transform.h	/^typedef Transform<float,3,Projective> Projective3f;$/;"	t	namespace:Eigen
Push	tinyxml2/tinyxml2.h	/^    void Push( T t ) {$/;"	f	class:tinyxml2::DynArray
PushArr	tinyxml2/tinyxml2.h	/^    T* PushArr( int count ) {$/;"	f	class:tinyxml2::DynArray
PushAttrib	srLib/srg/srgColor.cpp	/^void srgColor::PushAttrib(void) const$/;"	f	class:srgColor
PushAttrib	srLib/srg/srgColor.cpp	/^void srgMaterialColor::PushAttrib(void) const$/;"	f	class:srgMaterialColor
PushAttrib_OnlyColor4	srLib/srg/srgColor.cpp	/^void srgMaterialColor::PushAttrib_OnlyColor4(void) const$/;"	f	class:srgMaterialColor
PushAttribute	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, bool v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, const char* value )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, double v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, int v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushAttribute( const char* name, unsigned v )$/;"	f	class:tinyxml2::XMLPrinter
PushAttribute	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushAttribute(const char* name, int64_t v)$/;"	f	class:tinyxml2::XMLPrinter
PushComment	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushComment( const char* comment )$/;"	f	class:tinyxml2::XMLPrinter
PushDeclaration	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushDeclaration( const char* value )$/;"	f	class:tinyxml2::XMLPrinter
PushHeader	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushHeader( bool writeBOM, bool writeDec )$/;"	f	class:tinyxml2::XMLPrinter
PushState	srLib/srDyn/srLink.cpp	/^void srLink::PushState()$/;"	f	class:srLink
PushState	srLib/srDyn/srState.cpp	/^void srBallState::PushState()$/;"	f	class:srBallState
PushState	srLib/srDyn/srState.cpp	/^void srRevoluteState::PushState()$/;"	f	class:srRevoluteState
PushState	srLib/srDyn/srState.cpp	/^void srUniversalState::PushState()$/;"	f	class:srUniversalState
PushState	srLib/srDyn/srState.h	/^	void PushState() {};$/;"	f	class:srWeldState
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( bool value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( const char* text, bool cdata )$/;"	f	class:tinyxml2::XMLPrinter
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( double value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( float value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( int value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( int64_t value )$/;"	f	class:tinyxml2::XMLPrinter
PushText	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushText( unsigned value )$/;"	f	class:tinyxml2::XMLPrinter
PushUnknown	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::PushUnknown( const char* value )$/;"	f	class:tinyxml2::XMLPrinter
QR	Eigen/src/Eigen2Support/QR.h	/^    QR() : Base() {}$/;"	f	class:Eigen::QR
QR	Eigen/src/Eigen2Support/QR.h	/^    explicit QR(const T& t) : Base(t) {}$/;"	f	class:Eigen::QR
QR	Eigen/src/Eigen2Support/QR.h	/^class QR : public HouseholderQR<MatrixType>$/;"	c	namespace:Eigen
QRMatrixType	Eigen/src/SparseQR/SparseQR.h	/^    typedef SparseMatrix<Scalar,ColMajor,Index> QRMatrixType;$/;"	t	class:Eigen::SparseQR
QRPreconditioners	Eigen/src/Core/util/Constants.h	/^enum QRPreconditioners {$/;"	g	namespace:Eigen
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef ColPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef FullPivHouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<MatrixType> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QRType	Eigen/src/SVD/JacobiSVD.h	/^  typedef HouseholderQR<TransposeTypeWithSameStorageOrder> QRType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
QUOTE	srLib/SceneGraph/Model3DS.cpp	/^#define QUOTE(/;"	d	file:
QuadraticFunction	srMath/Function.h	/^		QuadraticFunction() {}$/;"	f	class:srMath::QuadraticFunction
QuadraticFunction	srMath/Function.h	/^	class QuadraticFunction : public Function$/;"	c	namespace:srMath
QuadricState	srLib/srg/srgGeometryDraw.h	/^struct QuadricState$/;"	s
Quaternion	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Quaternion /;"	d
Quaternion	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Quaternion$/;"	d
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(Scalar w, Scalar x, Scalar y, Scalar z)$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion(const Quaternion& other) { m_coeffs = other.m_coeffs; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline explicit Quaternion(const Quaternion<OtherScalarType>& other)$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^class Quaternion : public RotationBase<Quaternion<_Scalar>,3>$/;"	c	namespace:Eigen
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const AngleAxisType& aa) { *this = aa; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const MatrixBase<Derived>& other) { *this = other; }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  explicit inline Quaternion(const Quaternion<OtherScalar, OtherOptions>& other)$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion() {}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar& w, const Scalar& x, const Scalar& y, const Scalar& z) : m_coeffs(x, y, z, w){}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion(const Scalar* data) : m_coeffs(data) {}$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> EIGEN_STRONG_INLINE Quaternion(const QuaternionBase<Derived>& other) { this->Base::operator=(other); }$/;"	f	class:Eigen::Quaternion
Quaternion	Eigen/src/Geometry/Quaternion.h	/^class Quaternion : public QuaternionBase<Quaternion<_Scalar,_Options> >$/;"	c	namespace:Eigen
Quaternion	srLib/LieGroup/LieGroup.cpp	/^Quaternion::Quaternion(const SE3& m)$/;"	f	class:Quaternion
Quaternion	srLib/LieGroup/LieGroup.cpp	/^Quaternion::Quaternion(const Vec3& axis, SR_REAL angle)$/;"	f	class:Quaternion
Quaternion	srLib/LieGroup/LieGroup.h	/^	Quaternion() {};                                        \/\/ new Q$/;"	f	union:Quaternion
Quaternion	srLib/LieGroup/LieGroup.h	/^	Quaternion(SR_REAL xx, SR_REAL yy, SR_REAL zz, SR_REAL ww)$/;"	f	union:Quaternion
Quaternion	srLib/LieGroup/LieGroup.h	/^union Quaternion$/;"	u
QuaternionBase	Eigen/src/Geometry/Quaternion.h	/^class QuaternionBase : public RotationBase<Derived, 3>$/;"	c	namespace:Eigen
QuaternionMapAlignedd	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, Aligned>  QuaternionMapAlignedd;$/;"	t	namespace:Eigen
QuaternionMapAlignedf	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, Aligned>   QuaternionMapAlignedf;$/;"	t	namespace:Eigen
QuaternionMapd	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<double>, 0>        QuaternionMapd;$/;"	t	namespace:Eigen
QuaternionMapf	Eigen/src/Geometry/Quaternion.h	/^typedef Map<Quaternion<float>, 0>         QuaternionMapf;$/;"	t	namespace:Eigen
QuaternionType	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis
QuaternionType	Eigen/src/Geometry/AngleAxis.h	/^  typedef Quaternion<Scalar> QuaternionType;$/;"	t	class:Eigen::AngleAxis
Quaterniond	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Quaterniond /;"	d
Quaterniond	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Quaterniond$/;"	d
Quaterniond	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaterniond	Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<double> Quaterniond;$/;"	t	namespace:Eigen
Quaternionf	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Quaternionf /;"	d
Quaternionf	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Quaternionf$/;"	d
Quaternionf	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
Quaternionf	Eigen/src/Geometry/Quaternion.h	/^typedef Quaternion<float> Quaternionf;$/;"	t	namespace:Eigen
QueryAttribute	tinyxml2/tinyxml2.h	/^	int QueryAttribute( const char* name, bool* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	tinyxml2/tinyxml2.h	/^	int QueryAttribute( const char* name, double* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	tinyxml2/tinyxml2.h	/^	int QueryAttribute( const char* name, float* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	tinyxml2/tinyxml2.h	/^	int QueryAttribute( const char* name, int* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	tinyxml2/tinyxml2.h	/^	int QueryAttribute( const char* name, unsigned int* value ) const {$/;"	f	class:tinyxml2::XMLElement
QueryAttribute	tinyxml2/tinyxml2.h	/^	int QueryAttribute(const char* name, int64_t* value) const {$/;"	f	class:tinyxml2::XMLElement
QueryBoolAttribute	tinyxml2/tinyxml2.h	/^    XMLError QueryBoolAttribute( const char* name, bool* value ) const				{$/;"	f	class:tinyxml2::XMLElement
QueryBoolText	tinyxml2/tinyxml2.cpp	/^XMLError XMLElement::QueryBoolText( bool* bval ) const$/;"	f	class:tinyxml2::XMLElement
QueryBoolValue	tinyxml2/tinyxml2.cpp	/^XMLError XMLAttribute::QueryBoolValue( bool* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryDoubleAttribute	tinyxml2/tinyxml2.h	/^    XMLError QueryDoubleAttribute( const char* name, double* value ) const			{$/;"	f	class:tinyxml2::XMLElement
QueryDoubleText	tinyxml2/tinyxml2.cpp	/^XMLError XMLElement::QueryDoubleText( double* dval ) const$/;"	f	class:tinyxml2::XMLElement
QueryDoubleValue	tinyxml2/tinyxml2.cpp	/^XMLError XMLAttribute::QueryDoubleValue( double* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryFloatAttribute	tinyxml2/tinyxml2.h	/^    XMLError QueryFloatAttribute( const char* name, float* value ) const			{$/;"	f	class:tinyxml2::XMLElement
QueryFloatText	tinyxml2/tinyxml2.cpp	/^XMLError XMLElement::QueryFloatText( float* fval ) const$/;"	f	class:tinyxml2::XMLElement
QueryFloatValue	tinyxml2/tinyxml2.cpp	/^XMLError XMLAttribute::QueryFloatValue( float* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryInt64Attribute	tinyxml2/tinyxml2.h	/^	XMLError QueryInt64Attribute(const char* name, int64_t* value) const {$/;"	f	class:tinyxml2::XMLElement
QueryInt64Text	tinyxml2/tinyxml2.cpp	/^XMLError XMLElement::QueryInt64Text(int64_t* ival) const$/;"	f	class:tinyxml2::XMLElement
QueryInt64Value	tinyxml2/tinyxml2.cpp	/^XMLError XMLAttribute::QueryInt64Value(int64_t* value) const$/;"	f	class:tinyxml2::XMLAttribute
QueryIntAttribute	tinyxml2/tinyxml2.h	/^    XMLError QueryIntAttribute( const char* name, int* value ) const				{$/;"	f	class:tinyxml2::XMLElement
QueryIntText	tinyxml2/tinyxml2.cpp	/^XMLError XMLElement::QueryIntText( int* ival ) const$/;"	f	class:tinyxml2::XMLElement
QueryIntValue	tinyxml2/tinyxml2.cpp	/^XMLError XMLAttribute::QueryIntValue( int* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QueryUnsignedAttribute	tinyxml2/tinyxml2.h	/^    XMLError QueryUnsignedAttribute( const char* name, unsigned int* value ) const	{$/;"	f	class:tinyxml2::XMLElement
QueryUnsignedText	tinyxml2/tinyxml2.cpp	/^XMLError XMLElement::QueryUnsignedText( unsigned* uval ) const$/;"	f	class:tinyxml2::XMLElement
QueryUnsignedValue	tinyxml2/tinyxml2.cpp	/^XMLError XMLAttribute::QueryUnsignedValue( unsigned int* value ) const$/;"	f	class:tinyxml2::XMLAttribute
QuickSplit	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^Index QuickSplit(VectorV &row, VectorI &ind, Index ncut)$/;"	f	namespace:Eigen::internal
R	srLib/srg/srgColor.h	/^	typedef struct _sRGBA { float R; float G; float B; float A; } SRGBA;$/;"	m	struct:srgColor::_sRGBA
RAD2DEG	srLib/common/types.h	/^inline SR_REAL RAD2DEG(double r){ return (r * SR_DEGREE); }$/;"	f
RAD2DEG	srLib/common/types.h	/^inline SR_REAL RAD2DEG(float r) { return (r * SR_DEGREE); }$/;"	f
RAD2DEG	srLib/common/types.h	/^inline SR_REAL RAD2DEG(int r)	 { return (r * SR_DEGREE); }$/;"	f
RAD2DEG	srMath/Constant.h	/^	static const Real	RAD2DEG = 57.2957795130823208768;				\/\/\/< deg = RAD2DEG * rad$/;"	m	namespace:srMath
RADIAN_TO_DEGREE	srLib/srDyn/srDYN.cpp	/^#define RADIAN_TO_DEGREE	/;"	d	file:
RANGE	srLib/SceneGraph/Leaf.h	/^	GLdouble	RANGE;$/;"	m	class:Grid
RANGEFINDER	srLib/srDyn/srSensor.h	/^	enum SENSORTYPE { IRSENSOR, RANGEFINDER, TOUCHSENSOR };$/;"	e	enum:srSensor::SENSORTYPE
REF_BLUR_PERC	srLib/SceneGraph/Model3DS.cpp	/^   #define REF_BLUR_PERC	/;"	d	file:
REF_FRAME	srLib/srExt/srExt_System.h	/^		enum REF_FRAME$/;"	g	class:srExt::srExtSystem
RENDER_TYPE	srLib/SceneGraph/Model3DS.cpp	/^   #define RENDER_TYPE	/;"	d	file:
RESTITUTIONCOEFF_EPS	srLib/srDyn/srContactConstraint.h	/^#define RESTITUTIONCOEFF_EPS	/;"	d
REVOLUTE	srLib/srDyn/srJoint.h	/^	enum JOINTTYPE { REVOLUTE, PRISMATIC, UNIVERSAL, WELD, BALL };$/;"	e	enum:srJoint::JOINTTYPE
RGL_CAMERA_APPROACH_INV_RATE	srLib/srg/srgCamera.h	/^#define RGL_CAMERA_APPROACH_INV_RATE	/;"	d
RGL_CAMERA_MIN_FOCUSLENGTH	srLib/srg/srgCamera.h	/^#define RGL_CAMERA_MIN_FOCUSLENGTH	/;"	d
RJidx_	Example/DracoP1/draco.h	/^  int RJidx_;$/;"	m	class:srDraco
RM	build/Example/DracoP1/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/LieGroup/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/SceneGraph/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/common/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/srDyn/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/srExt/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srLib/srg/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/srMath/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
RM	build/tinyxml2/Makefile	/^RM = \/usr\/local\/bin\/cmake -E remove -f$/;"	m
ROW_IS_ALIVE	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define ROW_IS_ALIVE(/;"	d
ROW_IS_DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define ROW_IS_DEAD(/;"	d
ROW_IS_MARKED_DEAD	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^#define ROW_IS_MARKED_DEAD(/;"	d
RUNTIME_MARK9	srLib/srDyn/srDYN.cpp	/^void srDYN::RUNTIME_MARK9()$/;"	f	class:srDYN
RUNTIME_MARKKH	srLib/srDyn/srDYN.cpp	/^bool srDYN::RUNTIME_MARKKH()$/;"	f	class:srDYN
Random	Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random()$/;"	f	class:Eigen::DenseBase
Random	Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index rows, Index cols)$/;"	f	class:Eigen::DenseBase
Random	Eigen/src/Core/Random.h	/^DenseBase<Derived>::Random(Index size)$/;"	f	class:Eigen::DenseBase
RandomAccessLinSpacedReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,true>,Derived> RandomAccessLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
RandomAccessPattern	Eigen/src/SparseCore/SparseUtil.h	/^const int RandomAccessPattern       = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern;$/;"	m	namespace:Eigen
RayDetection	srLib/srDyn/srCollision.cpp	/^bool srCollision::RayDetection(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist)$/;"	f	class:srCollision
RayToCylinder	srLib/srDyn/srCollision.cpp	/^bool RayToCylinder(Vec3& point, Vec3& direction, SR_REAL& range, $/;"	f
RayToSphere	srLib/srDyn/srCollision.cpp	/^bool RayToSphere(Vec3& point,Vec3& direction, SR_REAL& range, $/;"	f
ReadBOM	tinyxml2/tinyxml2.cpp	/^const char* XMLUtil::ReadBOM( const char* p, bool* bom )$/;"	f	class:tinyxml2::XMLUtil
ReadCost	Eigen/src/Core/NumTraits.h	/^    ReadCost = 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon337
ReadOnlyAccessors	Eigen/src/Core/util/Constants.h	/^  ReadOnlyAccessors, $/;"	e	enum:Eigen::AccessorLevels
ReadOnlyMapBase	Eigen/src/Core/MapBase.h	/^    typedef MapBase<Derived, ReadOnlyAccessors> ReadOnlyMapBase;$/;"	t	class:Eigen::MapBase
Real	Eigen/src/Core/NumTraits.h	/^  typedef T Real;$/;"	t	struct:Eigen::GenericNumTraits
Real	srMath/Constant.h	/^	typedef	double	Real;$/;"	t	namespace:srMath
RealBigger	srMath/Common.h	/^	static bool RealBigger(const Eigen::MatrixBase<T>& op1, const Real& op2)$/;"	f	namespace:srMath
RealBigger	srMath/Common.h	/^	static bool RealBigger(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
RealBigger	srMath/Common.h	/^	static bool RealBigger(const Real& op1, const Real& op2, const Real& eps)$/;"	f	namespace:srMath
RealBiggerEqual	srMath/Common.h	/^	static bool RealBiggerEqual(const Eigen::MatrixBase<T>& op1, const Real& op2)$/;"	f	namespace:srMath
RealBiggerEqual	srMath/Common.h	/^	static bool RealBiggerEqual(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
RealBiggerEqual	srMath/Common.h	/^	static bool RealBiggerEqual(const Real& op1, const Real& op2, const Real& eps)$/;"	f	namespace:srMath
RealEps	srMath/Constant.h	/^	static const Real	RealEps = std::numeric_limits<Real>::epsilon();$/;"	m	namespace:srMath
RealEqual	srMath/Common.h	/^	static bool RealEqual(const Eigen::MatrixBase<T1>& op1, const Eigen::MatrixBase<T2>& op2)$/;"	f	namespace:srMath
RealEqual	srMath/Common.h	/^	static bool RealEqual(const Eigen::MatrixBase<T>& op1, const Real& op2)$/;"	f	namespace:srMath
RealEqual	srMath/Common.h	/^	static bool RealEqual(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
RealEqual	srMath/Common.h	/^	static bool RealEqual(const Real& op1, const Real& op2, const Real& eps)$/;"	f	namespace:srMath
RealLess	srMath/Common.h	/^	static bool RealLess(const Eigen::MatrixBase<T>& op1, const Real& op2)$/;"	f	namespace:srMath
RealLess	srMath/Common.h	/^	static bool RealLess(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
RealLess	srMath/Common.h	/^	static bool RealLess(const Real& op1, const Real& op2, const Real& eps)$/;"	f	namespace:srMath
RealLessEqual	srMath/Common.h	/^	static bool RealLessEqual(const Eigen::MatrixBase<T>& op1, const Real& op2)$/;"	f	namespace:srMath
RealLessEqual	srMath/Common.h	/^	static bool RealLessEqual(const Real& op1, const Real& op2)$/;"	f	namespace:srMath
RealLessEqual	srMath/Common.h	/^	static bool RealLessEqual(const Real& op1, const Real& op2, const Real& eps)$/;"	f	namespace:srMath
RealMax	srMath/Constant.h	/^	static const Real	RealMax = std::numeric_limits<Real>::max();$/;"	m	namespace:srMath
RealMin	srMath/Constant.h	/^	static const Real	RealMin = std::numeric_limits<Real>::lowest();$/;"	m	namespace:srMath
RealPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RealScalar>::type RealPacket;$/;"	t	class:Eigen::internal::gebp_traits
RealPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacketSize  = Vectorizable ? packet_traits<RealScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
RealQZ	Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime) : $/;"	f	class:Eigen::RealQZ
RealQZ	Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ(const MatrixType& A, const MatrixType& B, bool computeQZ = true) :$/;"	f	class:Eigen::RealQZ
RealQZ	Eigen/src/Eigenvalues/RealQZ.h	/^  template<typename _MatrixType> class RealQZ$/;"	c	namespace:Eigen
RealReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^                  >::type RealReturnType;$/;"	t
RealRowVectorType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType, RealScalar>::type RealRowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RealScalar	Eigen/src/Cholesky/LDLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LDLT
RealScalar	Eigen/src/Cholesky/LLT.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LLT
RealScalar	Eigen/src/Cholesky/LLT.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::llt_inplace
RealScalar	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::CholmodBase
RealScalar	Eigen/src/Core/ArrayBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ArrayBase
RealScalar	Eigen/src/Core/DenseBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseBase
RealScalar	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::DenseCoeffsBase
RealScalar	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::RealScalar RealScalar;$/;"	t	class:Eigen::DiagonalBase
RealScalar	Eigen/src/Core/Dot.h	/^  typedef typename NumTraits<typename traits<Derived>::Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::lpNorm_selector
RealScalar	Eigen/src/Core/IO.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::significant_decimals_default_impl
RealScalar	Eigen/src/Core/MapBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MapBase
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef bool RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::abs2_impl_default
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::atanh2_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::hypot_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::imag_ref_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::norm1_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_default_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::real_ref_impl
RealScalar	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::scalar_fuzzy_default_impl
RealScalar	Eigen/src/Core/MatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::MatrixBase
RealScalar	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::PlainObjectBase
RealScalar	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointView
RealScalar	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::RealScalar RealScalar;$/;"	t	class:Eigen::VectorwiseOp
RealScalar	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::AlignedBox
RealScalar	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane
RealScalar	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine
RealScalar	Eigen/src/Eigen2Support/LU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::LU
RealScalar	Eigen/src/Eigen2Support/SVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::SVD
RealScalar	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexEigenSolver
RealScalar	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ComplexSchur
RealScalar	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::EigenSolver
RealScalar	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
RealScalar	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::HessenbergDecomposition
RealScalar	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
RealScalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Tridiagonalization
RealScalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
RealScalar	Eigen/src/Geometry/AlignedBox.h	/^  typedef typename ScalarTraits::Real               RealScalar;$/;"	t	class:Eigen::AlignedBox
RealScalar	Eigen/src/Geometry/Hyperplane.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::Hyperplane
RealScalar	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
RealScalar	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::ParametrizedLine
RealScalar	Eigen/src/Geometry/Quaternion.h	/^  typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::QuaternionBase
RealScalar	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::BiCGSTAB
RealScalar	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ConjugateGradient
RealScalar	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::IncompleteLUT
RealScalar	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::IterativeSolverBase
RealScalar	Eigen/src/Jacobi/Jacobi.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiRotation
RealScalar	Eigen/src/LU/FullPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::FullPivLU
RealScalar	Eigen/src/LU/PartialPivLU.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::PartialPivLU
RealScalar	Eigen/src/LU/PartialPivLU.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::partial_lu_impl
RealScalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::PastixBase
RealScalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pastix_traits
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLDLT
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLLT
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoLU
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::RealScalar RealScalar;$/;"	t	class:Eigen::PardisoImpl
RealScalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::pardiso_traits
RealScalar	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::ColPivHouseholderQR
RealScalar	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::FullPivHouseholderQR
RealScalar	Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::HouseholderQR
RealScalar	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SPQR
RealScalar	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename NumTraits<typename MatrixType::Scalar>::Real RealScalar;$/;"	t	class:Eigen::JacobiSVD
RealScalar	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
RealScalar	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholesky
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLDLT
RealScalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SimplicialLLT
RealScalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector
RealScalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
RealScalar	Eigen/src/SparseCore/CompressedStorage.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::internal::CompressedStorage
RealScalar	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename NumTraits<Scalar>::Real RealScalar;$/;"	t	class:Eigen::SparseMatrixBase
RealScalar	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename ResultType::RealScalar RealScalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
RealScalar	Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::RealScalar RealScalar; $/;"	t	class:Eigen::SparseLU
RealScalar	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef typename ScalarVector::RealScalar RealScalar; $/;"	t	class:Eigen::internal::SparseLUImpl
RealScalar	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SparseQR
RealScalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperILU
RealScalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLU
RealScalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::SuperLUBase
RealScalar	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::RealScalar RealScalar;$/;"	t	class:Eigen::UmfPackLU
RealSchur	Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(Index size = RowsAtCompileTime==Dynamic ? 1 : RowsAtCompileTime)$/;"	f	class:Eigen::RealSchur
RealSchur	Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur(const MatrixType& matrix, bool computeU = true)$/;"	f	class:Eigen::RealSchur
RealSchur	Eigen/src/Eigenvalues/RealSchur.h	/^template<typename _MatrixType> class RealSchur$/;"	c	namespace:Eigen
RealVectorType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename internal::plain_col_type<MatrixType, RealScalar>::type RealVectorType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
ReduxReturnType	Eigen/src/Core/VectorwiseOp.h	/^    template<typename BinaryOp> struct ReduxReturnType$/;"	s	class:Eigen::VectorwiseOp
Ref	Eigen/src/Core/Ref.h	/^    inline Ref(PlainObjectBase<Derived>& expr,$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^    inline Ref(const DenseBase<Derived>& expr,$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^    inline Ref(const Ref& other) : Base(other) {$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^    inline Ref(const RefBase<OtherRef>& other) {$/;"	f	class:Eigen::Ref
Ref	Eigen/src/Core/Ref.h	/^template<typename PlainObjectType, int Options, typename StrideType> class Ref$/;"	c	namespace:Eigen
Ref	Eigen/src/Core/Ref.h	/^template<typename TPlainObjectType, int Options, typename StrideType> class Ref<const TPlainObjectType, Options, StrideType>$/;"	c	namespace:Eigen
RefBase	Eigen/src/Core/Ref.h	/^  RefBase()$/;"	f	class:Eigen::RefBase
RefBase	Eigen/src/Core/Ref.h	/^template<typename Derived> class RefBase$/;"	c	namespace:Eigen
RelativeFrame	srLib/srDyn/srClosedLoopConstraint.h	/^	SE3		RelativeFrame;$/;"	m	class:ClosedLoop
RelativeFrame	srLib/srDyn/srSystem.h	/^		SE3		 RelativeFrame;$/;"	m	struct:srSystem::linkpair_for_closedloop
RemoveCollision	srLib/srDyn/srLink.cpp	/^void srLink::RemoveCollision(srCollision* pCollision)$/;"	f	class:srLink
RemoveContactPoint	srLib/srDyn/srContactConstraint.cpp	/^inline void		ContactConstraint::RemoveContactPoint(int _index)$/;"	f	class:ContactConstraint
RemoveObject	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::RemoveObject(srCollision* object)$/;"	f	class:srIRSensor
RemoveObject	srLib/srDyn/srObject.cpp	/^void srObject::RemoveObject(srObject* obj)$/;"	f	class:srObject
RemoveObject	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::RemoveObject(srCollision* object)$/;"	f	class:srRangeFinder
RemoveObject	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::RemoveObject(srCollision* object)$/;"	f	class:srTouchSensor
RemoveSensor	srLib/srDyn/srLink.cpp	/^void srLink::RemoveSensor(srSensor* pSensor)$/;"	f	class:srLink
RemovedBits	Eigen/src/SparseCore/SparseProduct.h	/^    RemovedBits = ~(EvalToRowMajor ? 0 : RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon390
Rendering_Fnc	Example/DracoP1/Draco_Dyn_environment.cpp	/^void Draco_Dyn_environment::Rendering_Fnc()$/;"	f	class:Draco_Dyn_environment
Replicate	Eigen/src/Core/Replicate.h	/^    inline Replicate(const OriginalMatrixType& a_matrix, Index rowFactor, Index colFactor)$/;"	f	class:Eigen::Replicate
Replicate	Eigen/src/Core/Replicate.h	/^    inline explicit Replicate(const OriginalMatrixType& a_matrix)$/;"	f	class:Eigen::Replicate
Replicate	Eigen/src/Core/Replicate.h	/^template<typename MatrixType,int RowFactor,int ColFactor> class Replicate$/;"	c	namespace:Eigen
ReplicateReturnType	Eigen/src/Core/DenseBase.h	/^    typedef Replicate<Derived,Dynamic,Dynamic> ReplicateReturnType;$/;"	t	class:Eigen::DenseBase
ReplicateReturnType	Eigen/src/Core/VectorwiseOp.h	/^    typedef Replicate<ExpressionType,Direction==Vertical?Dynamic:1,Direction==Horizontal?Dynamic:1> ReplicateReturnType;$/;"	t	class:Eigen::VectorwiseOp
ReportTriangles	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::ReportTriangles(vector<Triangle> *trigs)$/;"	f	class:Model3DS
RequireInitialization	Eigen/src/Core/NumTraits.h	/^    RequireInitialization = internal::is_arithmetic<T>::value ? 0 : 1,$/;"	e	enum:Eigen::GenericNumTraits::__anon337
Res	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseResType>::type Res;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResPacket ResPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,ScalarPacket,Scalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
ResPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_ResPacket,ResScalar>::type ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize   = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Traits::ResPacketSize$/;"	e	enum:Eigen::internal::gebp_kernel::__anon114
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
ResPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
ResPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon130
ResPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  ResPacketSize = Vectorizable ? packet_traits<ResScalar>::size : 1$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon131
ResScalar	Eigen/src/Core/Dot.h	/^  typedef typename scalar_product_traits<typename traits<T>::Scalar,typename traits<U>::Scalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::dot_nocheck
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::gebp_kernel
ResScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	class:Eigen::internal::gebp_traits
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef           Scalar      ResScalar;$/;"	t	class:Eigen::GeneralProduct
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_product
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename Traits::ResScalar ResScalar;$/;"	t	struct:Eigen::internal::tribb_kernel
ResScalar	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_matrix_triangular_product
ResScalar	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
ResScalar	Eigen/src/Core/products/TriangularMatrixVector.h	/^  typedef typename scalar_product_traits<LhsScalar, RhsScalar>::ReturnType ResScalar;$/;"	t	struct:Eigen::internal::triangular_matrix_vector_product
Reset	srLib/srg/srgCamera.cpp	/^void srgCamera::Reset(void)$/;"	f	class:srgCamera
Reset	tinyxml2/tinyxml2.cpp	/^void StrPair::Reset()$/;"	f	class:tinyxml2::StrPair
ResetAcc	srLib/srDyn/srState.cpp	/^void srBallState::ResetAcc()$/;"	f	class:srBallState
ResetAcc	srLib/srDyn/srState.cpp	/^void srRevoluteState::ResetAcc()$/;"	f	class:srRevoluteState
ResetAcc	srLib/srDyn/srState.cpp	/^void srUniversalState::ResetAcc()$/;"	f	class:srUniversalState
ResetAcc	srLib/srDyn/srState.h	/^	void ResetAcc() {};$/;"	f	class:srWeldState
ResetCommand	srLib/srDyn/srState.cpp	/^void srBallState::ResetCommand()$/;"	f	class:srBallState
ResetCommand	srLib/srDyn/srState.cpp	/^void srRevoluteState::ResetCommand()$/;"	f	class:srRevoluteState
ResetCommand	srLib/srDyn/srState.cpp	/^void srUniversalState::ResetCommand()$/;"	f	class:srUniversalState
ResetCommand	srLib/srDyn/srState.h	/^	void ResetCommand() {};$/;"	f	class:srWeldState
ResetConstraintImpulse	srLib/srDyn/srState.cpp	/^void srBallState::ResetConstraintImpulse()$/;"	f	class:srBallState
ResetConstraintImpulse	srLib/srDyn/srState.cpp	/^void srRevoluteState::ResetConstraintImpulse()$/;"	f	class:srRevoluteState
ResetConstraintImpulse	srLib/srDyn/srState.cpp	/^void srUniversalState::ResetConstraintImpulse()$/;"	f	class:srUniversalState
ResetConstraintImpulse	srLib/srDyn/srState.h	/^	void ResetConstraintImpulse() {};$/;"	f	class:srWeldState
ResetPosErrVel	srLib/srDyn/srState.cpp	/^void srBallState::ResetPosErrVel()$/;"	f	class:srBallState
ResetPosErrVel	srLib/srDyn/srState.cpp	/^void srRevoluteState::ResetPosErrVel()$/;"	f	class:srRevoluteState
ResetPosErrVel	srLib/srDyn/srState.cpp	/^void srUniversalState::ResetPosErrVel()$/;"	f	class:srUniversalState
ResetPosErrVel	srLib/srDyn/srState.h	/^	void ResetPosErrVel() {};$/;"	f	class:srWeldState
ResetPosErrVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::ResetPosErrVelocity()$/;"	f	class:srSystem
ResetSensor	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::ResetSensor()$/;"	f	class:srIRSensor
ResetSensor	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::ResetSensor()$/;"	f	class:srRangeFinder
ResetSensor	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::ResetSensor()$/;"	f	class:srTouchSensor
ResetSimulationTime	srLib/srDyn/srSpace.cpp	/^void srSpace::ResetSimulationTime()$/;"	f	class:srSpace
ResetUserExternalForce	srLib/srDyn/srLink.cpp	/^void srLink::ResetUserExternalForce()$/;"	f	class:srLink
ResetVel	srLib/srDyn/srState.cpp	/^void srBallState::ResetVel()$/;"	f	class:srBallState
ResetVel	srLib/srDyn/srState.cpp	/^void srRevoluteState::ResetVel()$/;"	f	class:srRevoluteState
ResetVel	srLib/srDyn/srState.cpp	/^void srUniversalState::ResetVel()$/;"	f	class:srUniversalState
ResetVel	srLib/srDyn/srState.h	/^	void ResetVel() {};$/;"	f	class:srWeldState
RestoreInitState	srLib/srDyn/srLink.cpp	/^void srLink::RestoreInitState()$/;"	f	class:srLink
RestoreInitState	srLib/srDyn/srState.cpp	/^void srBallState::RestoreInitState()$/;"	f	class:srBallState
RestoreInitState	srLib/srDyn/srState.cpp	/^void srRevoluteState::RestoreInitState()$/;"	f	class:srRevoluteState
RestoreInitState	srLib/srDyn/srState.cpp	/^void srUniversalState::RestoreInitState()$/;"	f	class:srUniversalState
RestoreInitState	srLib/srDyn/srState.h	/^	void RestoreInitState() {};$/;"	f	class:srWeldState
RestoreInitState	srLib/srDyn/srSystem.cpp	/^void srSystem::RestoreInitState()$/;"	f	class:srSystem
ResultAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment     = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon429
ResultAlignment	Eigen/src/LU/arch/Inverse_SSE.h	/^    ResultAlignment = bool(ResultType::Flags&AlignedBit),$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon430
ResultMode	Eigen/src/Geometry/Transform.h	/^  enum { ResultMode = transform_product_result<LhsMode,RhsMode>::Mode };$/;"	e	enum:Eigen::internal::transform_transform_product_impl::__anon456
ResultScalar	Eigen/src/Householder/HouseholderSequence.h	/^    ResultScalar;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
ResultType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl
ResultType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl
ResultType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename ProductReturnType<MatrixType,Other>::Type ResultType;$/;"	t	struct:Eigen::ei_transform_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^    typedef typename ProductType::ResultType ResultType;$/;"	t	struct:Eigen::Transform::icc_11_workaround
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,ResultMode,LhsOptions> ResultType;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Projective,Options> ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef TransformType ResultType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
ResultType	Eigen/src/Geometry/Transform.h	/^  typedef typename MatrixType::PlainObject ResultType;$/;"	t	struct:Eigen::internal::transform_right_product_impl
ReturnByValue	Eigen/src/Core/ReturnByValue.h	/^template<typename Derived> class ReturnByValue$/;"	c	namespace:Eigen
ReturnOpposite	Eigen/src/Core/BandMatrix.h	/^        ReturnOpposite = (Options&SelfAdjoint) && (((Index)>0 && Supers==0) || ((Index)<0 && Subs==0)),$/;"	e	enum:Eigen::internal::BandMatrixBase::DiagonalIntReturnType::__anon214
ReturnType	Eigen/src/Core/PermutationMatrix.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Core/ReturnByValue.h	/^    typedef typename internal::traits<Derived>::ReturnType ReturnType;$/;"	t	class:Eigen::ReturnByValue
ReturnType	Eigen/src/Core/SolveTriangular.h	/^  typedef typename internal::plain_matrix_type_column_major<Rhs>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Core/Transpositions.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Core/VectorwiseOp.h	/^                      typename Scalar=typename internal::traits<ExpressionType>::Scalar> struct ReturnType$/;"	s	class:Eigen::VectorwiseOp
ReturnType	Eigen/src/Core/util/Meta.h	/^  typedef T ReturnType;$/;"	t	struct:Eigen::scalar_product_traits
ReturnType	Eigen/src/Core/util/Meta.h	/^  typedef std::complex<T> ReturnType;$/;"	t	struct:Eigen::scalar_product_traits
ReturnType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^  typedef MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Geometry/Homogeneous.h	/^                 MatrixTypeCleaned::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Geometry/Homogeneous.h	/^                 Rhs::MaxColsAtCompileTime>::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,1> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	Eigen/src/Geometry/RotationBase.h	/^  typedef Matrix<typename RotationDerived::Scalar,Dim,Dim> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	Eigen/src/Geometry/RotationBase.h	/^  typedef Transform<Scalar,Dim,Affine> ReturnType;$/;"	t	struct:Eigen::internal::rotation_base_generic_product_selector
ReturnType	Eigen/src/LU/Inverse.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/QR/FullPivHouseholderQR.h	/^  typedef typename MatrixType::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^      typedef typename SPQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SparseCore/SparsePermutation.h	/^        SparseMatrix<Scalar,int(SrcStorageOrder)==RowMajor?ColMajor:RowMajor,Index> >::type ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename Derived::PlainObject ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename SparseQRType::MatrixType ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/Image.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/Kernel.h	/^  > ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/Solve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/SparseSolve.h	/^                 Rhs::MaxColsAtCompileTime> ReturnType;$/;"	t	struct:Eigen::internal::traits
ReturnType	Eigen/src/misc/SparseSolve.h	/^  typedef SparseMatrix<typename Rhs::Scalar, Rhs::Options, typename Rhs::Index> ReturnType;$/;"	t	struct:Eigen::internal::traits
Reverse	Eigen/src/Core/Reverse.h	/^    inline Reverse(const MatrixType& matrix) : m_matrix(matrix) { }$/;"	f	class:Eigen::Reverse
Reverse	Eigen/src/Core/Reverse.h	/^template<typename MatrixType, int Direction> class Reverse$/;"	c	namespace:Eigen
ReverseCol	Eigen/src/Core/Reverse.h	/^      ReverseCol = (Direction == Horizontal) || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon19
ReverseInnerIterator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    ReverseInnerIterator(const MappedSparseMatrix& mat, Index outer)$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/MappedSparseMatrix.h	/^class MappedSparseMatrix<Scalar,_Flags,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::MappedSparseMatrix
ReverseInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^        inline ReverseInnerIterator(const BlockType& xpr, Index outer)$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^      EIGEN_STRONG_INLINE ReverseInnerIterator(const BlockType& block, Index outer)$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator : public _MatrixTypeNested::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl
ReverseInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public SparseMatrixType::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl
ReverseInnerIterator	Eigen/src/SparseCore/SparseBlock.h	/^    class ReverseInnerIterator: public XprType::ReverseInnerIterator$/;"	c	class:Eigen::BlockImpl
ReverseInnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryOpImpl& unaryOp, typename CwiseUnaryOpImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const CwiseUnaryViewImpl& unaryOp, typename CwiseUnaryViewImpl::Index outer)$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryOpImpl<UnaryOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryOpImpl
ReverseInnerIterator	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^class CwiseUnaryViewImpl<ViewOp,MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::CwiseUnaryViewImpl
ReverseInnerIterator	Eigen/src/SparseCore/SparseMatrix.h	/^    ReverseInnerIterator(const SparseMatrix& mat, Index outer)$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseMatrix
ReverseInnerIterator	Eigen/src/SparseCore/SparseTranspose.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const TransposeImpl& xpr, typename TransposeImpl<MatrixType,Sparse>::Index outer)$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>::ReverseInnerIterator$/;"	c	class:Eigen::TransposeImpl
ReverseInnerIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator(const SparseTriangularView& view, Index outer)$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseTriangularView.h	/^class SparseTriangularView<MatrixType,Mode>::ReverseInnerIterator : public MatrixTypeNestedCleaned::ReverseInnerIterator$/;"	c	class:Eigen::SparseTriangularView
ReverseInnerIterator	Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const SparseVector& vec, Index outer=0)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseVector.h	/^    ReverseInnerIterator(const internal::CompressedStorage<Scalar,Index>& data)$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
ReverseInnerIterator	Eigen/src/SparseCore/SparseVector.h	/^class SparseVector<Scalar,_Options,_Index>::ReverseInnerIterator$/;"	c	class:Eigen::SparseVector
ReversePacket	Eigen/src/Core/Reverse.h	/^      ReversePacket = (Direction == BothDirections)$/;"	e	enum:Eigen::Reverse::__anon19
ReverseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef Reverse<Derived, BothDirections> ReverseReturnType;$/;"	t	class:Eigen::DenseBase
ReverseRow	Eigen/src/Core/Reverse.h	/^      ReverseRow = (Direction == Vertical)   || (Direction == BothDirections),$/;"	e	enum:Eigen::Reverse::__anon19
Rhs	Eigen/src/Core/ProductBase.h	/^  typedef typename remove_all<_Rhs>::type Rhs;$/;"	t	struct:Eigen::internal::traits
Rhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,AffineCompact,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,Projective,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,RhsMode,RhsOptions> Rhs;$/;"	t	struct:Eigen::internal::transform_transform_product_impl
Rhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename internal::remove_all<DenseRhsType>::type Rhs;$/;"	t	struct:Eigen::internal::sparse_time_dense_product_impl
RhsBlasTraits	Eigen/src/Core/ProductBase.h	/^    typedef internal::blas_traits<_RhsNested> RhsBlasTraits;$/;"	t	class:Eigen::ProductBase
RhsCoeffReadCost	Eigen/src/Core/CwiseBinaryOp.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon228
RhsCoeffReadCost	Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon122
RhsCoeffReadCost	Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsCoeffReadCost = traits<_RhsNested>::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon374
RhsCoeffReadCost	Eigen/src/SparseCore/SparseProduct.h	/^    RhsCoeffReadCost = _RhsNested::CoeffReadCost,$/;"	e	enum:Eigen::internal::traits::__anon390
RhsFlags	Eigen/src/Core/CwiseBinaryOp.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon228
RhsFlags	Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon122
RhsFlags	Eigen/src/SparseCore/SparseProduct.h	/^    RhsFlags = _RhsNested::Flags,$/;"	e	enum:Eigen::internal::traits::__anon390
RhsIsSelfAdjoint	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsSelfAdjoint = (RhsMode&SelfAdjoint)==SelfAdjoint$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon137
RhsIsUpper	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^    RhsIsUpper = (RhsMode&(Upper|Lower))==Upper,$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon137
RhsIsVectorAtCompileTime	Eigen/src/Core/SolveTriangular.h	/^      RhsIsVectorAtCompileTime = (Side==OnTheLeft ? Rhs::ColsAtCompileTime : Rhs::RowsAtCompileTime)==1$/;"	e	enum:Eigen::internal::trsolve_traits::__anon309
RhsIterator	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename _RhsNested::InnerIterator RhsIterator;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
RhsMode	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^      RhsMode = internal::is_diagonal<_RhsNested>::ret ? internal::SDP_IsDiagonal$/;"	e	enum:Eigen::SparseDiagonalProduct::__anon370
RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::nested<Rhs>::type RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	Eigen/src/Core/GeneralProduct.h	/^  typedef typename internal::nested<Rhs, Lhs::RowsAtCompileTime, typename internal::plain_matrix_type<Rhs>::type >::type RhsNested;$/;"	t	struct:Eigen::ProductReturnType
RhsNested	Eigen/src/Core/ProductBase.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::ProductBase
RhsNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNested;$/;"	t	struct:Eigen::internal::homogeneous_right_product_impl
RhsNested	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::RhsNested RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
RhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::RhsNested RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
RhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename Rhs::Nested RhsNested;$/;"	t	struct:Eigen::internal::traits
RhsNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename Rhs::Nested RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
RhsNested	Eigen/src/SparseCore/SparseProduct.h	/^    typename internal::nested<Rhs,Lhs::RowsAtCompileTime>::type>::type RhsNested;$/;"	t	struct:Eigen::SparseSparseProductReturnType
RhsNestedCleaned	Eigen/src/Core/SolveTriangular.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::triangular_solve_retval
RhsNestedCleaned	Eigen/src/misc/Solve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::solve_retval_base
RhsNestedCleaned	Eigen/src/misc/SparseSolve.h	/^  typedef typename remove_all<typename Rhs::Nested>::type RhsNestedCleaned;$/;"	t	struct:Eigen::internal::sparse_solve_retval_base
RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename Traits::RhsPacket RhsPacket;$/;"	t	struct:Eigen::internal::gebp_kernel
RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,DoublePacket,Scalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
RhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename conditional<Vectorizable,_RhsPacket,RhsScalar>::type RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
RhsPacketSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
RhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon130
RhsPacketSize	Eigen/src/Core/products/GeneralMatrixVector.h	/^  RhsPacketSize = Vectorizable ? packet_traits<RhsScalar>::size : 1,$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon131
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress   = Traits::RhsProgress,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon114
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = ResPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = RhsPacketSize$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
RhsProgress	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RhsProgress = Vectorizable ? 2*ResPacketSize : 1$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
RhsRowMajor	Eigen/src/Core/products/CoeffBasedProduct.h	/^      RhsRowMajor = RhsFlags & RowMajorBit,$/;"	e	enum:Eigen::internal::traits::__anon122
RhsRowMajor	Eigen/src/SparseCore/SparseProduct.h	/^    RhsRowMajor = internal::traits<Rhs>::Flags & RowMajorBit,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon389
RhsScalar	Eigen/src/Core/GeneralProduct.h	/^    typedef typename Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct
RhsScalar	Eigen/src/Core/ProductBase.h	/^    typedef typename internal::traits<Rhs>::Scalar RhsScalar;$/;"	t	class:Eigen::ProductBase
RhsScalar	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar RhsScalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef RealScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef Scalar      RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  RhsScalar;$/;"	t	class:Eigen::internal::gebp_traits
RhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef _RhsScalar RhsScalar;$/;"	t	class:Eigen::internal::level3_blocking
RhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename  Rhs::Scalar RhsScalar;$/;"	t	class:Eigen::GeneralProduct
RhsScalar	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef typename conditional<Transpose,_LhsScalar,_RhsScalar>::type RhsScalar;$/;"	t	class:Eigen::internal::gemm_blocking_space
RhsUpLo	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^    RhsUpLo = RhsMode&(Upper|Lower)$/;"	e	enum:Eigen::SelfadjointProductMatrix::__anon129
RhsVectors	Eigen/src/Core/SolveTriangular.h	/^      RhsVectors  = RhsIsVectorAtCompileTime ? 1 : Dynamic$/;"	e	enum:Eigen::internal::trsolve_traits::__anon310
RightLink	srLib/srDyn/srSystem.h	/^		srLink * RightLink;$/;"	m	struct:srSystem::linkpair_for_closedloop
RootElement	tinyxml2/tinyxml2.h	/^    XMLElement* RootElement()				{$/;"	f	class:tinyxml2::XMLDocument
RootElement	tinyxml2/tinyxml2.h	/^    const XMLElement* RootElement() const	{$/;"	f	class:tinyxml2::XMLDocument
RotX	srMath/SO3.cpp	/^	SO3 SO3::RotX(const Real angle)$/;"	f	class:srMath::SO3
RotY	srMath/SO3.cpp	/^	SO3 SO3::RotY(const Real angle)$/;"	f	class:srMath::SO3
RotZ	srMath/SO3.cpp	/^	SO3 SO3::RotZ(const Real angle)$/;"	f	class:srMath::SO3
Rotate_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_Camera(const Vec3& vUnitAxis_Camera, float fStep)$/;"	f	class:srgCamera
Rotate_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_World(const Vec3& vUnitAxis_World, float fStep)$/;"	f	class:srgCamera
Rotate_X_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_X_Camera(float fStep)$/;"	f	class:srgCamera
Rotate_X_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_X_World(float fStep)$/;"	f	class:srgCamera
Rotate_Y_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_Y_Camera(float fStep)$/;"	f	class:srgCamera
Rotate_Y_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_Y_World(float fStep)$/;"	f	class:srgCamera
Rotate_Z_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_Z_Camera(float fStep)$/;"	f	class:srgCamera
Rotate_Z_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Rotate_Z_World(float fStep)$/;"	f	class:srgCamera
Rotation2D	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Rotation2D /;"	d
Rotation2D	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Rotation2D$/;"	d
Rotation2D	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D(Scalar a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  Rotation2D() {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D(const Scalar& a) : m_angle(a) {}$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^  inline explicit Rotation2D(const Rotation2D<OtherScalarType>& other)$/;"	f	class:Eigen::Rotation2D
Rotation2D	Eigen/src/Geometry/Rotation2D.h	/^class Rotation2D : public RotationBase<Rotation2D<_Scalar>,2>$/;"	c	namespace:Eigen
Rotation2Dd	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Rotation2Dd /;"	d
Rotation2Dd	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Rotation2Dd$/;"	d
Rotation2Dd	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Dd	Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<double> Rotation2Dd;$/;"	t	namespace:Eigen
Rotation2Df	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Rotation2Df /;"	d
Rotation2Df	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Rotation2Df$/;"	d
Rotation2Df	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
Rotation2Df	Eigen/src/Geometry/Rotation2D.h	/^typedef Rotation2D<float> Rotation2Df;$/;"	t	namespace:Eigen
RotationBase	Eigen/src/Eigen2Support/Geometry/All.h	/^#define RotationBase /;"	d
RotationBase	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef RotationBase$/;"	d
RotationBase	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationBase	Eigen/src/Geometry/RotationBase.h	/^class RotationBase$/;"	c	namespace:Eigen
RotationMatrixType	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase
RotationMatrixType	Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,Dim> RotationMatrixType;$/;"	t	class:Eigen::RotationBase
RoughCheck____________________________________MARK7	srLib/srDyn/srContactConstraint.cpp	/^bool CollisionPair::RoughCheck____________________________________MARK7()$/;"	f	class:CollisionPair
RowIndex	Eigen/src/Core/SolveTriangular.h	/^    RowIndex = IsLower ? Index : Size - Index - 1,$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon311
RowMajor	Eigen/src/Core/util/Constants.h	/^  RowMajor = 0x1,  \/\/ it is only a coincidence that this is equal to RowMajorBit -- don't rely on that$/;"	e	enum:Eigen::StorageOptions
RowMajorBit	Eigen/src/Core/util/Constants.h	/^const unsigned int RowMajorBit = 0x1;$/;"	m	namespace:Eigen
RowType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowType;$/;"	t	class:Eigen::JacobiSVD
RowVector	Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MatrixType::ColsAtCompileTime, 1> RowVector;$/;"	t	class:Eigen::SVD
RowVectorType	Eigen/src/Eigen2Support/LU.h	/^    typedef Matrix<Scalar, 1, MatrixType::ColsAtCompileTime, MatrixType::Options, 1, MatrixType::MaxColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::LU
RowVectorType	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::ColPivHouseholderQR
RowVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::FullPivHouseholderQR
RowVectorType	Eigen/src/QR/HouseholderQR.h	/^    typedef typename internal::plain_row_type<MatrixType>::type RowVectorType;$/;"	t	class:Eigen::HouseholderQR
RowVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, 1, ColsAtCompileTime> RowVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
RowXpr	Eigen/src/Core/MatrixBase.h	/^    typedef typename Base::RowXpr RowXpr;$/;"	t	class:Eigen::MatrixBase
RowXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, 1, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowXpr;$/;"	t
Rows	Eigen/src/Core/GeneralProduct.h	/^    Rows  = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::product_type::__anon283
Rows	Eigen/src/Geometry/Transform.h	/^    Rows = int(Mode)==(AffineCompact) ? Dim : HDim$/;"	e	enum:Eigen::Transform::__anon451
RowsAtCompileTime	Eigen/src/Cholesky/LDLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LDLT::__anon425
RowsAtCompileTime	Eigen/src/Cholesky/LLT.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::LLT::__anon426
RowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
RowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon215
RowsAtCompileTime	Eigen/src/Core/BandMatrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon216
RowsAtCompileTime	Eigen/src/Core/Block.h	/^    RowsAtCompileTime = MatrixRows == 0 ? 0 : BlockRows,$/;"	e	enum:Eigen::internal::traits::__anon273
RowsAtCompileTime	Eigen/src/Core/CwiseBinaryOp.h	/^    RowsAtCompileTime = traits<Ancestor>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon227
RowsAtCompileTime	Eigen/src/Core/DenseBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon341
RowsAtCompileTime	Eigen/src/Core/Diagonal.h	/^    RowsAtCompileTime = (int(DiagIndex) == DynamicIndex || int(MatrixType::SizeAtCompileTime) == Dynamic) ? Dynamic$/;"	e	enum:Eigen::internal::traits::__anon339
RowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^      RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::DiagonalBase::__anon32
RowsAtCompileTime	Eigen/src/Core/DiagonalMatrix.h	/^    RowsAtCompileTime = DiagonalVectorType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon34
RowsAtCompileTime	Eigen/src/Core/DiagonalProduct.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon232
RowsAtCompileTime	Eigen/src/Core/MapBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::MapBase::__anon220
RowsAtCompileTime	Eigen/src/Core/Matrix.h	/^    RowsAtCompileTime = _Rows,$/;"	e	enum:Eigen::internal::traits::__anon221
RowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::PermutationBase::__anon20
RowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^      RowsAtCompileTime = Traits::RowsAtCompileTime,$/;"	e	enum:Eigen::Transpose::__anon22
RowsAtCompileTime	Eigen/src/Core/PermutationMatrix.h	/^    RowsAtCompileTime = _IndicesType::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon21
RowsAtCompileTime	Eigen/src/Core/ProductBase.h	/^    RowsAtCompileTime = traits<Lhs>::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon139
RowsAtCompileTime	Eigen/src/Core/Replicate.h	/^    RowsAtCompileTime = RowFactor==Dynamic || int(MatrixType::RowsAtCompileTime)==Dynamic$/;"	e	enum:Eigen::internal::traits::__anon271
RowsAtCompileTime	Eigen/src/Core/Reverse.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon18
RowsAtCompileTime	Eigen/src/Core/Select.h	/^    RowsAtCompileTime = ConditionMatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon343
RowsAtCompileTime	Eigen/src/Core/Transpose.h	/^    RowsAtCompileTime = MatrixType::ColsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon324
RowsAtCompileTime	Eigen/src/Core/TriangularMatrix.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::TriangularBase::__anon238
RowsAtCompileTime	Eigen/src/Core/VectorwiseOp.h	/^    RowsAtCompileTime = Direction==Vertical   ? 1 : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon313
RowsAtCompileTime	Eigen/src/Core/products/CoeffBasedProduct.h	/^      RowsAtCompileTime = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon122
RowsAtCompileTime	Eigen/src/Eigen2Support/Minor.h	/^    RowsAtCompileTime = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon406
RowsAtCompileTime	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexEigenSolver::__anon472
RowsAtCompileTime	Eigen/src/Eigenvalues/ComplexSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ComplexSchur::__anon473
RowsAtCompileTime	Eigen/src/Eigenvalues/EigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::EigenSolver::__anon468
RowsAtCompileTime	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::GeneralizedEigenSolver::__anon467
RowsAtCompileTime	Eigen/src/Eigenvalues/RealQZ.h	/^        RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealQZ::__anon475
RowsAtCompileTime	Eigen/src/Eigenvalues/RealSchur.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::RealSchur::__anon469
RowsAtCompileTime	Eigen/src/Geometry/Homogeneous.h	/^    RowsAtCompileTime = Direction==Vertical  ?  RowsPlusOne : MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon440
RowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^      RowsAtCompileTime = internal::traits<HouseholderSequence>::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderSequence::__anon356
RowsAtCompileTime	Eigen/src/Householder/HouseholderSequence.h	/^    RowsAtCompileTime = Side==OnTheLeft ? traits<VectorsType>::RowsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon355
RowsAtCompileTime	Eigen/src/LU/FullPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivLU::__anon432
RowsAtCompileTime	Eigen/src/LU/PartialPivLU.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::PartialPivLU::__anon431
RowsAtCompileTime	Eigen/src/QR/ColPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::ColPivHouseholderQR::__anon395
RowsAtCompileTime	Eigen/src/QR/FullPivHouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::FullPivHouseholderQR::__anon393
RowsAtCompileTime	Eigen/src/QR/HouseholderQR.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HouseholderQR::__anon394
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::JacobiSVD::__anon423
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon419
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon420
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon421
RowsAtCompileTime	Eigen/src/SVD/JacobiSVD.h	/^    RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::qr_preconditioner_impl::__anon422
RowsAtCompileTime	Eigen/src/SVD/UpperBidiagonalization.h	/^      RowsAtCompileTime = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::UpperBidiagonalization::__anon424
RowsAtCompileTime	Eigen/src/SparseCore/SparseDenseProduct.h	/^    RowsAtCompileTime    = Tr ? int(traits<Rhs>::RowsAtCompileTime)     : int(traits<Lhs>::RowsAtCompileTime),$/;"	e	enum:Eigen::internal::traits::__anon374
RowsAtCompileTime	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RowsAtCompileTime = _Lhs::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon368
RowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon361
RowsAtCompileTime	Eigen/src/SparseCore/SparseMatrix.h	/^    RowsAtCompileTime = Dynamic,$/;"	e	enum:Eigen::internal::traits::__anon362
RowsAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      RowsAtCompileTime = internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
RowsAtCompileTime	Eigen/src/SparseCore/SparseProduct.h	/^    RowsAtCompileTime    = _LhsNested::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::traits::__anon390
RowsAtCompileTime	Eigen/src/SparseCore/SparseVector.h	/^    RowsAtCompileTime = IsColVector ? Dynamic : 1,$/;"	e	enum:Eigen::internal::traits::__anon385
RowsBlockXpr	Eigen/src/plugins/BlockMethods.h	/^typedef Block<Derived, Dynamic, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> RowsBlockXpr;$/;"	t
RowsPlusOne	Eigen/src/Geometry/Homogeneous.h	/^    RowsPlusOne = (MatrixType::RowsAtCompileTime != Dynamic) ?$/;"	e	enum:Eigen::internal::traits::__anon440
RowwiseReturnType	Eigen/src/Core/DenseBase.h	/^    typedef VectorwiseOp<Derived, Horizontal> RowwiseReturnType;$/;"	t	class:Eigen::DenseBase
RunRendering	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::RunRendering()$/;"	f	class:SceneGraphRenderer
S	Eigen/src/Core/SolveTriangular.h	/^    S = IsLower ? 0     : RowIndex+1$/;"	e	enum:Eigen::internal::triangular_solver_unroller::__anon311
SAFE_DELETE	srLib/SceneGraph/Model3DS.cpp	/^#define SAFE_DELETE(/;"	d	file:
SAFE_DELETE_ARRAY	srLib/SceneGraph/Model3DS.cpp	/^#define SAFE_DELETE_ARRAY(/;"	d	file:
SCMatrix	Eigen/src/SparseLU/SparseLU.h	/^    typedef internal::MappedSuperNodalMatrix<Scalar, Index> SCMatrix; $/;"	t	class:Eigen::SparseLU
SDP_IsDiagonal	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon369
SDP_IsSparseColMajor	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon369
SDP_IsSparseRowMajor	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^enum {SDP_IsDiagonal, SDP_IsSparseRowMajor, SDP_IsSparseColMajor};$/;"	e	enum:Eigen::internal::__anon369
SE3	srLib/LieGroup/LieGroup.h	/^class SE3$/;"	c
SE3	srMath/SE3.cpp	/^	SE3::SE3(const Matrix4& T)$/;"	f	class:srMath::SE3
SE3	srMath/SE3.cpp	/^	SE3::SE3(const SE3& T)$/;"	f	class:srMath::SE3
SE3	srMath/SE3.h	/^		SE3(const Matrix3& R, const Vector3& p = (Vector3::Zero())) : _R(R), _p(p) {}$/;"	f	class:srMath::SE3
SE3	srMath/SE3.h	/^		SE3(const SO3& R, const Vector3& p = (Vector3::Zero())) : _R(R), _p(p) {}$/;"	f	class:srMath::SE3
SE3	srMath/SE3.h	/^		SE3(const Vector3& p = (Vector3::Zero())) : _R(), _p(p) {}$/;"	f	class:srMath::SE3
SE3	srMath/SE3.h	/^	class SE3$/;"	c	namespace:srMath
SELF_ILLUM	srLib/SceneGraph/Model3DS.cpp	/^   #define SELF_ILLUM	/;"	d	file:
SENSORTYPE	srLib/srDyn/srSensor.h	/^	enum SENSORTYPE { IRSENSOR, RANGEFINDER, TOUCHSENSOR };$/;"	g	class:srSensor
SENSOR_DELAY	Example/DracoP1/Draco_Dyn_environment.cpp	/^#define SENSOR_DELAY /;"	d	file:
SET_USER_CONTROL_FUNCTION	srLib/srDyn/srSpace.cpp	/^void srSpace::SET_USER_CONTROL_FUNCTION(void (*pfn)())$/;"	f	class:srSpace
SHAPETYPE	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	g	class:srGeometryInfo
SHELL	build/Example/DracoP1/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/LieGroup/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/SceneGraph/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/common/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/srDyn/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/srExt/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srLib/srg/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/srMath/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/tinyxml2/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHINY_PERC	srLib/SceneGraph/Model3DS.cpp	/^   #define SHINY_PERC	/;"	d	file:
SHINY_STR_PERC	srLib/SceneGraph/Model3DS.cpp	/^   #define SHINY_STR_PERC	/;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define SIMULATE_ID /;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define SIMULATE_ID /;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define SIMULATE_VERSION_MAJOR /;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define SIMULATE_VERSION_MAJOR /;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#  define SIMULATE_VERSION_MINOR /;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define SIMULATE_VERSION_MINOR /;"	d	file:
SINGLE_QUOTE	tinyxml2/tinyxml2.cpp	/^static const char SINGLE_QUOTE			= '\\'';$/;"	v	file:
SINGLE_WINDOWS	srLib/SceneGraph/SceneGraphRenderer.h	/^	enum	NUM_WINDOWS	{SINGLE_WINDOWS, DOUBLE_WINDOWS};$/;"	e	enum:SceneGraphRenderer::NUM_WINDOWS
SLERP_EPSILON	srLib/LieGroup/LieGroup.cpp	/^#define SLERP_EPSILON /;"	d	file:
SMOOTH_GROUP	srLib/SceneGraph/Model3DS.cpp	/^     #define SMOOTH_GROUP	/;"	d	file:
SO3	srLib/LieGroup/LieGroup.h	/^class SO3$/;"	c
SO3	srMath/SO3.cpp	/^	SO3::SO3(const Matrix3& R)$/;"	f	class:srMath::SO3
SO3	srMath/SO3.h	/^		SO3() : _e(Matrix3::Identity()) {}$/;"	f	class:srMath::SO3
SO3	srMath/SO3.h	/^		SO3(const SO3& R) : _e(R._e) {}$/;"	f	class:srMath::SO3
SO3	srMath/SO3.h	/^	class SO3$/;"	c	namespace:srMath
SPACE	srLib/srExt/srExt_System.h	/^			SPACE,$/;"	e	enum:srExt::srExtSystem::REF_FRAME
SPACE	srLib/srExt/srExtension.h	/^		SPACE,$/;"	e	enum:srExt::FRAME
SPARSELU_COLUMN_BMOD_H	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^#define SPARSELU_COLUMN_BMOD_H$/;"	d
SPARSELU_COLUMN_DFS_H	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^#define SPARSELU_COLUMN_DFS_H$/;"	d
SPARSELU_COPY_TO_UCOL_H	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^#define SPARSELU_COPY_TO_UCOL_H$/;"	d
SPARSELU_HEAP_RELAX_SNODE_H	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^#define SPARSELU_HEAP_RELAX_SNODE_H$/;"	d
SPARSELU_IMPL_H	Eigen/src/SparseLU/SparseLUImpl.h	/^#define SPARSELU_IMPL_H$/;"	d
SPARSELU_KERNEL_BMOD_H	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^#define SPARSELU_KERNEL_BMOD_H$/;"	d
SPARSELU_PANEL_BMOD_H	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^#define SPARSELU_PANEL_BMOD_H$/;"	d
SPARSELU_PANEL_DFS_H	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^#define SPARSELU_PANEL_DFS_H$/;"	d
SPARSELU_PIVOTL_H	Eigen/src/SparseLU/SparseLU_pivotL.h	/^#define SPARSELU_PIVOTL_H$/;"	d
SPARSELU_PRUNEL_H	Eigen/src/SparseLU/SparseLU_pruneL.h	/^#define SPARSELU_PRUNEL_H$/;"	d
SPARSELU_RELAX_SNODE_H	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^#define SPARSELU_RELAX_SNODE_H$/;"	d
SPARSE_COLETREE_H	Eigen/src/SparseCore/SparseColEtree.h	/^#define SPARSE_COLETREE_H$/;"	d
SPHERE	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR() $/;"	f	class:Eigen::SPQR
SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQR(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR
SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^class SPQR$/;"	c	namespace:Eigen
SPQRMatrixQReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQReturnType
SPQRMatrixQReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQReturnType{$/;"	s	namespace:Eigen
SPQRMatrixQTransposeReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType(const SPQRType& spqr) : m_spqr(spqr) {}$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType
SPQRMatrixQTransposeReturnType	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQRMatrixQTransposeReturnType{$/;"	s	namespace:Eigen
SPQR_QProduct	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct(const SPQRType& spqr, const Derived& other, bool transpose) : m_spqr(spqr),m_other(other),m_transpose(transpose) {}$/;"	f	struct:Eigen::SPQR_QProduct
SPQR_QProduct	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct SPQR_QProduct : ReturnByValue<SPQR_QProduct<SPQRType,Derived> >$/;"	s	namespace:Eigen
SPQR_free	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void SPQR_free()$/;"	f	class:Eigen::SPQR
SQRT2_OVER_2	srLib/srDyn/srCollisionPair.cpp	/^#define SQRT2_OVER_2	/;"	d	file:
SQRT2_OVER_2	srLib/srDyn/srContactConstraint.cpp	/^#define SQRT2_OVER_2	/;"	d	file:
SRGBA	srLib/srg/srgColor.h	/^	typedef struct _sRGBA { float R; float G; float B; float A; } SRGBA;$/;"	t	class:srgColor	typeref:struct:srgColor::_sRGBA
SRG_BYTE_SWAP	srLib/srg/srgMath.h	/^#define SRG_BYTE_SWAP(/;"	d
SRG_COLOR_DEFAULT_ALPHA	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_ALPHA	/;"	d
SRG_COLOR_DEFAULT_AMBIENT_FACTOR	srLib/SceneGraph/Shader.cpp	/^#define SRG_COLOR_DEFAULT_AMBIENT_FACTOR	/;"	d	file:
SRG_COLOR_DEFAULT_AMBIENT_FACTOR	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_AMBIENT_FACTOR	/;"	d
SRG_COLOR_DEFAULT_BLUE	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_BLUE	/;"	d
SRG_COLOR_DEFAULT_DIFFUSE_FACTOR	srLib/SceneGraph/Shader.cpp	/^#define SRG_COLOR_DEFAULT_DIFFUSE_FACTOR	/;"	d	file:
SRG_COLOR_DEFAULT_DIFFUSE_FACTOR	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_DIFFUSE_FACTOR	/;"	d
SRG_COLOR_DEFAULT_EMISSION_FACTOR	srLib/SceneGraph/Shader.cpp	/^#define SRG_COLOR_DEFAULT_EMISSION_FACTOR	/;"	d	file:
SRG_COLOR_DEFAULT_EMISSION_FACTOR	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_EMISSION_FACTOR	/;"	d
SRG_COLOR_DEFAULT_GREEN	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_GREEN	/;"	d
SRG_COLOR_DEFAULT_RED	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_RED	/;"	d
SRG_COLOR_DEFAULT_SHININESS_FACTOR	srLib/SceneGraph/Shader.cpp	/^#define SRG_COLOR_DEFAULT_SHININESS_FACTOR	/;"	d	file:
SRG_COLOR_DEFAULT_SHININESS_FACTOR	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_SHININESS_FACTOR	/;"	d
SRG_COLOR_DEFAULT_SPECULAR_FACTOR	srLib/SceneGraph/Shader.cpp	/^#define SRG_COLOR_DEFAULT_SPECULAR_FACTOR	/;"	d	file:
SRG_COLOR_DEFAULT_SPECULAR_FACTOR	srLib/srg/srgColor.h	/^#define SRG_COLOR_DEFAULT_SPECULAR_FACTOR	/;"	d
SRG_DEG2RAD	srLib/srg/srgMath.h	/^#define SRG_DEG2RAD(/;"	d
SRG_DEG2RADd	srLib/srg/srgMath.h	/^inline double SRG_DEG2RADd(const double val)	{ return val*0.0174532925199432957692369076848861;}$/;"	f
SRG_DEG2RADf	srLib/srg/srgMath.h	/^inline double SRG_DEG2RADf(const float val)		{ return val*0.017453292519943296f;}$/;"	f
SRG_FIGURE_BACK_FEATURELINE	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_BACK_FEATURELINE	/;"	d
SRG_FIGURE_DRAWINGSTYLE_MASK	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_DRAWINGSTYLE_MASK	/;"	d
SRG_FIGURE_FEATURELINE	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_FEATURELINE	/;"	d
SRG_FIGURE_FILL	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_FILL	/;"	d
SRG_FIGURE_SILHOUETTE	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_SILHOUETTE	/;"	d
SRG_FIGURE_TEXTURE	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_TEXTURE	/;"	d
SRG_FIGURE_TEXTURE_MASK	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_TEXTURE_MASK	/;"	d
SRG_FIGURE_WIREFRAME	srLib/srg/srgGeometryDraw.h	/^#define SRG_FIGURE_WIREFRAME	/;"	d
SRG_HALF_PI	srLib/srg/srgMath.h	/^#define SRG_HALF_PI	/;"	d
SRG_INV_PI_DIV_180	srLib/srg/srgMath.h	/^#define SRG_INV_PI_DIV_180	/;"	d
SRG_MAX	srLib/srg/srgMath.h	/^#define SRG_MAX(/;"	d
SRG_ONESIXTH	srLib/srg/srgMath.h	/^#define SRG_ONESIXTH	/;"	d
SRG_ONETHIRD	srLib/srg/srgMath.h	/^#define SRG_ONETHIRD	/;"	d
SRG_PI	srLib/srg/srgMath.h	/^#define SRG_PI	/;"	d
SRG_PI_DIV_180	srLib/srg/srgMath.h	/^#define SRG_PI_DIV_180	/;"	d
SRG_RAD2DEG	srLib/srg/srgMath.h	/^#define SRG_RAD2DEG(/;"	d
SRG_RAD2DEGd	srLib/srg/srgMath.h	/^inline double SRG_RAD2DEGd(const double val)	{ return val*57.2957795130823208767981548141052;}$/;"	f
SRG_RAD2DEGf	srLib/srg/srgMath.h	/^inline double SRG_RAD2DEGf(const float val)		{ return val*57.2957795130823229f;}$/;"	f
SRG_SQR	srLib/srg/srgMath.h	/^#define SRG_SQR(/;"	d
SRG_TWO_PI	srLib/srg/srgMath.h	/^#define SRG_TWO_PI	/;"	d
SRLIB_BALL_JOINT	srLib/srDyn/srBallJoint.h	/^#define SRLIB_BALL_JOINT$/;"	d
SRLIB_COLLISION	srLib/srDyn/srCollision.h	/^#define SRLIB_COLLISION$/;"	d
SRLIB_DOUBLE	srLib/common/types.h	/^#define SRLIB_DOUBLE$/;"	d
SRLIB_ENTITY	srLib/srDyn/srEntity.h	/^#define SRLIB_ENTITY$/;"	d
SRLIB_GEOMETRY_INFO	srLib/srDyn/srGeometryInfo.h	/^#define SRLIB_GEOMETRY_INFO$/;"	d
SRLIB_IR_RANGE_FINDER	srLib/srDyn/srRangeFinder.h	/^#define SRLIB_IR_RANGE_FINDER$/;"	d
SRLIB_IR_SENSOR	srLib/srDyn/srIRSensor.h	/^#define SRLIB_IR_SENSOR$/;"	d
SRLIB_JOINT	srLib/srDyn/srJoint.h	/^#define SRLIB_JOINT$/;"	d
SRLIB_LIE_ALGEBRA	srLib/LieGroup/LieGroup.h	/^#define SRLIB_LIE_ALGEBRA$/;"	d
SRLIB_LINEAR_SPRING	srLib/srDyn/srLinearSpring.h	/^#define SRLIB_LINEAR_SPRING$/;"	d
SRLIB_LINK	srLib/srDyn/srLink.h	/^#define SRLIB_LINK$/;"	d
SRLIB_OBJECT	srLib/srDyn/srObject.h	/^#define SRLIB_OBJECT$/;"	d
SRLIB_PRISMATIC_JOINT	srLib/srDyn/srPrismaticJoint.h	/^#define SRLIB_PRISMATIC_JOINT$/;"	d
SRLIB_REVOLUTE_JOINT	srLib/srDyn/srRevoluteJoint.h	/^#define SRLIB_REVOLUTE_JOINT$/;"	d
SRLIB_SENSOR	srLib/srDyn/srSensor.h	/^#define	SRLIB_SENSOR$/;"	d
SRLIB_SPACE	srLib/srDyn/srSpace.h	/^#define SRLIB_SPACE$/;"	d
SRLIB_SPRING	srLib/srDyn/srSpring.h	/^#define SRLIB_SPRING$/;"	d
SRLIB_STATE	srLib/srDyn/srState.h	/^#define SRLIB_STATE$/;"	d
SRLIB_SYSTEM	srLib/srDyn/srSystem.h	/^#define SRLIB_SYSTEM$/;"	d
SRLIB_TOUCH_SENSOR	srLib/srDyn/srTouchSensor.h	/^#define SRLIB_TOUCH_SENSOR$/;"	d
SRLIB_TYPE	srLib/common/types.h	/^#define	SRLIB_TYPE$/;"	d
SRLIB_UNIVERSAL_JOINT	srLib/srDyn/srUniversalJoint.h	/^#define SRLIB_UNIVERSAL_JOINT$/;"	d
SRLIB_WELD_JOINT	srLib/srDyn/srWeldJoint.h	/^#define SRLIB_WELD_JOINT$/;"	d
SR_DEGREE	srLib/common/types.h	/^	#define SR_DEGREE	/;"	d
SR_EPS	srLib/common/types.h	/^	#define SR_EPS	/;"	d
SR_FOURTHIRD	srLib/common/types.h	/^	#define SR_FOURTHIRD	/;"	d
SR_HALF	srLib/common/types.h	/^	#define SR_HALF	/;"	d
SR_ISEQUAL	srLib/common/types.h	/^	#define SR_ISEQUAL(/;"	d
SR_ISZERO	srLib/common/types.h	/^	#define SR_ISZERO(/;"	d
SR_ONE	srLib/common/types.h	/^	#define SR_ONE	/;"	d
SR_ONESIXTH	srLib/common/types.h	/^	#define SR_ONESIXTH	/;"	d
SR_ONETHIRD	srLib/common/types.h	/^	#define SR_ONETHIRD	/;"	d
SR_PI	srLib/common/types.h	/^	#define SR_PI	/;"	d
SR_PI_HALF	srLib/common/types.h	/^	#define	SR_PI_HALF	/;"	d
SR_PI_SQR	srLib/common/types.h	/^	#define SR_PI_SQR	/;"	d
SR_PI_SQRT2	srLib/common/types.h	/^	#define SR_PI_SQRT2	/;"	d
SR_RADIAN	srLib/common/types.h	/^	#define SR_RADIAN	/;"	d
SR_RAND	srLib/common/types.h	/^	#define SR_RAND(/;"	d
SR_REAL	srLib/common/types.h	/^	typedef double			SR_REAL;$/;"	t
SR_REAL	srLib/common/types.h	/^	typedef float			SR_REAL;$/;"	t
SR_ROUND	srLib/common/types.h	/^	#define SR_ROUND(/;"	d
SR_SAFE_DELETE	srLib/common/utils.h	/^#define SR_SAFE_DELETE(/;"	d
SR_SAFE_DELETE_AR	srLib/common/utils.h	/^#define SR_SAFE_DELETE_AR(/;"	d
SR_SAFE_DESTROY_WINDOW	srLib/common/utils.h	/^#define SR_SAFE_DESTROY_WINDOW(/;"	d
SR_SAFE_RELEASE	srLib/common/utils.h	/^#define SR_SAFE_RELEASE(/;"	d
SR_SENSOR_MSG_NA	srLib/common/types.h	/^#define SR_SENSOR_MSG_NA	/;"	d
SR_TWO	srLib/common/types.h	/^	#define SR_TWO	/;"	d
SR_TWO_PI	srLib/common/types.h	/^	#define SR_TWO_PI	/;"	d
SR_ZERO	srLib/common/types.h	/^	#define SR_ZERO	/;"	d
SSE	Eigen/src/Core/util/Constants.h	/^    SSE = 0x1,$/;"	e	enum:Eigen::Architecture::Type
STATIC	srLib/srDyn/srLink.h	/^	enum DYNTYPE { DYNAMIC, STATIC, KINEMATIC };$/;"	e	enum:srLink::DYNTYPE
STEP	srLib/SceneGraph/Leaf.h	/^	GLdouble	STEP;$/;"	m	class:Grid
STL	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
STL2Collsion	srLib/common/srSTL.h	/^	static srCollision* STL2Collsion(STLc stl_content, string type)$/;"	f	namespace:srSTL
STLNode	srLib/SceneGraph/Leaf.h	/^	STLNode(const char* name, SE3 T = SE3(0.0))$/;"	f	class:STLNode
STLNode	srLib/SceneGraph/Leaf.h	/^class STLNode : public Leaf$/;"	c
STLc	srLib/common/srSTL.h	/^	typedef list<facet> STLc;$/;"	t	namespace:srSTL
STORAGE_LAYOUT_DOES_NOT_MATCH	Eigen/src/Core/util/StaticAssert.h	/^        STORAGE_LAYOUT_DOES_NOT_MATCH$/;"	e	enum:Eigen::internal::static_assertion::__anon143
STRINGIFY	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#define STRINGIFY(/;"	d	file:
STRINGIFY	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define STRINGIFY(/;"	d	file:
STRINGIFY_HELPER	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^#define STRINGIFY_HELPER(/;"	d	file:
STRINGIFY_HELPER	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define STRINGIFY_HELPER(/;"	d	file:
SUFFIXES	build/Example/DracoP1/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/LieGroup/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/SceneGraph/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/common/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/srDyn/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/srExt/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srLib/srg/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/srMath/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/tinyxml2/Makefile	/^SUFFIXES =$/;"	m
SVA_Inner	Eigen/src/SparseCore/SparseVector.h	/^  SVA_Inner,$/;"	e	enum:Eigen::internal::__anon386
SVA_Outer	Eigen/src/SparseCore/SparseVector.h	/^  SVA_Outer$/;"	e	enum:Eigen::internal::__anon386
SVA_RuntimeSwitch	Eigen/src/SparseCore/SparseVector.h	/^  SVA_RuntimeSwitch,$/;"	e	enum:Eigen::internal::__anon386
SVD	Eigen/src/Eigen2Support/SVD.h	/^    SVD() {} \/\/ a user who relied on compiler-generated default compiler reported problems with MSVC in 2.0.7$/;"	f	class:Eigen::SVD
SVD	Eigen/src/Eigen2Support/SVD.h	/^    SVD(const MatrixType& matrix)$/;"	f	class:Eigen::SVD
SVD	Eigen/src/Eigen2Support/SVD.h	/^template<typename MatrixType> class SVD$/;"	c	namespace:Eigen
SVD	Eigen/src/SVD/JacobiSVD.h	/^  typedef JacobiSVD<MatrixType, QRPreconditioner> SVD;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
SWITCH_GROUP_RENDER	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::SWITCH_GROUP_RENDER(unsigned n)$/;"	f	class:SceneGraphRenderer
SameType	Eigen/src/Core/CwiseBinaryOp.h	/^    SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon228
SameType	Eigen/src/Core/products/CoeffBasedProduct.h	/^      SameType = is_same<typename _LhsNested::Scalar,typename _RhsNested::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon122
SaveFile	tinyxml2/tinyxml2.cpp	/^XMLError XMLDocument::SaveFile( FILE* fp, bool compact )$/;"	f	class:tinyxml2::XMLDocument
SaveFile	tinyxml2/tinyxml2.cpp	/^XMLError XMLDocument::SaveFile( const char* filename, bool compact )$/;"	f	class:tinyxml2::XMLDocument
Scalar	Eigen/src/Cholesky/LDLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LDLT
Scalar	Eigen/src/Cholesky/LLT.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LLT
Scalar	Eigen/src/CholmodSupport/CholmodSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::CholmodBase
Scalar	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::ArrayBase
Scalar	Eigen/src/Core/Assign_MKL.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::vml_assign_impl
Scalar	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrix>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrix
Scalar	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<BandMatrixWrapper>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixWrapper
Scalar	Eigen/src/Core/BandMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::internal::BandMatrixBase
Scalar	Eigen/src/Core/BandMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CommaInitializer.h	/^  typedef typename XprType::Scalar Scalar;$/;"	t	struct:Eigen::CommaInitializer
Scalar	Eigen/src/Core/CoreIterators.h	/^    typedef typename Derived::Scalar Scalar;$/;"	t	class:Eigen::DenseBase::InnerIterator
Scalar	Eigen/src/Core/CwiseBinaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CwiseUnaryOp.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/CwiseUnaryView.h	/^                   >::type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseBase
Scalar	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::DenseCoeffsBase
Scalar	Eigen/src/Core/DiagonalMatrix.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalMatrix
Scalar	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	class:Eigen::DiagonalBase
Scalar	Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/DiagonalProduct.h	/^  typedef typename scalar_product_traits<typename MatrixType::Scalar, typename DiagonalType::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Map.h	/^  typedef typename PlainObjectType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/MapBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MapBase
Scalar	Eigen/src/Core/Matrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/MatrixBase.h	/^      typedef typename internal::scalar_product_traits<typename internal::traits<Derived>::Scalar,typename internal::traits<OtherDerived>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
Scalar	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::MatrixBase
Scalar	Eigen/src/Core/NoAlias.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::NoAlias
Scalar	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PermutationBase
Scalar	Eigen/src/Core/PermutationMatrix.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::Transpose
Scalar	Eigen/src/Core/PermutationMatrix.h	/^  typedef typename _IndicesType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::PlainObjectBase
Scalar	Eigen/src/Core/ProductBase.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:ScaledProduct
Scalar	Eigen/src/Core/ProductBase.h	/^  typedef typename scalar_product_traits<typename Lhs::Scalar, typename Rhs::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_impl
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_novec_unroller
Scalar	Eigen/src/Core/Redux.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::redux_vec_unroller
Scalar	Eigen/src/Core/Replicate.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Reverse.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/SelfAdjointView.h	/^    typedef typename internal::traits<SelfAdjointView>::Scalar Scalar; $/;"	t	class:Eigen::SelfAdjointView
Scalar	Eigen/src/Core/SolveTriangular.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_solver_selector
Scalar	Eigen/src/Core/Transpose.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::TriangularBase
Scalar	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::Scalar Scalar;$/;"	t	class:Eigen::TriangularView
Scalar	Eigen/src/Core/TriangularMatrix.h	/^  typedef typename Derived1::Scalar Scalar;$/;"	t	struct:Eigen::internal::triangular_assignment_selector
Scalar	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename ExpressionType::Scalar Scalar;$/;"	t	class:Eigen::VectorwiseOp
Scalar	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename MemberOp::result_type Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::coeff_visitor
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::max_coeff_visitor
Scalar	Eigen/src/Core/Visitor.h	/^  typedef typename Derived::Scalar Scalar;$/;"	t	struct:Eigen::internal::min_coeff_visitor
Scalar	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename scalar_product_traits<typename _LhsNested::Scalar, typename _RhsNested::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef std::complex<RealScalar>  Scalar;$/;"	t	class:Eigen::internal::gebp_traits
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef std::complex<RealScalar> Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename NestedXpr::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::conj_helper
Scalar	Eigen/src/Core/util/BlasUtil.h	/^  typedef typename traits<XprType>::Scalar Scalar;$/;"	t	struct:Eigen::internal::blas_traits
Scalar	Eigen/src/Eigen2Support/Cwise.h	/^    typedef typename internal::traits<ExpressionType>::Scalar Scalar;$/;"	t	class:Eigen::Cwise
Scalar	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AlignedBox
Scalar	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis
Scalar	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits
Scalar	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane
Scalar	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine
Scalar	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion
Scalar	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits
Scalar	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_quaternion_assign_impl
Scalar	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D
Scalar	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::ei_traits
Scalar	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    typedef typename ei_traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase
Scalar	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Scaling
Scalar	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform
Scalar	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::ei_transform_product_impl
Scalar	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation
Scalar	Eigen/src/Eigen2Support/LU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::LU
Scalar	Eigen/src/Eigen2Support/SVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SVD
Scalar	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexEigenSolver
Scalar	Eigen/src/Eigenvalues/ComplexSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ComplexSchur
Scalar	Eigen/src/Eigenvalues/EigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::EigenSolver
Scalar	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::GeneralizedEigenSolver
Scalar	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HessenbergDecomposition
Scalar	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealQZ
Scalar	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::RealSchur
Scalar	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Scalar	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::Scalar Scalar;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
Scalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::Tridiagonalization
Scalar	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::tridiagonalization_inplace_selector
Scalar	Eigen/src/Geometry/AlignedBox.h	/^  typedef _Scalar                                   Scalar;$/;"	t	class:Eigen::AlignedBox
Scalar	Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::AngleAxis
Scalar	Eigen/src/Geometry/AngleAxis.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/Hyperplane.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Hyperplane
Scalar	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename traits<Derived>::Scalar Scalar;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Scalar	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::ParametrizedLine
Scalar	Eigen/src/Geometry/Quaternion.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::Map
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Quaternion
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef typename Other::Scalar Scalar;$/;"	t	struct:Eigen::internal::quaternionbase_assign_impl
Scalar	Eigen/src/Geometry/Quaternion.h	/^  typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::QuaternionBase
Scalar	Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Rotation2D
Scalar	Eigen/src/Geometry/Rotation2D.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/Geometry/RotationBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::RotationBase
Scalar	Eigen/src/Geometry/Scaling.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::UniformScaling
Scalar	Eigen/src/Geometry/Transform.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Transform
Scalar	Eigen/src/Geometry/Translation.h	/^  typedef _Scalar Scalar;$/;"	t	class:Eigen::Translation
Scalar	Eigen/src/Householder/HouseholderSequence.h	/^    typedef typename internal::traits<HouseholderSequence>::Scalar Scalar;$/;"	t	class:Eigen::HouseholderSequence
Scalar	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::DiagonalPreconditioner
Scalar	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::BiCGSTAB
Scalar	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ConjugateGradient
Scalar	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::IncompleteLUT
Scalar	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::IterativeSolverBase
Scalar	Eigen/src/LU/FullPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivLU
Scalar	Eigen/src/LU/PartialPivLU.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PartialPivLU
Scalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::PastixBase
Scalar	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pastix_traits
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLDLT
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLLT
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::PardisoLU
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename Traits::Scalar Scalar;$/;"	t	class:Eigen::PardisoImpl
Scalar	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::pardiso_traits
Scalar	Eigen/src/QR/ColPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::ColPivHouseholderQR
Scalar	Eigen/src/QR/FullPivHouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::FullPivHouseholderQR
Scalar	Eigen/src/QR/HouseholderQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::HouseholderQR
Scalar	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    typedef typename _MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SPQR
Scalar	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  typedef typename SPQRType::Scalar Scalar;$/;"	t	struct:Eigen::SPQR_QProduct
Scalar	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::JacobiSVD
Scalar	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
Scalar	Eigen/src/SVD/JacobiSVD.h	/^  typedef typename MatrixType::Scalar Scalar;$/;"	t	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
Scalar	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::internal::UpperBidiagonalization
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholesky
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialCholeskyBase
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLDLT
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SimplicialLLT
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                             Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  typedef typename MatrixType::Scalar                         Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector
Scalar	Eigen/src/SparseCore/AmbiVector.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::AmbiVector::Iterator
Scalar	Eigen/src/SparseCore/CompressedStorage.h	/^    typedef _Scalar Scalar;$/;"	t	class:Eigen::internal::CompressedStorage
Scalar	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename LhsCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::conservative_sparse_sparse_product_selector
Scalar	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename BlockType::Scalar Scalar;$/;"	t	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
Scalar	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename CwiseBinaryXpr::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Scalar	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::Scalar Scalar;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
Scalar	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::InnerIterator
Scalar	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryOpImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
Scalar	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::InnerIterator
Scalar	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename CwiseUnaryViewImpl::Scalar Scalar;$/;"	t	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
Scalar	Eigen/src/SparseCore/SparseDenseProduct.h	/^                                         typename traits<Rhs>::Scalar>::ReturnType Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename _Lhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Scalar Scalar;$/;"	t	class:Eigen::SparseMatrixBase
Scalar	Eigen/src/SparseCore/SparsePermutation.h	/^    typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::permut_sparsematrix_product_retval
Scalar	Eigen/src/SparseCore/SparsePermutation.h	/^  typedef typename MatrixTypeNestedCleaned::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename _LhsNested::Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename internal::traits<Lhs>::Scalar Scalar;$/;"	t	struct:Eigen::SparseSparseProductReturnType
Scalar	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSelfAdjointView
Scalar	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
Scalar	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  typedef typename traits<typename remove_all<Lhs>::type>::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
Scalar	Eigen/src/SparseCore/SparseVector.h	/^  typedef _Scalar Scalar;$/;"	t	struct:Eigen::internal::traits
Scalar	Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_selector
Scalar	Eigen/src/SparseCore/TriangularSolver.h	/^  typedef typename Rhs::Scalar Scalar;$/;"	t	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
Scalar	Eigen/src/SparseLU/SparseLU.h	/^    typedef typename MatrixType::Scalar Scalar; $/;"	t	class:Eigen::SparseLU
Scalar	Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MappedSupernodalType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixLReturnType
Scalar	Eigen/src/SparseLU/SparseLU.h	/^  typedef typename MatrixLType::Scalar Scalar;$/;"	t	struct:Eigen::SparseLUMatrixUReturnType
Scalar	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef _Scalar Scalar; $/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
Scalar	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typedef typename ScalarVector::Scalar Scalar;$/;"	t	struct:Eigen::internal::column_dfs_traits
Scalar	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SparseQR
Scalar	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQRMatrixQReturnType
Scalar	Eigen/src/SparseQR/SparseQR.h	/^  typedef typename SparseQRType::Scalar Scalar;$/;"	t	struct:Eigen::SparseQR_QProduct
Scalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperILU
Scalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename Base::Scalar Scalar;$/;"	t	class:Eigen::SuperLU
Scalar	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::SuperLUBase
Scalar	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef typename MatrixType::Scalar Scalar;$/;"	t	class:Eigen::UmfPackLU
ScalarAddReturnType	Eigen/src/Eigen2Support/Cwise.h	/^    typedef CwiseUnaryOp<internal::scalar_add_op<Scalar>, ExpressionType> ScalarAddReturnType;$/;"	t	class:Eigen::Cwise
ScalarCoeffImpl	Eigen/src/Core/products/CoeffBasedProduct.h	/^                                   _LhsNested, _RhsNested, Scalar> ScalarCoeffImpl;$/;"	t	class:Eigen::CoeffBasedProduct
ScalarIsComplex	Eigen/src/PardisoSupport/PardisoSupport.h	/^      ScalarIsComplex = NumTraits<Scalar>::IsComplex$/;"	e	enum:Eigen::PardisoImpl::__anon358
ScalarMatrix	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,Dynamic,ColMajor> ScalarMatrix;$/;"	t	class:Eigen::internal::SparseLUImpl
ScalarMultipleReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_multiple_op<Scalar>, const Derived> ScalarMultipleReturnType;$/;"	t
ScalarPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<Scalar>::type     ScalarPacket;$/;"	t	class:Eigen::internal::gebp_traits
ScalarQuotient1ReturnType	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^typedef CwiseUnaryOp<internal::scalar_quotient1_op<Scalar>, const Derived> ScalarQuotient1ReturnType;$/;"	t
ScalarTraits	Eigen/src/Geometry/AlignedBox.h	/^  typedef NumTraits<Scalar>                         ScalarTraits;$/;"	t	class:Eigen::AlignedBox
ScalarTypeMatch	Eigen/src/Core/Ref.h	/^      ScalarTypeMatch = internal::is_same<typename PlainObjectType::Scalar, typename Derived::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::match::__anon323
ScalarVector	Eigen/src/SparseLU/SparseLU.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::SparseLU
ScalarVector	Eigen/src/SparseLU/SparseLUImpl.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::SparseLUImpl
ScalarVector	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    typedef Matrix<Scalar,Dynamic,1> ScalarVector;$/;"	t	class:Eigen::internal::MappedSuperNodalMatrix
ScalarVector	Eigen/src/SparseQR/SparseQR.h	/^    typedef Matrix<Scalar, Dynamic, 1> ScalarVector;$/;"	t	class:Eigen::SparseQR
ScalarWithConstIfNotLvalue	Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::ArrayWrapper
ScalarWithConstIfNotLvalue	Eigen/src/Core/ArrayWrapper.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MatrixWrapper
ScalarWithConstIfNotLvalue	Eigen/src/Core/Diagonal.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::Diagonal
ScalarWithConstIfNotLvalue	Eigen/src/Core/MapBase.h	/^                  >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::MapBase
ScalarWithConstIfNotLvalue	Eigen/src/Core/Swap.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::SwapWrapper
ScalarWithConstIfNotLvalue	Eigen/src/Core/Transpose.h	/^                     >::type ScalarWithConstIfNotLvalue;$/;"	t	class:Eigen::TransposeImpl
ScaledProduct	Eigen/src/Core/ProductBase.h	/^    ScaledProduct(const NestedProduct& prod, const Scalar& x)$/;"	f	class:ScaledProduct
ScaledProduct	Eigen/src/Core/ProductBase.h	/^class ScaledProduct$/;"	c
Scaling	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling /;"	d
Scaling	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling$/;"	d
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  Scaling() {}$/;"	f	class:Eigen::Scaling
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const Scalar& s) { m_coeffs.setConstant(s); }$/;"	f	class:Eigen::Scaling
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  explicit inline Scaling(const VectorType& coeffs) : m_coeffs(coeffs) {}$/;"	f	class:Eigen::Scaling
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Scaling
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Scaling
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline explicit Scaling(const Scaling<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Scaling
Scaling	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^class Scaling$/;"	c	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,2> Scaling(const Scalar& sx, const Scalar& sy)$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^static inline DiagonalMatrix<Scalar,3> Scaling(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<double> Scaling(double s) { return UniformScaling<double>(s); }$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<float> Scaling(float s) { return UniformScaling<float>(s); }$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^static inline UniformScaling<std::complex<RealScalar> > Scaling(const std::complex<RealScalar>& s)$/;"	f	namespace:Eigen
Scaling	Eigen/src/Geometry/Scaling.h	/^static inline const DiagonalWrapper<const Derived> Scaling(const MatrixBase<Derived>& coeffs)$/;"	f	namespace:Eigen
Scaling2d	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling2d /;"	d
Scaling2d	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling2d$/;"	d
Scaling2d	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,2> Scaling2d;$/;"	t	namespace:Eigen
Scaling2f	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling2f /;"	d
Scaling2f	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling2f$/;"	d
Scaling2f	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 2> Scaling2f;$/;"	t	namespace:Eigen
Scaling3d	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling3d /;"	d
Scaling3d	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling3d$/;"	d
Scaling3d	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<double,3> Scaling3d;$/;"	t	namespace:Eigen
Scaling3f	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Scaling3f /;"	d
Scaling3f	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Scaling3f$/;"	d
Scaling3f	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^typedef Scaling<float, 3> Scaling3f;$/;"	t	namespace:Eigen
ScalingType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Transform
ScalingType	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Scaling<Scalar,Dim> ScalingType;$/;"	t	class:Eigen::Translation
SceneGraphRenderer	srLib/SceneGraph/SceneGraphRenderer.cpp	/^SceneGraphRenderer::SceneGraphRenderer(void)$/;"	f	class:SceneGraphRenderer
SceneGraphRenderer	srLib/SceneGraph/SceneGraphRenderer.h	/^class SceneGraphRenderer$/;"	c
SealElementIfJustOpened	tinyxml2/tinyxml2.cpp	/^void XMLPrinter::SealElementIfJustOpened()$/;"	f	class:tinyxml2::XMLPrinter
SegmentReturnType	Eigen/src/plugins/BlockMethods.h	/^typedef VectorBlock<Derived> SegmentReturnType;$/;"	t
Select	Eigen/src/Core/Select.h	/^    Select(const ConditionMatrixType& a_conditionMatrix,$/;"	f	class:Eigen::Select
Select	Eigen/src/Core/Select.h	/^class Select : internal::no_assignment_operator,$/;"	c	namespace:Eigen
SelfAdjoint	Eigen/src/Core/util/Constants.h	/^  SelfAdjoint=0x10,$/;"	e	enum:Eigen::UpLoType
SelfAdjointBit	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int SelfAdjointBit = SelfAdjoint;$/;"	m	namespace:Eigen
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver()$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(Index size)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    SelfAdjointEigenSolver(const MatrixType& matrix, int options = ComputeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
SelfAdjointEigenSolver	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename _MatrixType> class SelfAdjointEigenSolver$/;"	c	namespace:Eigen
SelfAdjointView	Eigen/src/Core/SelfAdjointView.h	/^    inline SelfAdjointView(MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SelfAdjointView
SelfAdjointView	Eigen/src/Core/SelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SelfAdjointView$/;"	c	namespace:Eigen
SelfAdjointViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	s	class:Eigen::MatrixBase
SelfCwiseBinaryOp	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline SelfCwiseBinaryOp(Lhs& xpr, const BinaryOp& func = BinaryOp()) : m_matrix(xpr), m_functor(func) {}$/;"	f	class:Eigen::SelfCwiseBinaryOp
SelfCwiseBinaryOp	Eigen/src/Core/SelfCwiseBinaryOp.h	/^template<typename BinaryOp, typename Lhs, typename Rhs> class SelfCwiseBinaryOp$/;"	c	namespace:Eigen
SelfadjointProductMatrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix
SelfadjointProductMatrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false>$/;"	s	namespace:Eigen
SelfadjointProductMatrix	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  SelfadjointProductMatrix(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::SelfadjointProductMatrix
SelfadjointProductMatrix	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false>$/;"	s	namespace:Eigen
SelfadjointProductMatrix	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true>$/;"	s	namespace:Eigen
Sequential	Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	e	enum:Eigen::Sequential_t
SequentialLinSpacedReturnType	Eigen/src/Core/DenseBase.h	/^    typedef CwiseNullaryOp<internal::linspaced_op<Scalar,false>,Derived> SequentialLinSpacedReturnType;$/;"	t	class:Eigen::DenseBase
Sequential_t	Eigen/src/Core/util/Constants.h	/^enum Sequential_t { Sequential };$/;"	g	namespace:Eigen
Set	tinyxml2/tinyxml2.h	/^    void Set( char* start, char* end, int flags ) {$/;"	f	class:tinyxml2::StrPair
SetAccelerationLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetAccelerationLimit(SR_REAL abslimit)$/;"	f	class:srExtRevoluteJoint
SetAccelerationLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetAccelerationLimit(SR_REAL lowerlimit, SR_REAL upperlimit)$/;"	f	class:srExtRevoluteJoint
SetActType	srLib/srDyn/srJoint.cpp	/^void srJoint::SetActType(ACTTYPE v)$/;"	f	class:srJoint
SetAction	Eigen/src/Core/util/Constants.h	/^enum Action {GetAction, SetAction};$/;"	e	enum:Eigen::Action
SetAllowedPenetration	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::SetAllowedPenetration(SR_REAL _allowedpenetration)$/;"	f	class:ClosedLoop
SetAllowedPenetration	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::SetAllowedPenetration(SR_REAL _allowedpenetration)$/;"	f	class:ContactConstraint
SetAllowedPenetration	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::SetAllowedPenetration(SR_REAL _allowedpenetration)$/;"	f	class:JointConstraint
SetAlpha	srLib/srg/srgColor.cpp	/^void srgColor::SetAlpha(float Alpha)	{m_RGBA[3] = Alpha;};$/;"	f	class:srgColor
SetAmbient	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetAmbient(float fValue)$/;"	f	class:srgMaterialColor
SetAspectRatio	srLib/srg/srgCamera.cpp	/^void srgCamera::SetAspectRatio( double val )$/;"	f	class:srgCamera
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( bool v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( const char* v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( double v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( float v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( int v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute( unsigned v )$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetAttribute(int64_t v)$/;"	f	class:tinyxml2::XMLAttribute
SetAttribute	tinyxml2/tinyxml2.h	/^	void SetAttribute(const char* name, int64_t value) {$/;"	f	class:tinyxml2::XMLElement
SetAttribute	tinyxml2/tinyxml2.h	/^    void SetAttribute( const char* name, bool value )			{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	tinyxml2/tinyxml2.h	/^    void SetAttribute( const char* name, const char* value )	{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	tinyxml2/tinyxml2.h	/^    void SetAttribute( const char* name, double value )		{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	tinyxml2/tinyxml2.h	/^    void SetAttribute( const char* name, float value )		{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	tinyxml2/tinyxml2.h	/^    void SetAttribute( const char* name, int value )			{$/;"	f	class:tinyxml2::XMLElement
SetAttribute	tinyxml2/tinyxml2.h	/^    void SetAttribute( const char* name, unsigned value )		{$/;"	f	class:tinyxml2::XMLElement
SetBOM	tinyxml2/tinyxml2.h	/^    void SetBOM( bool useBOM ) {$/;"	f	class:tinyxml2::XMLDocument
SetBaseLink	srLib/srDyn/srSystem.cpp	/^void srSystem::SetBaseLink(srLink* v)$/;"	f	class:srSystem
SetBaseLinkType	srLib/srDyn/srSystem.cpp	/^void srSystem::SetBaseLinkType(BASELINKTYPE v)$/;"	f	class:srSystem
SetBlue	srLib/srg/srgColor.cpp	/^void srgColor::SetBlue(float Blue)	{m_RGBA[2] = Blue;};$/;"	f	class:srgColor
SetBouncingThreshold	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::SetBouncingThreshold(SR_REAL _bouncingthreshold)$/;"	f	class:ContactConstraint
SetBouncingThreshold	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::SetBouncingThreshold(SR_REAL _bouncingthreshold)$/;"	f	class:JointConstraint
SetC	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetC(SR_REAL c)$/;"	f	class:srLinearSpring
SetCData	tinyxml2/tinyxml2.h	/^    void SetCData( bool isCData )			{$/;"	f	class:tinyxml2::XMLText
SetCameraFrame	srLib/srg/srgCamera.cpp	/^void srgCamera::SetCameraFrame(const SE3& _T, double _length)$/;"	f	class:srgCamera
SetCameraFrame	srLib/srg/srgCamera.cpp	/^void srgCamera::SetCameraFrame(const Vec3& _eye, const Vec3& _center, const Vec3& _up)$/;"	f	class:srgCamera
SetCenter	srLib/srg/srgCamera.cpp	/^void srgCamera::SetCenter( const Vec3& _Center )$/;"	f	class:srgCamera
SetChildLink	srLib/srDyn/srJoint.cpp	/^void srJoint::SetChildLink(srLink* pLink)$/;"	f	class:srJoint
SetChildLinkFrame	srLib/srDyn/srJoint.cpp	/^void srJoint::SetChildLinkFrame(SE3 v)$/;"	f	class:srJoint
SetColor	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetColor(float r, float g, float b, float a)$/;"	f	class:srGeometryInfo
SetColor	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetColor(float* c)$/;"	f	class:srGeometryInfo
SetColor	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetColor(float Red, float Green, float Blue, float Alpha)$/;"	f	class:srgMaterialColor
SetColor	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetColor(float Red, float Green, float Blue,$/;"	f	class:srgMaterialColor
SetCoulombCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetCoulombCoeff(const SR_REAL fc)$/;"	f	class:srExtRevoluteJoint
SetDamping	srLib/srDyn/srLink.cpp	/^void srLink::SetDamping(SR_REAL v)$/;"	f	class:srLink
SetDampingCoeff	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::SetDampingCoeff(SR_REAL v)$/;"	f	class:srPrismaticJoint
SetDampingCoeff	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::SetDampingCoeff(SR_REAL v)$/;"	f	class:srRevoluteJoint
SetDampingCoeff	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::SetDampingCoeff(SR_REAL v, int idx)$/;"	f	class:srUniversalJoint
SetDefault	srLib/srDyn/srISLAND.cpp	/^void	PGSOption::SetDefault()$/;"	f	class:PGSOption
SetDetectedCallback	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::SetDetectedCallback(void (*pfn)(void*), void* pVoid)$/;"	f	class:srTouchSensor
SetDeviceOnOff	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::SetDeviceOnOff(bool onoff)$/;"	f	class:srBallJoint
SetDeviceOnOff	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::SetDeviceOnOff(bool onoff)$/;"	f	class:srPrismaticJoint
SetDeviceOnOff	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::SetDeviceOnOff(bool onoff)$/;"	f	class:srRevoluteJoint
SetDeviceOnOff	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::SetDeviceOnOff(bool onoff)$/;"	f	class:srUniversalJoint
SetDeviceOnOff	srLib/srDyn/srWeldJoint.cpp	/^void srWeldJoint::SetDeviceOnOff(bool onoff)$/;"	f	class:srWeldJoint
SetDiag	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon134
SetDiag	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SetDiag = (Mode&(ZeroDiag|UnitDiag)) ? 0 : 1$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon135
SetDiffuse	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetDiffuse(float fValue)$/;"	f	class:srgMaterialColor
SetDimension	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetDimension(Vec3 v)$/;"	f	class:srGeometryInfo
SetDimension	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetDimension(double w, double h, double d)$/;"	f	class:srGeometryInfo
SetDimension	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetDimension(float* v)$/;"	f	class:srGeometryInfo
SetDynType	srLib/srDyn/srLink.cpp	/^void srLink::SetDynType()$/;"	f	class:srLink
SetEmission	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetEmission(float fValue)$/;"	f	class:srgMaterialColor
SetErp	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::SetErp(SR_REAL _erp)$/;"	f	class:ClosedLoop
SetErp	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::SetErp(SR_REAL _erp)$/;"	f	class:ContactConstraint
SetErp	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::SetErp(SR_REAL _erp)$/;"	f	class:JointConstraint
SetError	tinyxml2/tinyxml2.cpp	/^void XMLDocument::SetError( XMLError error, const char* str1, const char* str2, int lineNum )$/;"	f	class:tinyxml2::XMLDocument
SetEulerAngle	srLib/srDyn/srEntity.cpp	/^void srEntity::SetEulerAngle(InvVec3 v)$/;"	f	class:srEntity
SetEye	srLib/srg/srgCamera.cpp	/^void srgCamera::SetEye( const Vec3& _Eye )$/;"	f	class:srgCamera
SetFOVy	srLib/srg/srgCamera.cpp	/^void srgCamera::SetFOVy( double val )$/;"	f	class:srgCamera
SetFar	srLib/srg/srgCamera.cpp	/^void srgCamera::SetFar( double val )$/;"	f	class:srgCamera
SetFileName	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetFileName(char* name)$/;"	f	class:srGeometryInfo
SetFrame	srLib/srDyn/srEntity.cpp	/^void srEntity::SetFrame(SE3 v)$/;"	f	class:srEntity
SetFriction	srLib/srDyn/srLink.cpp	/^void srLink::SetFriction(SR_REAL v)$/;"	f	class:srLink
SetFrictionCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetFrictionCoeff(const SR_REAL fv, const SR_REAL fc)$/;"	f	class:srExtRevoluteJoint
SetGearRatio	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetGearRatio(const SR_REAL G)$/;"	f	class:srExtRevoluteJoint
SetGeomInfo	srLib/srDyn/srEntity.cpp	/^void srEntity::SetGeomInfo(srGeometryInfo& v)$/;"	f	class:srEntity
SetGravity	srLib/srDyn/srSpace.cpp	/^void srSpace::SetGravity(SR_REAL x, SR_REAL y, SR_REAL z)$/;"	f	class:srSpace
SetGreen	srLib/srg/srgColor.cpp	/^void srgColor::SetGreen(float Green)	{m_RGBA[1] = Green;};$/;"	f	class:srgColor
SetImpulse	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::SetImpulse(SR_REAL * _lambda)$/;"	f	class:ClosedLoop
SetImpulse	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::SetImpulse(SR_REAL * _lambda)$/;"	f	class:ContactConstraint
SetImpulse	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::SetImpulse(SR_REAL * _lambda)$/;"	f	class:JointConstraint
SetInertia	srLib/srDyn/srLink.cpp	/^void srLink::SetInertia(Inertia v)$/;"	f	class:srLink
SetInitialLength	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetInitialLength(SR_REAL l)$/;"	f	class:srLinearSpring
SetInternedStr	tinyxml2/tinyxml2.h	/^    void SetInternedStr( const char* str ) {$/;"	f	class:tinyxml2::StrPair
SetK	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetK(SR_REAL k)$/;"	f	class:srLinearSpring
SetLeftLink	srLib/srDyn/srSpring.cpp	/^void srSpring::SetLeftLink(srLink* lLink)$/;"	f	class:srSpring
SetLeftLinkPosition	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetLeftLinkPosition(SE3 lp)$/;"	f	class:srLinearSpring
SetLeftLinkPosition	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetLeftLinkPosition(Vec3 lp)$/;"	f	class:srLinearSpring
SetLeftLinkPosition	srLib/srDyn/srSpring.cpp	/^void srSpring::SetLeftLinkPosition(SE3 lf)$/;"	f	class:srSpring
SetLeftLinkPosition	srLib/srDyn/srSpring.cpp	/^void srSpring::SetLeftLinkPosition(Vec3 lf)$/;"	f	class:srSpring
SetLocalFrame	srLib/srDyn/srCollision.cpp	/^void srCollision::SetLocalFrame(SE3 v)$/;"	f	class:srCollision
SetLocalFrame	srLib/srDyn/srCollision.cpp	/^void srCollision::SetLocalFrame(SE3& v)$/;"	f	class:srCollision
SetLocalFrame	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetLocalFrame(SE3 T)$/;"	f	class:srGeometryInfo
SetLocalFrame	srLib/srDyn/srSensor.cpp	/^void srSensor::SetLocalFrame(SE3 T)$/;"	f	class:srSensor
SetLocalFrame	srLib/srDyn/srSensor.cpp	/^void srSensor::SetLocalFrame(SE3& T)$/;"	f	class:srSensor
SetMaxRPM	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetMaxRPM(const SR_REAL maxRPM)$/;"	f	class:srExtRevoluteJoint
SetMaxRange	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::SetMaxRange(SR_REAL max)$/;"	f	class:srIRSensor
SetMaxRange	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::SetMaxRange(SR_REAL max)$/;"	f	class:srRangeFinder
SetMaximumBouncingVelocity	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::SetMaximumBouncingVelocity(SR_REAL _maximum_bouncing_velocity)$/;"	f	class:ContactConstraint
SetMaximumBouncingVelocity	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::SetMaximumBouncingVelocity(SR_REAL _maximum_bouncing_velocity)$/;"	f	class:JointConstraint
SetMaximumErpVelocity	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::SetMaximumErpVelocity(SR_REAL _maximum_erp_velocity)$/;"	f	class:ClosedLoop
SetMaximumErpVelocity	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::SetMaximumErpVelocity(SR_REAL _maximum_erp_velocity)$/;"	f	class:ContactConstraint
SetMaximumErpVelocity	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::SetMaximumErpVelocity(SR_REAL _maximum_erp_velocity)$/;"	f	class:JointConstraint
SetMinRange	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::SetMinRange(SR_REAL min)$/;"	f	class:srIRSensor
SetMinRange	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::SetMinRange(SR_REAL min)$/;"	f	class:srRangeFinder
SetName	srLib/srDyn/srObject.cpp	/^void srObject::SetName(char* name)$/;"	f	class:srObject
SetName	srLib/srDyn/srObject.cpp	/^void srObject::SetName(string name)$/;"	f	class:srObject
SetName	srLib/srDyn/srObject.cpp	/^void srObject::SetName(wchar_t* name)$/;"	f	class:srObject
SetName	srLib/srDyn/srObject.cpp	/^void srObject::SetName(wstring name)$/;"	f	class:srObject
SetName	tinyxml2/tinyxml2.cpp	/^void XMLAttribute::SetName( const char* n )$/;"	f	class:tinyxml2::XMLAttribute
SetName	tinyxml2/tinyxml2.h	/^    void SetName( const char* str, bool staticMem=false )	{$/;"	f	class:tinyxml2::XMLElement
SetNear	srLib/srg/srgCamera.cpp	/^void srgCamera::SetNear( double val )$/;"	f	class:srgCamera
SetNumberofSubstepForRendering	srLib/srDyn/srSpace.cpp	/^void srSpace::SetNumberofSubstepForRendering(int v)$/;"	f	class:srSpace
SetOffset	srLib/srDyn/srLink.cpp	/^void srLink::SetOffset(Vec3 ofs)$/;"	f	class:srLink
SetOffset	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::SetOffset(SR_REAL v)$/;"	f	class:srPrismaticJoint
SetOffset	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::SetOffset(SR_REAL v)$/;"	f	class:srRevoluteJoint
SetOffset	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::SetOffset(SR_REAL v, int idx)$/;"	f	class:srUniversalJoint
SetOrientation	srLib/srDyn/srEntity.cpp	/^void srEntity::SetOrientation(SO3 v)$/;"	f	class:srEntity
SetParentLink	srLib/srDyn/srJoint.cpp	/^void srJoint::SetParentLink(srLink* pLink)$/;"	f	class:srJoint
SetParentLinkFrame	srLib/srDyn/srJoint.cpp	/^void srJoint::SetParentLinkFrame(SE3 v)$/;"	f	class:srJoint
SetPosition	srLib/srDyn/srEntity.cpp	/^void srEntity::SetPosition(Vec3 v)$/;"	f	class:srEntity
SetPositionLimit	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::SetPositionLimit(SR_REAL lowerlimit, SR_REAL upperlimit)$/;"	f	class:srPrismaticJoint
SetPositionLimit	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::SetPositionLimit(SR_REAL lowerlimit, SR_REAL upperlimit)$/;"	f	class:srRevoluteJoint
SetPositionLimit	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::SetPositionLimit(SR_REAL lowerlimit, SR_REAL upperlimit, int idx \/*= 2*\/)$/;"	f	class:srUniversalJoint
SetPriorityIndex	srLib/srDyn/srJoint.cpp	/^void srJoint::SetPriorityIndex(int idx)$/;"	f	class:srJoint
SetProjMat	srLib/srg/srgCamera.cpp	/^void srgCamera::SetProjMat( SE3 val )$/;"	f	class:srgCamera
SetProjectionMode	srLib/srg/srgCamera.cpp	/^void srgCamera::SetProjectionMode( srgCamera::ProjectionType val )$/;"	f	class:srgCamera
SetRGB	srLib/srg/srgColor.cpp	/^void srgColor::SetRGB(float Red, float Green, float Blue)$/;"	f	class:srgColor
SetRGBA	srLib/srg/srgColor.cpp	/^void srgColor::SetRGBA(float Red, float Green, float Blue, float Alpha)$/;"	f	class:srgColor
SetRange	srLib/srDyn/srIRSensor.cpp	/^void srIRSensor::SetRange(SR_REAL max, SR_REAL min)$/;"	f	class:srIRSensor
SetRange	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::SetRange(SR_REAL max, SR_REAL min)$/;"	f	class:srRangeFinder
SetRange	srLib/srDyn/srTouchSensor.cpp	/^void srTouchSensor::SetRange(SR_REAL R)$/;"	f	class:srTouchSensor
SetRed	srLib/srg/srgColor.cpp	/^void srgColor::SetRed(float Red)		{m_RGBA[0] = Red;};$/;"	f	class:srgColor
SetResistance	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetResistance(const SR_REAL R)$/;"	f	class:srExtRevoluteJoint
SetResolution	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::SetResolution(SR_REAL r)$/;"	f	class:srRangeFinder
SetRestitution	srLib/srDyn/srLink.cpp	/^void srLink::SetRestitution(SR_REAL v)$/;"	f	class:srLink
SetRightLink	srLib/srDyn/srSpring.cpp	/^void srSpring::SetRightLink(srLink* rLink)$/;"	f	class:srSpring
SetRightLinkPosition	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetRightLinkPosition(SE3 rp)$/;"	f	class:srLinearSpring
SetRightLinkPosition	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::SetRightLinkPosition(Vec3 rp)$/;"	f	class:srLinearSpring
SetRightLinkPosition	srLib/srDyn/srSpring.cpp	/^void srSpring::SetRightLinkPosition(SE3 rf)$/;"	f	class:srSpring
SetRightLinkPosition	srLib/srDyn/srSpring.cpp	/^void srSpring::SetRightLinkPosition(Vec3 rf)$/;"	f	class:srSpring
SetRotorInertia	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetRotorInertia(const SR_REAL R)$/;"	f	class:srExtRevoluteJoint
SetSelfCollision	srLib/srDyn/srSystem.cpp	/^void srSystem::SetSelfCollision(bool v \/* = true *\/)$/;"	f	class:srSystem
SetShape	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::SetShape(SHAPETYPE t)$/;"	f	class:srGeometryInfo
SetShininess	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetShininess(float m_fShininessFactor)$/;"	f	class:srgMaterialColor
SetSpecular	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetSpecular(float fValue)$/;"	f	class:srgMaterialColor
SetSpread	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::SetSpread(int s)$/;"	f	class:srRangeFinder
SetSpringCoeff	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::SetSpringCoeff(SR_REAL v)$/;"	f	class:srPrismaticJoint
SetSpringCoeff	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::SetSpringCoeff(SR_REAL v)$/;"	f	class:srRevoluteJoint
SetSpringCoeff	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::SetSpringCoeff(SR_REAL v, int idx)$/;"	f	class:srUniversalJoint
SetStr	tinyxml2/tinyxml2.cpp	/^void StrPair::SetStr( const char* str, int flags )$/;"	f	class:tinyxml2::StrPair
SetText	tinyxml2/tinyxml2.cpp	/^void	XMLElement::SetText( const char* inText )$/;"	f	class:tinyxml2::XMLElement
SetText	tinyxml2/tinyxml2.cpp	/^void XMLElement::SetText( bool v )$/;"	f	class:tinyxml2::XMLElement
SetText	tinyxml2/tinyxml2.cpp	/^void XMLElement::SetText( double v ) $/;"	f	class:tinyxml2::XMLElement
SetText	tinyxml2/tinyxml2.cpp	/^void XMLElement::SetText( float v ) $/;"	f	class:tinyxml2::XMLElement
SetText	tinyxml2/tinyxml2.cpp	/^void XMLElement::SetText( int v ) $/;"	f	class:tinyxml2::XMLElement
SetText	tinyxml2/tinyxml2.cpp	/^void XMLElement::SetText( unsigned v ) $/;"	f	class:tinyxml2::XMLElement
SetText	tinyxml2/tinyxml2.cpp	/^void XMLElement::SetText(int64_t v)$/;"	f	class:tinyxml2::XMLElement
SetTimestep	srLib/srDyn/srSpace.cpp	/^void srSpace::SetTimestep(SR_REAL v)$/;"	f	class:srSpace
SetTorqueConstant	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetTorqueConstant(const SR_REAL TorqueCnt)$/;"	f	class:srExtRevoluteJoint
SetTorqueLimit	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::SetTorqueLimit(SR_REAL lowerlimit, SR_REAL upperlimit)$/;"	f	class:srPrismaticJoint
SetTorqueLimit	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::SetTorqueLimit(SR_REAL lowerlimit, SR_REAL upperlimit)$/;"	f	class:srRevoluteJoint
SetTorqueLimit	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::SetTorqueLimit(SR_REAL lowerlimit, SR_REAL upperlimit, int idx \/*=2*\/)$/;"	f	class:srUniversalJoint
SetTracked	tinyxml2/tinyxml2.h	/^    void SetTracked() {$/;"	f	class:tinyxml2::MemPoolT
SetTransp	srLib/srg/srgColor.cpp	/^void srgMaterialColor::SetTransp(float _alpha)$/;"	f	class:srgMaterialColor
SetUp	srLib/srg/srgCamera.cpp	/^void srgCamera::SetUp( const Vec3& _Up )$/;"	f	class:srgCamera
SetUserData	tinyxml2/tinyxml2.h	/^	void SetUserData(void* userData)	{ _userData = userData; }$/;"	f	class:tinyxml2::XMLNode
SetValue	tinyxml2/tinyxml2.cpp	/^void XMLNode::SetValue( const char* str, bool staticMem )$/;"	f	class:tinyxml2::XMLNode
SetVelocity	Example/MobileRobots/MobileRobots.h	/^	void		SetVelocity(real l, real r) {$/;"	f	class:MobileRobot
SetVelocityLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetVelocityLimit()$/;"	f	class:srExtRevoluteJoint
SetVelocityLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetVelocityLimit(SR_REAL abslimit)$/;"	f	class:srExtRevoluteJoint
SetVelocityLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetVelocityLimit(SR_REAL lowerlimit, SR_REAL upperlimit)$/;"	f	class:srExtRevoluteJoint
SetViewDirection	srLib/srg/srgCamera.cpp	/^void srgCamera::SetViewDirection( srgCamera::ViewDirection val )$/;"	f	class:srgCamera
SetViscousCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	void	SetViscousCoeff(const SR_REAL fv)$/;"	f	class:srExtRevoluteJoint
Set_UpdateFrame_Ftn	srLib/srDyn/srJoint.cpp	/^void srJoint::Set_UpdateFrame_Ftn()$/;"	f	class:srJoint
Shader	srLib/SceneGraph/Shader.cpp	/^Shader::Shader(void)$/;"	f	class:Shader
Shader	srLib/SceneGraph/Shader.h	/^class Shader :$/;"	c
ShallowClone	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLComment::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLComment
ShallowClone	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLDeclaration::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLDeclaration
ShallowClone	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLElement::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLElement
ShallowClone	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLText::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLText
ShallowClone	tinyxml2/tinyxml2.cpp	/^XMLNode* XMLUnknown::ShallowClone( XMLDocument* doc ) const$/;"	f	class:tinyxml2::XMLUnknown
ShallowClone	tinyxml2/tinyxml2.h	/^    virtual XMLNode* ShallowClone( XMLDocument* \/*document*\/ ) const	{$/;"	f	class:tinyxml2::XMLDocument
ShallowEqual	tinyxml2/tinyxml2.cpp	/^bool XMLComment::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLComment
ShallowEqual	tinyxml2/tinyxml2.cpp	/^bool XMLDeclaration::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLDeclaration
ShallowEqual	tinyxml2/tinyxml2.cpp	/^bool XMLElement::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLElement
ShallowEqual	tinyxml2/tinyxml2.cpp	/^bool XMLText::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLText
ShallowEqual	tinyxml2/tinyxml2.cpp	/^bool XMLUnknown::ShallowEqual( const XMLNode* compare ) const$/;"	f	class:tinyxml2::XMLUnknown
ShallowEqual	tinyxml2/tinyxml2.h	/^    virtual bool ShallowEqual( const XMLNode* \/*compare*\/ ) const	{$/;"	f	class:tinyxml2::XMLDocument
Shininess	srLib/srg/srgColor.h	/^		float Shininess;		\/\/ material property for shininess (±¤ÅÃ)$/;"	m	struct:srgMaterialColor::sMaterialColor
Side	Eigen/src/Core/GeneralProduct.h	/^    enum { Side = Lhs::IsVectorAtCompileTime ? OnTheLeft : OnTheRight };$/;"	e	enum:Eigen::GeneralProduct::__anon308
SideType	Eigen/src/Core/util/Constants.h	/^enum SideType {$/;"	g	namespace:Eigen
SignMatrix	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	g	namespace:Eigen::internal
SimplicialCholesky	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky() : Base(), m_LDLT(true) {}$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholesky	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
SimplicialCholesky	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialCholesky : public SimplicialCholeskyBase<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholeskyBase(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^class SimplicialCholeskyBase : internal::noncopyable$/;"	c	namespace:Eigen
SimplicialCholeskyLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLDLT$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  SimplicialCholeskyLLT,$/;"	e	enum:Eigen::SimplicialCholeskyMode
SimplicialCholeskyMode	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^enum SimplicialCholeskyMode {$/;"	g	namespace:Eigen
SimplicialLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT() : Base() {}$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
SimplicialLDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLDLT : public SimplicialCholeskyBase<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SimplicialLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT() : Base() {}$/;"	f	class:Eigen::SimplicialLLT
SimplicialLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
SimplicialLLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    class SimplicialLLT : public SimplicialCholeskyBase<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	c	namespace:Eigen
SingletonVector	Eigen/src/SparseCore/SparseMatrix.h	/^        SingletonVector(Index i, Index v)$/;"	f	class:Eigen::SparseMatrix::SingletonVector
SingletonVector	Eigen/src/SparseCore/SparseMatrix.h	/^    class SingletonVector$/;"	c	class:Eigen::SparseMatrix
SingularValuesType	Eigen/src/Eigen2Support/SVD.h	/^    typedef Matrix<Scalar, MinSize, 1> SingularValuesType;$/;"	t	class:Eigen::SVD
SingularValuesType	Eigen/src/SVD/JacobiSVD.h	/^    typedef typename internal::plain_diag_type<MatrixType, RealScalar>::type SingularValuesType;$/;"	t	class:Eigen::JacobiSVD
Size	Eigen/src/Core/Redux.h	/^    Size = Derived::SizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_impl::__anon336
Size	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon471
Size	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::SelfAdjointEigenSolver::__anon474
Size	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      Size = MatrixType::RowsAtCompileTime,$/;"	e	enum:Eigen::Tridiagonalization::__anon470
Size	tinyxml2/tinyxml2.h	/^    int Size() const					{$/;"	f	class:tinyxml2::DynArray
SizeA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeA = ActualRows * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon118
SizeAtCompileTime	Eigen/src/Core/BandMatrix.h	/^      SizeAtCompileTime = EIGEN_SIZE_MIN_PREFER_DYNAMIC(RowsAtCompileTime,ColsAtCompileTime)$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon213
SizeAtCompileTime	Eigen/src/Core/DenseBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::DenseBase::__anon341
SizeAtCompileTime	Eigen/src/Core/MapBase.h	/^      SizeAtCompileTime = Base::SizeAtCompileTime$/;"	e	enum:Eigen::MapBase::__anon220
SizeAtCompileTime	Eigen/src/SparseCore/SparseMatrixBase.h	/^      SizeAtCompileTime = (internal::size_at_compile_time<internal::traits<Derived>::RowsAtCompileTime,$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
SizeB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeB = ActualCols * MaxDepth,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon118
SizeMinusOne	Eigen/src/Core/MatrixBase.h	/^      SizeMinusOne = SizeAtCompileTime==Dynamic ? Dynamic : SizeAtCompileTime-1$/;"	e	enum:Eigen::MatrixBase::__anon202
SizeMinusOne	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : Size - 1,$/;"	e	enum:Eigen::HessenbergDecomposition::__anon471
SizeMinusOne	Eigen/src/Eigenvalues/Tridiagonalization.h	/^      SizeMinusOne = Size == Dynamic ? Dynamic : (Size > 1 ? Size - 1 : 1),$/;"	e	enum:Eigen::Tridiagonalization::__anon470
SizeW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      SizeW = MaxDepth * Traits::WorkSpaceFactor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon118
SkipDiag	Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipDiag = (Mode&ZeroDiag) ? 1 : 0,$/;"	e	enum:Eigen::SparseTriangularView::__anon371
SkipFirst	Eigen/src/SparseCore/SparseTriangularView.h	/^    enum { SkipFirst = ((Mode&Lower) && !(MatrixType::Flags&RowMajorBit))$/;"	e	enum:Eigen::SparseTriangularView::__anon371
SkipLast	Eigen/src/SparseCore/SparseTriangularView.h	/^           SkipLast = !SkipFirst,$/;"	e	enum:Eigen::SparseTriangularView::__anon371
SkipWhiteSpace	tinyxml2/tinyxml2.h	/^    static char* SkipWhiteSpace( char* p, int* curLineNumPtr )				{$/;"	f	class:tinyxml2::XMLUtil
SkipWhiteSpace	tinyxml2/tinyxml2.h	/^    static const char* SkipWhiteSpace( const char* p, int* curLineNumPtr )	{$/;"	f	class:tinyxml2::XMLUtil
SliceVectorizedTraversal	Eigen/src/Core/util/Constants.h	/^  SliceVectorizedTraversal,$/;"	e	enum:Eigen::TraversalType
SluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix()$/;"	f	struct:Eigen::SluMatrix
SluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
SluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrix : SuperMatrix$/;"	s	namespace:Eigen
SluMatrixMapHelper	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<Matrix<Scalar,Rows,Cols,Options,MRows,MCols> >$/;"	s	namespace:Eigen
SluMatrixMapHelper	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct SluMatrixMapHelper<SparseMatrixBase<Derived> >$/;"	s	namespace:Eigen
Small	Eigen/src/Core/GeneralProduct.h	/^  Small = 3$/;"	e	enum:Eigen::__anon281
SmallPanelWidth	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = 2 * EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon134
SmallPanelWidth	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^    SmallPanelWidth   = EIGEN_PLAIN_ENUM_MAX(Traits::mr,Traits::nr),$/;"	e	enum:Eigen::internal::product_triangular_matrix_matrix::__anon135
Solid_Constraints	srLib/srDyn/srDYN.h	/^	ConstraintPtrArray					Solid_Constraints;$/;"	m	class:srDYN
SonarDetection	srLib/srDyn/srCollision.cpp	/^bool srCollision::SonarDetection(SE3& T0, SR_REAL & range , SR_REAL & angle, bool & res)$/;"	f	class:srCollision
SortContactPoints	srLib/srDyn/srContactConstraint.cpp	/^inline int ContactConstraint::SortContactPoints(Vec3& localpoint_Left, SR_REAL & penetration)$/;"	f	class:ContactConstraint
SparseBase	Eigen/src/SparseCore/SparseVector.h	/^    typedef SparseMatrixBase<SparseVector> SparseBase;$/;"	t	class:Eigen::SparseVector
SparseDenseOuterProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDenseOuterProduct
SparseDenseOuterProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE SparseDenseOuterProduct(const Rhs& rhs, const Lhs& lhs)$/;"	f	class:Eigen::SparseDenseOuterProduct
SparseDenseOuterProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseDenseOuterProduct$/;"	c	namespace:Eigen
SparseDenseProductReturnType	Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs, int InnerSize> struct SparseDenseProductReturnType$/;"	s	namespace:Eigen
SparseDenseProductReturnType	Eigen/src/SparseCore/SparseDenseProduct.h	/^template<typename Lhs, typename Rhs> struct SparseDenseProductReturnType<Lhs,Rhs,1>$/;"	s	namespace:Eigen
SparseDiagonalProduct	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE SparseDiagonalProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseDiagonalProduct
SparseDiagonalProduct	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class SparseDiagonalProduct$/;"	c	namespace:Eigen
SparseFlags	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    SparseFlags = is_diagonal<_Lhs>::ret ? int(_Rhs::Flags) : int(_Lhs::Flags),$/;"	e	enum:Eigen::internal::traits::__anon368
SparseLU	Eigen/src/SparseLU/SparseLU.h	/^    SparseLU():m_isInitialized(true),m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU
SparseLU	Eigen/src/SparseLU/SparseLU.h	/^    SparseLU(const MatrixType& matrix):m_isInitialized(true),m_lastError(""),m_Ustore(0,0,0,0,0,0),m_symmetricmode(false),m_diagpivotthresh(1.0),m_detPermR(1)$/;"	f	class:Eigen::SparseLU
SparseLU	Eigen/src/SparseLU/SparseLU.h	/^class SparseLU : public internal::SparseLUImpl<typename _MatrixType::Scalar, typename _MatrixType::Index>$/;"	c	namespace:Eigen
SparseLUImpl	Eigen/src/SparseLU/SparseLUImpl.h	/^class SparseLUImpl$/;"	c	namespace:Eigen::internal
SparseLUMatrixLReturnType	Eigen/src/SparseLU/SparseLU.h	/^  SparseLUMatrixLReturnType(const MappedSupernodalType& mapL) : m_mapL(mapL)$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
SparseLUMatrixLReturnType	Eigen/src/SparseLU/SparseLU.h	/^struct SparseLUMatrixLReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen
SparseLUMatrixUReturnType	Eigen/src/SparseLU/SparseLU.h	/^  SparseLUMatrixUReturnType(const MatrixLType& mapL, const MatrixUType& mapU)$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
SparseLUMatrixUReturnType	Eigen/src/SparseLU/SparseLU.h	/^struct SparseLUMatrixUReturnType : internal::no_assignment_operator$/;"	s	namespace:Eigen
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    SparseMatrix(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix(const SparseSelfAdjointView<OtherDerived, UpLo>& other)$/;"	f	class:Eigen::SparseMatrix
SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^class SparseMatrix$/;"	c	namespace:Eigen
SparseMatrixBase	Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseMatrixBase() : m_isRValue(false) { \/* TODO check flags *\/ }$/;"	f	class:Eigen::SparseMatrixBase
SparseMatrixBase	Eigen/src/SparseCore/SparseMatrixBase.h	/^template<typename Derived> class SparseMatrixBase$/;"	c	namespace:Eigen
SparseMatrixType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef SparseMatrix<Scalar,RowMajor,Index> SparseMatrixType;$/;"	t	class:Eigen::PardisoImpl
SparseMatrixType	Eigen/src/SparseCore/SparseBlock.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> SparseMatrixType;$/;"	t	class:Eigen::BlockImpl
SparseQR	Eigen/src/SparseQR/SparseQR.h	/^    SparseQR () : m_isInitialized(false), m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR
SparseQR	Eigen/src/SparseQR/SparseQR.h	/^    SparseQR(const MatrixType& mat) : m_isInitialized(false), m_analysisIsok(false), m_lastError(""), m_useDefaultThreshold(true),m_isQSorted(false),m_isEtreeOk(false)$/;"	f	class:Eigen::SparseQR
SparseQR	Eigen/src/SparseQR/SparseQR.h	/^class SparseQR$/;"	c	namespace:Eigen
SparseQRMatrixQReturnType	Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
SparseQRMatrixQReturnType	Eigen/src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQReturnType : public EigenBase<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen
SparseQRMatrixQTransposeReturnType	Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType(const SparseQRType& qr) : m_qr(qr) {}$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType
SparseQRMatrixQTransposeReturnType	Eigen/src/SparseQR/SparseQR.h	/^struct SparseQRMatrixQTransposeReturnType$/;"	s	namespace:Eigen
SparseQR_QProduct	Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct(const SparseQRType& qr, const Derived& other, bool transpose) : $/;"	f	struct:Eigen::SparseQR_QProduct
SparseQR_QProduct	Eigen/src/SparseQR/SparseQR.h	/^struct SparseQR_QProduct : ReturnByValue<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen
SparseSelfAdjointTimeDenseProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct
SparseSelfAdjointTimeDenseProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSelfAdjointTimeDenseProduct$/;"	c	namespace:Eigen
SparseSelfAdjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline SparseSelfAdjointView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::SparseSelfAdjointView
SparseSelfAdjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^template<typename MatrixType, unsigned int UpLo> class SparseSelfAdjointView$/;"	c	namespace:Eigen
SparseSparseProduct	Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::SparseSparseProduct
SparseSparseProduct	Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE SparseSparseProduct(const Lhs& lhs, const Rhs& rhs, const RealScalar& tolerance)$/;"	f	class:Eigen::SparseSparseProduct
SparseSparseProduct	Eigen/src/SparseCore/SparseProduct.h	/^class SparseSparseProduct : internal::no_assignment_operator,$/;"	c	namespace:Eigen
SparseSparseProductReturnType	Eigen/src/SparseCore/SparseProduct.h	/^struct SparseSparseProductReturnType$/;"	s	namespace:Eigen
SparseSymmetricPermutationProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct(const MatrixType& mat, const Perm& perm)$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
SparseSymmetricPermutationProduct	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^class SparseSymmetricPermutationProduct$/;"	c	namespace:Eigen
SparseTimeDenseProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseTimeDenseProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs)$/;"	f	class:Eigen::SparseTimeDenseProduct
SparseTimeDenseProduct	Eigen/src/SparseCore/SparseDenseProduct.h	/^class SparseTimeDenseProduct$/;"	c	namespace:Eigen
SparseTriangularView	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline SparseTriangularView(const MatrixType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::SparseTriangularView
SparseTriangularView	Eigen/src/SparseCore/SparseTriangularView.h	/^template<typename MatrixType, int Mode> class SparseTriangularView$/;"	c	namespace:Eigen
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector() : m_size(0) { check_template_parameters(); resize(0); }$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index rows, Index cols) : m_size(0) { check_template_parameters(); resize(rows,cols); }$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(Index size) : m_size(0) { check_template_parameters(); resize(size); }$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
SparseVector	Eigen/src/SparseCore/SparseVector.h	/^class SparseVector$/;"	c	namespace:Eigen
SparseView	Eigen/src/SparseCore/SparseView.h	/^  explicit SparseView(const MatrixType& mat, const Scalar& reference = Scalar(0),$/;"	f	class:Eigen::SparseView
SparseView	Eigen/src/SparseCore/SparseView.h	/^class SparseView : public SparseMatrixBase<SparseView<MatrixType> >$/;"	c	namespace:Eigen
Specialized	Eigen/src/Core/util/Constants.h	/^  Specialized,$/;"	e	enum:Eigen::SpecializedType
SpecializedType	Eigen/src/Core/util/Constants.h	/^enum SpecializedType {$/;"	g	namespace:Eigen
Specular	srLib/srg/srgColor.h	/^		float Specular[4];		\/\/ material property for specular lighting (¹Ý»ç)$/;"	m	struct:srgMaterialColor::sMaterialColor
Sphere	srLib/SceneGraph/Leaf.cpp	/^Sphere::Sphere(double _radius \/*=1*\/)$/;"	f	class:Sphere
Sphere	srLib/SceneGraph/Leaf.h	/^class Sphere : public Leaf$/;"	c
SphereInertia	srLib/LieGroup/LieGroup.cpp	/^Inertia SphereInertia(SR_REAL density, SR_REAL rad)$/;"	f
SquareMatrixType	Eigen/src/Core/MatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::MatrixBase
SquareMatrixType	Eigen/src/SparseCore/SparseMatrixBase.h	/^                          EIGEN_SIZE_MAX(RowsAtCompileTime,ColsAtCompileTime)> SquareMatrixType;$/;"	t	class:Eigen::SparseMatrixBase
SrcHasDirectAccess	Eigen/src/Core/Assign_MKL.h	/^      SrcHasDirectAccess = Src::Flags & DirectAccessBit,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
SrcIsAligned	Eigen/src/Core/Assign.h	/^    SrcIsAligned = OtherDerived::Flags & AlignedBit,$/;"	e	enum:Eigen::internal::assign_traits::__anon23
SrcStorageOrder	Eigen/src/SparseCore/SparsePermutation.h	/^      SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::permut_sparsematrix_product_retval::__anon373
SrcStorageOrder	Eigen/src/SparseCore/SparsePermutation.h	/^    SrcStorageOrder = MatrixTypeNestedCleaned::Flags&RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon372
StatePtrArray	srLib/srDyn/srDYN.h	/^typedef _array<srState*>			StatePtrArray;$/;"	t
StemFunction	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::stem_function<Scalar>::type StemFunction;$/;"	t	class:Eigen::MatrixBase
Storage	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseMatrix
Storage	Eigen/src/SparseCore/SparseVector.h	/^    typedef internal::CompressedStorage<Scalar,Index> Storage;$/;"	t	class:Eigen::SparseVector
StorageBaseType	Eigen/src/Core/ArrayBase.h	/^    typedef ArrayBase StorageBaseType;$/;"	t	class:Eigen::ArrayBase
StorageBaseType	Eigen/src/Core/MatrixBase.h	/^    typedef MatrixBase StorageBaseType;$/;"	t	class:Eigen::MatrixBase
StorageBaseType	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef SparseMatrixBase StorageBaseType;$/;"	t	class:Eigen::SparseMatrixBase
StorageIndex	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::Index StorageIndex;$/;"	t	class:Eigen::SparseMatrixBase
StorageKind	Eigen/src/Core/ArrayBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::ArrayBase
StorageKind	Eigen/src/Core/BandMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/BandMatrix.h	/^  typedef typename _CoefficientsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/CwiseBinaryOp.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/DenseBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseBase
StorageKind	Eigen/src/Core/DenseCoeffsBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DenseCoeffsBase
StorageKind	Eigen/src/Core/Diagonal.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalBase
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^    typedef typename internal::traits<DiagonalMatrix>::StorageKind StorageKind;$/;"	t	class:Eigen::DiagonalMatrix
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/DiagonalMatrix.h	/^  typedef typename DiagonalVectorType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/EigenBase.h	/^  typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	struct:Eigen::EigenBase
StorageKind	Eigen/src/Core/MapBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MapBase
StorageKind	Eigen/src/Core/Matrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/MatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::MatrixBase
StorageKind	Eigen/src/Core/PermutationMatrix.h	/^  typedef PermutationStorage StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/PlainObjectBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::PlainObjectBase
StorageKind	Eigen/src/Core/ProductBase.h	/^                                           typename traits<Rhs>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/ProductBase.h	/^  typedef typename traits<NestedProduct>::StorageKind StorageKind;$/;"	t	struct:internal::traits
StorageKind	Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Select.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularBase
StorageKind	Eigen/src/Core/TriangularMatrix.h	/^    typedef typename internal::traits<TriangularView>::StorageKind StorageKind;$/;"	t	class:Eigen::TriangularView
StorageKind	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Core/products/CoeffBasedProduct.h	/^                                           typename traits<_RhsNested>::StorageKind>::ret StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Eigen2Support/Minor.h	/^  typedef typename MatrixType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename traits<MatrixType>::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/Householder/HouseholderSequence.h	/^  typedef typename VectorsType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/LU/FullPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::FullPivLU
StorageKind	Eigen/src/LU/PartialPivLU.h	/^    typedef typename internal::traits<MatrixType>::StorageKind StorageKind;$/;"	t	class:Eigen::PartialPivLU
StorageKind	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseMatrixBase.h	/^    typedef typename internal::traits<Derived>::StorageKind StorageKind;$/;"	t	class:Eigen::SparseMatrixBase
StorageKind	Eigen/src/SparseCore/SparseProduct.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^  typedef Dense StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseVector.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseCore/SparseView.h	/^  typedef Sparse StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageKind	Eigen/src/SparseQR/SparseQR.h	/^    typedef typename ReturnType::StorageKind StorageKind;$/;"	t	struct:Eigen::internal::traits
StorageOptions	Eigen/src/Core/util/Constants.h	/^enum StorageOptions {$/;"	g	namespace:Eigen
StorageOrderMatch	Eigen/src/Core/Ref.h	/^      StorageOrderMatch = PlainObjectType::IsVectorAtCompileTime || Derived::IsVectorAtCompileTime || ((PlainObjectType::Flags&RowMajorBit)==(Derived::Flags&RowMajorBit)),$/;"	e	enum:Eigen::internal::traits::match::__anon323
StorageOrdersAgree	Eigen/src/Core/Assign.h	/^    StorageOrdersAgree = (int(Derived::IsRowMajor) == int(OtherDerived::IsRowMajor)),$/;"	e	enum:Eigen::internal::assign_traits::__anon25
StorageOrdersAgree	Eigen/src/Core/Assign_MKL.h	/^      StorageOrdersAgree = (int(Dst::IsRowMajor) == int(Src::IsRowMajor)),$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
StorageOrdersAgree	Eigen/src/Core/CwiseBinaryOp.h	/^    StorageOrdersAgree = (int(Lhs::Flags)&RowMajorBit)==(int(Rhs::Flags)&RowMajorBit),$/;"	e	enum:Eigen::internal::traits::__anon228
StorageOrdersMatch	Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon429
StorageOrdersMatch	Eigen/src/LU/arch/Inverse_SSE.h	/^    StorageOrdersMatch  = (MatrixType::Flags&RowMajorBit) == (ResultType::Flags&RowMajorBit)$/;"	e	enum:Eigen::internal::compute_inverse_size4::__anon430
StrPair	tinyxml2/tinyxml2.h	/^    StrPair() : _flags( 0 ), _start( 0 ), _end( 0 ) {}$/;"	f	class:tinyxml2::StrPair
StrPair	tinyxml2/tinyxml2.h	/^class StrPair$/;"	c	namespace:tinyxml2
StreamPrecision	Eigen/src/Core/IO.h	/^enum { StreamPrecision = -1,$/;"	e	enum:Eigen::__anon243
Stri	srLib/SceneGraph/Model3DS.h	/^	double	Stri[3][3];			\/\/ Storing the triangle$/;"	m	class:Model3DS
StrictlyLower	Eigen/src/Core/util/Constants.h	/^  StrictlyLower=ZeroDiag|Lower, $/;"	e	enum:Eigen::UpLoType
StrictlyUpper	Eigen/src/Core/util/Constants.h	/^  StrictlyUpper=ZeroDiag|Upper,$/;"	e	enum:Eigen::UpLoType
Stride	Eigen/src/Core/Stride.h	/^    Stride()$/;"	f	class:Eigen::Stride
Stride	Eigen/src/Core/Stride.h	/^    Stride(Index outerStride, Index innerStride)$/;"	f	class:Eigen::Stride
Stride	Eigen/src/Core/Stride.h	/^    Stride(const Stride& other)$/;"	f	class:Eigen::Stride
Stride	Eigen/src/Core/Stride.h	/^class Stride$/;"	c	namespace:Eigen
StrideBase	Eigen/src/Core/Ref.h	/^  typedef Stride<StrideType::OuterStrideAtCompileTime,StrideType::InnerStrideAtCompileTime> StrideBase;$/;"	t	class:Eigen::RefBase
StrideType	Eigen/src/Core/Ref.h	/^  typedef _StrideType StrideType;$/;"	t	struct:Eigen::internal::traits
StrideType	Eigen/src/Core/Ref.h	/^  typedef typename internal::traits<Derived>::StrideType StrideType;$/;"	t	class:Eigen::RefBase
StridedAlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstAlignedMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedConstMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StridedMapType	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	s	class:Eigen::PlainObjectBase
StringEqual	tinyxml2/tinyxml2.h	/^    inline static bool StringEqual( const char* p, const char* q, int nChar=INT_MAX )  {$/;"	f	class:tinyxml2::XMLUtil
Strip	srLib/SceneGraph/Leaf.cpp	/^Strip::Strip(void)$/;"	f	class:Strip
Strip	srLib/SceneGraph/Leaf.h	/^class Strip : public Leaf$/;"	c
SubDiagonalReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^            >::type SubDiagonalReturnType;$/;"	t	class:Eigen::Tridiagonalization
SubDiagonalType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typedef Matrix<RealScalar, SizeMinusOne, 1, Options & ~RowMajor, MaxSizeMinusOne, 1> SubDiagonalType;$/;"	t	class:Eigen::Tridiagonalization
SubVector	Eigen/src/Core/VectorwiseOp.h	/^                               typename ExpressionType::RowXpr>::type SubVector;$/;"	t	class:Eigen::VectorwiseOp
Subs	Eigen/src/Core/BandMatrix.h	/^      Subs   = internal::traits<Derived>::Subs,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
Subs	Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon215
Subs	Eigen/src/Core/BandMatrix.h	/^    Subs = _Subs,$/;"	e	enum:Eigen::internal::traits::__anon216
Success	Eigen/src/Core/util/Constants.h	/^  Success = 0,        $/;"	e	enum:Eigen::ComputationInfo
SuperDiagVectorType	Eigen/src/SVD/UpperBidiagonalization.h	/^    typedef Matrix<Scalar, ColsAtCompileTimeMinusOne, 1> SuperDiagVectorType;$/;"	t	class:Eigen::internal::UpperBidiagonalization
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU() : Base() { init(); }$/;"	f	class:Eigen::SuperILU
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(SuperILU& ) { }$/;"	f	class:Eigen::SuperILU
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperILU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperILU
SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperILU : public SuperLUBase<_MatrixType,SuperILU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU() : Base() { init(); }$/;"	f	class:Eigen::SuperLU
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(SuperLU& ) { }$/;"	f	class:Eigen::SuperLU
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLU(const MatrixType& matrix) : Base()$/;"	f	class:Eigen::SuperLU
SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLU : public SuperLUBase<_MatrixType,SuperLU<_MatrixType> >$/;"	c	namespace:Eigen
SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase() {}$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    SuperLUBase(SuperLUBase& ) { }$/;"	f	class:Eigen::SuperLUBase
SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^class SuperLUBase : internal::noncopyable$/;"	c	namespace:Eigen
Supers	Eigen/src/Core/BandMatrix.h	/^      Supers = internal::traits<Derived>::Supers,$/;"	e	enum:Eigen::internal::BandMatrixBase::__anon212
Supers	Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon215
Supers	Eigen/src/Core/BandMatrix.h	/^    Supers = _Supers,$/;"	e	enum:Eigen::internal::traits::__anon216
SupportedAccessPatterns	Eigen/src/SparseCore/SparseMatrix.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon361
SupportedAccessPatterns	Eigen/src/SparseCore/SparseVector.h	/^    SupportedAccessPatterns = InnerRandomAccessPattern$/;"	e	enum:Eigen::internal::traits::__anon385
SwapWrapper	Eigen/src/Core/Swap.h	/^    inline SwapWrapper(ExpressionType& xpr) : m_expression(xpr) {}$/;"	f	class:Eigen::SwapWrapper
SwapWrapper	Eigen/src/Core/Swap.h	/^template<typename ExpressionType> class SwapWrapper$/;"	c	namespace:Eigen
Symmetric	Eigen/src/Core/util/Constants.h	/^  Symmetric=0x20$/;"	e	enum:Eigen::UpLoType
SystemPtrArray	srLib/srDyn/srDYN.h	/^typedef _array<srSystem*>			SystemPtrArray;$/;"	t
TDS	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
TDSNode	srLib/SceneGraph/Leaf.h	/^	TDSNode(const char* name, SE3 T = SE3(0.0))$/;"	f	class:TDSNode
TDSNode	srLib/SceneGraph/Leaf.h	/^class TDSNode : public Leaf$/;"	c
TEMP_INNER14	srLib/srDyn/srCollisionPair.cpp	/^#define TEMP_INNER14(/;"	d	file:
TEMP_INNER14	srLib/srDyn/srCollisionPair.cpp	/^#undef TEMP_INNER14$/;"	d	file:
TEXTURE_H	srLib/SceneGraph/Texture3DS.h	/^#define TEXTURE_H$/;"	d
TEXT_ELEMENT	tinyxml2/tinyxml2.h	/^        TEXT_ELEMENT		            = NEEDS_ENTITY_PROCESSING | NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon478
TEXT_ELEMENT_LEAVE_ENTITIES	tinyxml2/tinyxml2.h	/^        TEXT_ELEMENT_LEAVE_ENTITIES		= NEEDS_NEWLINE_NORMALIZATION,$/;"	e	enum:tinyxml2::StrPair::__anon478
TEX_VERTS	srLib/SceneGraph/Model3DS.cpp	/^    #define TEX_VERTS	/;"	d	file:
THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD	Eigen/src/Core/util/StaticAssert.h	/^        THE_BRACKET_OPERATOR_IS_ONLY_FOR_VECTORS__USE_THE_PARENTHESIS_OPERATOR_INSTEAD,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE	Eigen/src/Core/util/StaticAssert.h	/^        THE_INDEX_TYPE_MUST_BE_A_SIGNED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE	Eigen/src/Core/util/StaticAssert.h	/^        THE_MATRIX_OR_EXPRESSION_THAT_YOU_PASSED_DOES_NOT_HAVE_THE_EXPECTED_TYPE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH	Eigen/src/Core/util/StaticAssert.h	/^        THE_STORAGE_ORDER_OF_BOTH_SIDES_MUST_MATCH,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY	Eigen/src/Core/util/StaticAssert.h	/^        THIS_EXPRESSION_IS_NOT_A_LVALUE__IT_IS_READ_ONLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_FUNCTION_IS_NOT_FOR_INTEGER_NUMERIC_TYPES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_1x1_EXPRESSIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ARRAYS_NOT_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_COLUMN_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_DIAGONAL_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_OF_BOOL,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_EXPRESSIONS_WITH_DIRECT_MEMORY_ACCESS_SUCH_AS_MAP_OR_PLAIN_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_FIXED_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_MATRICES_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_OBJECTS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_ROW_MAJOR_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_SPECIFIC_TRANSFORMATIONS,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE	Eigen/src/Core/util/StaticAssert.h	/^        THIS_METHOD_IS_ONLY_FOR_VECTORS_OF_A_SPECIFIC_SIZE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
TINYXML2_INCLUDED	tinyxml2/tinyxml2.h	/^#define TINYXML2_INCLUDED$/;"	d
TINYXML2_LIB	tinyxml2/tinyxml2.h	/^#       define TINYXML2_LIB /;"	d
TINYXML2_LIB	tinyxml2/tinyxml2.h	/^#       define TINYXML2_LIB$/;"	d
TINYXML2_LIB	tinyxml2/tinyxml2.h	/^#   define TINYXML2_LIB /;"	d
TINYXML2_LIB	tinyxml2/tinyxml2.h	/^#   define TINYXML2_LIB$/;"	d
TIXML2_MAJOR_VERSION	tinyxml2/tinyxml2.h	/^static const int TIXML2_MAJOR_VERSION = 4;$/;"	v
TIXML2_MINOR_VERSION	tinyxml2/tinyxml2.h	/^static const int TIXML2_MINOR_VERSION = 0;$/;"	v
TIXML2_PATCH_VERSION	tinyxml2/tinyxml2.h	/^static const int TIXML2_PATCH_VERSION = 1;$/;"	v
TIXMLASSERT	tinyxml2/tinyxml2.h	/^#       define TIXMLASSERT /;"	d
TIXMLASSERT	tinyxml2/tinyxml2.h	/^#       define TIXMLASSERT(/;"	d
TIXMLASSERT	tinyxml2/tinyxml2.h	/^#   define TIXMLASSERT(/;"	d
TIXML_SNPRINTF	tinyxml2/tinyxml2.cpp	/^	#define TIXML_SNPRINTF	/;"	d	file:
TIXML_SNPRINTF	tinyxml2/tinyxml2.cpp	/^	static inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )$/;"	f	file:
TIXML_SSCANF	tinyxml2/tinyxml2.cpp	/^	#define TIXML_SSCANF	/;"	d	file:
TIXML_SSCANF	tinyxml2/tinyxml2.cpp	/^	#define TIXML_SSCANF /;"	d	file:
TIXML_UTF_LEAD_0	tinyxml2/tinyxml2.cpp	/^static const unsigned char TIXML_UTF_LEAD_0 = 0xefU;$/;"	v	file:
TIXML_UTF_LEAD_1	tinyxml2/tinyxml2.cpp	/^static const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;$/;"	v	file:
TIXML_UTF_LEAD_2	tinyxml2/tinyxml2.cpp	/^static const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;$/;"	v	file:
TIXML_VSCPRINTF	tinyxml2/tinyxml2.cpp	/^		#define TIXML_VSCPRINTF /;"	d	file:
TIXML_VSCPRINTF	tinyxml2/tinyxml2.cpp	/^		static inline int TIXML_VSCPRINTF( const char* format, va_list va )$/;"	f	file:
TIXML_VSCPRINTF	tinyxml2/tinyxml2.cpp	/^	#define TIXML_VSCPRINTF	/;"	d	file:
TIXML_VSCPRINTF	tinyxml2/tinyxml2.cpp	/^	static inline int TIXML_VSCPRINTF( const char* format, va_list va )$/;"	f	file:
TIXML_VSNPRINTF	tinyxml2/tinyxml2.cpp	/^	#define TIXML_VSNPRINTF	/;"	d	file:
TIXML_VSNPRINTF	tinyxml2/tinyxml2.cpp	/^	#define TIXML_VSNPRINTF /;"	d	file:
TIXML_VSNPRINTF	tinyxml2/tinyxml2.cpp	/^	static inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )$/;"	f	file:
TORQUE	srLib/srDyn/srJoint.h	/^	enum ACTTYPE { PASSIVE, TORQUE, VELOCITY, HYBRID };$/;"	e	enum:srJoint::ACTTYPE
TOUCHSENSOR	srLib/srDyn/srSensor.h	/^	enum SENSORTYPE { IRSENSOR, RANGEFINDER, TOUCHSENSOR };$/;"	e	enum:srSensor::SENSORTYPE
TRACK00	srLib/SceneGraph/Model3DS.cpp	/^   #define TRACK00	/;"	d	file:
TRACK01	srLib/SceneGraph/Model3DS.cpp	/^   #define TRACK01	/;"	d	file:
TRACK02	srLib/SceneGraph/Model3DS.cpp	/^   #define TRACK02	/;"	d	file:
TRANS_FOFF_PERC	srLib/SceneGraph/Model3DS.cpp	/^   #define TRANS_FOFF_PERC	/;"	d	file:
TRANS_PERC	srLib/SceneGraph/Model3DS.cpp	/^   #define TRANS_PERC	/;"	d	file:
TRIG_MESH	srLib/SceneGraph/Model3DS.cpp	/^   #define TRIG_MESH	/;"	d	file:
TRUE	srLib/srg/srgL.h	/^	#define TRUE /;"	d
TST	srLib/srDyn/srCollisionPair.cpp	/^#define TST(/;"	d	file:
TST	srLib/srDyn/srCollisionPair.cpp	/^#undef TST$/;"	d	file:
T_ALPHA_1	srLib/SceneGraph/gl2ps.c	/^  T_ALPHA_1      = 1<<2,$/;"	e	enum:__anon5	file:
T_ALPHA_LESS_1	srLib/SceneGraph/gl2ps.c	/^  T_ALPHA_LESS_1 = 1<<3,$/;"	e	enum:__anon5	file:
T_CONST_COLOR	srLib/SceneGraph/gl2ps.c	/^  T_CONST_COLOR  = 1,$/;"	e	enum:__anon5	file:
T_UNDEFINED	srLib/SceneGraph/gl2ps.c	/^  T_UNDEFINED    = -1,$/;"	e	enum:__anon5	file:
T_VAR_ALPHA	srLib/SceneGraph/gl2ps.c	/^  T_VAR_ALPHA    = 1<<4$/;"	e	enum:__anon5	file:
T_VAR_COLOR	srLib/SceneGraph/gl2ps.c	/^  T_VAR_COLOR    = 1<<1,$/;"	e	enum:__anon5	file:
TangentPlane	srLib/srDyn/srContactConstraint.cpp	/^inline void		ContactConstraint::TangentPlane(const Vec3& n, Vec3& p, Vec3& q)$/;"	f	class:ContactConstraint
Target	Eigen/src/Core/util/Constants.h	/^    Target = SSE$/;"	e	enum:Eigen::Architecture::Type
TexCoords	srLib/SceneGraph/Model3DS.h	/^		float	*TexCoords;			\/\/ The array of texture coordinates for the vertexes$/;"	m	struct:Model3DS::Object
TexCoordsChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::TexCoordsChunkProcessor(long length, long findex, int objindex)$/;"	f	class:Model3DS
Texture	srLib/SceneGraph/Texture.cpp	/^Texture::Texture(void)$/;"	f	class:Texture
Texture	srLib/SceneGraph/Texture.h	/^class Texture :$/;"	c
Texture3DS	srLib/SceneGraph/Texture3DS.cpp	/^Texture3DS::Texture3DS()$/;"	f	class:Texture3DS
Texture3DS	srLib/SceneGraph/Texture3DS.h	/^class Texture3DS  $/;"	c
TextureMapChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::TextureMapChunkProcessor(long length, long findex, int matindex)$/;"	f	class:Model3DS
ThenMatrixNested	Eigen/src/Core/Select.h	/^  typedef typename ThenMatrixType::Nested ThenMatrixNested;$/;"	t	struct:Eigen::internal::traits
ThisConstantIsPrivateInPlainObjectBase	Eigen/src/Core/DenseBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::DenseBase::__anon342
ThisConstantIsPrivateInPlainObjectBase	Eigen/src/Core/PlainObjectBase.h	/^    enum { ThisConstantIsPrivateInPlainObjectBase };$/;"	e	enum:Eigen::PlainObjectBase::__anon276
Through	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane
Through	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane
Through	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine
Through	Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::Hyperplane
Through	Eigen/src/Geometry/Hyperplane.h	/^  static inline Hyperplane Through(const VectorType& p0, const VectorType& p1, const VectorType& p2)$/;"	f	class:Eigen::Hyperplane
Through	Eigen/src/Geometry/ParametrizedLine.h	/^  static inline ParametrizedLine Through(const VectorType& p0, const VectorType& p1)$/;"	f	class:Eigen::ParametrizedLine
TmpFlags	Eigen/src/Geometry/Homogeneous.h	/^    TmpFlags = _MatrixTypeNested::Flags & HereditaryBits,$/;"	e	enum:Eigen::internal::traits::__anon440
TmpMatrixType	Eigen/src/Cholesky/LDLT.h	/^    typedef Matrix<Scalar, RowsAtCompileTime, 1, Options, MaxRowsAtCompileTime, 1> TmpMatrixType;$/;"	t	class:Eigen::LDLT
ToBool	tinyxml2/tinyxml2.cpp	/^bool XMLUtil::ToBool( const char* str, bool* value )$/;"	f	class:tinyxml2::XMLUtil
ToComment	tinyxml2/tinyxml2.h	/^    virtual XMLComment*		ToComment()		{$/;"	f	class:tinyxml2::XMLNode
ToComment	tinyxml2/tinyxml2.h	/^    virtual XMLComment*	ToComment()					{$/;"	f	class:tinyxml2::XMLComment
ToComment	tinyxml2/tinyxml2.h	/^    virtual const XMLComment*		ToComment() const		{$/;"	f	class:tinyxml2::XMLNode
ToComment	tinyxml2/tinyxml2.h	/^    virtual const XMLComment* ToComment() const		{$/;"	f	class:tinyxml2::XMLComment
ToDeclaration	tinyxml2/tinyxml2.h	/^    XMLDeclaration* ToDeclaration() 			{$/;"	f	class:tinyxml2::XMLHandle
ToDeclaration	tinyxml2/tinyxml2.h	/^    const XMLDeclaration* ToDeclaration() const	{$/;"	f	class:tinyxml2::XMLConstHandle
ToDeclaration	tinyxml2/tinyxml2.h	/^    virtual XMLDeclaration*	ToDeclaration()					{$/;"	f	class:tinyxml2::XMLDeclaration
ToDeclaration	tinyxml2/tinyxml2.h	/^    virtual XMLDeclaration*	ToDeclaration()	{$/;"	f	class:tinyxml2::XMLNode
ToDeclaration	tinyxml2/tinyxml2.h	/^    virtual const XMLDeclaration*	ToDeclaration() const	{$/;"	f	class:tinyxml2::XMLNode
ToDeclaration	tinyxml2/tinyxml2.h	/^    virtual const XMLDeclaration* ToDeclaration() const		{$/;"	f	class:tinyxml2::XMLDeclaration
ToDocument	tinyxml2/tinyxml2.h	/^    virtual XMLDocument*	ToDocument()	{$/;"	f	class:tinyxml2::XMLNode
ToDocument	tinyxml2/tinyxml2.h	/^    virtual XMLDocument* ToDocument()				{$/;"	f	class:tinyxml2::XMLDocument
ToDocument	tinyxml2/tinyxml2.h	/^    virtual const XMLDocument*		ToDocument() const		{$/;"	f	class:tinyxml2::XMLNode
ToDocument	tinyxml2/tinyxml2.h	/^    virtual const XMLDocument* ToDocument() const	{$/;"	f	class:tinyxml2::XMLDocument
ToDouble	tinyxml2/tinyxml2.cpp	/^bool XMLUtil::ToDouble( const char* str, double* value )$/;"	f	class:tinyxml2::XMLUtil
ToElement	tinyxml2/tinyxml2.h	/^    XMLElement* ToElement() 					{$/;"	f	class:tinyxml2::XMLHandle
ToElement	tinyxml2/tinyxml2.h	/^    const XMLElement* ToElement() const			{$/;"	f	class:tinyxml2::XMLConstHandle
ToElement	tinyxml2/tinyxml2.h	/^    virtual XMLElement*		ToElement()		{$/;"	f	class:tinyxml2::XMLNode
ToElement	tinyxml2/tinyxml2.h	/^    virtual XMLElement* ToElement()				{$/;"	f	class:tinyxml2::XMLElement
ToElement	tinyxml2/tinyxml2.h	/^    virtual const XMLElement*		ToElement() const		{$/;"	f	class:tinyxml2::XMLNode
ToElement	tinyxml2/tinyxml2.h	/^    virtual const XMLElement* ToElement() const {$/;"	f	class:tinyxml2::XMLElement
ToElementWithName	tinyxml2/tinyxml2.cpp	/^const XMLElement* XMLNode::ToElementWithName( const char* name ) const$/;"	f	class:tinyxml2::XMLNode
ToFloat	tinyxml2/tinyxml2.cpp	/^bool XMLUtil::ToFloat( const char* str, float* value )$/;"	f	class:tinyxml2::XMLUtil
ToInt	tinyxml2/tinyxml2.cpp	/^bool XMLUtil::ToInt( const char* str, int* value )$/;"	f	class:tinyxml2::XMLUtil
ToInt64	tinyxml2/tinyxml2.cpp	/^bool XMLUtil::ToInt64(const char* str, int64_t* value)$/;"	f	class:tinyxml2::XMLUtil
ToNode	tinyxml2/tinyxml2.h	/^    XMLNode* ToNode()							{$/;"	f	class:tinyxml2::XMLHandle
ToNode	tinyxml2/tinyxml2.h	/^    const XMLNode* ToNode() const				{$/;"	f	class:tinyxml2::XMLConstHandle
ToStr	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ToStr( bool v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ToStr( double v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ToStr( float v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ToStr( int v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ToStr( unsigned v, char* buffer, int bufferSize )$/;"	f	class:tinyxml2::XMLUtil
ToStr	tinyxml2/tinyxml2.cpp	/^void XMLUtil::ToStr(int64_t v, char* buffer, int bufferSize)$/;"	f	class:tinyxml2::XMLUtil
ToText	tinyxml2/tinyxml2.h	/^    XMLText* ToText() 							{$/;"	f	class:tinyxml2::XMLHandle
ToText	tinyxml2/tinyxml2.h	/^    const XMLText* ToText() const				{$/;"	f	class:tinyxml2::XMLConstHandle
ToText	tinyxml2/tinyxml2.h	/^    virtual XMLText*		ToText()		{$/;"	f	class:tinyxml2::XMLNode
ToText	tinyxml2/tinyxml2.h	/^    virtual XMLText* ToText()			{$/;"	f	class:tinyxml2::XMLText
ToText	tinyxml2/tinyxml2.h	/^    virtual const XMLText*			ToText() const			{$/;"	f	class:tinyxml2::XMLNode
ToText	tinyxml2/tinyxml2.h	/^    virtual const XMLText* ToText() const	{$/;"	f	class:tinyxml2::XMLText
ToUnknown	tinyxml2/tinyxml2.h	/^    XMLUnknown* ToUnknown() 					{$/;"	f	class:tinyxml2::XMLHandle
ToUnknown	tinyxml2/tinyxml2.h	/^    const XMLUnknown* ToUnknown() const			{$/;"	f	class:tinyxml2::XMLConstHandle
ToUnknown	tinyxml2/tinyxml2.h	/^    virtual XMLUnknown*		ToUnknown()		{$/;"	f	class:tinyxml2::XMLNode
ToUnknown	tinyxml2/tinyxml2.h	/^    virtual XMLUnknown*	ToUnknown()					{$/;"	f	class:tinyxml2::XMLUnknown
ToUnknown	tinyxml2/tinyxml2.h	/^    virtual const XMLUnknown*		ToUnknown() const		{$/;"	f	class:tinyxml2::XMLNode
ToUnknown	tinyxml2/tinyxml2.h	/^    virtual const XMLUnknown* ToUnknown() const		{$/;"	f	class:tinyxml2::XMLUnknown
ToUnsigned	tinyxml2/tinyxml2.cpp	/^bool XMLUtil::ToUnsigned( const char* str, unsigned *value )$/;"	f	class:tinyxml2::XMLUtil
Top	srLib/srg/srgCamera.h	/^		Top, Free, Front, Left$/;"	e	enum:srgCamera::ViewDirection
TopLeft	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopLeft	Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftCeil	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopLeftFloor	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRight	Eigen/src/Core/util/Constants.h	/^enum CornerType { TopLeft, TopRight, BottomLeft, BottomRight };$/;"	e	enum:Eigen::CornerType
TopRight	Eigen/src/Geometry/AlignedBox.h	/^    TopLeft=2, TopRight=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightCeil	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftCeil=6, TopRightCeil=7$/;"	e	enum:Eigen::AlignedBox::CornerType
TopRightFloor	Eigen/src/Geometry/AlignedBox.h	/^    TopLeftFloor=2, TopRightFloor=3,$/;"	e	enum:Eigen::AlignedBox::CornerType
TouchDetection	srLib/srDyn/srCollision.cpp	/^bool srCollision::TouchDetection(Vec3& position, SR_REAL radius, Vec3& point, Vec3& normal, SR_REAL& penetration)$/;"	f	class:srCollision
Trace	tinyxml2/tinyxml2.h	/^    void Trace( const char* name ) {$/;"	f	class:tinyxml2::MemPoolT
Traits	Eigen/src/Cholesky/LDLT.h	/^    typedef internal::LDLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LDLT
Traits	Eigen/src/Cholesky/LLT.h	/^    typedef internal::LLT_Traits<MatrixType,UpLo> Traits;$/;"	t	class:Eigen::LLT
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::PermutationBase
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationMatrix> Traits;$/;"	t	class:Eigen::PermutationMatrix
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationType> Traits;$/;"	t	class:Eigen::Transpose
Traits	Eigen/src/Core/PermutationMatrix.h	/^    typedef internal::traits<PermutationWrapper> Traits;$/;"	t	class:Eigen::PermutationWrapper
Traits	Eigen/src/Core/Ref.h	/^    typedef internal::traits<Ref> Traits;$/;"	t	class:Eigen::Ref
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Derived> Traits;$/;"	t	class:Eigen::TranspositionsBase
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Map> Traits;$/;"	t	class:Eigen::Map
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<Transpositions> Traits;$/;"	t	class:Eigen::Transpositions
Traits	Eigen/src/Core/Transpositions.h	/^    typedef internal::traits<TranspositionsWrapper> Traits;$/;"	t	class:Eigen::TranspositionsWrapper
Traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjugateLhs,ConjugateRhs> Traits;$/;"	t	struct:Eigen::internal::gebp_kernel
Traits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    typedef gebp_traits<LhsScalar,RhsScalar> Traits;$/;"	t	class:Eigen::internal::gemm_blocking_space
Traits	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  typedef gebp_traits<LhsScalar,RhsScalar,ConjLhs,ConjRhs> Traits;$/;"	t	struct:Eigen::internal::tribb_kernel
Traits	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  typedef gebp_traits<Scalar,Scalar> Traits;$/;"	t	struct:Eigen::internal::product_triangular_matrix_matrix
Traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef internal::pardiso_traits<Derived> Traits;$/;"	t	class:Eigen::PardisoImpl
Traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialCholesky> Traits;$/;"	t	class:Eigen::SimplicialCholesky
Traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLDLT> Traits;$/;"	t	class:Eigen::SimplicialLDLT
Traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef internal::traits<SimplicialLLT> Traits;$/;"	t	class:Eigen::SimplicialLLT
Traits	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef internal::traits<SparseDenseOuterProduct> Traits;$/;"	t	class:Eigen::SparseDenseOuterProduct
TraitsBase	Eigen/src/Core/Map.h	/^  typedef traits<PlainObjectType> TraitsBase;$/;"	t	struct:Eigen::internal::traits
TraitsBase	Eigen/src/Geometry/Quaternion.h	/^    typedef traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> > TraitsBase;$/;"	t	struct:Eigen::internal::traits
TransferTo	tinyxml2/tinyxml2.cpp	/^void StrPair::TransferTo( StrPair* other )$/;"	f	class:tinyxml2::StrPair
Transform	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform /;"	d
Transform	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform$/;"	d
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform() { }$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r) { *this = r; }$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const ScalingType& s) { *this = s; }$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t) { *this = t; }$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	Eigen/src/Geometry/Transform.h	/^  Transform(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline Transform()$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,Mode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline Transform(const Transform<Scalar,Dim,OtherMode,OtherOptions>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const RotationBase<Derived, Dim>& r)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const Transform<OtherScalarType,Dim,Mode,Options>& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const TranslationType& t)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^  inline explicit Transform(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QMatrix& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::Transform(const QTransform& other)$/;"	f	class:Eigen::Transform
Transform	Eigen/src/Geometry/Transform.h	/^class Transform$/;"	c	namespace:Eigen
Transform	srLib/SceneGraph/Transformation.cpp	/^void Transform( Node* pNode, SE3 transMatrix, double scale )$/;"	f
Transform	srLib/SceneGraph/Transformation.cpp	/^void Transform( Transformation* pTrans, SE3 transMatrix, double scale )$/;"	f
Transform2d	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform2d /;"	d
Transform2d	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform2d$/;"	d
Transform2d	Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,2> Transform2d;$/;"	t	namespace:Eigen
Transform2f	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform2f /;"	d
Transform2f	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform2f$/;"	d
Transform2f	Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,2> Transform2f;$/;"	t	namespace:Eigen
Transform3d	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform3d /;"	d
Transform3d	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform3d$/;"	d
Transform3d	Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<double,3> Transform3d;$/;"	t	namespace:Eigen
Transform3f	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Transform3f /;"	d
Transform3f	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Transform3f$/;"	d
Transform3f	Eigen/src/Eigen2Support/Geometry/Transform.h	/^typedef Transform<float,3> Transform3f;$/;"	t	namespace:Eigen
TransformTimeDiagonalMode	Eigen/src/Geometry/Transform.h	/^  enum { TransformTimeDiagonalMode = ((Mode==int(Isometry))?Affine:int(Mode)) };$/;"	e	enum:Eigen::Transform::__anon452
TransformTimeDiagonalReturnType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim,TransformTimeDiagonalMode> TransformTimeDiagonalReturnType;$/;"	t	class:Eigen::Transform
TransformTraits	Eigen/src/Core/util/Constants.h	/^enum TransformTraits {$/;"	g	namespace:Eigen
TransformType	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Scaling
TransformType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl
TransformType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim> TransformType;$/;"	t	struct:Eigen::ei_transform_product_impl
TransformType	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Transform<Scalar,Dim> TransformType;$/;"	t	class:Eigen::Translation
TransformType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Mode, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	Eigen/src/Geometry/Homogeneous.h	/^  typedef Transform<Scalar, Dim, Projective, Options> TransformType;$/;"	t	struct:Eigen::internal::take_matrix_for_product
TransformType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,AffineCompact,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
TransformType	Eigen/src/Geometry/Transform.h	/^  typedef Transform<typename Other::Scalar,Dim,Mode,Options> TransformType;$/;"	t	struct:Eigen::internal::transform_left_product_impl
Transformation	srLib/SceneGraph/Transformation.cpp	/^Transformation::Transformation(SE3 trans, double scale)$/;"	f	class:Transformation
Transformation	srLib/SceneGraph/Transformation.h	/^class Transformation$/;"	c
TranslateBMPError	srLib/SceneGraph/Bitmap.cpp	/^string _Bitmap::TranslateBMPError(BMPError err)$/;"	f	class:_Bitmap
TranslateBMPError	srLib/srg/srgBitmap.cpp	/^string _Bitmap::TranslateBMPError(BMPError err)$/;"	f	class:_Bitmap
Translate_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_Camera(const Vec3& vMovement_Camera)$/;"	f	class:srgCamera
Translate_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_Camera(const Vec3& vUnitAxis_Camera, float fStep)$/;"	f	class:srgCamera
Translate_ToPoint	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_ToPoint( Vec3& vPoint, float fLength )$/;"	f	class:srgCamera
Translate_View	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_View( int FromX, int FromY, int ToX, int ToY, float ViewSizeY )$/;"	f	class:srgCamera
Translate_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_World(const Vec3& vMovement_World)$/;"	f	class:srgCamera
Translate_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_World(const Vec3& vUnitAxis_World, float fStep)$/;"	f	class:srgCamera
Translate_X_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_X_Camera(float fStep)$/;"	f	class:srgCamera
Translate_X_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_X_World(float fStep)$/;"	f	class:srgCamera
Translate_Y_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_Y_Camera(float fStep)$/;"	f	class:srgCamera
Translate_Y_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_Y_World(float fStep)$/;"	f	class:srgCamera
Translate_Z_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_Z_Camera(float fStep)$/;"	f	class:srgCamera
Translate_Z_World	srLib/srg/srgCamera.cpp	/^void srgCamera::Translate_Z_World(float fStep)$/;"	f	class:srgCamera
Translation	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation /;"	d
Translation	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation$/;"	d
Translation	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Eigen2Support/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation	Eigen/src/Geometry/Translation.h	/^  Translation() {}$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  explicit inline Translation(const VectorType& vector) : m_coeffs(vector) {}$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  inline Translation(const Scalar& sx, const Scalar& sy, const Scalar& sz)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^  inline explicit Translation(const Translation<OtherScalarType,Dim>& other)$/;"	f	class:Eigen::Translation
Translation	Eigen/src/Geometry/Translation.h	/^class Translation$/;"	c	namespace:Eigen
Translation2d	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation2d /;"	d
Translation2d	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation2d$/;"	d
Translation2d	Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2d	Eigen/src/Geometry/Translation.h	/^typedef Translation<double,2> Translation2d;$/;"	t	namespace:Eigen
Translation2f	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation2f /;"	d
Translation2f	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation2f$/;"	d
Translation2f	Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation2f	Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 2> Translation2f;$/;"	t	namespace:Eigen
Translation3d	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation3d /;"	d
Translation3d	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation3d$/;"	d
Translation3d	Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3d	Eigen/src/Geometry/Translation.h	/^typedef Translation<double,3> Translation3d;$/;"	t	namespace:Eigen
Translation3f	Eigen/src/Eigen2Support/Geometry/All.h	/^#define Translation3f /;"	d
Translation3f	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef Translation3f$/;"	d
Translation3f	Eigen/src/Eigen2Support/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
Translation3f	Eigen/src/Geometry/Translation.h	/^typedef Translation<float, 3> Translation3f;$/;"	t	namespace:Eigen
TranslationPart	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1> TranslationPart;$/;"	t	class:Eigen::Transform
TranslationPart	Eigen/src/Geometry/Transform.h	/^  typedef Block<MatrixType,Dim,1,int(Mode)==(AffineCompact)> TranslationPart;$/;"	t	class:Eigen::Transform
TranslationType	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Scaling
TranslationType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform
TranslationType	Eigen/src/Geometry/Transform.h	/^  typedef Translation<Scalar,Dim> TranslationType;$/;"	t	class:Eigen::Transform
Transpose	Eigen/src/Core/PermutationMatrix.h	/^    Transpose(const PermutationType& p) : m_permutation(p) {}$/;"	f	class:Eigen::Transpose
Transpose	Eigen/src/Core/PermutationMatrix.h	/^class Transpose<PermutationBase<Derived> >$/;"	c	namespace:Eigen
Transpose	Eigen/src/Core/Transpose.h	/^    inline Transpose(MatrixType& a_matrix) : m_matrix(a_matrix) {}$/;"	f	class:Eigen::Transpose
Transpose	Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class Transpose$/;"	c	namespace:Eigen
Transpose	Eigen/src/Core/Transpositions.h	/^    Transpose(const TranspositionType& t) : m_transpositions(t) {}$/;"	f	class:Eigen::Transpose
Transpose	Eigen/src/Core/Transpositions.h	/^class Transpose<TranspositionsBase<TranspositionsDerived> >$/;"	c	namespace:Eigen
Transpose	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon119
Transpose	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^      Transpose = StorageOrder==RowMajor,$/;"	e	enum:Eigen::internal::gemm_blocking_space::__anon117
TransposeImpl	Eigen/src/Core/Transpose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Dense>$/;"	c	namespace:Eigen
TransposeImpl	Eigen/src/SparseCore/SparseTranspose.h	/^template<typename MatrixType> class TransposeImpl<MatrixType,Sparse>$/;"	c	namespace:Eigen
TransposeImpl_base	Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base$/;"	s	namespace:Eigen::internal
TransposeImpl_base	Eigen/src/Core/Transpose.h	/^struct TransposeImpl_base<MatrixType, false>$/;"	s	namespace:Eigen::internal
TransposeLhs	Eigen/src/SparseCore/SparseProduct.h	/^    TransposeLhs = LhsRowMajor && (!RhsRowMajor)$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon389
TransposeMode	Eigen/src/Core/TriangularMatrix.h	/^      TransposeMode = (Mode & Upper ? Lower : 0)$/;"	e	enum:Eigen::TriangularView::__anon240
TransposeRhs	Eigen/src/SparseCore/SparseProduct.h	/^    TransposeRhs = (!LhsRowMajor) && RhsRowMajor,$/;"	e	enum:Eigen::SparseSparseProductReturnType::__anon389
TransposeTypeWithSameStorageOrder	Eigen/src/SVD/JacobiSVD.h	/^          TransposeTypeWithSameStorageOrder;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
TransposedSparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    typedef SparseMatrix<Scalar,(Flags&~RowMajorBit)|(IsRowMajor?RowMajorBit:0)> TransposedSparseMatrix;$/;"	t	class:Eigen::SparseMatrix
TranspositionType	Eigen/src/Cholesky/LDLT.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::LDLT
TranspositionType	Eigen/src/Core/Transpositions.h	/^    typedef TranspositionsDerived TranspositionType;$/;"	t	class:Eigen::Transpose
TranspositionType	Eigen/src/LU/PartialPivLU.h	/^    typedef Transpositions<RowsAtCompileTime, MaxRowsAtCompileTime> TranspositionType;$/;"	t	class:Eigen::PartialPivLU
Transpositions	Eigen/src/Core/Transpositions.h	/^    explicit inline Transpositions(const MatrixBase<Other>& a_indices) : m_indices(a_indices)$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions() {}$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions(Index size) : m_indices(size)$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const Transpositions& other) : m_indices(other.indices()) {}$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^    inline Transpositions(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
Transpositions	Eigen/src/Core/Transpositions.h	/^class Transpositions : public TranspositionsBase<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	c	namespace:Eigen
TranspositionsBase	Eigen/src/Core/Transpositions.h	/^class TranspositionsBase$/;"	c	namespace:Eigen
TranspositionsWrapper	Eigen/src/Core/Transpositions.h	/^    inline TranspositionsWrapper(IndicesType& a_indices)$/;"	f	class:Eigen::TranspositionsWrapper
TranspositionsWrapper	Eigen/src/Core/Transpositions.h	/^class TranspositionsWrapper$/;"	c	namespace:Eigen
Traversal	Eigen/src/Core/Assign.h	/^    Traversal = int(MayInnerVectorize)  ? int(InnerVectorizedTraversal)$/;"	e	enum:Eigen::internal::assign_traits::__anon26
Traversal	Eigen/src/Core/Assign_MKL.h	/^      Traversal = MayLinearize ? LinearVectorizedTraversal$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon219
Traversal	Eigen/src/Core/Redux.h	/^    Traversal = int(MayLinearVectorize) ? int(LinearVectorizedTraversal)$/;"	e	enum:Eigen::internal::redux_traits::__anon329
TraversalSize	Eigen/src/Core/VectorwiseOp.h	/^    TraversalSize = Direction==Vertical ? MatrixType::RowsAtCompileTime :  MatrixType::ColsAtCompileTime$/;"	e	enum:Eigen::internal::traits::__anon313
TraversalType	Eigen/src/Core/util/Constants.h	/^enum TraversalType {$/;"	g	namespace:Eigen
Triangle	srLib/SceneGraph/Model3DS.h	/^	struct Triangle {$/;"	s	class:Model3DS
TriangularBase	Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularBase() { eigen_assert(!((Mode&UnitDiag) && (Mode&ZeroDiag))); }$/;"	f	class:Eigen::TriangularBase
TriangularBase	Eigen/src/Core/TriangularMatrix.h	/^template<typename Derived> class TriangularBase : public EigenBase<Derived>$/;"	c	namespace:Eigen
TriangularMeshChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::TriangularMeshChunkProcessor(long length, long findex, int objindex)$/;"	f	class:Model3DS
TriangularProduct	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct
TriangularProduct	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false>$/;"	s	namespace:Eigen
TriangularProduct	Eigen/src/Core/products/TriangularMatrixVector.h	/^  TriangularProduct(const Lhs& lhs, const Rhs& rhs) : Base(lhs,rhs) {}$/;"	f	struct:Eigen::TriangularProduct
TriangularProduct	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,false,Lhs,true,Rhs,false>$/;"	s	namespace:Eigen
TriangularProduct	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct TriangularProduct<Mode,true,Lhs,false,Rhs,true>$/;"	s	namespace:Eigen
TriangularView	Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView(const MatrixType& matrix) : m_matrix(matrix)$/;"	f	class:Eigen::TriangularView
TriangularView	Eigen/src/Core/TriangularMatrix.h	/^template<typename _MatrixType, unsigned int _Mode> class TriangularView$/;"	c	namespace:Eigen
TriangularViewReturnType	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	s	class:Eigen::MatrixBase
TridiagonalMatrix	Eigen/src/Core/BandMatrix.h	/^    TridiagonalMatrix(Index size = Size) : Base(size,size,Options&SelfAdjoint?0:1,1) {}$/;"	f	class:Eigen::internal::TridiagonalMatrix
TridiagonalMatrix	Eigen/src/Core/BandMatrix.h	/^class TridiagonalMatrix : public BandMatrix<Scalar,Size,Size,Options&SelfAdjoint?0:1,1,Options|RowMajor>$/;"	c	namespace:Eigen::internal
Tridiagonalization	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(Index size = Size==Dynamic ? 2 : Size)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization
Tridiagonalization	Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename _MatrixType> class Tridiagonalization$/;"	c	namespace:Eigen
TridiagonalizationMatrixTReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    TridiagonalizationMatrixTReturnType(const MatrixType& mat) : m_matrix(mat) { }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
TridiagonalizationMatrixTReturnType	Eigen/src/Eigenvalues/Tridiagonalization.h	/^template<typename MatrixType> struct TridiagonalizationMatrixTReturnType$/;"	s	namespace:Eigen::internal
TridiagonalizationType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typedef Tridiagonalization<MatrixType> TridiagonalizationType;$/;"	t	class:Eigen::SelfAdjointEigenSolver
Triplet	Eigen/src/SparseCore/SparseUtil.h	/^  Triplet() : m_row(0), m_col(0), m_value(0) {}$/;"	f	class:Eigen::Triplet
Triplet	Eigen/src/SparseCore/SparseUtil.h	/^  Triplet(const Index& i, const Index& j, const Scalar& v = Scalar(0))$/;"	f	class:Eigen::Triplet
Triplet	Eigen/src/SparseCore/SparseUtil.h	/^class Triplet$/;"	c	namespace:Eigen
Tube	srLib/SceneGraph/Leaf.cpp	/^Tube::Tube(const vector<SE3> _frames, double _inner_radius, double _outer_radius)$/;"	f	class:Tube
Tube	srLib/SceneGraph/Leaf.h	/^class Tube : public Leaf$/;"	c
TurnCenter_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_Camera(const Vec3& vUnitAxis_Camera, float fStep)$/;"	f	class:srgCamera
TurnCenter_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_World(const Vec3& vUnitAxis_World, float fStep)$/;"	f	class:srgCamera
TurnCenter_X_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_X_Camera(float fStep)$/;"	f	class:srgCamera
TurnCenter_X_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_X_World(float fStep)$/;"	f	class:srgCamera
TurnCenter_Y_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_Y_Camera(float fStep)$/;"	f	class:srgCamera
TurnCenter_Y_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_Y_World(float fStep)$/;"	f	class:srgCamera
TurnCenter_Z_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_Z_Camera(float fStep)$/;"	f	class:srgCamera
TurnCenter_Z_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnCenter_Z_World(float fStep)$/;"	f	class:srgCamera
TurnPoint_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_Camera(const Vec3& vUnitAxis_Camera, float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_World(const Vec3& vUnitAxis_World, float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_X_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_X_Camera(float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_X_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_X_World(float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_Y_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_Y_Camera(float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_Y_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_Y_World(float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_Z_Camera	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_Z_Camera(float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
TurnPoint_Z_World	srLib/srg/srgCamera.cpp	/^void srgCamera::TurnPoint_Z_World(float fStep, const Vec3& vPoint)$/;"	f	class:srgCamera
Turn_Focus	srLib/srg/srgCamera.cpp	/^void srgCamera::Turn_Focus( int FromX, int FromY, int ToX, int ToY, int ViewportX, int ViewportY, int ViewportSizeX, int ViewportSizeY, float fRadius_Circle_ViewPort )$/;"	f	class:srgCamera
Type	Eigen/src/Core/BandMatrix.h	/^                 BuildType>::type Type;$/;"	t	struct:Eigen::internal::BandMatrixBase::DiagonalIntReturnType
Type	Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, EvalBeforeAssigningBit | EvalBeforeNestingBit> Type;$/;"	t	struct:Eigen::ProductReturnType
Type	Eigen/src/Core/GeneralProduct.h	/^  typedef CoeffBasedProduct<LhsNested, RhsNested, NestByRefBit> Type;$/;"	t	struct:Eigen::ProductReturnType
Type	Eigen/src/Core/GeneralProduct.h	/^  typedef GeneralProduct<Lhs\/*Nested*\/, Rhs\/*Nested*\/, ProductType> Type;$/;"	t	struct:Eigen::ProductReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct ConstDiagonalIndexReturnType { typedef const Diagonal<const Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstDiagonalIndexReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<int Index> struct DiagonalIndexReturnType { typedef Diagonal<Derived,Index> Type; };$/;"	t	struct:Eigen::MatrixBase::DiagonalIndexReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct ConstTriangularViewReturnType { typedef const TriangularView<const Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstTriangularViewReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int Mode> struct TriangularViewReturnType { typedef TriangularView<Derived, Mode> Type; };$/;"	t	struct:Eigen::MatrixBase::TriangularViewReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct ConstSelfAdjointViewReturnType { typedef const SelfAdjointView<const Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::ConstSelfAdjointViewReturnType
Type	Eigen/src/Core/MatrixBase.h	/^    template<unsigned int UpLo> struct SelfAdjointViewReturnType { typedef SelfAdjointView<Derived, UpLo> Type; };$/;"	t	struct:Eigen::MatrixBase::SelfAdjointViewReturnType
Type	Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReduxReturnType
Type	Eigen/src/Core/VectorwiseOp.h	/^                              > Type;$/;"	t	struct:Eigen::VectorwiseOp::ReturnType
Type	Eigen/src/Core/VectorwiseOp.h	/^                        Direction==Horizontal ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::ExtendedType
Type	Eigen/src/Core/VectorwiseOp.h	/^                        Direction==Vertical   ? 1 : ExpressionType::ColsAtCompileTime> Type;$/;"	t	struct:Eigen::VectorwiseOp::OppositeExtendedType
Type	Eigen/src/Core/util/Constants.h	/^  enum Type {$/;"	g	namespace:Eigen::Architecture
Type	Eigen/src/Householder/HouseholderSequence.h	/^                 0, MatrixType::MaxRowsAtCompileTime, MatrixType::MaxColsAtCompileTime> Type;$/;"	t	struct:Eigen::internal::matrix_type_times_scalar_type
Type	Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseDenseOuterProduct<Lhs,Rhs,false> >::type Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType
Type	Eigen/src/SparseCore/SparseDenseProduct.h	/^    SparseDenseOuterProduct<Lhs,Rhs,false> >::type Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType
Type	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef DenseTimeSparseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::DenseSparseProductReturnType
Type	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef SparseTimeDenseProduct<Lhs,Rhs> Type;$/;"	t	struct:Eigen::SparseDenseProductReturnType
Type	Eigen/src/SparseCore/SparseMatrixBase.h	/^                          > Type;$/;"	t	struct:Eigen::SparseMatrixBase::CwiseProductDenseReturnType
Type	Eigen/src/SparseCore/SparseProduct.h	/^  typedef SparseSparseProduct<LhsNested, RhsNested> Type;$/;"	t	struct:Eigen::SparseSparseProductReturnType
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNColsBlockXpr { typedef const Block<const Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:ConstNColsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct ConstNRowsBlockXpr { typedef const Block<const Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:ConstNRowsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NColsBlockXpr { typedef Block<Derived, internal::traits<Derived>::RowsAtCompileTime, N, !IsRowMajor> Type; };$/;"	t	struct:NColsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int N> struct NRowsBlockXpr { typedef Block<Derived, N, internal::traits<Derived>::ColsAtCompileTime, IsRowMajor> Type; };$/;"	t	struct:NRowsBlockXpr
Type	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct ConstFixedSegmentReturnType { typedef const VectorBlock<const Derived, Size> Type; };$/;"	t	struct:ConstFixedSegmentReturnType
Type	Eigen/src/plugins/BlockMethods.h	/^template<int Size> struct FixedSegmentReturnType { typedef VectorBlock<Derived, Size> Type; };$/;"	t	struct:FixedSegmentReturnType
UCOL	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon346
UF_Find_Constraint	srLib/srDyn/srClosedLoopConstraint.cpp	/^srSystem* ClosedLoop::UF_Find_Constraint()$/;"	f	class:ClosedLoop
UF_Find_Constraint	srLib/srDyn/srContactConstraint.cpp	/^srSystem* ContactConstraint::UF_Find_Constraint()$/;"	f	class:ContactConstraint
UF_Find_Constraint	srLib/srDyn/srJointConstraint.cpp	/^srSystem* JointConstraint::UF_Find_Constraint()$/;"	f	class:JointConstraint
UF_Find_System	srLib/srDyn/srConstraint.cpp	/^srSystem* Constraint::UF_Find_System(srSystem* pSystem)$/;"	f	class:Constraint
UF_Find_System_PathCompression	srLib/srDyn/srConstraint.cpp	/^srSystem* Constraint::UF_Find_System_PathCompression(srSystem* pSystem) \/\/ Path Compression$/;"	f	class:Constraint
UF_Reset	srLib/srDyn/srSystem.cpp	/^void srSystem::UF_Reset() \/\/ inline ÇØ¾ßµÇ´Âµ¥$/;"	f	class:srSystem
UF_Unite	srLib/srDyn/srContactConstraint.cpp	/^inline void	ContactConstraint::UF_Unite()$/;"	f	class:ContactConstraint
UInt16	srLib/common/types.h	/^typedef unsigned short int	UInt16;		\/\/< 2 bytes integer 0 ~ 65535$/;"	t
UInt32	srLib/common/types.h	/^typedef unsigned int		UInt32;		\/\/< 4 bytes integer 0 ~ 4294967255$/;"	t
ULVL	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon346
UMatrixType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef TriangularView<LUMatrixType,  Upper>           UMatrixType;$/;"	t	class:Eigen::SuperLU
UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC	Eigen/src/Core/util/StaticAssert.h	/^        UNALIGNED_LOAD_AND_STORE_OPERATIONS_UNIMPLEMENTED_ON_ALTIVEC,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
UNIVERSAL	srLib/srDyn/srJoint.h	/^	enum JOINTTYPE { REVOLUTE, PRISMATIC, UNIVERSAL, WELD, BALL };$/;"	e	enum:srJoint::JOINTTYPE
USER	srLib/srDyn/srGeometryInfo.h	/^    enum SHAPETYPE { SPHERE, BOX, CAPSULE, CYLINDER, PLANE, TDS, STL, USER };$/;"	e	enum:srGeometryInfo::SHAPETYPE
USE_FRICTION	srLib/srExt/srExt_System.h	/^#define USE_FRICTION$/;"	d
USUB	Eigen/src/SparseLU/SparseLU_Structs.h	/^typedef enum {LUSUP, UCOL, LSUB, USUB, LLVL, ULVL} MemType; $/;"	e	enum:Eigen::internal::__anon346
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU() { init(); }$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(UmfPackLU& ) { }$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfPackLU(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^class UmfPackLU : internal::noncopyable$/;"	c	namespace:Eigen
UmfpackMatrixType	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef SparseMatrix<Scalar,ColMajor,int> UmfpackMatrixType;$/;"	t	class:Eigen::UmfPackLU
UnExcite	srLib/srDyn/srClosedLoopConstraint.cpp	/^void ClosedLoop::UnExcite()$/;"	f	class:ClosedLoop
UnExcite	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::UnExcite()$/;"	f	class:ContactConstraint
UnExcite	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::UnExcite()$/;"	f	class:JointConstraint
UnExciteSystem	srLib/srDyn/srSystem.cpp	/^void srSystem::UnExciteSystem()$/;"	f	class:srSystem
Unaligned	Eigen/src/Core/util/Constants.h	/^  Unaligned=0, $/;"	e	enum:Eigen::AlignmentType
UniformScaling	Eigen/src/Geometry/Scaling.h	/^  UniformScaling() {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	Eigen/src/Geometry/Scaling.h	/^  explicit inline UniformScaling(const Scalar& s) : m_factor(s) {}$/;"	f	class:Eigen::UniformScaling
UniformScaling	Eigen/src/Geometry/Scaling.h	/^  inline explicit UniformScaling(const UniformScaling<OtherScalarType>& other)$/;"	f	class:Eigen::UniformScaling
UniformScaling	Eigen/src/Geometry/Scaling.h	/^class UniformScaling$/;"	c	namespace:Eigen
Unit	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index i)$/;"	f	class:Eigen::MatrixBase
Unit	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::Unit(Index newSize, Index i)$/;"	f	class:Eigen::MatrixBase
UnitDiag	Eigen/src/Core/util/Constants.h	/^  UnitDiag=0x4, $/;"	e	enum:Eigen::UpLoType
UnitDiagBit	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitDiagBit = UnitDiag;$/;"	m	namespace:Eigen
UnitImp	srLib/srDyn/srClosedLoopConstraint.cpp	/^dse3 ClosedLoop::UnitImp[6] = {	dse3(1.0, 0.0, 0.0, 0.0, 0.0, 0.0),$/;"	m	class:ClosedLoop	file:
UnitImp	srLib/srDyn/srClosedLoopConstraint.h	/^	static dse3 UnitImp[6]; \/\/ constraint jacobian : this is same for all closed loop, hence i chose to use static variable.$/;"	m	class:ClosedLoop
UnitLower	Eigen/src/Core/util/Constants.h	/^  UnitLower=UnitDiag|Lower, $/;"	e	enum:Eigen::UpLoType
UnitLowerTriangular	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitLowerTriangular = UnitLower;$/;"	m	namespace:Eigen
UnitUpper	Eigen/src/Core/util/Constants.h	/^  UnitUpper=UnitDiag|Upper,$/;"	e	enum:Eigen::UpLoType
UnitUpperTriangular	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UnitUpperTriangular = UnitUpper;$/;"	m	namespace:Eigen
UnitW	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitW()$/;"	f	class:Eigen::MatrixBase
UnitX	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitX()$/;"	f	class:Eigen::MatrixBase
UnitY	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitY()$/;"	f	class:Eigen::MatrixBase
UnitZ	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE const typename MatrixBase<Derived>::BasisReturnType MatrixBase<Derived>::UnitZ()$/;"	f	class:Eigen::MatrixBase
Unlink	tinyxml2/tinyxml2.cpp	/^void XMLNode::Unlink( XMLNode* child )$/;"	f	class:tinyxml2::XMLNode
Unroll	Eigen/src/Core/products/CoeffBasedProduct.h	/^      Unroll = CoeffReadCost != Dynamic && CoeffReadCost <= EIGEN_UNROLLING_LIMIT,$/;"	e	enum:Eigen::CoeffBasedProduct::__anon123
Unrolling	Eigen/src/Core/Assign.h	/^    Unrolling = (int(Traversal) == int(InnerVectorizedTraversal) || int(Traversal) == int(DefaultTraversal))$/;"	e	enum:Eigen::internal::assign_traits::__anon28
Unrolling	Eigen/src/Core/Redux.h	/^    Unrolling = Cost != Dynamic && Cost <= UnrollingLimit$/;"	e	enum:Eigen::internal::redux_traits::__anon331
Unrolling	Eigen/src/Core/SolveTriangular.h	/^      Unrolling   = (RhsIsVectorAtCompileTime && Rhs::SizeAtCompileTime != Dynamic && Rhs::SizeAtCompileTime <= 8)$/;"	e	enum:Eigen::internal::trsolve_traits::__anon310
UnrollingLimit	Eigen/src/Core/Assign.h	/^    UnrollingLimit      = EIGEN_UNROLLING_LIMIT * (Vectorized ? int(PacketSize) : 1),$/;"	e	enum:Eigen::internal::assign_traits::__anon27
UnrollingLimit	Eigen/src/Core/Redux.h	/^    UnrollingLimit = EIGEN_UNROLLING_LIMIT * (int(Traversal) == int(DefaultTraversal) ? 1 : int(PacketSize))$/;"	e	enum:Eigen::internal::redux_traits::__anon330
UnrollingType	Eigen/src/Core/util/Constants.h	/^enum UnrollingType {$/;"	g	namespace:Eigen
UnsignedAttribute	tinyxml2/tinyxml2.cpp	/^unsigned XMLElement::UnsignedAttribute(const char* name, unsigned defaultValue) const $/;"	f	class:tinyxml2::XMLElement
UnsignedText	tinyxml2/tinyxml2.cpp	/^unsigned XMLElement::UnsignedText(unsigned defaultValue) const$/;"	f	class:tinyxml2::XMLElement
UnsignedValue	tinyxml2/tinyxml2.h	/^    unsigned UnsignedValue() const			{$/;"	f	class:tinyxml2::XMLAttribute
Untracked	tinyxml2/tinyxml2.h	/^    int Untracked() const {$/;"	f	class:tinyxml2::MemPoolT
Unusable	Eigen/src/Core/ReturnByValue.h	/^      Unusable(const Unusable&) {}$/;"	f	class:Eigen::ReturnByValue::Unusable
Unusable	Eigen/src/Core/ReturnByValue.h	/^    class Unusable{$/;"	c	class:Eigen::ReturnByValue
Unusable	Eigen/src/Core/ReturnByValue.h	/^#define Unusable /;"	d
UpLo	Eigen/src/Cholesky/LDLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LDLT::__anon425
UpLo	Eigen/src/Cholesky/LLT.h	/^      UpLo = _UpLo$/;"	e	enum:Eigen::LLT::__anon427
UpLo	Eigen/src/CholmodSupport/CholmodSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::CholmodBase::__anon17
UpLo	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^    UpLo = _UpLo$/;"	e	enum:Eigen::ConjugateGradient::__anon428
UpLo	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLDLT::__anon477
UpLo	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PastixLLT::__anon476
UpLo	Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = Options&(Upper|Lower) };$/;"	e	enum:Eigen::PardisoLDLT::__anon360
UpLo	Eigen/src/PardisoSupport/PardisoSupport.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::PardisoLLT::__anon359
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialCholesky::__anon466
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLDLT::__anon465
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = _UpLo };$/;"	e	enum:Eigen::SimplicialLLT::__anon464
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    enum { UpLo = internal::traits<Derived>::UpLo };$/;"	e	enum:Eigen::SimplicialCholeskyBase::__anon460
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon461
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon462
UpLo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  enum { UpLo = _UpLo };$/;"	e	enum:Eigen::internal::traits::__anon463
UpLoType	Eigen/src/Core/util/Constants.h	/^enum UpLoType {$/;"	g	namespace:Eigen
UpdateAccWithDelVel	srLib/srDyn/srState.cpp	/^void srBallState::UpdateAccWithDelVel(SR_REAL & fps)$/;"	f	class:srBallState
UpdateAccWithDelVel	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdateAccWithDelVel(SR_REAL& fps)	\/\/ fps == reciprocal of time step$/;"	f	class:srRevoluteState
UpdateAccWithDelVel	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdateAccWithDelVel(SR_REAL & fps)$/;"	f	class:srUniversalState
UpdateAccWithDelVel	srLib/srDyn/srState.h	/^	void UpdateAccWithDelVel(SR_REAL& ) {};$/;"	f	class:srWeldState
UpdateBoundingRadius	srLib/srDyn/srCollision.cpp	/^void srCollision::UpdateBoundingRadius()$/;"	f	class:srCollision
UpdateBoundingRadius	srLib/srDyn/srGeometryInfo.cpp	/^void srGeometryInfo::UpdateBoundingRadius()$/;"	f	class:srGeometryInfo
UpdateCOMZMP	srLib/srDyn/srSystem.cpp	/^void srSystem::UpdateCOMZMP(Vec3& g)$/;"	f	class:srSystem
UpdateCameraFrame	srLib/srg/srgCamera.cpp	/^inline void srgCamera::UpdateCameraFrame(void)$/;"	f	class:srgCamera
UpdateCameraVec3s	srLib/srg/srgCamera.cpp	/^inline void srgCamera::UpdateCameraVec3s(void)$/;"	f	class:srgCamera
UpdateForce	srLib/srDyn/srLinearSpring.cpp	/^void srLinearSpring::UpdateForce()$/;"	f	class:srLinearSpring
UpdateFrame	srLib/srDyn/srCollision.cpp	/^void srCollision::UpdateFrame()$/;"	f	class:srCollision
UpdateFrame	srLib/srDyn/srJoint.cpp	/^void srJoint::UpdateFrame()$/;"	f	class:srJoint
UpdateFrame	srLib/srDyn/srSensor.cpp	/^void srSensor::UpdateFrame()$/;"	f	class:srSensor
UpdateInertia	srLib/srDyn/srLink.cpp	/^void srLink::UpdateInertia(SR_REAL density)$/;"	f	class:srLink
UpdateLength	srLib/srDyn/srLinearSpring.cpp	/^SR_REAL& srLinearSpring::UpdateLength()$/;"	f	class:srLinearSpring
UpdateNumOfPoints	srMath/EulerIntegrator.h	/^		virtual void	UpdateNumOfPoints(int num_of_points)$/;"	f	class:srMath::EulerIntegrator
UpdateNumOfPoints	srMath/GaussianQuadrature.cpp	/^	void GaussianQuadrature::UpdateNumOfPoints(int num_of_points)$/;"	f	class:srMath::GaussianQuadrature
UpdatePosErrVelWithDelVel	srLib/srDyn/srState.cpp	/^void srBallState::UpdatePosErrVelWithDelVel()$/;"	f	class:srBallState
UpdatePosErrVelWithDelVel	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdatePosErrVelWithDelVel()$/;"	f	class:srRevoluteState
UpdatePosErrVelWithDelVel	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdatePosErrVelWithDelVel()$/;"	f	class:srUniversalState
UpdatePosErrVelWithDelVel	srLib/srDyn/srState.h	/^	void UpdatePosErrVelWithDelVel() {};$/;"	f	class:srWeldState
UpdatePosWithCorrection	srLib/srDyn/srState.cpp	/^void srBallState::UpdatePosWithCorrection(SR_REAL & t)$/;"	f	class:srBallState
UpdatePosWithCorrection	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdatePosWithCorrection(SR_REAL& t)$/;"	f	class:srRevoluteState
UpdatePosWithCorrection	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdatePosWithCorrection(SR_REAL & t)$/;"	f	class:srUniversalState
UpdatePosWithCorrection	srLib/srDyn/srState.h	/^	void UpdatePosWithCorrection(SR_REAL &) {};$/;"	f	class:srWeldState
UpdatePosWithPosErrVel	srLib/srDyn/srState.cpp	/^void srBallState::UpdatePosWithPosErrVel(SR_REAL & t)$/;"	f	class:srBallState
UpdatePosWithPosErrVel	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdatePosWithPosErrVel(SR_REAL& t)$/;"	f	class:srRevoluteState
UpdatePosWithPosErrVel	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdatePosWithPosErrVel(SR_REAL & t)$/;"	f	class:srUniversalState
UpdatePosWithPosErrVel	srLib/srDyn/srState.h	/^	void UpdatePosWithPosErrVel(SR_REAL &) {};$/;"	f	class:srWeldState
UpdatePosition	srLib/srDyn/srState.cpp	/^void srBallState::UpdatePosition(SR_REAL & t)$/;"	f	class:srBallState
UpdatePosition	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdatePosition(SR_REAL& t)$/;"	f	class:srRevoluteState
UpdatePosition	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdatePosition(SR_REAL & t)$/;"	f	class:srUniversalState
UpdatePosition	srLib/srDyn/srState.h	/^	void UpdatePosition(SR_REAL& ) {};$/;"	f	class:srWeldState
UpdateRayDetectionFtn	srLib/srDyn/srCollision.cpp	/^void srCollision::UpdateRayDetectionFtn()$/;"	f	class:srCollision
UpdateSonarDetectionFtn	srLib/srDyn/srCollision.cpp	/^void srCollision::UpdateSonarDetectionFtn()$/;"	f	class:srCollision
UpdateSpeed	srLib/srDyn/srLinearSpring.cpp	/^SR_REAL srLinearSpring::UpdateSpeed()$/;"	f	class:srLinearSpring
UpdateTimeInterval	srMath/EulerIntegrator.h	/^		virtual void	UpdateTimeInterval(Real initialTime, Real finalTime)$/;"	f	class:srMath::EulerIntegrator
UpdateTimeInterval	srMath/GaussianQuadrature.cpp	/^	void GaussianQuadrature::UpdateTimeInterval(Real initialTime, Real finalTime)$/;"	f	class:srMath::GaussianQuadrature
UpdateTorqueWithImp	srLib/srDyn/srState.cpp	/^void srBallState::UpdateTorqueWithImp(SR_REAL & fps)$/;"	f	class:srBallState
UpdateTorqueWithImp	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdateTorqueWithImp(SR_REAL& fps)$/;"	f	class:srRevoluteState
UpdateTorqueWithImp	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdateTorqueWithImp(SR_REAL & fps)$/;"	f	class:srUniversalState
UpdateTorqueWithImp	srLib/srDyn/srState.h	/^	void UpdateTorqueWithImp(SR_REAL& ) {};$/;"	f	class:srWeldState
UpdateTouchDetectionFtn	srLib/srDyn/srCollision.cpp	/^void srCollision::UpdateTouchDetectionFtn()$/;"	f	class:srCollision
UpdateVelWithDelVel	srLib/srDyn/srState.cpp	/^void srBallState::UpdateVelWithDelVel()$/;"	f	class:srBallState
UpdateVelWithDelVel	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdateVelWithDelVel()$/;"	f	class:srRevoluteState
UpdateVelWithDelVel	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdateVelWithDelVel()$/;"	f	class:srUniversalState
UpdateVelWithDelVel	srLib/srDyn/srState.h	/^	void UpdateVelWithDelVel() {};$/;"	f	class:srWeldState
UpdateVelocity	srLib/srDyn/srState.cpp	/^void srBallState::UpdateVelocity(SR_REAL & t)$/;"	f	class:srBallState
UpdateVelocity	srLib/srDyn/srState.cpp	/^void srRevoluteState::UpdateVelocity(SR_REAL& t)$/;"	f	class:srRevoluteState
UpdateVelocity	srLib/srDyn/srState.cpp	/^void srUniversalState::UpdateVelocity(SR_REAL & t)$/;"	f	class:srUniversalState
UpdateVelocity	srLib/srDyn/srState.h	/^	void UpdateVelocity(SR_REAL& ) {};$/;"	f	class:srWeldState
UpdateWeights	srMath/GaussianQuadrature.cpp	/^	void GaussianQuadrature::UpdateWeights()$/;"	f	class:srMath::GaussianQuadrature
Upper	Eigen/src/Core/util/Constants.h	/^  Upper=0x2,                      $/;"	e	enum:Eigen::UpLoType
UpperBidiagonalization	Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization() : m_householder(), m_bidiagonal(), m_isInitialized(false) {}$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	Eigen/src/SVD/UpperBidiagonalization.h	/^    UpperBidiagonalization(const MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
UpperBidiagonalization	Eigen/src/SVD/UpperBidiagonalization.h	/^template<typename _MatrixType> class UpperBidiagonalization$/;"	c	namespace:Eigen::internal
UpperTriangular	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangular = Upper;$/;"	m	namespace:Eigen
UpperTriangularBit	Eigen/src/Eigen2Support/TriangularSolver.h	/^const unsigned int UpperTriangularBit = Upper;$/;"	m	namespace:Eigen
Use	srLib/SceneGraph/Texture3DS.cpp	/^void Texture3DS::Use()$/;"	f	class:Texture3DS
User_CBFunc_ControlLoop	Example/MobileRobots/MobileRobots.cpp	/^void User_CBFunc_ControlLoop()$/;"	f
User_CBFunc_KeyFunc	Example/MobileRobots/MobileRobots.cpp	/^void User_CBFunc_KeyFunc(char key, void* pvData)$/;"	f
User_CBFunc_Pause_DYN	Example/DracoP1/simulation_draco.cpp	/^void User_CBFunc_Pause_DYN()$/;"	f
User_CBFunc_Pause_DYN	Example/MobileRobots/MobileRobots.cpp	/^void User_CBFunc_Pause_DYN()$/;"	f
User_CBFunc_Render	Example/DracoP1/simulation_draco.cpp	/^void User_CBFunc_Render(void* pvData)$/;"	f
User_CBFunc_Render	Example/MobileRobots/MobileRobots.cpp	/^void User_CBFunc_Render(void* pvData)$/;"	f
User_CBFunc_Run_DYN	Example/DracoP1/simulation_draco.cpp	/^void User_CBFunc_Run_DYN()$/;"	f
User_CBFunc_Run_DYN	Example/MobileRobots/MobileRobots.cpp	/^void User_CBFunc_Run_DYN()$/;"	f
User_Modeling	Example/MobileRobots/MobileRobots.cpp	/^void User_Modeling()$/;"	f
User_SimulationSetting	Example/DracoP1/simulation_draco.cpp	/^void User_SimulationSetting()$/;"	f
User_SimulationSetting	Example/MobileRobots/MobileRobots.cpp	/^void User_SimulationSetting()$/;"	f
User_Simulation_Go_One_Step	Example/DracoP1/simulation_draco.cpp	/^void User_Simulation_Go_One_Step()$/;"	f
User_Simulation_Go_One_Step	Example/MobileRobots/MobileRobots.cpp	/^void User_Simulation_Go_One_Step()$/;"	f
User_Simulation_Pause	Example/DracoP1/simulation_draco.cpp	/^void User_Simulation_Pause()$/;"	f
User_Simulation_Pause	Example/MobileRobots/MobileRobots.cpp	/^void User_Simulation_Pause()$/;"	f
VELOCITY	srLib/srDyn/srJoint.h	/^	enum ACTTYPE { PASSIVE, TORQUE, VELOCITY, HYBRID };$/;"	e	enum:srJoint::ACTTYPE
VERT_LIST	srLib/SceneGraph/Model3DS.cpp	/^    #define VERT_LIST	/;"	d	file:
Value	tinyxml2/tinyxml2.cpp	/^const char* XMLAttribute::Value() const $/;"	f	class:tinyxml2::XMLAttribute
Value	tinyxml2/tinyxml2.cpp	/^const char* XMLNode::Value() const $/;"	f	class:tinyxml2::XMLNode
Vec2	srLib/LieGroup/LieGroup.h	/^class Vec2$/;"	c
Vec3	srLib/LieGroup/LieGroup.h	/^class Vec3$/;"	c
Vector	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::DiagonalPreconditioner
Vector	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::IncompleteLUT
Vector	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::PastixBase
Vector	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::SuperLUBase
Vector	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> Vector;$/;"	t	class:Eigen::UmfPackLU
Vector	srLib/SceneGraph/Model3DS.h	/^	struct Vector {$/;"	s	class:Model3DS
Vector2	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D
Vector2	Eigen/src/Geometry/OrthoMethods.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
Vector2	Eigen/src/Geometry/Rotation2D.h	/^  typedef Matrix<Scalar,2,1> Vector2;$/;"	t	class:Eigen::Rotation2D
Vector2	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 2, 1>		Vector2;$/;"	t	namespace:srMath
Vector2s	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,2,1> Vector2s;$/;"	t	class:Eigen::RealQZ
Vector3	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis
Vector3	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::Quaternion
Vector3	Eigen/src/Geometry/AngleAxis.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::AngleAxis
Vector3	Eigen/src/Geometry/Quaternion.h	/^  typedef Matrix<Scalar,3,1> Vector3;$/;"	t	class:Eigen::QuaternionBase
Vector3	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 3, 1>		Vector3;$/;"	t	namespace:srMath
Vector3s	Eigen/src/Eigenvalues/RealQZ.h	/^      typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealQZ
Vector3s	Eigen/src/Eigenvalues/RealSchur.h	/^    typedef Matrix<Scalar,3,1> Vector3s;$/;"	t	class:Eigen::RealSchur
Vector4	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 4, 1>		Vector4;$/;"	t	namespace:srMath
Vector6	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, 6, 1>		Vector6;$/;"	t	namespace:srMath
Vector6d	srLib/srExt/srExt_Eigen.h	/^	typedef Eigen::Matrix<double, 6, 1>	Vector6d;$/;"	t	namespace:Eigen
VectorBlock	Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start)$/;"	f	class:Eigen::VectorBlock
VectorBlock	Eigen/src/Core/VectorBlock.h	/^    inline VectorBlock(VectorType& vector, Index start, Index size)$/;"	f	class:Eigen::VectorBlock
VectorBlock	Eigen/src/Core/VectorBlock.h	/^template<typename VectorType, int Size> class VectorBlock$/;"	c	namespace:Eigen
VectorI	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSelfAdjointView
VectorI	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef Matrix<Index,Dynamic,1> VectorI;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
VectorI	srMath/Constant.h	/^	typedef Eigen::Matrix<int, -1, 1>				VectorI;$/;"	t	namespace:srMath
VectorType	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::AlignedBox
VectorType	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane
VectorType	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::ParametrizedLine
VectorType	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Scaling
VectorType	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform
VectorType	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation
VectorType	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    typedef Matrix<Scalar, ColsAtCompileTime, 1, Options & ~RowMajor, MaxColsAtCompileTime, 1> VectorType;$/;"	t	class:Eigen::GeneralizedEigenSolver
VectorType	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    typedef Matrix<Scalar, 1, Size, Options | RowMajor, 1, MaxSize> VectorType;$/;"	t	class:Eigen::HessenbergDecomposition
VectorType	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  typedef typename SolverType::RealVectorType VectorType;$/;"	t	struct:Eigen::internal::direct_selfadjoint_eigenvalues
VectorType	Eigen/src/Geometry/AlignedBox.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1>  VectorType;$/;"	t	class:Eigen::AlignedBox
VectorType	Eigen/src/Geometry/Hyperplane.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1> VectorType;$/;"	t	class:Eigen::Hyperplane
VectorType	Eigen/src/Geometry/OrthoMethods.h	/^  typedef typename plain_matrix_type<Derived>::type VectorType;$/;"	t	struct:Eigen::internal::unitOrthogonal_selector
VectorType	Eigen/src/Geometry/ParametrizedLine.h	/^  typedef Matrix<Scalar,AmbientDimAtCompileTime,1,Options> VectorType;$/;"	t	class:Eigen::ParametrizedLine
VectorType	Eigen/src/Geometry/RotationBase.h	/^    typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::RotationBase
VectorType	Eigen/src/Geometry/Transform.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Transform
VectorType	Eigen/src/Geometry/Translation.h	/^  typedef Matrix<Scalar,Dim,1> VectorType;$/;"	t	class:Eigen::Translation
VectorType	Eigen/src/PardisoSupport/PardisoSupport.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::PardisoImpl
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholesky
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialCholeskyBase
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLDLT
VectorType	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    typedef Matrix<Scalar,Dynamic,1> VectorType;$/;"	t	class:Eigen::SimplicialLLT
VectorU	srMath/Constant.h	/^	typedef Eigen::Matrix<unsigned int, -1, 1>		VectorU;$/;"	t	namespace:srMath
VectorX	srMath/Constant.h	/^	typedef Eigen::Matrix<Real, -1, 1>		VectorX;$/;"	t	namespace:srMath
Vectorizable	Eigen/src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasDiv && packet_traits<RhsScalar>::HasDiv$/;"	e	enum:Eigen::internal::scalar_quotient_op::__anon45
Vectorizable	Eigen/src/Core/Functors.h	/^    Vectorizable = is_same<LhsScalar,RhsScalar>::value && packet_traits<LhsScalar>::HasMul && packet_traits<RhsScalar>::HasMul$/;"	e	enum:Eigen::internal::scalar_product_op::__anon36
Vectorizable	Eigen/src/Core/GenericPacketMath.h	/^    Vectorizable = 0,$/;"	e	enum:Eigen::internal::packet_traits::__anon225
Vectorizable	Eigen/src/Core/arch/AltiVec/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
Vectorizable	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
Vectorizable	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon264
Vectorizable	Eigen/src/Core/arch/NEON/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
Vectorizable	Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
Vectorizable	Eigen/src/Core/arch/NEON/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon258
Vectorizable	Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
Vectorizable	Eigen/src/Core/arch/SSE/Complex.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
Vectorizable	Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
Vectorizable	Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon248
Vectorizable	Eigen/src/Core/arch/SSE/PacketMath.h	/^    Vectorizable = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon249
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable  = Traits::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_kernel::__anon114
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
Vectorizable	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    Vectorizable = packet_traits<RealScalar>::Vectorizable$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
Vectorizable	Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon130
Vectorizable	Eigen/src/Core/products/GeneralMatrixVector.h	/^  Vectorizable = packet_traits<LhsScalar>::Vectorizable && packet_traits<RhsScalar>::Vectorizable$/;"	e	enum:Eigen::internal::general_matrix_vector_product::__anon131
Vectorized	Eigen/src/Core/Assign.h	/^    Vectorized = int(Traversal) == InnerVectorizedTraversal$/;"	e	enum:Eigen::internal::assign_traits::__anon26
VectorizedSize	Eigen/src/Core/Redux.h	/^    VectorizedSize = (Size \/ PacketSize) * PacketSize$/;"	e	enum:Eigen::internal::redux_impl::__anon336
VectorwiseOp	Eigen/src/Core/VectorwiseOp.h	/^    inline VectorwiseOp(ExpressionType& matrix) : m_matrix(matrix) {}$/;"	f	class:Eigen::VectorwiseOp
VectorwiseOp	Eigen/src/Core/VectorwiseOp.h	/^template<typename ExpressionType, int Direction> class VectorwiseOp$/;"	c	namespace:Eigen
Vertex	srLib/SceneGraph/Model3DS.h	/^	struct Vertex {$/;"	s	class:Model3DS
VertexListChunkProcessor	srLib/SceneGraph/Model3DS.cpp	/^void Model3DS::VertexListChunkProcessor(long length, long findex, int objindex)$/;"	f	class:Model3DS
Vertexes	srLib/SceneGraph/Model3DS.h	/^		float	*Vertexes;			\/\/ The array of vertexes$/;"	m	struct:Model3DS::Object
Vertical	Eigen/src/Core/util/Constants.h	/^  Vertical, $/;"	e	enum:Eigen::DirectionType
ViewDirection	srLib/srg/srgCamera.h	/^	enum ViewDirection$/;"	g	class:srgCamera
Visit	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLComment& comment )$/;"	f	class:tinyxml2::XMLPrinter
Visit	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLDeclaration& declaration )$/;"	f	class:tinyxml2::XMLPrinter
Visit	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLText& text )$/;"	f	class:tinyxml2::XMLPrinter
Visit	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::Visit( const XMLUnknown& unknown )$/;"	f	class:tinyxml2::XMLPrinter
Visit	tinyxml2/tinyxml2.h	/^    virtual bool Visit( const XMLComment& \/*comment*\/ )				{$/;"	f	class:tinyxml2::XMLVisitor
Visit	tinyxml2/tinyxml2.h	/^    virtual bool Visit( const XMLDeclaration& \/*declaration*\/ )		{$/;"	f	class:tinyxml2::XMLVisitor
Visit	tinyxml2/tinyxml2.h	/^    virtual bool Visit( const XMLText& \/*text*\/ )					{$/;"	f	class:tinyxml2::XMLVisitor
Visit	tinyxml2/tinyxml2.h	/^    virtual bool Visit( const XMLUnknown& \/*unknown*\/ )				{$/;"	f	class:tinyxml2::XMLVisitor
VisitEnter	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::VisitEnter( const XMLDocument& doc )$/;"	f	class:tinyxml2::XMLPrinter
VisitEnter	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::VisitEnter( const XMLElement& element, const XMLAttribute* attribute )$/;"	f	class:tinyxml2::XMLPrinter
VisitEnter	tinyxml2/tinyxml2.h	/^    virtual bool VisitEnter( const XMLDocument& \/*doc*\/ )			{$/;"	f	class:tinyxml2::XMLVisitor
VisitEnter	tinyxml2/tinyxml2.h	/^    virtual bool VisitEnter( const XMLElement& \/*element*\/, const XMLAttribute* \/*firstAttribute*\/ )	{$/;"	f	class:tinyxml2::XMLVisitor
VisitExit	tinyxml2/tinyxml2.cpp	/^bool XMLPrinter::VisitExit( const XMLElement& element )$/;"	f	class:tinyxml2::XMLPrinter
VisitExit	tinyxml2/tinyxml2.h	/^    virtual bool VisitExit( const XMLDocument& \/*doc*\/ )			{$/;"	f	class:tinyxml2::XMLPrinter
VisitExit	tinyxml2/tinyxml2.h	/^    virtual bool VisitExit( const XMLDocument& \/*doc*\/ )			{$/;"	f	class:tinyxml2::XMLVisitor
VisitExit	tinyxml2/tinyxml2.h	/^    virtual bool VisitExit( const XMLElement& \/*element*\/ )			{$/;"	f	class:tinyxml2::XMLVisitor
VmlSize	Eigen/src/Core/Assign_MKL.h	/^      VmlSize = MightLinearize ? MaxSizeAtCompileTime : InnerMaxSize,$/;"	e	enum:Eigen::internal::vml_assign_traits::__anon218
WELD	srLib/srDyn/srJoint.h	/^	enum JOINTTYPE { REVOLUTE, PRISMATIC, UNIVERSAL, WELD, BALL };$/;"	e	enum:srJoint::JOINTTYPE
WIRE_THICKNESS	srLib/SceneGraph/Model3DS.cpp	/^   #define WIRE_THICKNESS	/;"	d	file:
WJidx_	Example/DracoP1/draco.h	/^  int WJidx_;$/;"	m	class:srDraco
WORK	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^#define WORK(/;"	d
WORK	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^#undef WORK$/;"	d
WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED	Eigen/src/Core/util/StaticAssert.h	/^        WRITING_TO_TRIANGULAR_PART_WITH_UNIT_DIAGONAL_IS_NOT_SUPPORTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
Whitespace	tinyxml2/tinyxml2.h	/^enum Whitespace {$/;"	g	namespace:tinyxml2
WhitespaceMode	tinyxml2/tinyxml2.h	/^    Whitespace WhitespaceMode() const	{$/;"	f	class:tinyxml2::XMLDocument
WithFormat	Eigen/src/Core/IO.h	/^    WithFormat(const ExpressionType& matrix, const IOFormat& format)$/;"	f	class:Eigen::WithFormat
WithFormat	Eigen/src/Core/IO.h	/^class WithFormat$/;"	c	namespace:Eigen
WorkMatrixType	Eigen/src/SVD/JacobiSVD.h	/^            WorkMatrixType;$/;"	t	class:Eigen::JacobiSVD
WorkSpaceFactor	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = Vectorizable ? 2*nr*RealPacketSize : nr,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
WorkSpaceFactor	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr * RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
WorkSpaceFactor	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
WorkSpaceFactor	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    WorkSpaceFactor = nr*RhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
WorkVectorType	Eigen/src/QR/FullPivHouseholderQR.h	/^                 MatrixType::MaxRowsAtCompileTime> WorkVectorType;$/;"	t	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
WorkspaceType	Eigen/src/SVD/JacobiSVD.h	/^  typedef Matrix<Scalar, 1, RowsAtCompileTime, RowMajor, 1, MaxRowsAtCompileTime> WorkspaceType;$/;"	t	class:Eigen::internal::qr_preconditioner_impl
WriteAccessors	Eigen/src/Core/util/Constants.h	/^  WriteAccessors, $/;"	e	enum:Eigen::AccessorLevels
XMLAttribute	tinyxml2/tinyxml2.h	/^    XMLAttribute() : _next( 0 ), _memPool( 0 ) {}$/;"	f	class:tinyxml2::XMLAttribute
XMLAttribute	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLAttribute$/;"	c	namespace:tinyxml2
XMLComment	tinyxml2/tinyxml2.cpp	/^XMLComment::XMLComment( XMLDocument* doc ) : XMLNode( doc )$/;"	f	class:tinyxml2::XMLComment
XMLComment	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLComment : public XMLNode$/;"	c	namespace:tinyxml2
XMLConstHandle	tinyxml2/tinyxml2.h	/^    XMLConstHandle( const XMLConstHandle& ref )										{$/;"	f	class:tinyxml2::XMLConstHandle
XMLConstHandle	tinyxml2/tinyxml2.h	/^    XMLConstHandle( const XMLNode& node )											{$/;"	f	class:tinyxml2::XMLConstHandle
XMLConstHandle	tinyxml2/tinyxml2.h	/^    XMLConstHandle( const XMLNode* node )											{$/;"	f	class:tinyxml2::XMLConstHandle
XMLConstHandle	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLConstHandle$/;"	c	namespace:tinyxml2
XMLDeclaration	tinyxml2/tinyxml2.cpp	/^XMLDeclaration::XMLDeclaration( XMLDocument* doc ) : XMLNode( doc )$/;"	f	class:tinyxml2::XMLDeclaration
XMLDeclaration	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLDeclaration : public XMLNode$/;"	c	namespace:tinyxml2
XMLDocument	tinyxml2/tinyxml2.cpp	/^XMLDocument::XMLDocument( bool processEntities, Whitespace whitespace ) :$/;"	f	class:tinyxml2::XMLDocument
XMLDocument	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLDocument : public XMLNode$/;"	c	namespace:tinyxml2
XMLElement	tinyxml2/tinyxml2.cpp	/^XMLElement::XMLElement( XMLDocument* doc ) : XMLNode( doc ),$/;"	f	class:tinyxml2::XMLElement
XMLElement	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLElement : public XMLNode$/;"	c	namespace:tinyxml2
XMLError	tinyxml2/tinyxml2.h	/^enum XMLError {$/;"	g	namespace:tinyxml2
XMLHandle	tinyxml2/tinyxml2.h	/^    XMLHandle( XMLNode& node )												{$/;"	f	class:tinyxml2::XMLHandle
XMLHandle	tinyxml2/tinyxml2.h	/^    XMLHandle( XMLNode* node )												{$/;"	f	class:tinyxml2::XMLHandle
XMLHandle	tinyxml2/tinyxml2.h	/^    XMLHandle( const XMLHandle& ref )										{$/;"	f	class:tinyxml2::XMLHandle
XMLHandle	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLHandle$/;"	c	namespace:tinyxml2
XMLNode	tinyxml2/tinyxml2.cpp	/^XMLNode::XMLNode( XMLDocument* doc ) :$/;"	f	class:tinyxml2::XMLNode
XMLNode	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLNode$/;"	c	namespace:tinyxml2
XMLPrinter	tinyxml2/tinyxml2.cpp	/^XMLPrinter::XMLPrinter( FILE* file, bool compact, int depth ) :$/;"	f	class:tinyxml2::XMLPrinter
XMLPrinter	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLPrinter : public XMLVisitor$/;"	c	namespace:tinyxml2
XMLText	tinyxml2/tinyxml2.h	/^    XMLText( XMLDocument* doc )	: XMLNode( doc ), _isCData( false )	{}$/;"	f	class:tinyxml2::XMLText
XMLText	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLText : public XMLNode$/;"	c	namespace:tinyxml2
XMLUnknown	tinyxml2/tinyxml2.cpp	/^XMLUnknown::XMLUnknown( XMLDocument* doc ) : XMLNode( doc )$/;"	f	class:tinyxml2::XMLUnknown
XMLUnknown	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLUnknown : public XMLNode$/;"	c	namespace:tinyxml2
XMLUtil	tinyxml2/tinyxml2.h	/^class XMLUtil$/;"	c	namespace:tinyxml2
XMLVisitor	tinyxml2/tinyxml2.h	/^class TINYXML2_LIB XMLVisitor$/;"	c	namespace:tinyxml2
XML_CAN_NOT_CONVERT_TEXT	tinyxml2/tinyxml2.h	/^    XML_CAN_NOT_CONVERT_TEXT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_COUNT	tinyxml2/tinyxml2.h	/^	XML_ERROR_COUNT$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_ELEMENT_MISMATCH	tinyxml2/tinyxml2.h	/^    XML_ERROR_ELEMENT_MISMATCH,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_EMPTY_DOCUMENT	tinyxml2/tinyxml2.h	/^    XML_ERROR_EMPTY_DOCUMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_FILE_COULD_NOT_BE_OPENED	tinyxml2/tinyxml2.h	/^    XML_ERROR_FILE_COULD_NOT_BE_OPENED,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_FILE_NOT_FOUND	tinyxml2/tinyxml2.h	/^    XML_ERROR_FILE_NOT_FOUND,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_FILE_READ_ERROR	tinyxml2/tinyxml2.h	/^    XML_ERROR_FILE_READ_ERROR,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_IDENTIFYING_TAG	tinyxml2/tinyxml2.h	/^    XML_ERROR_IDENTIFYING_TAG,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_MISMATCHED_ELEMENT	tinyxml2/tinyxml2.h	/^    XML_ERROR_MISMATCHED_ELEMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_ATTRIBUTE	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_ATTRIBUTE,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_CDATA	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_CDATA,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_COMMENT	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_COMMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_DECLARATION	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_DECLARATION,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_ELEMENT	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_ELEMENT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_TEXT	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_TEXT,$/;"	e	enum:tinyxml2::XMLError
XML_ERROR_PARSING_UNKNOWN	tinyxml2/tinyxml2.h	/^    XML_ERROR_PARSING_UNKNOWN,$/;"	e	enum:tinyxml2::XMLError
XML_NO_ATTRIBUTE	tinyxml2/tinyxml2.h	/^    XML_NO_ATTRIBUTE,$/;"	e	enum:tinyxml2::XMLError
XML_NO_TEXT_NODE	tinyxml2/tinyxml2.h	/^    XML_NO_TEXT_NODE,$/;"	e	enum:tinyxml2::XMLError
XML_SUCCESS	tinyxml2/tinyxml2.h	/^    XML_SUCCESS = 0,$/;"	e	enum:tinyxml2::XMLError
XML_WRONG_ATTRIBUTE_TYPE	tinyxml2/tinyxml2.h	/^    XML_WRONG_ATTRIBUTE_TYPE,$/;"	e	enum:tinyxml2::XMLError
XprBase	Eigen/src/Core/Array.h	/^  typedef ArrayBase<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > XprBase;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Array.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/ArrayWrapper.h	/^  typedef ArrayXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/ArrayWrapper.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Block.h	/^  typedef typename traits<XprType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename traits<Ancestor>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Matrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/ProductBase.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Replicate.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Reverse.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Select.h	/^  typedef typename traits<ThenMatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/Transpose.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename traits<MatrixType>::XprKind XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseProduct.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprKind	Eigen/src/SparseCore/SparseVector.h	/^  typedef MatrixXpr XprKind;$/;"	t	struct:Eigen::internal::traits
XprType	Eigen/src/Core/Transpose.h	/^  typedef SelfCwiseBinaryOp<BinOp,Xpr,Rhs> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_conjugate_op<Scalar>, Xpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_multiple_op<Scalar>, Xpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef CwiseUnaryOp<scalar_opposite_op<Scalar>, Xpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprType	Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<Xpr> XprType;$/;"	t	struct:Eigen::internal::blas_traits
XprTypeIsRowMajor	Eigen/src/Core/Block.h	/^    XprTypeIsRowMajor = (int(traits<XprType>::Flags)&RowMajorBit) != 0,$/;"	e	enum:Eigen::internal::traits::__anon273
XprTypeNested	Eigen/src/Core/Block.h	/^  typedef typename nested<XprType>::type XprTypeNested;$/;"	t	struct:Eigen::internal::traits
XprTypeNested	Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename XprType::Nested XprTypeNested;$/;"	t	struct:Eigen::internal::traits
YOU_ALREADY_SPECIFIED_THIS_STRIDE	Eigen/src/Core/util/StaticAssert.h	/^        YOU_ALREADY_SPECIFIED_THIS_STRIDE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT	Eigen/src/Core/util/StaticAssert.h	/^        YOU_ARE_TRYING_TO_USE_AN_INDEX_BASED_ACCESSOR_ON_AN_EXPRESSION_THAT_DOES_NOT_SUPPORT_THAT,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR	Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_DYNAMIC_SIZE_METHOD_ON_A_FIXED_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR	Eigen/src/Core/util/StaticAssert.h	/^        YOU_CALLED_A_FIXED_SIZE_METHOD_ON_A_DYNAMIC_SIZE_MATRIX_OR_VECTOR,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_CANNOT_MIX_ARRAYS_AND_MATRICES	Eigen/src/Core/util/StaticAssert.h	/^        YOU_CANNOT_MIX_ARRAYS_AND_MATRICES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_MADE_A_PROGRAMMING_MISTAKE	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MADE_A_PROGRAMMING_MISTAKE,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES	Eigen/src/Core/util/StaticAssert.h	/^        YOU_MIXED_VECTORS_OF_DIFFERENT_SIZES,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED	Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_COLUMN_VECTOR_BUT_A_ROW_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED	Eigen/src/Core/util/StaticAssert.h	/^        YOU_PASSED_A_ROW_VECTOR_BUT_A_COLUMN_VECTOR_WAS_EXPECTED,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION	Eigen/src/Core/util/StaticAssert.h	/^        YOU_PERFORMED_AN_INVALID_TRANSFORMATION_CONVERSION,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX	Eigen/src/Core/util/StaticAssert.h	/^        YOU_TRIED_CALLING_A_VECTOR_METHOD_ON_A_MATRIX,$/;"	e	enum:Eigen::internal::static_assertion::__anon143
Zero	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero()$/;"	f	class:Eigen::DenseBase
Zero	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase
Zero	Eigen/src/Core/CwiseNullaryOp.h	/^DenseBase<Derived>::Zero(Index size)$/;"	f	class:Eigen::DenseBase
ZeroDiag	Eigen/src/Core/util/Constants.h	/^  ZeroDiag=0x8,$/;"	e	enum:Eigen::UpLoType
ZeroSign	Eigen/src/Cholesky/LDLT.h	/^  enum SignMatrix { PositiveSemiDef, NegativeSemiDef, ZeroSign, Indefinite };$/;"	e	enum:Eigen::internal::SignMatrix
_A	srMath/Function.h	/^		MatrixX _A;$/;"	m	class:srMath::AffineFunction
_A	srMath/Function.h	/^		MatrixX _A;$/;"	m	class:srMath::QuadraticFunction
_ALLOC_pContactPts	srLib/srDyn/srContactConstraint.cpp	/^void	ContactConstraint::_ALLOC_pContactPts()$/;"	f	class:ContactConstraint
_ActualLhsType	Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualLhsType>::type _ActualLhsType;$/;"	t	class:Eigen::ProductBase
_ActualRhsType	Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<ActualRhsType>::type _ActualRhsType;$/;"	t	class:Eigen::ProductBase
_AssembleRobot	Example/DracoP1/draco.cpp	/^void srDraco::_AssembleRobot(Vec3 location){$/;"	f	class:srDraco
_BackupInitState	srLib/srDyn/srSpace.cpp	/^void srSpace::_BackupInitState()$/;"	f	class:srSpace
_Bitmap	srLib/SceneGraph/Bitmap.cpp	/^_Bitmap::_Bitmap()$/;"	f	class:_Bitmap
_Bitmap	srLib/SceneGraph/Bitmap.h	/^class _Bitmap$/;"	c
_Bitmap	srLib/srg/srgBitmap.cpp	/^_Bitmap::_Bitmap()$/;"	f	class:_Bitmap
_Bitmap	srLib/srg/srgBitmap.h	/^class _Bitmap$/;"	c
_BoxBox_____________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_BoxBox_____________MARK8()$/;"	f	class:CollisionPair
_BoxCapsule_________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int	CollisionPair::_BoxCapsule_________MARK8()$/;"	f	class:CollisionPair
_BoxCylinder________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_BoxCylinder________MARK8()$/;"	f	class:CollisionPair
_BoxPlane___________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_BoxPlane___________MARK8()$/;"	f	class:CollisionPair
_BoxSphere__________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int	CollisionPair::_BoxSphere__________MARK8()$/;"	f	class:CollisionPair
_CRT_NONSTDC_NO_DEPRECATE	srLib/srDyn/srGeometryInfo.h	/^	#define _CRT_NONSTDC_NO_DEPRECATE /;"	d
_CRT_NONSTDC_NO_DEPRECATE	srLib/srDyn/srObject.h	/^	#define _CRT_NONSTDC_NO_DEPRECATE /;"	d
_CRT_NONSTDC_NO_DEPRECATE	srLib/srg/srgBitmap.h	/^	#define _CRT_NONSTDC_NO_DEPRECATE /;"	d
_CRT_NONSTDC_NO_DEPRECATE	srLib/srg/srgL.h	/^	#define _CRT_NONSTDC_NO_DEPRECATE /;"	d
_CRT_SECURE_NO_DEPRECATE	srLib/srDyn/srGeometryInfo.h	/^	#define _CRT_SECURE_NO_DEPRECATE /;"	d
_CRT_SECURE_NO_DEPRECATE	srLib/srDyn/srObject.h	/^	#define _CRT_SECURE_NO_DEPRECATE /;"	d
_CRT_SECURE_NO_DEPRECATE	srLib/srg/srgBitmap.h	/^	#define _CRT_SECURE_NO_DEPRECATE /;"	d
_CRT_SECURE_NO_DEPRECATE	srLib/srg/srgL.h	/^	#define _CRT_SECURE_NO_DEPRECATE /;"	d
_CRT_SECURE_NO_WARNINGS	srLib/srDyn/srGeometryInfo.h	/^	#define _CRT_SECURE_NO_WARNINGS /;"	d
_CRT_SECURE_NO_WARNINGS	srLib/srDyn/srObject.h	/^	#define _CRT_SECURE_NO_WARNINGS /;"	d
_CRT_SECURE_NO_WARNINGS	srLib/srg/srgBitmap.h	/^	#define _CRT_SECURE_NO_WARNINGS /;"	d
_CRT_SECURE_NO_WARNINGS	srLib/srg/srgL.h	/^	#define _CRT_SECURE_NO_WARNINGS /;"	d
_CapsuleBox_________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CapsuleBox_________MARK8()$/;"	f	class:CollisionPair
_CapsuleCapsule_____MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CapsuleCapsule_____MARK8()$/;"	f	class:CollisionPair
_CapsuleCylinder____MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CapsuleCylinder____MARK8()$/;"	f	class:CollisionPair
_CapsulePlane_______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CapsulePlane_______MARK8()$/;"	f	class:CollisionPair
_CapsuleSphere______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CapsuleSphere______MARK8()$/;"	f	class:CollisionPair
_Clamp	srLib/srg/srgColor.cpp	/^void srgColor::_Clamp()$/;"	f	class:srgColor
_Color	srLib/srg/srgColor.h	/^	srgColor _Color;$/;"	m	class:srgMaterialColor
_ConeToSlab	srLib/srDyn/srCollision.cpp	/^bool _ConeToSlab(Vec3& normal, Vec3& center, SR_REAL min, SR_REAL max, SE3& T0, SR_REAL& range, SR_REAL& radius)$/;"	f
_CylinderBox________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CylinderBox________MARK8()$/;"	f	class:CollisionPair
_CylinderCapsule____MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CylinderCapsule____MARK8()$/;"	f	class:CollisionPair
_CylinderCylinder___MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CylinderCylinder___MARK8()$/;"	f	class:CollisionPair
_CylinderPlane______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CylinderPlane______MARK8()$/;"	f	class:CollisionPair
_CylinderSphere_____MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_CylinderSphere_____MARK8()$/;"	f	class:CollisionPair
_D	srMath/Interpolation.h	/^		int _D; \/\/\/< Polynomial degree$/;"	m	class:srMath::BSpline
_DIFFKIN_IntegratePosition_All_The_Links_All_The_Systmes	srLib/srDyn/srSpace.cpp	/^void srSpace::_DIFFKIN_IntegratePosition_All_The_Links_All_The_Systmes()$/;"	f	class:srSpace
_DIFFKIN_LinkVelocityPropagation_All_The_Systmes	srLib/srDyn/srSpace.cpp	/^void srSpace::_DIFFKIN_LinkVelocityPropagation_All_The_Systmes()$/;"	f	class:srSpace
_DYN_Step_Forward_All_The_Systems	srLib/srDyn/srSpace.cpp	/^inline void srSpace::_DYN_Step_Forward_All_The_Systems()$/;"	f	class:srSpace
_DefineActuatedJoint	Example/DracoP1/draco.cpp	/^void srDraco::_DefineActuatedJoint(){$/;"	f	class:srDraco
_DefineLinks	Example/DracoP1/draco.cpp	/^void srDraco::_DefineLinks(){$/;"	f	class:srDraco
_DefineVirtualJoint	Example/DracoP1/draco.cpp	/^void srDraco::_DefineVirtualJoint(){$/;"	f	class:srDraco
_DetectOneSpot	srLib/srDyn/srRangeFinder.cpp	/^void srRangeFinder::_DetectOneSpot(int &idx, Vec3 &direction, Vec3 &position)$/;"	f	class:srRangeFinder
_EIGEN_ACCUMULATE_PACKETS	Eigen/src/Core/products/GeneralMatrixVector.h	/^  #define _EIGEN_ACCUMULATE_PACKETS(/;"	d
_EIGEN_ACCUMULATE_PACKETS	Eigen/src/Core/products/GeneralMatrixVector.h	/^  #undef _EIGEN_ACCUMULATE_PACKETS$/;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4f	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_FAST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_FAST_Packet4i	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_FAST_Packet4i(/;"	d
_EIGEN_DECLARE_CONST_Packet2d	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet2d(/;"	d
_EIGEN_DECLARE_CONST_Packet4f	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_Packet4f	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_Packet4f	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f(/;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(/;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(/;"	d
_EIGEN_DECLARE_CONST_Packet4f_FROM_INT	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4f_FROM_INT(/;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4i(/;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/NEON/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4i(/;"	d
_EIGEN_DECLARE_CONST_Packet4i	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define _EIGEN_DECLARE_CONST_Packet4i(/;"	d
_EIGEN_SPARSE_PUBLIC_INTERFACE	Eigen/src/SparseCore/SparseUtil.h	/^#define _EIGEN_SPARSE_PUBLIC_INTERFACE(/;"	d
_ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef Transpose<const typename Base::_ExtractType> _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_ExtractType	Eigen/src/Core/util/BlasUtil.h	/^  typedef XprType _ExtractType;$/;"	t	struct:Eigen::internal::blas_traits
_FREE_pContactPts	srLib/srDyn/srContactConstraint.cpp	/^void	ContactConstraint::_FREE_pContactPts()$/;"	f	class:ContactConstraint
_FS_ForwardDynamics_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::_FS_ForwardDynamics_Set00(SR_REAL & _step)$/;"	f	class:srSystem
_FS_Impulsedynamics_set00	srLib/srDyn/srSystem.cpp	/^void srSystem::_FS_Impulsedynamics_set00(SR_REAL & _fps)$/;"	f	class:srSystem
_FS_IntegratePosition_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::_FS_IntegratePosition_Set00(SR_REAL & _step)$/;"	f	class:srSystem
_FS_Transform_Reverse	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_Transform_Reverse()$/;"	f	class:srBallJoint
_FS_Transform_Straight	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_Transform_Straight()$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_Hybrid(const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_Hybrid(const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_Hybrid(const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_Hybrid(const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_P_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_P_Hybrid(AInertia& __AI, const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_P_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_P_Hybrid(AInertia& __AI, const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_P_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_P_Hybrid(AInertia& __AI, const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_P_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_P_Hybrid(AInertia& __AI, const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_P_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_P_Passive(AInertia& __AI, const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_P_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_P_Passive(AInertia& __AI, const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_P_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_P_Passive(AInertia& __AI, const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_P_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_P_Passive(AInertia& __AI, const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_P_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_P_Servo(AInertia& __AI, const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_P_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_P_Servo(AInertia& __AI, const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_P_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_P_Servo(AInertia& __AI, const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_P_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_P_Servo(AInertia& __AI, const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_P_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_P_Torque(AInertia& __AI, const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_P_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_P_Torque(AInertia& __AI, const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_P_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_P_Torque(AInertia& __AI, const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_P_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_P_Torque(AInertia& __AI, const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_Passive(const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_Passive(const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_Passive(const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_Passive(const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_Servo(const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_Servo(const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_Servo(const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_Servo(const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateAIS_K_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateAIS_K_Torque(const AInertia& AI)$/;"	f	class:srBallJoint
_FS_UpdateAIS_K_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateAIS_K_Torque(const AInertia& AI)$/;"	f	class:srPrismaticJoint
_FS_UpdateAIS_K_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateAIS_K_Torque(const AInertia& AI)$/;"	f	class:srRevoluteJoint
_FS_UpdateAIS_K_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateAIS_K_Torque(const AInertia& AI)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasImp_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasImp_Hybrid(dse3& Cias, const dse3& Bias)$/;"	f	class:srBallJoint
_FS_UpdateBiasImp_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasImp_Hybrid(dse3& Cias, const dse3& Bias)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasImp_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasImp_Hybrid(dse3& Cias, const dse3& Bias)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasImp_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasImp_Hybrid(dse3& Cias, const dse3& Bias)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasImp_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasImp_Passive(dse3& Cias, const dse3& Bias)$/;"	f	class:srBallJoint
_FS_UpdateBiasImp_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasImp_Passive(dse3& Cias, const dse3& Bias)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasImp_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasImp_Passive(dse3& Cias, const dse3& Bias)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasImp_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasImp_Passive(dse3& Cias, const dse3& Bias)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasImp_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasImp_Servo(dse3& Cias, const dse3& Bias)$/;"	f	class:srBallJoint
_FS_UpdateBiasImp_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasImp_Servo(dse3& Cias, const dse3& Bias)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasImp_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasImp_Servo(dse3& Cias, const dse3& Bias)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasImp_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasImp_Servo(dse3& Cias, const dse3& Bias)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasImp_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasImp_Torque(dse3& Cias, const dse3& Bias)$/;"	f	class:srBallJoint
_FS_UpdateBiasImp_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasImp_Torque(dse3& Cias, const dse3& Bias)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasImp_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasImp_Torque(dse3& Cias, const dse3& Bias)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasImp_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasImp_Torque(dse3& Cias, const dse3& Bias)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasforce_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasforce_Hybrid(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srBallJoint
_FS_UpdateBiasforce_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasforce_Hybrid(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasforce_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasforce_Hybrid(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasforce_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasforce_Hybrid(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasforce_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasforce_Passive(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srBallJoint
_FS_UpdateBiasforce_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasforce_Passive(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasforce_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasforce_Passive(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasforce_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasforce_Passive(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasforce_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasforce_Servo(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srBallJoint
_FS_UpdateBiasforce_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasforce_Servo(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasforce_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasforce_Servo(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasforce_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasforce_Servo(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srUniversalJoint
_FS_UpdateBiasforce_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateBiasforce_Torque(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srBallJoint
_FS_UpdateBiasforce_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateBiasforce_Torque(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srPrismaticJoint
_FS_UpdateBiasforce_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateBiasforce_Torque(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srRevoluteJoint
_FS_UpdateBiasforce_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateBiasforce_Torque(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V)$/;"	f	class:srUniversalJoint
_FS_UpdateForce_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateForce_Hybrid(const dse3& F)$/;"	f	class:srBallJoint
_FS_UpdateForce_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateForce_Hybrid(const dse3& F)$/;"	f	class:srPrismaticJoint
_FS_UpdateForce_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateForce_Hybrid(const dse3& F)$/;"	f	class:srRevoluteJoint
_FS_UpdateForce_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateForce_Hybrid(const dse3& F)$/;"	f	class:srUniversalJoint
_FS_UpdateForce_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateForce_Passive(const dse3& \/* F *\/)$/;"	f	class:srBallJoint
_FS_UpdateForce_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateForce_Passive(const dse3& \/* F *\/)$/;"	f	class:srPrismaticJoint
_FS_UpdateForce_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateForce_Passive(const dse3& \/* F *\/)$/;"	f	class:srRevoluteJoint
_FS_UpdateForce_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateForce_Passive(const dse3& \/* F *\/)$/;"	f	class:srUniversalJoint
_FS_UpdateForce_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateForce_Servo(const dse3& \/* F *\/)$/;"	f	class:srBallJoint
_FS_UpdateForce_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateForce_Servo(const dse3& \/* F *\/)$/;"	f	class:srPrismaticJoint
_FS_UpdateForce_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateForce_Servo(const dse3& \/* F *\/)$/;"	f	class:srRevoluteJoint
_FS_UpdateForce_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateForce_Servo(const dse3& \/* F *\/)$/;"	f	class:srUniversalJoint
_FS_UpdateForce_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateForce_Torque(const dse3& \/* F *\/)$/;"	f	class:srBallJoint
_FS_UpdateForce_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateForce_Torque(const dse3& \/* F *\/)$/;"	f	class:srPrismaticJoint
_FS_UpdateForce_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateForce_Torque(const dse3& \/* F *\/)$/;"	f	class:srRevoluteJoint
_FS_UpdateForce_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateForce_Torque(const dse3& \/* F *\/)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalAcc_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalAcc_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalAcc_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalAcc_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalAcc_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalAcc_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalAcc_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalAcc_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalAcc_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalAcc_Passive(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalAcc_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalAcc_Passive(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalAcc_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalAcc_Passive(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalAcc_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalAcc_Passive(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalAcc_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalAcc_Servo(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalAcc_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalAcc_Servo(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalAcc_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalAcc_Servo(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalAcc_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalAcc_Servo(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalAcc_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalAcc_Torque(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalAcc_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalAcc_Torque(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalAcc_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalAcc_Torque(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalAcc_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalAcc_Torque(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalDelVel_Hybrid	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalDelVel_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalDelVel_Hybrid	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalDelVel_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalDelVel_Hybrid	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalDelVel_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalDelVel_Hybrid	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalDelVel_Hybrid(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalDelVel_Passive	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalDelVel_Passive(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalDelVel_Passive	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalDelVel_Passive(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalDelVel_Passive	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalDelVel_Passive(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalDelVel_Passive	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalDelVel_Passive(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalDelVel_Servo	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalDelVel_Servo(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalDelVel_Servo	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalDelVel_Servo(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalDelVel_Servo	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalDelVel_Servo(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalDelVel_Servo	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalDelVel_Servo(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FS_UpdateLocalDelVel_Torque	srLib/srDyn/srBallJoint.cpp	/^void srBallJoint::_FS_UpdateLocalDelVel_Torque(se3& jari, const se3& DV)$/;"	f	class:srBallJoint
_FS_UpdateLocalDelVel_Torque	srLib/srDyn/srPrismaticJoint.cpp	/^void srPrismaticJoint::_FS_UpdateLocalDelVel_Torque(se3& jari, const se3& DV)$/;"	f	class:srPrismaticJoint
_FS_UpdateLocalDelVel_Torque	srLib/srDyn/srRevoluteJoint.cpp	/^void srRevoluteJoint::_FS_UpdateLocalDelVel_Torque(se3& jari, const se3& DV)$/;"	f	class:srRevoluteJoint
_FS_UpdateLocalDelVel_Torque	srLib/srDyn/srUniversalJoint.cpp	/^void srUniversalJoint::_FS_UpdateLocalDelVel_Torque(se3& jari, const se3& DV)$/;"	f	class:srUniversalJoint
_FontIndex	srLib/SceneGraph/Font.h	/^	int _FontIndex;$/;"	m	class:srgString
_FontIndex	srLib/srg/srgFont.h	/^	int _FontIndex;$/;"	m	class:srgString
_GL2PSbsptree	srLib/SceneGraph/gl2ps.c	/^struct _GL2PSbsptree {$/;"	s	file:
_GL2PSbsptree2d	srLib/SceneGraph/gl2ps.c	/^struct _GL2PSbsptree2d {$/;"	s	file:
_GL2PSimagemap	srLib/SceneGraph/gl2ps.c	/^struct _GL2PSimagemap {$/;"	s	file:
_HasDirectAccess	Eigen/src/SparseCore/SparseMatrixBase.h	/^      _HasDirectAccess = (int(Flags)&DirectAccessBit) ? 1 : 0 \/\/ workaround sunCC$/;"	e	enum:Eigen::SparseMatrixBase::__anon367
_I	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_I[10];$/;"	m	class:Inertia
_Index	Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::sparse_eval
_Index	Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Index _Index;$/;"	t	struct:Eigen::internal::plain_matrix_type
_InvDeltaU	srMath/Interpolation.h	/^		Eigen::Matrix<Real, OrderK, ((OrderK == -1) || (CoefficientN == -1) ? -1 : CoefficientN + OrderK)> _InvDeltaU;$/;"	m	class:srMath::BSpline
_J	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_J[21];$/;"	m	class:AInertia
_K	srMath/Interpolation.h	/^		int _K; \/\/\/< Order$/;"	m	class:srMath::BSpline
_KIN_UpdateFrame_All_The_Entity_All_The_Systems	srLib/srDyn/srSpace.cpp	/^inline void srSpace::_KIN_UpdateFrame_All_The_Entity_All_The_Systems()$/;"	f	class:srSpace
_KIN_UpdateFrame_All_The_Joints_All_The_Systems	srLib/srDyn/srSpace.cpp	/^inline void srSpace::_KIN_UpdateFrame_All_The_Joints_All_The_Systems()$/;"	f	class:srSpace
_KIN_UpdateFrame_All_The_Sensors_All_The_Systems	srLib/srDyn/srSpace.cpp	/^void srSpace::_KIN_UpdateFrame_All_The_Sensors_All_The_Systems()$/;"	f	class:srSpace
_KIN_Update_All_The_Sensors	srLib/srDyn/srSpace.cpp	/^inline void srSpace::_KIN_Update_All_The_Sensors()$/;"	f	class:srSpace
_L_ForwardDynamics_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::_L_ForwardDynamics_Set00(SR_REAL & _step)$/;"	f	class:srSystem
_L_Impulsedynamics_set00	srLib/srDyn/srSystem.cpp	/^void srSystem::_L_Impulsedynamics_set00(SR_REAL & _fps)$/;"	f	class:srSystem
_L_IntegratePosition_Set00	srLib/srDyn/srSystem.cpp	/^void srSystem::_L_IntegratePosition_Set00(SR_REAL & _step)$/;"	f	class:srSystem
_Lhs	Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::product_type
_Lhs	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Lhs>::type _Lhs;$/;"	t	struct:Eigen::internal::traits
_LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_LhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::ProductBase
_LhsNested	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::CoeffBasedProduct
_LhsNested	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_LhsNested _LhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
_LhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
_LhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<LhsNested>::type _LhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
_LhsNested	Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_LhsNested _LhsNested;$/;"	t	class:Eigen::SparseSparseProduct
_LhsNested	Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<LhsNested>::type _LhsNested;$/;"	t	struct:Eigen::internal::traits
_LhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_LhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<LhsScalar>::type  _LhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_LinearAccessMask	Eigen/src/Core/DiagonalProduct.h	/^    _LinearAccessMask = (RowsAtCompileTime==1 || ColsAtCompileTime==1) ? LinearAccessBit : 0,$/;"	e	enum:Eigen::internal::traits::__anon232
_M	srMath/Interpolation.h	/^		int _M; \/\/\/< Size of dimension$/;"	m	class:srMath::BSpline
_MaterialColor	srLib/srg/srgColor.h	/^	sMaterialColor	_MaterialColor;$/;"	m	class:srgMaterialColor
_MatrixType	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    typedef typename internal::pastix_traits<Derived>::MatrixType _MatrixType;$/;"	t	class:Eigen::PastixBase
_MatrixTypeNested	Eigen/src/Core/CwiseUnaryView.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/Diagonal.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/Replicate.h	/^    typedef typename internal::traits<Replicate>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::Replicate
_MatrixTypeNested	Eigen/src/Core/Replicate.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/Reverse.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Core/VectorwiseOp.h	/^    typedef typename internal::traits<PartialReduxExpr>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::PartialReduxExpr
_MatrixTypeNested	Eigen/src/Core/VectorwiseOp.h	/^  typedef typename remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Eigen2Support/Minor.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename SparseMatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseBlock.h	/^    typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseBlock.h	/^  typedef typename internal::remove_all<typename XprType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::BlockImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_MatrixTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryViewImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    typedef typename internal::traits<Derived>::_XprTypeNested _MatrixTypeNested;$/;"	t	class:Eigen::CwiseUnaryOpImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseMatrix.h	/^  typedef typename remove_reference<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	struct:Eigen::internal::traits
_MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSelfAdjointView
_MatrixTypeNested	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseSymmetricPermutationProduct
_MatrixTypeNested	Eigen/src/SparseCore/SparseTranspose.h	/^    typedef typename internal::remove_all<typename MatrixType::Nested>::type _MatrixTypeNested;$/;"	t	class:Eigen::TransposeImpl
_MatrixTypeNested	Eigen/src/SparseCore/SparseView.h	/^  typedef typename internal::remove_all<MatrixTypeNested>::type _MatrixTypeNested;$/;"	t	class:Eigen::SparseView
_Mode	srLib/SceneGraph/Font.h	/^	mode_type _Mode;$/;"	m	class:srgString
_Mode	srLib/srg/srgFont.h	/^	mode_type _Mode;$/;"	m	class:srgString
_N	srMath/Interpolation.h	/^		int _N; \/\/\/< Number of control points on a spline$/;"	m	class:srMath::BSpline
_N	srMath/LinearIntegrator.h	/^		int			_N;$/;"	m	class:srMath::LinearIntegrator
_NONE	srLib/SceneGraph/Camera.h	/^	enum CAMERAMODE{ _NONE = 0, _TRANSLATE, _ROTATE, _ZOOM_IN, _ZOOM_OUT};$/;"	e	enum:Camera::CAMERAMODE
_Options	Eigen/src/SparseCore/SparseUtil.h	/^    enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::sparse_eval::__anon391
_Options	Eigen/src/SparseCore/SparseUtil.h	/^  enum { _Options = ((traits<T>::Flags&RowMajorBit)==RowMajorBit) ? RowMajor : ColMajor };$/;"	e	enum:Eigen::internal::plain_matrix_type::__anon392
_OthersOthers_______RoughCheck_TEMP	srLib/srDyn/srCollisionPair.cpp	/^bool	CollisionPair::_OthersOthers_______RoughCheck_TEMP()$/;"	f	class:CollisionPair
_OthersPlane________RoughCheck_TEMP	srLib/srDyn/srCollisionPair.cpp	/^bool	CollisionPair::_OthersPlane________RoughCheck_TEMP()$/;"	f	class:CollisionPair
_PGS_Solve_Constraint_____________________MARK7	srLib/srDyn/srISLAND.cpp	/^void ISLAND::_PGS_Solve_Constraint_____________________MARK7(PGSOption * option)$/;"	f	class:ISLAND
_PRESTEP_Build_Baked_ClosedLoop_______________MARK7	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_Build_Baked_ClosedLoop_______________MARK7(SystemPtrArray & _systemptrarray)$/;"	f	class:srDYN
_PRESTEP_Build_Baked_ContactConstraint________MARK7	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_Build_Baked_ContactConstraint________MARK7()$/;"	f	class:srDYN
_PRESTEP_Build_Baked_JointConstraint__________MARK11	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_Build_Baked_JointConstraint__________MARK11(JointPtrArray & _jointptrarray)$/;"	f	class:srDYN
_PRESTEP_Build_ObjectPools	srLib/srDyn/srSpace.cpp	/^void srSpace::_PRESTEP_Build_ObjectPools()$/;"	f	class:srSpace
_PRESTEP_Calculate_FrictionCoeff___________MARK7	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL	ContactConstraint::_PRESTEP_Calculate_FrictionCoeff___________MARK7(SR_REAL leftmat, SR_REAL rightmat)$/;"	f	class:ContactConstraint
_PRESTEP_Calculate_RestitutionCoeff________MARK7	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL	ContactConstraint::_PRESTEP_Calculate_RestitutionCoeff________MARK7(SR_REAL leftmat, SR_REAL rightmat)$/;"	f	class:ContactConstraint
_PRESTEP_Collision_Setting	srLib/srDyn/srSpace.cpp	/^void srSpace::_PRESTEP_Collision_Setting()$/;"	f	class:srSpace
_PRESTEP_DYN_Space_Setting	srLib/srDyn/srSpace.cpp	/^void srSpace::_PRESTEP_DYN_Space_Setting()$/;"	f	class:srSpace
_PRESTEP_DYN_Spring_Setting	srLib/srDyn/srSpace.cpp	/^void srSpace::_PRESTEP_DYN_Spring_Setting()$/;"	f	class:srSpace
_PRESTEP_DYN_System_Setting	srLib/srDyn/srSpace.cpp	/^void srSpace::_PRESTEP_DYN_System_Setting()$/;"	f	class:srSpace
_PRESTEP_Initialize_Static_Variables__________MARK11	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_Initialize_Static_Variables__________MARK11()$/;"	f	class:srDYN
_PRESTEP_Sensor_Setting	srLib/srDyn/srSpace.cpp	/^void srSpace::_PRESTEP_Sensor_Setting()$/;"	f	class:srSpace
_PRESTEP_Set_SpaceVariables___________________MARK9	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_Set_SpaceVariables___________________MARK9(SR_REAL & _timestep, SR_REAL & _fps)$/;"	f	class:srDYN
_PRESTEP_Set_Virual_Function_______________MARK7	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_PRESTEP_Set_Virual_Function_______________MARK7()$/;"	f	class:ContactConstraint
_PRESTEP_TEMP_BuildMassPair___________________MARK9	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_TEMP_BuildMassPair___________________MARK9(LinkPtrArray & _linkptrarray)$/;"	f	class:srDYN
_PRESTEP_TEMP_Eliminate_SelfCollision_________MARK7	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_TEMP_Eliminate_SelfCollision_________MARK7()$/;"	f	class:srDYN
_PRESTEP_TEMP_OnOff_MassPair__________________MARK7	srLib/srDyn/srDYN.cpp	/^void srDYN::_PRESTEP_TEMP_OnOff_MassPair__________________MARK7(bool onoff \/*= true*\/)$/;"	f	class:srDYN
_PlaneBox___________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_PlaneBox___________MARK8()$/;"	f	class:CollisionPair
_PlaneCapsule_______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_PlaneCapsule_______MARK8()$/;"	f	class:CollisionPair
_PlaneCylinder______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_PlaneCylinder______MARK8()$/;"	f	class:CollisionPair
_PlaneOthers________RoughCheck_TEMP	srLib/srDyn/srCollisionPair.cpp	/^bool	CollisionPair::_PlaneOthers________RoughCheck_TEMP()$/;"	f	class:CollisionPair
_PlaneSphere________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_PlaneSphere________MARK8()$/;"	f	class:CollisionPair
_PrintBitmapString	srLib/SceneGraph/Font.cpp	/^void srgString::_PrintBitmapString( void* font, const char* s )$/;"	f	class:srgString
_PrintBitmapString	srLib/srg/srgFont.cpp	/^void srgString::_PrintBitmapString( void* font, const char* s )$/;"	f	class:srgString
_PrintStrokeString	srLib/SceneGraph/Font.cpp	/^void srgString::_PrintStrokeString( void* font, const char* s )$/;"	f	class:srgString
_PrintStrokeString	srLib/srg/srgFont.cpp	/^void srgString::_PrintStrokeString( void* font, const char* s )$/;"	f	class:srgString
_QUOTE	srLib/SceneGraph/Model3DS.cpp	/^#define _QUOTE(/;"	d	file:
_R	srLib/LieGroup/LieGroup.h	/^	SR_REAL _R[9];$/;"	m	class:SO3
_R	srMath/SE3.h	/^		SO3 _R;$/;"	m	class:srMath::SE3
_ROTATE	srLib/SceneGraph/Camera.h	/^	enum CAMERAMODE{ _NONE = 0, _TRANSLATE, _ROTATE, _ZOOM_IN, _ZOOM_OUT};$/;"	e	enum:Camera::CAMERAMODE
_RUNTIME_Build_ISLANDs_MARK10	srLib/srDyn/srDYN.cpp	/^inline void srDYN::_RUNTIME_Build_ISLANDs_MARK10()$/;"	f	class:srDYN
_RUNTIME_Build_ISLANDs_MARK9	srLib/srDyn/srDYN.cpp	/^inline void srDYN::_RUNTIME_Build_ISLANDs_MARK9()$/;"	f	class:srDYN
_RUNTIME_Detect_Blink_Constraints_MARK10	srLib/srDyn/srDYN.cpp	/^inline void srDYN::_RUNTIME_Detect_Blink_Constraints_MARK10()$/;"	f	class:srDYN
_RUNTIME_Solve_Constraints_by_ISLANDs_MARK9	srLib/srDyn/srDYN.cpp	/^inline void srDYN::_RUNTIME_Solve_Constraints_by_ISLANDs_MARK9()$/;"	f	class:srDYN
_RayToBox	srLib/srDyn/srCollision.cpp	/^bool srCollision::_RayToBox(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist)$/;"	f	class:srCollision
_RayToCapsule	srLib/srDyn/srCollision.cpp	/^bool srCollision::_RayToCapsule(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist)$/;"	f	class:srCollision
_RayToCylinder	srLib/srDyn/srCollision.cpp	/^bool srCollision::_RayToCylinder(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist)$/;"	f	class:srCollision
_RayToPlane	srLib/srDyn/srCollision.cpp	/^bool srCollision::_RayToPlane(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist)$/;"	f	class:srCollision
_RayToSphere	srLib/srDyn/srCollision.cpp	/^bool srCollision::_RayToSphere(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist)$/;"	f	class:srCollision
_RayToUser	srLib/srDyn/srCollision.cpp	/^bool srCollision::_RayToUser(Vec3& \/*point*\/, Vec3& \/*direction*\/, SR_REAL& \/*range*\/, SR_REAL& \/*dist*\/)$/;"	f	class:srCollision
_ResPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	class:Eigen::internal::gebp_traits
_ResPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<ResScalar>::type  _ResPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_RestoreInitState	srLib/srDyn/srSpace.cpp	/^void srSpace::_RestoreInitState()$/;"	f	class:srSpace
_Rhs	Eigen/src/Core/GeneralProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::product_type
_Rhs	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^  typedef typename remove_all<Rhs>::type _Rhs;$/;"	t	struct:Eigen::internal::traits
_RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^    typedef typename internal::remove_reference<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::CwiseBinaryOp
_RhsNested	Eigen/src/Core/CwiseBinaryOp.h	/^  typedef typename remove_reference<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	Eigen/src/Core/ProductBase.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::ProductBase
_RhsNested	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typedef typename internal::traits<CoeffBasedProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::CoeffBasedProduct
_RhsNested	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    typedef typename traits<CwiseBinaryXpr>::_RhsNested _RhsNested;$/;"	t	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
_RhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^    typedef typename Traits::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseDenseOuterProduct
_RhsNested	Eigen/src/SparseCore/SparseDenseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsNested	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    typedef typename internal::remove_all<RhsNested>::type _RhsNested;$/;"	t	class:Eigen::SparseDiagonalProduct
_RhsNested	Eigen/src/SparseCore/SparseProduct.h	/^    typedef typename internal::traits<SparseSparseProduct>::_RhsNested _RhsNested;$/;"	t	class:Eigen::SparseSparseProduct
_RhsNested	Eigen/src/SparseCore/SparseProduct.h	/^  typedef typename remove_all<RhsNested>::type _RhsNested;$/;"	t	struct:Eigen::internal::traits
_RhsPacket	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	class:Eigen::internal::gebp_traits
_RhsPacket	Eigen/src/Core/products/GeneralMatrixVector.h	/^typedef typename packet_traits<RhsScalar>::type  _RhsPacket;$/;"	t	struct:Eigen::internal::general_matrix_vector_product
_SameTypes	Eigen/src/Core/DiagonalProduct.h	/^    _SameTypes = is_same<typename MatrixType::Scalar, typename DiagonalType::Scalar>::value,$/;"	e	enum:Eigen::internal::traits::__anon232
_Scalar	Eigen/src/SparseCore/SparseUtil.h	/^    typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::sparse_eval
_Scalar	Eigen/src/SparseCore/SparseUtil.h	/^  typedef typename traits<T>::Scalar _Scalar;$/;"	t	struct:Eigen::internal::plain_matrix_type
_ScalarAccessOnDiag	Eigen/src/Core/DiagonalProduct.h	/^    _ScalarAccessOnDiag =  !((int(_StorageOrder) == ColMajor && int(ProductOrder) == OnTheLeft)$/;"	e	enum:Eigen::internal::traits::__anon232
_SetBase	Example/DracoP1/draco.cpp	/^void srDraco::_SetBase(Vec3 location, srSystem::BASELINKTYPE base_link_type){$/;"	f	class:srDraco
_SetCollision	Example/DracoP1/draco.cpp	/^void srDraco::_SetCollision(){$/;"	f	class:srDraco
_SetInertia	Example/DracoP1/draco.cpp	/^void srDraco::_SetInertia(){$/;"	f	class:srDraco
_SetInitialConf	Example/DracoP1/draco.cpp	/^void srDraco::_SetInitialConf(){$/;"	f	class:srDraco
_SetJointLimit	Example/DracoP1/draco.cpp	/^void srDraco::_SetJointLimit(){$/;"	f	class:srDraco
_SonarToBox	srLib/srDyn/srCollision.cpp	/^bool srCollision::_SonarToBox(SE3& T0, SR_REAL & range , SR_REAL & angle, bool & res)$/;"	f	class:srCollision
_SonarToCapsule	srLib/srDyn/srCollision.cpp	/^bool srCollision::_SonarToCapsule(SE3& \/*T0*\/, SR_REAL & \/*range*\/, SR_REAL & \/*angle*\/, bool & \/*res*\/)$/;"	f	class:srCollision
_SonarToCylinder	srLib/srDyn/srCollision.cpp	/^bool srCollision::_SonarToCylinder(SE3& \/*T0*\/, SR_REAL & \/*range*\/, SR_REAL & \/*angle*\/, bool & \/*res*\/)$/;"	f	class:srCollision
_SonarToPlane	srLib/srDyn/srCollision.cpp	/^bool srCollision::_SonarToPlane(SE3& T0, SR_REAL & range , SR_REAL & angle, bool & res)$/;"	f	class:srCollision
_SonarToSphere	srLib/srDyn/srCollision.cpp	/^bool srCollision::_SonarToSphere(SE3& T0, SR_REAL & range , SR_REAL & angle, bool & res)$/;"	f	class:srCollision
_SonarToUser	srLib/srDyn/srCollision.cpp	/^bool srCollision::_SonarToUser(SE3& \/*T0*\/, SR_REAL & \/*range*\/, SR_REAL & \/*angle*\/, bool & \/*res*\/)$/;"	f	class:srCollision
_SphereBox__________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_SphereBox__________MARK8()$/;"	f	class:CollisionPair
_SphereCapsule______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_SphereCapsule______MARK8()$/;"	f	class:CollisionPair
_SphereCylinder_____MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_SphereCylinder_____MARK8()$/;"	f	class:CollisionPair
_SpherePlane________MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_SpherePlane________MARK8()$/;"	f	class:CollisionPair
_SphereSphere_______MARK8	srLib/srDyn/srCollisionPair.cpp	/^int CollisionPair::_SphereSphere_______MARK8()$/;"	f	class:CollisionPair
_Step_Simulation_Time	srLib/srDyn/srSpace.cpp	/^inline void	srSpace::_Step_Simulation_Time()$/;"	f	class:srSpace
_StorageOrder	Eigen/src/Core/DiagonalProduct.h	/^    _StorageOrder = MatrixType::Flags & RowMajorBit ? RowMajor : ColMajor,$/;"	e	enum:Eigen::internal::traits::__anon232
_StrokeScale	srLib/SceneGraph/Font.h	/^	float _StrokeScale;$/;"	m	class:srgString
_StrokeScale	srLib/srg/srgFont.h	/^	float _StrokeScale;$/;"	m	class:srgString
_T	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_T[12];$/;"	m	class:SE3
_T	srLib/SceneGraph/Model3DS.h	/^	float _T[16];$/;"	m	class:Model3DS
_T	srLib/SceneGraph/ModelSTL.h	/^	float _T[16];$/;"	m	class:ModelSTL
_TRANSLATE	srLib/SceneGraph/Camera.h	/^	enum CAMERAMODE{ _NONE = 0, _TRANSLATE, _ROTATE, _ZOOM_IN, _ZOOM_OUT};$/;"	e	enum:Camera::CAMERAMODE
_TouchToBox	srLib/srDyn/srCollision.cpp	/^bool srCollision::_TouchToBox(Vec3& c0, SR_REAL r0, Vec3& point, Vec3& normal, SR_REAL& penetration)$/;"	f	class:srCollision
_TouchToCapsule	srLib/srDyn/srCollision.cpp	/^bool srCollision::_TouchToCapsule(Vec3& c1, SR_REAL r1, Vec3& point, Vec3& normal, SR_REAL& penetration)$/;"	f	class:srCollision
_TouchToCylinder	srLib/srDyn/srCollision.cpp	/^bool srCollision::_TouchToCylinder(Vec3& \/*position*\/, SR_REAL \/*radius*\/, Vec3& \/*point*\/, Vec3& \/*normal*\/, SR_REAL& \/*penetration*\/)$/;"	f	class:srCollision
_TouchToPlane	srLib/srDyn/srCollision.cpp	/^bool srCollision::_TouchToPlane(Vec3& c1, SR_REAL r1, Vec3& point, Vec3& normal, SR_REAL& penetration)$/;"	f	class:srCollision
_TouchToSphere	srLib/srDyn/srCollision.cpp	/^bool srCollision::_TouchToSphere(Vec3& c0, SR_REAL r0, Vec3& point, Vec3& normal, SR_REAL& penetration)$/;"	f	class:srCollision
_TouchToUser	srLib/srDyn/srCollision.cpp	/^bool srCollision::_TouchToUser(Vec3& \/*position*\/, SR_REAL \/*radius*\/, Vec3& \/*point*\/, Vec3& \/*normal*\/, SR_REAL& \/*penetration*\/)$/;"	f	class:srCollision
_USER_CONTROL	srLib/srDyn/srSpace.cpp	/^void srSpace::_USER_CONTROL()$/;"	f	class:srSpace
_USE_MATH_DEFINES	srLib/srg/srgMath.h	/^#define _USE_MATH_DEFINES$/;"	d
_UpdateMaterialColor	srLib/srg/srgColor.cpp	/^inline void srgMaterialColor::_UpdateMaterialColor()$/;"	f	class:srgMaterialColor
_Vectorizable	Eigen/src/Core/DiagonalProduct.h	/^    _Vectorizable = bool(int(MatrixType::Flags)&PacketAccessBit) && _SameTypes && (_ScalarAccessOnDiag || (bool(int(DiagonalType::DiagonalVectorType::Flags)&PacketAccessBit))),$/;"	e	enum:Eigen::internal::traits::__anon232
_XprTypeNested	Eigen/src/Core/Block.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
_XprTypeNested	Eigen/src/Core/CwiseUnaryOp.h	/^  typedef typename remove_reference<XprTypeNested>::type _XprTypeNested;$/;"	t	struct:Eigen::internal::traits
_ZOOM_IN	srLib/SceneGraph/Camera.h	/^	enum CAMERAMODE{ _NONE = 0, _TRANSLATE, _ROTATE, _ZOOM_IN, _ZOOM_OUT};$/;"	e	enum:Camera::CAMERAMODE
_ZOOM_OUT	srLib/SceneGraph/Camera.h	/^	enum CAMERAMODE{ _NONE = 0, _TRANSLATE, _ROTATE, _ZOOM_IN, _ZOOM_OUT};$/;"	e	enum:Camera::CAMERAMODE
__DYN_After_srDYN	srLib/srDyn/srSpace.cpp	/^inline void srSpace::__DYN_After_srDYN()$/;"	f	class:srSpace
__DYN_Before_srDYN	srLib/srDyn/srSpace.cpp	/^inline void srSpace::__DYN_Before_srDYN()$/;"	f	class:srSpace
__DYN_Reset	srLib/srDyn/srSpace.cpp	/^inline void srSpace::__DYN_Reset()$/;"	f	class:srSpace
__DYN_Reset_Post	srLib/srDyn/srSpace.cpp	/^inline void srSpace::__DYN_Reset_Post()$/;"	f	class:srSpace
__FILE__LINE__	srLib/SceneGraph/Model3DS.cpp	/^#define __FILE__LINE__ /;"	d	file:
__FS_IntegratePosition_Euler	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_IntegratePosition_Euler(SR_REAL & _step)$/;"	f	class:srSystem
__FS_IntegrateVelocity_Euler	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_IntegrateVelocity_Euler(SR_REAL & _step)$/;"	f	class:srSystem
__FS_LinkVelocityPropagation	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_LinkVelocityPropagation()$/;"	f	class:srSystem
__FS_UpdateAcceleration	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateAcceleration()$/;"	f	class:srSystem
__FS_UpdateAcceleration_with_DelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateAcceleration_with_DelVelocity(SR_REAL & _fps)$/;"	f	class:srSystem
__FS_UpdateArticulatedInertia	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateArticulatedInertia()$/;"	f	class:srSystem
__FS_UpdateBiasImpulse	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateBiasImpulse()$/;"	f	class:srSystem
__FS_UpdateBiasforce	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateBiasforce()$/;"	f	class:srSystem
__FS_UpdateDelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateDelVelocity(SR_REAL & _fps)$/;"	f	class:srSystem
__FS_UpdateVelocity_with_DelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::__FS_UpdateVelocity_with_DelVelocity()$/;"	f	class:srSystem
__GL2PS_H__	srLib/SceneGraph/gl2ps.h	/^#define __GL2PS_H__$/;"	d
__L_IntegratePosition_Euler	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_IntegratePosition_Euler(SR_REAL & _step)$/;"	f	class:srSystem
__L_IntegrateVelocity_Euler	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_IntegrateVelocity_Euler(SR_REAL & _step)$/;"	f	class:srSystem
__L_LinkVelocityPropagation	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_LinkVelocityPropagation()$/;"	f	class:srSystem
__L_UpdateAcceleration	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_UpdateAcceleration()$/;"	f	class:srSystem
__L_UpdateAcceleration_with_DelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_UpdateAcceleration_with_DelVelocity(SR_REAL & _fps)$/;"	f	class:srSystem
__L_UpdateBiasforce	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_UpdateBiasforce()$/;"	f	class:srSystem
__L_UpdateDelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_UpdateDelVelocity()$/;"	f	class:srSystem
__L_UpdateVelocity_with_DelVelocity	srLib/srDyn/srSystem.cpp	/^void srSystem::__L_UpdateVelocity_with_DelVelocity()$/;"	f	class:srSystem
__MODELSTL__	srLib/SceneGraph/ModelSTL.h	/^#define __MODELSTL__$/;"	d
__MY_RENDERER__	srLib/SceneGraph/srSpaceRenderer.h	/^#define __MY_RENDERER__$/;"	d
__PRESTEP_Build_CollisionPairs________________MARK9	srLib/srDyn/srDYN.cpp	/^void srDYN::__PRESTEP_Build_CollisionPairs________________MARK9(ContactConstraint * pContactConstraint)$/;"	f	class:srDYN
__PRESTEP_JointState_To_JointConstraint_______MARK11	srLib/srDyn/srDYN.cpp	/^void srDYN::__PRESTEP_JointState_To_JointConstraint_______MARK11(srJoint * pJoint)$/;"	f	class:srDYN
__PRESTEP_MassPair_To_ContactConstraint_______MARK7	srLib/srDyn/srDYN.cpp	/^void srDYN::__PRESTEP_MassPair_To_ContactConstraint_______MARK7(MassPair * pMassPair)$/;"	f	class:srDYN
__SRG_CAMERA__	srLib/srg/srgCamera.h	/^#define __SRG_CAMERA__$/;"	d
__SRG_COLOR__	srLib/srg/srgColor.h	/^#define __SRG_COLOR__$/;"	d
__SRG_FONT__	srLib/SceneGraph/Font.h	/^#define __SRG_FONT__$/;"	d
__SRG_FONT__	srLib/srg/srgFont.h	/^#define __SRG_FONT__$/;"	d
__SRG_GEOMETRY_DRAW__	srLib/srg/srgGeometryDraw.h	/^#define __SRG_GEOMETRY_DRAW__$/;"	d
__SRG_GL__	srLib/srg/srgL.h	/^#define __SRG_GL__$/;"	d
__SRG_LIE_GROUP__	srLib/srg/srgLieGroup.h	/^#define __SRG_LIE_GROUP__$/;"	d
__SRG_MATH__	srLib/srg/srgMath.h	/^#define __SRG_MATH__$/;"	d
__SRG_ROBOTICS_GRAPHIC__	srLib/srg/srg.h	/^#define __SRG_ROBOTICS_GRAPHIC__$/;"	d
__SR_ROBOT__	srLib/common/srRobot.h	/^#define __SR_ROBOT__$/;"	d
__SR_SDF__	srLib/common/srSDF.h	/^#define __SR_SDF__$/;"	d
__SR_STL__	srLib/common/srSTL.h	/^#define __SR_STL__$/;"	d
__SR_URDF__	srLib/common/srURDF.h	/^#define __SR_URDF__$/;"	d
__TangentPlane	srLib/srDyn/srCollisionPair.cpp	/^inline void __TangentPlane(const Vec3& n, Vec3& p, Vec3& q)$/;"	f
__array_	srLib/LieGroup/_array.h	/^#define __array_$/;"	d
__getdelvelocity_Bothsides	srLib/srDyn/srContactConstraint.cpp	/^inline void ContactConstraint::__getdelvelocity_Bothsides(SR_REAL *sjari)$/;"	f	class:ContactConstraint
__getdelvelocity_Leftside	srLib/srDyn/srContactConstraint.cpp	/^inline void ContactConstraint::__getdelvelocity_Leftside(SR_REAL *sjari)$/;"	f	class:ContactConstraint
__getdelvelocity_None	srLib/srDyn/srContactConstraint.cpp	/^inline void ContactConstraint::__getdelvelocity_None(SR_REAL *sjari)$/;"	f	class:ContactConstraint
__getdelvelocity_Rightside	srLib/srDyn/srContactConstraint.cpp	/^inline void ContactConstraint::__getdelvelocity_Rightside(SR_REAL *sjari)$/;"	f	class:ContactConstraint
__has_feature	Eigen/src/Core/util/Macros.h	/^# define __has_feature(/;"	d
__lse3	srLib/srg/srgCamera.h	/^	SE3 __lse3;$/;"	m	class:srgCamera
__sse3	srLib/srg/srgCamera.h	/^	se3 __sse3;$/;"	m	class:srgCamera
__v	srLib/srg/srgCamera.h	/^	Vec3 __v;$/;"	m	class:srgCamera
__x	srLib/srg/srgCamera.h	/^	Vec3 __x, __y, __z;$/;"	m	class:srgCamera
__y	srLib/srg/srgCamera.h	/^	Vec3 __x, __y, __z;$/;"	m	class:srgCamera
__z	srLib/srg/srgCamera.h	/^	Vec3 __x, __y, __z;$/;"	m	class:srgCamera
_allocateMem	srLib/SceneGraph/Bitmap.cpp	/^void _Bitmap::_allocateMem()$/;"	f	class:_Bitmap
_allocateMem	srLib/srg/srgBitmap.cpp	/^void _Bitmap::_allocateMem()$/;"	f	class:_Bitmap
_allocated	tinyxml2/tinyxml2.h	/^    int _allocated;		\/\/ objects allocated$/;"	m	class:tinyxml2::DynArray
_applyimpulse_B_RP	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_applyimpulse_B_RP(int \/* _idx *\/)$/;"	f	class:JointConstraint
_applyimpulse_B_Y	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_applyimpulse_B_Y(int \/* _idx *\/)$/;"	f	class:JointConstraint
_applyimpulse_Both	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_applyimpulse_Both(int _idx)$/;"	f	class:ContactConstraint
_applyimpulse_FS_Both	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_applyimpulse_FS_Both(int _idx)$/;"	f	class:ContactConstraint
_applyimpulse_FS_Left	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_applyimpulse_FS_Left(int _idx)$/;"	f	class:ContactConstraint
_applyimpulse_FS_Right	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_applyimpulse_FS_Right(int _idx)$/;"	f	class:ContactConstraint
_applyimpulse_L_Left	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_applyimpulse_L_Left(int _idx)$/;"	f	class:ContactConstraint
_applyimpulse_L_Right	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_applyimpulse_L_Right(int _idx)$/;"	f	class:ContactConstraint
_applyimpulse_P	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_applyimpulse_P(int \/* _idx *\/)$/;"	f	class:JointConstraint
_applyimpulse_R	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_applyimpulse_R(int \/* _idx *\/)$/;"	f	class:JointConstraint
_applyimpulse_U_1	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_applyimpulse_U_1(int \/* _idx *\/)$/;"	f	class:JointConstraint
_applyimpulse_U_2	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_applyimpulse_U_2(int \/* _idx *\/)$/;"	f	class:JointConstraint
_array	srLib/LieGroup/_array.h	/^	_array()$/;"	f	class:_array
_array	srLib/LieGroup/_array.h	/^	_array(const _array<TYPE> &ary)$/;"	f	class:_array
_array	srLib/LieGroup/_array.h	/^	_array(int sz)$/;"	f	class:_array
_array	srLib/LieGroup/_array.h	/^template <class TYPE> class _array$/;"	c
_attributePool	tinyxml2/tinyxml2.h	/^    MemPoolT< sizeof(XMLAttribute) > _attributePool;$/;"	m	class:tinyxml2::XMLDocument
_b	srMath/Function.h	/^		VectorX _b;$/;"	m	class:srMath::AffineFunction
_b	srMath/Function.h	/^		VectorX _b;$/;"	m	class:srMath::QuadraticFunction
_baseFunction	srMath/Function.h	/^		std::shared_ptr<const Function> _baseFunction;$/;"	m	class:srMath::MultiplyConstFunction
_blockPtrs	tinyxml2/tinyxml2.h	/^    DynArray< Block*, 10 > _blockPtrs;$/;"	m	class:tinyxml2::MemPoolT
_buffer	tinyxml2/tinyxml2.h	/^    DynArray< char, 20 > _buffer;$/;"	m	class:tinyxml2::XMLPrinter
_c	srMath/Function.h	/^		Eigen::Matrix<Real, 1, 1> _c;$/;"	m	class:srMath::QuadraticFunction
_charBuffer	tinyxml2/tinyxml2.h	/^    char*			_charBuffer;$/;"	m	class:tinyxml2::XMLDocument
_check_template_params	Eigen/src/Core/PlainObjectBase.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::PlainObjectBase
_check_template_params	Eigen/src/Geometry/Quaternion.h	/^    static EIGEN_STRONG_INLINE void _check_template_params()$/;"	f	class:Eigen::Quaternion
_closingType	tinyxml2/tinyxml2.h	/^    int _closingType;$/;"	m	class:tinyxml2::XMLElement
_commentPool	tinyxml2/tinyxml2.h	/^    MemPoolT< sizeof(XMLComment) >	 _commentPool;$/;"	m	class:tinyxml2::XMLDocument
_compactMode	tinyxml2/tinyxml2.h	/^	bool _compactMode;$/;"	m	class:tinyxml2::XMLPrinter
_compute	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^void HessenbergDecomposition<MatrixType>::_compute(MatrixType& matA, CoeffVectorType& hCoeffs, VectorType& temp)$/;"	f	class:Eigen::HessenbergDecomposition
_controlPoints	srMath/Interpolation.h	/^		Eigen::Matrix<Real, Dimension, ((CoefficientN == -1) ? -1 : CoefficientN)> _controlPoints;$/;"	m	class:srMath::BSpline
_currentAllocs	tinyxml2/tinyxml2.h	/^    int _currentAllocs;$/;"	m	class:tinyxml2::MemPoolT
_d	srMath/Interpolation.h	/^		Eigen::Matrix<Real, Dimension, (OrderK == -1 ? -1 : OrderK*OrderK)> _d;$/;"	m	class:srMath::BSpline
_data	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Storage& _data() { return m_data; }$/;"	f	class:Eigen::SparseVector
_data	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED const Storage& _data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
_depth	tinyxml2/tinyxml2.h	/^    int _depth;$/;"	m	class:tinyxml2::XMLPrinter
_do_nothing	srLib/srDyn/srSpace.cpp	/^void _do_nothing()$/;"	f
_document	tinyxml2/tinyxml2.h	/^    XMLDocument*	_document;$/;"	m	class:tinyxml2::XMLNode
_draw_box	srLib/srg/srgGeometryDraw.cpp	/^void _draw_box(const SR_REAL _sz[3])$/;"	f
_e	srMath/SO3.h	/^		Matrix3 _e;$/;"	m	class:srMath::SO3
_elementJustOpened	tinyxml2/tinyxml2.h	/^    bool _elementJustOpened;$/;"	m	class:tinyxml2::XMLPrinter
_elementPool	tinyxml2/tinyxml2.h	/^    MemPoolT< sizeof(XMLElement) >	 _elementPool;$/;"	m	class:tinyxml2::XMLDocument
_end	tinyxml2/tinyxml2.h	/^    char*   _end;$/;"	m	class:tinyxml2::StrPair
_entityFlag	tinyxml2/tinyxml2.h	/^    bool _entityFlag[ENTITY_RANGE];$/;"	m	class:tinyxml2::XMLPrinter
_eps	srMath/Function.h	/^		Real _eps;$/;"	m	class:srMath::Function
_errorID	tinyxml2/tinyxml2.h	/^    XMLError		_errorID;$/;"	m	class:tinyxml2::XMLDocument
_errorLineNum	tinyxml2/tinyxml2.h	/^    int             _errorLineNum;$/;"	m	class:tinyxml2::XMLDocument
_errorNames	tinyxml2/tinyxml2.cpp	/^const char* XMLDocument::_errorNames[XML_ERROR_COUNT] = {$/;"	m	class:tinyxml2::XMLDocument	file:
_errorNames	tinyxml2/tinyxml2.h	/^	static const char* _errorNames[XML_ERROR_COUNT];$/;"	m	class:tinyxml2::XMLDocument
_errorStr1	tinyxml2/tinyxml2.h	/^    mutable StrPair	_errorStr1;$/;"	m	class:tinyxml2::XMLDocument
_errorStr2	tinyxml2/tinyxml2.h	/^    mutable StrPair	_errorStr2;$/;"	m	class:tinyxml2::XMLDocument
_excite_BothSystem	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_excite_BothSystem()$/;"	f	class:ContactConstraint
_excite_LeftSystem	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_excite_LeftSystem()$/;"	f	class:ContactConstraint
_excite_RightSystem	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_excite_RightSystem()$/;"	f	class:ContactConstraint
_expression	Eigen/src/Core/Flagged.h	/^    const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Flagged
_expression	Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& _expression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
_expression	Eigen/src/Core/VectorwiseOp.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::VectorwiseOp
_expression	Eigen/src/Eigen2Support/Cwise.h	/^    inline const ExpressionType& _expression() const { return m_matrix; }$/;"	f	class:Eigen::Cwise
_fAmbientFactor	srLib/srg/srgColor.h	/^	float _fAmbientFactor;$/;"	m	class:srgMaterialColor
_fDiffuseFactor	srLib/srg/srgColor.h	/^	float _fDiffuseFactor;$/;"	m	class:srgMaterialColor
_fEmissionFactor	srLib/srg/srgColor.h	/^	float _fEmissionFactor;$/;"	m	class:srgMaterialColor
_fShininessFactor	srLib/srg/srgColor.h	/^	float _fShininessFactor;$/;"	m	class:srgMaterialColor
_fSpecularFactor	srLib/srg/srgColor.h	/^	float _fSpecularFactor;$/;"	m	class:srgMaterialColor
_find_return_leftID	srLib/srDyn/srContactConstraint.cpp	/^srSystem* ContactConstraint::_find_return_leftID()$/;"	f	class:ContactConstraint
_find_return_rightID	srLib/srDyn/srContactConstraint.cpp	/^srSystem* ContactConstraint::_find_return_rightID()$/;"	f	class:ContactConstraint
_findex	srLib/srDyn/srConstraint.h	/^	int	   * _findex;$/;"	m	struct:ConstraintInfo
_firstChild	tinyxml2/tinyxml2.h	/^    XMLNode*		_firstChild;$/;"	m	class:tinyxml2::XMLNode
_firstElement	tinyxml2/tinyxml2.h	/^    bool _firstElement;$/;"	m	class:tinyxml2::XMLPrinter
_flags	tinyxml2/tinyxml2.h	/^    int     _flags;$/;"	m	class:tinyxml2::StrPair
_fp	tinyxml2/tinyxml2.h	/^    FILE* _fp;$/;"	m	class:tinyxml2::XMLPrinter
_functionList	srMath/Function.h	/^		std::vector<FunctionPtr> _functionList;$/;"	m	class:srMath::AugmentedFunction
_getInformation_PositionLimit	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getInformation_PositionLimit(ConstraintInfo * info)$/;"	f	class:JointConstraint
_getInformation_TorqueLimit	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getInformation_TorqueLimit(ConstraintInfo * info)$/;"	f	class:JointConstraint
_getdelvelocity_B_RP	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getdelvelocity_B_RP(SR_REAL * \/* sjari *\/)$/;"	f	class:JointConstraint
_getdelvelocity_B_Y	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getdelvelocity_B_Y(SR_REAL * \/* sjari *\/)$/;"	f	class:JointConstraint
_getdelvelocity_BothMove	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_getdelvelocity_BothMove(SR_REAL *sjari)$/;"	f	class:ContactConstraint
_getdelvelocity_LeftMove	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_getdelvelocity_LeftMove(SR_REAL *sjari)$/;"	f	class:ContactConstraint
_getdelvelocity_P	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getdelvelocity_P(SR_REAL * sjari)$/;"	f	class:JointConstraint
_getdelvelocity_R	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getdelvelocity_R(SR_REAL * sjari)$/;"	f	class:JointConstraint
_getdelvelocity_RightMove	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_getdelvelocity_RightMove(SR_REAL *sjari)$/;"	f	class:ContactConstraint
_getdelvelocity_U_1	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getdelvelocity_U_1(SR_REAL * sjari)$/;"	f	class:JointConstraint
_getdelvelocity_U_2	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_getdelvelocity_U_2(SR_REAL * sjari)$/;"	f	class:JointConstraint
_getrelvelocity_BothMove	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_getrelvelocity_BothMove(SR_REAL * sjari)$/;"	f	class:ContactConstraint
_getrelvelocity_LeftMove	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_getrelvelocity_LeftMove(SR_REAL * sjari)$/;"	f	class:ContactConstraint
_getrelvelocity_RightMove	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_getrelvelocity_RightMove(SR_REAL * sjari)$/;"	f	class:ContactConstraint
_hi	srLib/srDyn/srConstraint.h	/^	SR_REAL * _hi;$/;"	m	struct:ConstraintInfo
_init2	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(Index nbRows, Index nbCols, typename internal::enable_if<Base::SizeAtCompileTime!=2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_init2	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _init2(const Scalar& val0, const Scalar& val1, typename internal::enable_if<Base::SizeAtCompileTime==2,T0>::type* = 0)$/;"	f	class:Eigen::PlainObjectBase
_inspect_B_RollPitch	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_B_RollPitch()$/;"	f	class:JointConstraint
_inspect_B_Yaw	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_B_Yaw()$/;"	f	class:JointConstraint
_inspect_P_PositionLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_P_PositionLimit()$/;"	f	class:JointConstraint
_inspect_P_TorqueLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_P_TorqueLimit()$/;"	f	class:JointConstraint
_inspect_R_PositionLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_R_PositionLimit()$/;"	f	class:JointConstraint
_inspect_R_TorqueLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_R_TorqueLimit()$/;"	f	class:JointConstraint
_inspect_U1_PositionLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_U1_PositionLimit()$/;"	f	class:JointConstraint
_inspect_U1_TorqueLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_U1_TorqueLimit()$/;"	f	class:JointConstraint
_inspect_U2_PositionLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_U2_PositionLimit()$/;"	f	class:JointConstraint
_inspect_U2_TorqueLimit	srLib/srDyn/srJointConstraint.cpp	/^bool JointConstraint::_inspect_U2_TorqueLimit()$/;"	f	class:JointConstraint
_isCData	tinyxml2/tinyxml2.h	/^    bool _isCData;$/;"	m	class:tinyxml2::XMLText
_knots	srMath/Interpolation.h	/^		Eigen::Matrix<Real, ((OrderK == -1) || (CoefficientN == -1) ? -1 : CoefficientN + OrderK), 1> _knots;$/;"	m	class:srMath::BSpline
_lambda	srLib/srDyn/srConstraint.h	/^	SR_REAL * _lambda;$/;"	m	struct:ConstraintInfo
_lastChild	tinyxml2/tinyxml2.h	/^    XMLNode*		_lastChild;$/;"	m	class:tinyxml2::XMLNode
_linkStateMap	srLib/srExt/srExtension.cpp	/^std::unordered_map<srLink*, linkState>	srExt::_linkStateMap;$/;"	m	class:srExt	file:
_lo	srLib/srDyn/srConstraint.h	/^	SR_REAL * _lo;$/;"	m	struct:ConstraintInfo
_m	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_m[6];$/;"	m	class:dse3
_maxAllocs	tinyxml2/tinyxml2.h	/^    int _maxAllocs;$/;"	m	class:tinyxml2::MemPoolT
_mem	tinyxml2/tinyxml2.h	/^    T*  _mem;$/;"	m	class:tinyxml2::DynArray
_memPool	tinyxml2/tinyxml2.h	/^    MemPool*		_memPool;$/;"	m	class:tinyxml2::XMLNode
_memPool	tinyxml2/tinyxml2.h	/^    MemPool*        _memPool;$/;"	m	class:tinyxml2::XMLAttribute
_nAllocs	tinyxml2/tinyxml2.h	/^    int _nAllocs;$/;"	m	class:tinyxml2::MemPoolT
_nUntracked	tinyxml2/tinyxml2.h	/^    int _nUntracked;$/;"	m	class:tinyxml2::MemPoolT
_name	tinyxml2/tinyxml2.h	/^    mutable StrPair _name;$/;"	m	class:tinyxml2::XMLAttribute
_next	tinyxml2/tinyxml2.h	/^    XMLAttribute*   _next;$/;"	m	class:tinyxml2::XMLAttribute
_next	tinyxml2/tinyxml2.h	/^    XMLNode*		_next;$/;"	m	class:tinyxml2::XMLNode
_node	tinyxml2/tinyxml2.h	/^    XMLNode* _node;$/;"	m	class:tinyxml2::XMLHandle
_node	tinyxml2/tinyxml2.h	/^    const XMLNode* _node;$/;"	m	class:tinyxml2::XMLConstHandle
_node_mutex	srLib/SceneGraph/node.h	/^	std::shared_mutex		_node_mutex;$/;"	m	class:Node
_p	srMath/SE3.h	/^		Vector3 _p;$/;"	m	class:srMath::SE3
_parent	tinyxml2/tinyxml2.h	/^    XMLNode*		_parent;$/;"	m	class:tinyxml2::XMLNode
_parseCurLineNum	tinyxml2/tinyxml2.h	/^    int				_parseCurLineNum;$/;"	m	class:tinyxml2::XMLDocument
_parseLineNum	tinyxml2/tinyxml2.h	/^    int             _parseLineNum;$/;"	m	class:tinyxml2::XMLAttribute
_parseLineNum	tinyxml2/tinyxml2.h	/^    int             _parseLineNum;$/;"	m	class:tinyxml2::XMLNode
_pixel	srLib/SceneGraph/Bitmap.cpp	/^BYTE& _Bitmap::_pixel(int x,int y,int c)$/;"	f	class:_Bitmap
_pixel	srLib/srg/srgBitmap.cpp	/^BYTE& _Bitmap::_pixel(int x,int y,int c)$/;"	f	class:_Bitmap
_pool	tinyxml2/tinyxml2.h	/^    T   _pool[INITIAL_SIZE];$/;"	m	class:tinyxml2::DynArray
_prev	tinyxml2/tinyxml2.h	/^    XMLNode*		_prev;$/;"	m	class:tinyxml2::XMLNode
_processEntities	tinyxml2/tinyxml2.h	/^    bool			_processEntities;$/;"	m	class:tinyxml2::XMLDocument
_processEntities	tinyxml2/tinyxml2.h	/^    bool _processEntities;$/;"	m	class:tinyxml2::XMLPrinter
_resize_to_match	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _resize_to_match(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_restrictedEntityFlag	tinyxml2/tinyxml2.h	/^    bool _restrictedEntityFlag[ENTITY_RANGE];$/;"	m	class:tinyxml2::XMLPrinter
_rhs	srLib/srDyn/srConstraint.h	/^	SR_REAL * _rhs;$/;"	m	struct:ConstraintInfo
_root	tinyxml2/tinyxml2.h	/^    Item* _root;$/;"	m	class:tinyxml2::MemPoolT
_rootAttribute	tinyxml2/tinyxml2.h	/^    XMLAttribute* _rootAttribute;$/;"	m	class:tinyxml2::XMLElement
_sRGBA	srLib/srg/srgColor.h	/^	typedef struct _sRGBA { float R; float G; float B; float A; } SRGBA;$/;"	s	class:srgColor
_set	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set_noalias	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& _set_noalias(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
_set_selector	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::false_type&) { _set_noalias(other); }$/;"	f	class:Eigen::PlainObjectBase
_set_selector	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void _set_selector(const OtherDerived& other, const internal::true_type&) { _set_noalias(other.eval()); }$/;"	f	class:Eigen::PlainObjectBase
_setimpulse_B_RP	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_setimpulse_B_RP(SR_REAL * \/* _lambda *\/)$/;"	f	class:JointConstraint
_setimpulse_B_Y	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_setimpulse_B_Y(SR_REAL * \/* _lambda *\/)$/;"	f	class:JointConstraint
_setimpulse_P	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_setimpulse_P(SR_REAL * _lambda)$/;"	f	class:JointConstraint
_setimpulse_R	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_setimpulse_R(SR_REAL * _lambda)$/;"	f	class:JointConstraint
_setimpulse_U_1	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_setimpulse_U_1(SR_REAL * _lambda)$/;"	f	class:JointConstraint
_setimpulse_U_2	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_setimpulse_U_2(SR_REAL * _lambda)$/;"	f	class:JointConstraint
_size	tinyxml2/tinyxml2.h	/^    int _size;			\/\/ number objects in use$/;"	m	class:tinyxml2::DynArray
_solve	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void _solve(const SparseMatrix<RhsScalar,RhsOptions,RhsIndex> &b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::CholmodBase
_solve	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::DiagonalPreconditioner
_solve	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solve	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    void _solve(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::IncompleteLUT
_solve	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^bool PastixBase<Base>::_solve (const MatrixBase<Rhs> &b, MatrixBase<Dest> &x) const$/;"	f	class:Eigen::PastixBase
_solve	Eigen/src/PardisoSupport/PardisoSupport.h	/^bool PardisoImpl<Base>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived>& x) const$/;"	f	class:Eigen::PardisoImpl
_solve	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SPQR
_solve	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholesky
_solve	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void _solve(const MatrixBase<Rhs> &b, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SimplicialCholeskyBase
_solve	Eigen/src/SparseLU/SparseLU.h	/^    bool _solve(const MatrixBase<Rhs> &B, MatrixBase<Dest> &X_base) const$/;"	f	class:Eigen::SparseLU
_solve	Eigen/src/SparseQR/SparseQR.h	/^    bool _solve(const MatrixBase<Rhs> &B, MatrixBase<Dest> &dest) const$/;"	f	class:Eigen::SparseQR
_solve	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperILU
_solve	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::_solve(const MatrixBase<Rhs> &b, MatrixBase<Dest>& x) const$/;"	f	class:Eigen::SuperLU
_solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^bool UmfPackLU<MatrixType>::_solve(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const$/;"	f	class:Eigen::UmfPackLU
_solveWithGuess	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::BiCGSTAB
_solveWithGuess	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  void _solveWithGuess(const Rhs& b, Dest& x) const$/;"	f	class:Eigen::ConjugateGradient
_solve_sparse	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void _solve_sparse(const Rhs& b, SparseMatrix<DestScalar,DestOptions,DestIndex> &dest) const$/;"	f	class:Eigen::IterativeSolverBase
_stack	tinyxml2/tinyxml2.h	/^    DynArray< const char*, 10 > _stack;$/;"	m	class:tinyxml2::XMLPrinter
_start	tinyxml2/tinyxml2.h	/^    char*   _start;$/;"	m	class:tinyxml2::StrPair
_state	srLib/srDyn/srState.h	/^	struct _state {$/;"	s	class:srUniversalState
_strlwr	srLib/SceneGraph/Texture3DS.cpp	/^	char* _strlwr(char* string)$/;"	f
_swap	Eigen/src/Core/PlainObjectBase.h	/^    void _swap(DenseBase<OtherDerived> const & other)$/;"	f	class:Eigen::PlainObjectBase
_t	srMath/LinearIntegrator.h	/^		VectorX		_t;$/;"	m	class:srMath::LinearIntegrator
_t0	srMath/LinearIntegrator.h	/^		Real		_t0, _tf;$/;"	m	class:srMath::LinearIntegrator
_textDepth	tinyxml2/tinyxml2.h	/^    int _textDepth;$/;"	m	class:tinyxml2::XMLPrinter
_textPool	tinyxml2/tinyxml2.h	/^    MemPoolT< sizeof(XMLText) >		 _textPool;$/;"	m	class:tinyxml2::XMLDocument
_tf	srMath/LinearIntegrator.h	/^		Real		_t0, _tf;$/;"	m	class:srMath::LinearIntegrator
_transformVector	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::_transformVector(const Vector3& v) const$/;"	f	class:Eigen::QuaternionBase
_transformVector	Eigen/src/Geometry/RotationBase.h	/^    inline VectorType _transformVector(const OtherVectorType& v) const$/;"	f	class:Eigen::RotationBase
_unexcite_B_RP	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_unexcite_B_RP()$/;"	f	class:JointConstraint
_unexcite_B_Y	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_unexcite_B_Y()$/;"	f	class:JointConstraint
_unexcite_BothSystem	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_unexcite_BothSystem()$/;"	f	class:ContactConstraint
_unexcite_LeftSystem	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_unexcite_LeftSystem()$/;"	f	class:ContactConstraint
_unexcite_P	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_unexcite_P()$/;"	f	class:JointConstraint
_unexcite_R	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_unexcite_R()$/;"	f	class:JointConstraint
_unexcite_RightSystem	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_unexcite_RightSystem()$/;"	f	class:ContactConstraint
_unexcite_U_1	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_unexcite_U_1()$/;"	f	class:JointConstraint
_unexcite_U_2	srLib/srDyn/srJointConstraint.cpp	/^void JointConstraint::_unexcite_U_2()$/;"	f	class:JointConstraint
_unite_do_nothing	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_unite_do_nothing()$/;"	f	class:ContactConstraint
_unite_do_something	srLib/srDyn/srContactConstraint.cpp	/^void ContactConstraint::_unite_do_something()$/;"	f	class:ContactConstraint
_updateScene	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::_updateScene()$/;"	f	class:SceneGraphRenderer
_updateframe_DoNothing	srLib/srDyn/srJoint.cpp	/^void srJoint::_updateframe_DoNothing()$/;"	f	class:srJoint
_updateframe_Primary	srLib/srDyn/srJoint.cpp	/^void srJoint::_updateframe_Primary()$/;"	f	class:srJoint
_updateframe_Secondary	srLib/srDyn/srJoint.cpp	/^void srJoint::_updateframe_Secondary()$/;"	f	class:srJoint
_userData	tinyxml2/tinyxml2.h	/^	void*			_userData;$/;"	m	class:tinyxml2::XMLNode
_v	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_v[2];$/;"	m	class:Vec2
_v	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_v[3];$/;"	m	class:Axis
_v	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_v[3];$/;"	m	class:Vec3
_value	tinyxml2/tinyxml2.h	/^    mutable StrPair	_value;$/;"	m	class:tinyxml2::XMLNode
_value	tinyxml2/tinyxml2.h	/^    mutable StrPair _value;$/;"	m	class:tinyxml2::XMLAttribute
_w	srLib/LieGroup/LieGroup.h	/^	SR_REAL			_w[6];$/;"	m	class:se3
_w	srMath/Function.h	/^		Real _w;$/;"	m	class:srMath::MultiplyConstFunction
_w	srMath/LinearIntegrator.h	/^		VectorX		_w;$/;"	m	class:srMath::LinearIntegrator
_whitespace	tinyxml2/tinyxml2.h	/^    Whitespace		_whitespace;$/;"	m	class:tinyxml2::XMLDocument
_writeBOM	tinyxml2/tinyxml2.h	/^    bool			_writeBOM;$/;"	m	class:tinyxml2::XMLDocument
_x	srMath/GaussianQuadrature.h	/^		VectorX		_x;$/;"	m	class:srMath::GaussianQuadrature
a	Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	m	struct:Eigen::internal::has_none
a	Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	m	struct:Eigen::internal::has_std_result_type
a	Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	m	struct:Eigen::internal::has_tr1_result
a	Eigen/src/SVD/JacobiSVD.h	/^  enum { a = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon418
a	srLib/SceneGraph/Leaf.h	/^	double	a;$/;"	m	class:Ellipsoid
a	srLib/SceneGraph/Model3DS.h	/^		unsigned char a;$/;"	m	struct:Model3DS::Color4i
abs	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs() const$/;"	f	class:Eigen::Cwise
abs	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs() const$/;"	f
abs2	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(abs2, Scalar) abs2(const Scalar& x)$/;"	f	namespace:Eigen::numext
abs2	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::abs2() const$/;"	f	class:Eigen::Cwise
abs2	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^abs2() const$/;"	f
abs2_impl	Eigen/src/Core/MathFunctions.h	/^struct abs2_impl$/;"	s	namespace:Eigen::internal
abs2_impl_default	Eigen/src/Core/MathFunctions.h	/^struct abs2_impl_default$/;"	s	namespace:Eigen::internal
abs2_impl_default	Eigen/src/Core/MathFunctions.h	/^struct abs2_impl_default<Scalar, true> \/\/ IsComplex$/;"	s	namespace:Eigen::internal
abs2_retval	Eigen/src/Core/MathFunctions.h	/^struct abs2_retval$/;"	s	namespace:Eigen::internal
absDeterminant	Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
absDeterminant	Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
absDeterminant	Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::absDeterminant() const$/;"	f	class:Eigen::HouseholderQR
absDeterminant	Eigen/src/SparseLU/SparseLU.h	/^     Scalar absDeterminant()$/;"	f	class:Eigen::SparseLU
absDiagIndex	Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index absDiagIndex() const { return m_index.value()>0 ? m_index.value() : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
absDistance	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { return ei_abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane
absDistance	Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar absDistance(const VectorType& p) const { using std::abs; return abs(signedDistance(p)); }$/;"	f	class:Eigen::Hyperplane
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const AccPacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const DoublePacket& c, const ResPacket& alpha, ResPacket& r) const$/;"	f	class:Eigen::internal::gebp_traits
acc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void acc(const Scalar& c, const Scalar& alpha, Scalar& r) const { r += alpha * c; }$/;"	f	class:Eigen::internal::gebp_traits
accessors_level	Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct accessors_level$/;"	s	namespace:Eigen::internal
acos	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^acos() const$/;"	f
actuationtype	srLib/srDyn/srJointConstraint.h	/^	srJoint::ACTTYPE		actuationtype;$/;"	m	class:JointConstraint
ad	srMath/SE3.cpp	/^	Matrix6 SE3::ad(const se3& S)$/;"	f	class:srMath::SE3
ad	srMath/SE3.cpp	/^	se3 SE3::ad(const se3& S1, const se3& S2)$/;"	f	class:srMath::SE3
adMat	srLib/srExt/srExt_LieGroup.cpp	/^Eigen::Matrix6d srExt::adMat(const se3 & _s)$/;"	f	class:srExt
adTranspose	srMath/SE3.cpp	/^	Matrix6 SE3::adTranspose(const se3& S)$/;"	f	class:srMath::SE3
adTranspose	srMath/SE3.cpp	/^	se3 SE3::adTranspose(const se3& S1, const se3& S2)$/;"	f	class:srMath::SE3
add	Eigen/src/Core/GeneralProduct.h	/^    struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	s	class:Eigen::GeneralProduct
addEdgePoint	srLib/SceneGraph/Leaf.cpp	/^void varianceStrap::addEdgePoint(const vector<Vec3>& edgePoint)$/;"	f	class:varianceStrap
addFunction	srMath/Function.cpp	/^	void AugmentedFunction::addFunction(const FunctionPtr& function)$/;"	f	class:srMath::AugmentedFunction
addJointValue	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::addJointValue(srLink * const _endEffector, const Eigen::VectorXd & _dq)$/;"	f	class:srExt::srExtSystem
addJointValue	srLib/srExt/srExtension.cpp	/^void srExt::addJointValue(srLink * const _endEffector, const VectorXd & _dq)$/;"	f	class:srExt
addLines	srLib/SceneGraph/srSpaceRenderer.h	/^	void addLines(const std::vector<Vec3>& pos, float r = 0.0, float g = 1.0, float b = 1.0, float alpha = 1.0)$/;"	f	class:srSpaceRenderer
addNode	srLib/SceneGraph/Node.cpp	/^void Node::addNode( Node* node )$/;"	f	class:Node
addNode	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::addNode(Node* node, bool bFirstRender)$/;"	f	class:SceneGraphRenderer
addPoint	srLib/SceneGraph/Leaf.cpp	/^void Lines::addPoint(Vec3 point)$/;"	f	class:Lines
addPoint	srLib/SceneGraph/Leaf.cpp	/^void Polygon::addPoint(const Vec3& point)$/;"	f	class:Polygon
addPoint	srLib/SceneGraph/Leaf.cpp	/^void Strip::addPoint(Vec3 lPoint, Vec3 rPoint)$/;"	f	class:Strip
addPoint	srLib/SceneGraph/srSpaceRenderer.h	/^	void addPoint(const Vec3& pos, double size = 1.0, double r = 1.0, double g = 0.0, double b = 0.0)$/;"	f	class:srSpaceRenderer
addTo	Eigen/src/Core/DiagonalMatrix.h	/^    inline void addTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase
addTo	Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void addTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
addTo	Eigen/src/Core/GeneralProduct.h	/^    inline void addTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct
addTo	Eigen/src/Core/ProductBase.h	/^    inline void addTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:ScaledProduct
add_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	s	namespace:Eigen::internal
add_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	s	namespace:Eigen::internal
add_const_on_value_type_if_arithmetic	Eigen/src/Core/DenseCoeffsBase.h	/^template<typename T> struct add_const_on_value_type_if_arithmetic$/;"	s	namespace:Eigen::internal
add_head	srLib/LieGroup/_array.h	/^	void add_head(const TYPE &value)$/;"	f	class:_array
add_tail	srLib/LieGroup/_array.h	/^	void add_tail(const TYPE &value)$/;"	f	class:_array
add_tail	srLib/LieGroup/_array.h	/^	void add_tail(const _array<TYPE> &ary)$/;"	f	class:_array
adds	Eigen/src/Core/GeneralProduct.h	/^      adds(const Scalar& s) : m_scale(s) {}$/;"	f	struct:Eigen::GeneralProduct::adds
adds	Eigen/src/Core/GeneralProduct.h	/^    struct adds {$/;"	s	class:Eigen::GeneralProduct
adjoint	Eigen/src/Core/Transpose.h	/^MatrixBase<Derived>::adjoint() const$/;"	f	class:Eigen::MatrixBase
adjoint	Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<const typename MatrixType::AdjointReturnType,TransposeMode> adjoint() const$/;"	f	class:Eigen::TriangularView
adjoint	Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType adjoint() const$/;"	f	class:Eigen::HouseholderSequence
adjoint	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation adjoint() const { using numext::conj; return JacobiRotation(conj(m_c), -m_s); }$/;"	f	class:Eigen::JacobiRotation
adjoint	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> adjoint() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType
adjoint	Eigen/src/SparseCore/SparseMatrixBase.h	/^    const AdjointReturnType adjoint() const { return transpose(); }$/;"	f	class:Eigen::SparseMatrixBase
adjoint	Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> adjoint() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
adjointInPlace	Eigen/src/Core/Transpose.h	/^inline void MatrixBase<Derived>::adjointInPlace()$/;"	f	class:Eigen::MatrixBase
adjust2Limit	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::adjust2Limit(srJoint * const _joint)$/;"	f	class:srExt::srExtSystem
adjust2Limit	srLib/srExt/srExtension.cpp	/^void srExt::adjust2Limit(srJoint * const _joint)$/;"	f	class:srExt
affine	Eigen/src/Geometry/Transform.h	/^  inline AffinePart affine() { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
affine	Eigen/src/Geometry/Transform.h	/^  inline ConstAffinePart affine() const { return take_affine_part::run(m_matrix); }$/;"	f	class:Eigen::Transform
aligned_allocator	Eigen/src/Core/util/Memory.h	/^  aligned_allocator() : std::allocator<T>() {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	Eigen/src/Core/util/Memory.h	/^  aligned_allocator(const aligned_allocator& other) : std::allocator<T>(other) {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	Eigen/src/Core/util/Memory.h	/^  aligned_allocator(const aligned_allocator<U>& other) : std::allocator<T>(other) {}$/;"	f	class:Eigen::aligned_allocator
aligned_allocator	Eigen/src/Core/util/Memory.h	/^class aligned_allocator : public std::allocator<T>$/;"	c	namespace:Eigen
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<T>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const EIGEN_ALIGNED_ALLOCATOR<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection& ) : EIGEN_ALIGNED_ALLOCATOR<T>() {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    aligned_allocator_indirection(const aligned_allocator_indirection<U>& ) {}$/;"	f	class:Eigen::aligned_allocator_indirection
aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^  class aligned_allocator_indirection : public EIGEN_ALIGNED_ALLOCATOR<T>$/;"	c	namespace:Eigen
aligned_delete	Eigen/src/Core/util/Memory.h	/^template<typename T> inline void aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
aligned_free	Eigen/src/Core/util/Memory.h	/^inline void aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
aligned_malloc	Eigen/src/Core/util/Memory.h	/^inline void* aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal
aligned_new	Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* aligned_new(size_t size)$/;"	f	namespace:Eigen::internal
aligned_realloc	Eigen/src/Core/util/Memory.h	/^inline void* aligned_realloc(void *ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
aligned_stack_memory_handler	Eigen/src/Core/util/Memory.h	/^    aligned_stack_memory_handler(T* ptr, size_t size, bool dealloc)$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
aligned_stack_memory_handler	Eigen/src/Core/util/Memory.h	/^template<typename T> class aligned_stack_memory_handler$/;"	c	namespace:Eigen::internal
alignment	Eigen/src/Core/Redux.h	/^    alignment = (Derived::Flags & AlignedBit) ? Aligned : Unaligned$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon335
alignment	srLib/SceneGraph/gl2ps.c	/^  GLint alignment;$/;"	m	struct:__anon9	file:
all	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::all() const$/;"	f	class:Eigen::DenseBase
all	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_all>::Type all() const$/;"	f	class:Eigen::VectorwiseOp
allFinite	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::allFinite() const$/;"	f	class:Eigen::DenseBase
all_unroller	Eigen/src/Core/BooleanRedux.h	/^struct all_unroller$/;"	s	namespace:Eigen::internal
all_unroller	Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
all_unroller	Eigen/src/Core/BooleanRedux.h	/^struct all_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
allocate	Eigen/src/Core/util/Memory.h	/^  pointer allocate(size_type num, const void* \/*hint*\/ = 0)$/;"	f	class:Eigen::aligned_allocator
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^  void allocate(const JacobiSVD<MatrixType, QRPreconditioner>&) {}$/;"	f	class:Eigen::internal::qr_preconditioner_impl
allocate	Eigen/src/SVD/JacobiSVD.h	/^void JacobiSVD<MatrixType, QRPreconditioner>::allocate(Index rows, Index cols, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
allocateA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateA() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateA()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateAll() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateAll	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateAll()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateB() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateB()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline void allocateW() {}$/;"	f	class:Eigen::internal::gemm_blocking_space
allocateW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    void allocateW()$/;"	f	class:Eigen::internal::gemm_blocking_space
allocatedSize	Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t allocatedSize() const { return m_allocatedSize; }$/;"	f	class:Eigen::internal::CompressedStorage
allowederror	srLib/srDyn/srClosedLoopConstraint.cpp	/^SR_REAL ClosedLoop::allowederror = 0.01;$/;"	m	class:ClosedLoop	file:
allowederror	srLib/srDyn/srClosedLoopConstraint.h	/^	static SR_REAL allowederror;$/;"	m	class:ClosedLoop
allowedjointerror	srLib/srDyn/srJointConstraint.cpp	/^SR_REAL JointConstraint::allowedjointerror = 0.0001;$/;"	m	class:JointConstraint	file:
allowedjointerror	srLib/srDyn/srJointConstraint.h	/^	static SR_REAL allowedjointerror;$/;"	m	class:JointConstraint
allowedpenetration	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL ContactConstraint::allowedpenetration = 0.01;$/;"	m	class:ContactConstraint	file:
allowedpenetration	srLib/srDyn/srContactConstraint.h	/^	static SR_REAL allowedpenetration;$/;"	m	class:ContactConstraint
alpha	Eigen/src/Core/ProductBase.h	/^    const Scalar& alpha() const { return m_alpha; }$/;"	f	class:ScaledProduct
alpha	srLib/SceneGraph/Leaf.h	/^	double				r, g, b, alpha;$/;"	m	class:Polygon
alphas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType alphas() const$/;"	f	class:Eigen::GeneralizedEigenSolver
always_void	Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	s	namespace:Eigen::internal
ambient	srLib/SceneGraph/Light.h	/^	float			ambient[4];$/;"	m	class:Light
ambient	srLib/SceneGraph/Shader.h	/^	float			ambient[4];$/;"	m	class:Shader
amd_flip	Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_flip(const T& i) { return -i-2; }$/;"	f	namespace:Eigen::internal
amd_mark	Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline void amd_mark(const T0* w, const T1& j) { return w[j] = amd_flip(w[j]); }$/;"	f	namespace:Eigen::internal
amd_marked	Eigen/src/OrderingMethods/Amd.h	/^template<typename T0, typename T1> inline bool amd_marked(const T0* w, const T1& j) { return w[j]<0; }$/;"	f	namespace:Eigen::internal
amd_unflip	Eigen/src/OrderingMethods/Amd.h	/^template<typename T> inline T amd_unflip(const T& i) { return i<0 ? amd_flip(i) : i; }$/;"	f	namespace:Eigen::internal
analyzePattern	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
analyzePattern	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& analyzePattern(const MatType& )$/;"	f	class:Eigen::DiagonalPreconditioner
analyzePattern	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& analyzePattern(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
analyzePattern	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::analyzePattern(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
analyzePattern	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& analyzePattern(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
analyzePattern	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::analyzePattern(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
analyzePattern	Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
analyzePattern	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void analyzePattern(const MatrixType& a, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
analyzePattern	Eigen/src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseLU
analyzePattern	Eigen/src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::analyzePattern(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
analyzePattern	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& \/*matrix*\/)$/;"	f	class:Eigen::SuperLUBase
analyzePattern	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperILU
analyzePattern	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void analyzePattern(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLU
analyzePattern	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
analyzePattern_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void analyzePattern_impl()$/;"	f	class:Eigen::UmfPackLU
analyzePattern_preordered	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::analyzePattern_preordered(const CholMatrixType& ap, bool doLDLT)$/;"	f	class:Eigen::SimplicialCholeskyBase
ang_vel	Example/DracoP1/Draco_Dyn_environment.h	/^    std::vector<double> ang_vel;$/;"	m	struct:state
ang_vel_	Example/DracoP1/Draco_Dyn_environment.h	/^        std::vector<double> ang_vel_  ;$/;"	m	class:Draco_Dyn_environment
angle	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	Eigen/src/Geometry/AngleAxis.h	/^  Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	Eigen/src/Geometry/AngleAxis.h	/^  Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::AngleAxis
angle	Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar angle() const { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	Eigen/src/Geometry/Rotation2D.h	/^  inline Scalar& angle() { return m_angle; }$/;"	f	class:Eigen::Rotation2D
angle	srLib/SceneGraph/gl2ps.c	/^  GLfloat angle;$/;"	m	struct:__anon9	file:
angularDistance	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Scalar Quaternion<Scalar>::angularDistance(const Quaternion& other) const$/;"	f	class:Eigen::Quaternion
angularDistance	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::angularDistance(const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
any	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::any() const$/;"	f	class:Eigen::DenseBase
any	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_any>::Type any() const$/;"	f	class:Eigen::VectorwiseOp
any_unroller	Eigen/src/Core/BooleanRedux.h	/^struct any_unroller$/;"	s	namespace:Eigen::internal
any_unroller	Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, 0>$/;"	s	namespace:Eigen::internal
any_unroller	Eigen/src/Core/BooleanRedux.h	/^struct any_unroller<Derived, Dynamic>$/;"	s	namespace:Eigen::internal
append	Eigen/src/SparseCore/CompressedStorage.h	/^    void append(const Scalar& v, Index i)$/;"	f	class:Eigen::internal::CompressedStorage
applyHouseholderOnTheLeft	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheLeft($/;"	f	class:Eigen::MatrixBase
applyHouseholderOnTheRight	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::applyHouseholderOnTheRight($/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	Eigen/src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheLeft	Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheLeft(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	Eigen/src/Core/MatrixBase.h	/^inline void MatrixBase<Derived>::applyOnTheRight(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
applyOnTheRight	Eigen/src/Jacobi/Jacobi.h	/^inline void MatrixBase<Derived>::applyOnTheRight(Index p, Index q, const JacobiRotation<OtherScalar>& j)$/;"	f	class:Eigen::MatrixBase
applyThisOnTheLeft	Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheLeft	Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheLeft(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheLeft	Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheLeft(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
applyThisOnTheRight	Eigen/src/Householder/HouseholderSequence.h	/^    inline void applyThisOnTheRight(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
applyThisOnTheRight	Eigen/src/Householder/HouseholderSequence.h	/^    template<typename Dest> inline void applyThisOnTheRight(Dest& dst) const$/;"	f	class:Eigen::HouseholderSequence
applyTranspositionOnTheLeft	Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheLeft(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
applyTranspositionOnTheRight	Eigen/src/Core/PermutationMatrix.h	/^    Derived& applyTranspositionOnTheRight(Index i, Index j)$/;"	f	class:Eigen::PermutationBase
apply_block_householder_on_the_left	Eigen/src/Householder/BlockHouseholder.h	/^void apply_block_householder_on_the_left(MatrixType& mat, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal
apply_rotation_in_the_plane	Eigen/src/Jacobi/Jacobi.h	/^void \/*EIGEN_DONT_INLINE*\/ apply_rotation_in_the_plane(VectorX& _x, VectorY& _y, const JacobiRotation<OtherScalar>& j)$/;"	f	namespace:Eigen::internal
array	Eigen/src/Core/ArrayBase.h	/^    ArrayBase<Derived>& array() { return *this; }$/;"	f	class:Eigen::ArrayBase
array	Eigen/src/Core/ArrayBase.h	/^    const ArrayBase<Derived>& array() const { return *this; }$/;"	f	class:Eigen::ArrayBase
array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[1];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  EIGEN_USER_ALIGN16 T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/DenseStorage.h	/^  T array[Size];$/;"	m	struct:Eigen::internal::plain_array
array	Eigen/src/Core/MatrixBase.h	/^    ArrayWrapper<Derived> array() { return derived(); }$/;"	f	class:Eigen::MatrixBase
array	Eigen/src/Core/MatrixBase.h	/^    const ArrayWrapper<const Derived> array() const { return derived(); }$/;"	f	class:Eigen::MatrixBase
array	srLib/SceneGraph/gl2ps.c	/^  char *array;$/;"	m	struct:__anon6	file:
arrayPoints	srLib/SceneGraph/Leaf.h	/^	list<PTY>    arrayPoints;$/;"	m	class:Strip
arrayPoints	srLib/SceneGraph/Leaf.h	/^	list<PTY>   arrayPoints;$/;"	m	class:Lines
arrow	srLib/SceneGraph/Leaf.h	/^	Vec3    arrow;$/;"	m	class:Arrow
arrowSize	srLib/SceneGraph/Leaf.h	/^	GLdouble	arrowSize;$/;"	m	class:Coordinate
asDiagonal	Eigen/src/Core/DiagonalMatrix.h	/^MatrixBase<Derived>::asDiagonal() const$/;"	f	class:Eigen::MatrixBase
asPermutation	Eigen/src/Core/PermutationMatrix.h	/^const PermutationWrapper<const Derived> MatrixBase<Derived>::asPermutation() const$/;"	f	class:Eigen::MatrixBase
asSluMatrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^SluMatrix asSluMatrix(MatrixType& mat)$/;"	f	namespace:Eigen::internal
asin	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^asin() const$/;"	f
assign	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& assign(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase
assignGeneric	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline void assignGeneric(const OtherDerived& other)$/;"	f	class:Eigen::SparseMatrixBase
assignProduct	Eigen/src/Core/PermutationMatrix.h	/^    void assignProduct(const Lhs& lhs, const Rhs& rhs)$/;"	f	class:Eigen::PermutationBase
assignProduct	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& assignProduct(const TriangularProduct<Mode, LhsIsTriangular, Lhs, LhsIsVector, Rhs, RhsIsVector>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView
assignProduct	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^TriangularView<MatrixType,UpLo>& TriangularView<MatrixType,UpLo>::assignProduct(const ProductBase<ProductDerived, _Lhs,_Rhs>& prod, const Scalar& alpha)$/;"	f	class:Eigen::TriangularView
assignTranspose	Eigen/src/Core/PermutationMatrix.h	/^    void assignTranspose(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
assign_DefaultTraversal_CompleteUnrolling	Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_CompleteUnrolling	Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_DefaultTraversal_InnerUnrolling	Eigen/src/Core/Assign.h	/^struct assign_DefaultTraversal_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_LinearTraversal_CompleteUnrolling	Eigen/src/Core/Assign.h	/^struct assign_LinearTraversal_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	Eigen/src/Core/util/MKL_support.h	/^inline void assign_conj_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_conj_scalar_eig2mkl	Eigen/src/Core/util/MKL_support.h	/^static inline void assign_conj_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, DefaultTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, InnerUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InnerVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, InvalidTraversal, Unrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, CompleteUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, LinearVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_impl	Eigen/src/Core/Assign.h	/^struct assign_impl<Derived1, Derived2, SliceVectorizedTraversal, NoUnrolling, Version>$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_CompleteUnrolling	Eigen/src/Core/Assign.h	/^struct assign_innervec_CompleteUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling$/;"	s	namespace:Eigen::internal
assign_innervec_InnerUnrolling	Eigen/src/Core/Assign.h	/^struct assign_innervec_InnerUnrolling<Derived1, Derived2, Stop, Stop>$/;"	s	namespace:Eigen::internal
assign_scalar_eig2mkl	Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex16,dcomplex>(MKL_Complex16& mklScalar, const dcomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_scalar_eig2mkl	Eigen/src/Core/util/MKL_support.h	/^inline void assign_scalar_eig2mkl<MKL_Complex8,scomplex>(MKL_Complex8& mklScalar, const scomplex& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_scalar_eig2mkl	Eigen/src/Core/util/MKL_support.h	/^static inline void assign_scalar_eig2mkl(MKLType& mklScalar, const EigenType& eigenScalar) {$/;"	f	namespace:Eigen::internal
assign_selector	Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,false> {$/;"	s	namespace:Eigen::internal
assign_selector	Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,false,true> {$/;"	s	namespace:Eigen::internal
assign_selector	Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,false> {$/;"	s	namespace:Eigen::internal
assign_selector	Eigen/src/Core/Assign.h	/^struct assign_selector<Derived,OtherDerived,true,true> {$/;"	s	namespace:Eigen::internal
assign_traits	Eigen/src/Core/Assign.h	/^struct assign_traits$/;"	s	namespace:Eigen::internal
at	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar at(Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
atInRange	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar atInRange(size_t start, size_t end, Index key, const Scalar& defaultValue = Scalar(0)) const$/;"	f	class:Eigen::internal::CompressedStorage
atWithInsertion	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& atWithInsertion(Index key, const Scalar& defaultValue = Scalar(0))$/;"	f	class:Eigen::internal::CompressedStorage
atanh2	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(atanh2, Scalar) atanh2(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext
atanh2_default_impl	Eigen/src/Core/MathFunctions.h	/^struct atanh2_default_impl$/;"	s	namespace:Eigen::internal
atanh2_default_impl	Eigen/src/Core/MathFunctions.h	/^struct atanh2_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
atanh2_impl	Eigen/src/Core/MathFunctions.h	/^struct atanh2_impl : atanh2_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
atanh2_retval	Eigen/src/Core/MathFunctions.h	/^struct atanh2_retval$/;"	s	namespace:Eigen::internal
attribute	srLib/common/srSTL.h	/^		short attribute;$/;"	m	class:srSTL::facet
auxprimitives	srLib/SceneGraph/gl2ps.c	/^  GL2PSlist *primitives, *auxprimitives;$/;"	m	struct:__anon15	file:
avoidPosLimit	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::avoidPosLimit(srJoint * const _joint)$/;"	f	class:srExt::srExtSystem
avoidPosLimit	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::avoidPosLimit(srLink * const _endEffector, srLink * _baseLink)$/;"	f	class:srExt::srExtSystem
avoidPosLimit	srLib/srExt/srExtension.cpp	/^void srExt::avoidPosLimit(srJoint * const _joint)$/;"	f	class:srExt
avoidPosLimit	srLib/srExt/srExtension.cpp	/^void srExt::avoidPosLimit(srLink * const _endEffector, srLink * _baseLink)$/;"	f	class:srExt
axis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	Eigen/src/Geometry/AngleAxis.h	/^  Vector3& axis() { return m_axis; }$/;"	f	class:Eigen::AngleAxis
axis	Eigen/src/Geometry/AngleAxis.h	/^  const Vector3& axis() const { return m_axis; }$/;"	f	class:Eigen::AngleAxis
b	Eigen/src/SVD/JacobiSVD.h	/^         b = MatrixType::RowsAtCompileTime != Dynamic &&$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon418
b	srLib/SceneGraph/Leaf.h	/^	double				r, g, b, alpha;$/;"	m	class:Polygon
b	srLib/SceneGraph/Leaf.h	/^	double	b;$/;"	m	class:Ellipsoid
b	srLib/SceneGraph/Leaf.h	/^	double b;$/;"	m	class:ColorPoint
b	srLib/SceneGraph/Leaf.h	/^	double b;$/;"	m	class:ColorPointGroup
b	srLib/SceneGraph/Model3DS.h	/^		unsigned char b;$/;"	m	struct:Model3DS::Color4i
bActive	srLib/srDyn/srContactConstraint.h	/^	bool			bActive;$/;"	m	class:ContactConstraint
bActive	srLib/srDyn/srContactConstraint.h	/^	bool	bActive;$/;"	m	struct:Contact
bActive	srLib/srDyn/srJointConstraint.h	/^	bool	bActive;$/;"	m	class:JointConstraint
bBounce	srLib/srDyn/srContactConstraint.h	/^	bool			bBounce;$/;"	m	class:ContactConstraint
bCollidable	srLib/srDyn/srContactConstraint.h	/^	bool			bCollidable;$/;"	m	struct:MassPair
bDrawFocus	srLib/SceneGraph/Camera.h	/^	bool				bDrawFocus;$/;"	m	class:Camera
bFriction	srLib/srDyn/srContactConstraint.h	/^	bool			bFriction;$/;"	m	class:ContactConstraint
bOrtho	srLib/SceneGraph/Camera.h	/^    bool            bOrtho;$/;"	m	class:Camera
bOverlap	srLib/SceneGraph/SceneGraphRenderer.cpp	/^bool	SceneGraphRenderer::bOverlap = false;$/;"	m	class:SceneGraphRenderer	file:
bOverlap	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	bool	bOverlap;$/;"	m	class:SceneGraphRenderer
bRender	srLib/SceneGraph/SceneGraphRenderer.cpp	/^bool	SceneGraphRenderer::bRender = true;$/;"	m	class:SceneGraphRenderer	file:
bRender	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	bool	bRender;$/;"	m	class:SceneGraphRenderer
bScreenShot	srLib/SceneGraph/SceneGraphRenderer.cpp	/^bool	SceneGraphRenderer::bScreenShot = false;$/;"	m	class:SceneGraphRenderer	file:
bScreenShot	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	bool	bScreenShot;$/;"	m	class:SceneGraphRenderer
bUpper	srLib/SceneGraph/Leaf.h	/^	bool	bUpper;$/;"	m	class:HalfSphere
back	srLib/SceneGraph/gl2ps.c	/^  GL2PSbsptree *front, *back;$/;"	m	struct:_GL2PSbsptree	file:
back	srLib/SceneGraph/gl2ps.c	/^  GL2PSbsptree2d *front, *back;$/;"	m	struct:_GL2PSbsptree2d	file:
base	Eigen/src/Core/PlainObjectBase.h	/^    Base& base() { return *static_cast<Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	Eigen/src/Core/PlainObjectBase.h	/^    const Base& base() const { return *static_cast<const Base*>(this); }$/;"	f	class:Eigen::PlainObjectBase
base	srLib/LieGroup/_array.h	/^	TYPE	*base;$/;"	m	class:_array
beginViewport	srLib/SceneGraph/gl2ps.c	/^  void  (*beginViewport)(GLint viewport[4]);$/;"	m	struct:__anon16	file:
betas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType betas() const$/;"	f	class:Eigen::GeneralizedEigenSolver
bgcolor	srLib/SceneGraph/gl2ps.c	/^  GL2PSrgba *colormap, lastrgba, threshold, bgcolor;$/;"	m	struct:__anon15	file:
bicgstab	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^bool bicgstab(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
bidiagonal	Eigen/src/SVD/UpperBidiagonalization.h	/^    const BidiagonalType& bidiagonal() const { return m_bidiagonal; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
bin3ds	srLib/SceneGraph/Model3DS.h	/^	FILE	*bin3ds;			\/\/ The binary 3ds file$/;"	m	class:Model3DS
binaryExpr	Eigen/src/plugins/CommonCwiseBinaryOps.h	/^binaryExpr(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other, const CustomBinaryOp& func = CustomBinaryOp()) const$/;"	f
binary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	s	namespace:Eigen::internal
binary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_std_result_type)>$/;"	s	namespace:Eigen::internal
binary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select<Func, ArgType0, ArgType1, sizeof(has_tr1_result)>$/;"	s	namespace:Eigen::internal
bitmap_font_names	srLib/SceneGraph/Font.h	/^	void* bitmap_font_names[7];$/;"	m	class:srgString
bitmap_font_names	srLib/srg/srgFont.h	/^	void* bitmap_font_names[7];$/;"	m	class:srgString
bitmap_fonts	srLib/SceneGraph/Font.h	/^	void* bitmap_fonts[7];$/;"	m	class:srgString
bitmap_fonts	srLib/srg/srgFont.h	/^	void* bitmap_fonts[7];$/;"	m	class:srgString
blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^    blas_data_mapper(Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::blas_data_mapper
blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^class blas_data_mapper$/;"	c	namespace:Eigen::internal
blas_traits	Eigen/src/Core/Transpose.h	/^struct blas_traits<SelfCwiseBinaryOp<BinOp,Xpr,Rhs> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_conjugate_op<Scalar>, Xpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_multiple_op<Scalar>, Xpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<CwiseUnaryOp<scalar_opposite_op<Scalar>, Xpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<Transpose<Xpr> >$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^struct blas_traits<const T>$/;"	s	namespace:Eigen::internal
blas_traits	Eigen/src/Core/util/BlasUtil.h	/^template<typename XprType> struct blas_traits$/;"	s	namespace:Eigen::internal
blendfunc	srLib/SceneGraph/gl2ps.c	/^  GLint viewport[4], blendfunc[2], lastfactor;$/;"	m	struct:__anon15	file:
blending	srLib/SceneGraph/gl2ps.c	/^  GLboolean boundary, blending;$/;"	m	struct:__anon15	file:
block	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol)$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, BlockRows, BlockCols> block(Index startRow, Index startCol, $/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols)$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol) const$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, BlockRows, BlockCols> block(Index startRow, Index startCol,$/;"	f
block	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> block(Index startRow, Index startCol, Index blockRows, Index blockCols) const$/;"	f
blockA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline LhsScalar* blockA() { return m_blockA; }$/;"	f	class:Eigen::internal::level3_blocking
blockB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockB() { return m_blockB; }$/;"	f	class:Eigen::internal::level3_blocking
blockW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline RhsScalar* blockW() { return m_blockW; }$/;"	f	class:Eigen::internal::level3_blocking
blocked	Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index blocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
blocked	Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index blocked(MatrixType& m)$/;"	f	struct:Eigen::internal::llt_inplace
blocked_lu	Eigen/src/LU/PartialPivLU.h	/^  static Index blocked_lu(Index rows, Index cols, Scalar* lu_data, Index luStride, PivIndex* row_transpositions, PivIndex& nb_transpositions, Index maxBlockSize=256)$/;"	f	struct:Eigen::internal::partial_lu_impl
blueNorm	Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::MatrixBase
blueNorm	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_blueNorm,RealScalar>::Type blueNorm() const$/;"	f	class:Eigen::VectorwiseOp
blueNorm	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::blueNorm() const$/;"	f	class:Eigen::SparseMatrixBase
blueNorm_impl	Eigen/src/Core/StableNorm.h	/^blueNorm_impl(const EigenBase<Derived>& _vec)$/;"	f	namespace:Eigen::internal
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomLeftCorner()$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> bottomLeftCorner(Index cRows, Index cCols)$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomLeftCorner() const$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomLeftCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomRightCorner()$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> bottomRightCorner(Index cRows, Index cCols)$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomRightCorner() const$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> bottomRightCorner(Index cRows, Index cCols) const$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr bottomRows(Index n) const$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr bottomRows(Index n)$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type bottomRows(Index n = N) const$/;"	f
bottomRows	Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type bottomRows(Index n = N)$/;"	f
bouncing_threshold	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL ContactConstraint::bouncing_threshold = 0.2;$/;"	m	class:ContactConstraint	file:
bouncing_threshold	srLib/srDyn/srContactConstraint.h	/^	static SR_REAL bouncing_threshold;$/;"	m	class:ContactConstraint
bouncing_threshold	srLib/srDyn/srJointConstraint.cpp	/^SR_REAL JointConstraint::bouncing_threshold = 0.2;$/;"	m	class:JointConstraint	file:
bouncing_threshold	srLib/srDyn/srJointConstraint.h	/^	static SR_REAL bouncing_threshold;$/;"	m	class:JointConstraint
boundary	srLib/SceneGraph/gl2ps.c	/^  GLboolean boundary, blending;$/;"	m	struct:__anon15	file:
boundary	srLib/SceneGraph/gl2ps.c	/^  char boundary, offset, culled;$/;"	m	struct:__anon11	file:
bruteforce_det3_helper	Eigen/src/LU/Determinant.h	/^inline const typename Derived::Scalar bruteforce_det3_helper$/;"	f	namespace:Eigen::internal
bruteforce_det4_helper	Eigen/src/LU/Determinant.h	/^const typename Derived::Scalar bruteforce_det4_helper$/;"	f	namespace:Eigen::internal
buffersize	srLib/SceneGraph/gl2ps.c	/^  GLint format, sort, options, colorsize, colormode, buffersize;$/;"	m	struct:__anon15	file:
c	Eigen/src/Jacobi/Jacobi.h	/^    Scalar c() const { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	Eigen/src/Jacobi/Jacobi.h	/^    Scalar& c() { return m_c; }$/;"	f	class:Eigen::JacobiRotation
c	srLib/LieGroup/LieGroup.h	/^	SR_REAL c[4];$/;"	m	union:Quaternion
c	srLib/SceneGraph/Leaf.h	/^	double	c;$/;"	m	class:Ellipsoid
c_to_fortran_numbering	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void c_to_fortran_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
callfopen	tinyxml2/tinyxml2.cpp	/^static FILE* callfopen( const char* filepath, const char* mode )$/;"	f	namespace:tinyxml2
cast	Eigen/src/Core/MathFunctions.h	/^inline NewType cast(const OldType& x)$/;"	f	namespace:Eigen::internal
cast	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox
cast	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis
cast	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::Hyperplane
cast	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine
cast	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Quaternion,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Quaternion
cast	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D
cast	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline typename internal::cast_return_type<Scaling,Scaling<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Scaling
cast	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Transform
cast	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation
cast	Eigen/src/Geometry/AlignedBox.h	/^           AlignedBox<NewScalarType,AmbientDimAtCompileTime> >::type cast() const$/;"	f	class:Eigen::AlignedBox
cast	Eigen/src/Geometry/AngleAxis.h	/^  inline typename internal::cast_return_type<AngleAxis,AngleAxis<NewScalarType> >::type cast() const$/;"	f	class:Eigen::AngleAxis
cast	Eigen/src/Geometry/Hyperplane.h	/^           Hyperplane<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::Hyperplane
cast	Eigen/src/Geometry/ParametrizedLine.h	/^           ParametrizedLine<NewScalarType,AmbientDimAtCompileTime,Options> >::type cast() const$/;"	f	class:Eigen::ParametrizedLine
cast	Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::cast_return_type<Derived,Quaternion<NewScalarType> >::type cast() const$/;"	f	class:Eigen::QuaternionBase
cast	Eigen/src/Geometry/Rotation2D.h	/^  inline typename internal::cast_return_type<Rotation2D,Rotation2D<NewScalarType> >::type cast() const$/;"	f	class:Eigen::Rotation2D
cast	Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling<NewScalarType> cast() const$/;"	f	class:Eigen::UniformScaling
cast	Eigen/src/Geometry/Transform.h	/^  inline typename internal::cast_return_type<Transform,Transform<NewScalarType,Dim,Mode,Options> >::type cast() const$/;"	f	class:Eigen::Transform
cast	Eigen/src/Geometry/Translation.h	/^  inline typename internal::cast_return_type<Translation,Translation<NewScalarType,Dim> >::type cast() const$/;"	f	class:Eigen::Translation
cast	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^cast() const$/;"	f
cast_impl	Eigen/src/Core/MathFunctions.h	/^struct cast_impl$/;"	s	namespace:Eigen::internal
cast_to_pointer_type	Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return const_cast<PointerType>(ptr); }$/;"	f	class:Eigen::Map
cast_to_pointer_type	Eigen/src/Core/Map.h	/^    inline PointerType cast_to_pointer_type(PointerArgType ptr) { return ptr; }$/;"	f	class:Eigen::Map
cdiv	Eigen/src/Eigenvalues/EigenSolver.h	/^std::complex<Scalar> cdiv(const Scalar& xr, const Scalar& xi, const Scalar& yr, const Scalar& yi)$/;"	f	namespace:Eigen
center	Eigen/src/Geometry/AlignedBox.h	/^  center() const$/;"	f	class:Eigen::AlignedBox
changeBaseOfSystem	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::changeBaseOfSystem(srLink * _baseLink)$/;"	f	class:srExt::srExtSystem
changeBaseOfSystem	srLib/srExt/srExtension.cpp	/^void srExt::changeBaseOfSystem(srSystem * _system, srLink * _baseLink)$/;"	f	class:srExt
changeFrame	srMath/Inertia.cpp	/^	void Inertia::changeFrame(const SE3& T)$/;"	f	class:srMath::Inertia
changeFrame	srMath/Inertia.h	/^		static Inertia changeFrame(const SE3& T, const Inertia& G)$/;"	f	class:srMath::Inertia
checkSanity	Eigen/src/Core/MapBase.h	/^    void checkSanity() const$/;"	f	class:Eigen::MapBase
checkTransposeAliasing	Eigen/src/Core/Transpose.h	/^void DenseBase<Derived>::checkTransposeAliasing(const OtherDerived& other) const$/;"	f	class:Eigen::DenseBase
checkTransposeAliasing_impl	Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl$/;"	s	namespace:Eigen::internal
checkTransposeAliasing_impl	Eigen/src/Core/Transpose.h	/^struct checkTransposeAliasing_impl<Derived, OtherDerived, false>$/;"	s	namespace:Eigen::internal
check_DenseIndex_is_signed	Eigen/src/Core/DenseBase.h	/^static inline void check_DenseIndex_is_signed() {$/;"	f	namespace:Eigen::internal
check_add_tail	srLib/LieGroup/_array.h	/^	void check_add_tail(const TYPE &value)$/;"	f	class:_array
check_coordinates	Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index , Index ) const {}$/;"	f	class:Eigen::TriangularBase
check_coordinates_internal	Eigen/src/Core/TriangularMatrix.h	/^    void check_coordinates_internal(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
check_rows_cols_for_overflow	Eigen/src/Core/PlainObjectBase.h	/^template<> struct check_rows_cols_for_overflow<Dynamic> {$/;"	s	namespace:Eigen::internal
check_rows_cols_for_overflow	Eigen/src/Core/PlainObjectBase.h	/^template<int MaxSizeAtCompileTime> struct check_rows_cols_for_overflow {$/;"	s	namespace:Eigen::internal
check_size_for_overflow	Eigen/src/Core/util/Memory.h	/^EIGEN_ALWAYS_INLINE void check_size_for_overflow(size_t size)$/;"	f	namespace:Eigen::internal
check_static_allocation_size	Eigen/src/Core/DenseStorage.h	/^template<typename T, int Size> void check_static_allocation_size()$/;"	f	namespace:Eigen::internal
check_template_parameters	Eigen/src/Cholesky/LDLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LDLT
check_template_parameters	Eigen/src/Cholesky/LLT.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::LLT
check_template_parameters	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ComplexEigenSolver
check_template_parameters	Eigen/src/Eigenvalues/EigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::EigenSolver
check_template_parameters	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::GeneralizedEigenSolver
check_template_parameters	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SelfAdjointEigenSolver
check_template_parameters	Eigen/src/LU/FullPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivLU
check_template_parameters	Eigen/src/LU/PartialPivLU.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::PartialPivLU
check_template_parameters	Eigen/src/QR/ColPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::ColPivHouseholderQR
check_template_parameters	Eigen/src/QR/FullPivHouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::FullPivHouseholderQR
check_template_parameters	Eigen/src/QR/HouseholderQR.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::HouseholderQR
check_template_parameters	Eigen/src/SVD/JacobiSVD.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::JacobiSVD
check_template_parameters	Eigen/src/SparseCore/SparseMatrix.h	/^  static void check_template_parameters()$/;"	f	class:Eigen::SparseMatrix
check_template_parameters	Eigen/src/SparseCore/SparseVector.h	/^    static void check_template_parameters()$/;"	f	class:Eigen::SparseVector
check_template_params	Eigen/src/Geometry/Transform.h	/^    static EIGEN_STRONG_INLINE void check_template_params()$/;"	f	class:Eigen::Transform
check_that_malloc_is_allowed	Eigen/src/Core/util/Memory.h	/^inline void check_that_malloc_is_allowed()$/;"	f	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_compile_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_compile_time_selector<DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector$/;"	s	namespace:Eigen::internal
check_transpose_aliasing_run_time_selector	Eigen/src/Core/Transpose.h	/^struct check_transpose_aliasing_run_time_selector<Scalar,DestIsTransposed,CwiseBinaryOp<BinOp,DerivedA,DerivedB> >$/;"	s	namespace:Eigen::internal
children	srLib/SceneGraph/node.h	/^	list<Node*>				children;$/;"	m	class:Node
cholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_common& cholmod() { return m_cholmod; }$/;"	f	class:Eigen::CholmodBase
cholmodCommon	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    cholmod_common *cholmodCommon() const { return &m_cc; }$/;"	f	class:Eigen::SPQR
cholmod_configure_matrix	Eigen/src/CholmodSupport/CholmodSupport.h	/^void cholmod_configure_matrix(CholmodType& mat)$/;"	f	namespace:Eigen::internal
cj	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<LhsScalar,RhsScalar,ConjLhs,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,ConjLhs,false> cj;$/;"	m	class:Eigen::internal::gebp_traits
cj	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  conj_helper<ResPacket,ResPacket,false,ConjRhs> cj;$/;"	m	class:Eigen::internal::gebp_traits
clamp	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
clamp	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& clamp(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
clean	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void clean()$/;"	f	class:Eigen::PastixBase
clear	Eigen/src/SparseCore/CompressedStorage.h	/^    inline void clear() { m_size = 0; }$/;"	f	class:Eigen::internal::CompressedStorage
clear	srLib/LieGroup/_array.h	/^	void clear(void)$/;"	f	class:_array
clearFactors	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void clearFactors()$/;"	f	class:Eigen::SuperLUBase
clearNode	srLib/SceneGraph/Node.cpp	/^void Node::clearNode()$/;"	f	class:Node
clearPoints	srLib/SceneGraph/Leaf.cpp	/^void Lines::clearPoints()$/;"	f	class:Lines
clearPoints	srLib/SceneGraph/Leaf.cpp	/^void Strip::clearPoints()$/;"	f	class:Strip
clear_mark	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline  Index clear_mark  \/* return the new value for tag_mark *\/$/;"	f	namespace:internal
closedloopError	srLib/srDyn/srClosedLoopConstraint.h	/^	SR_REAL	closedloopError[6];$/;"	m	class:ClosedLoop
cmp_EQ	Eigen/src/Core/util/Constants.h	/^    cmp_EQ = 0,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LE	Eigen/src/Core/util/Constants.h	/^    cmp_LE = 2,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_LT	Eigen/src/Core/util/Constants.h	/^    cmp_LT = 1,$/;"	e	enum:Eigen::internal::ComparisonName
cmp_NEQ	Eigen/src/Core/util/Constants.h	/^    cmp_NEQ = 4$/;"	e	enum:Eigen::internal::ComparisonName
cmp_UNORD	Eigen/src/Core/util/Constants.h	/^    cmp_UNORD = 3,$/;"	e	enum:Eigen::internal::ComparisonName
coeff	Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ArrayWrapper
coeff	Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::MatrixWrapper
coeff	Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper
coeff	Eigen/src/Core/ArrayWrapper.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper
coeff	Eigen/src/Core/Block.h	/^    EIGEN_STRONG_INLINE const CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeff	Eigen/src/Core/Block.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeff	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
coeff	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
coeff	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp
coeff	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseNullaryOp
coeff	Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
coeff	Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
coeff	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeff	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeff	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	Eigen/src/Core/DenseCoeffsBase.h	/^    coeff(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
coeff	Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index idx) const$/;"	f	class:Eigen::Diagonal
coeff	Eigen/src/Core/Diagonal.h	/^    inline CoeffReturnType coeff(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeff	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index idx) const$/;"	f	class:Eigen::DiagonalProduct
coeff	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct
coeff	Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Flagged
coeff	Eigen/src/Core/Flagged.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Flagged
coeff	Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	Eigen/src/Core/ForceAlignedAccess.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
coeff	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index index) const$/;"	f	class:Eigen::MapBase
coeff	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
coeff	Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::NestByValue
coeff	Eigen/src/Core/NestByValue.h	/^    inline const CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
coeff	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeff	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
coeff	Eigen/src/Core/Replicate.h	/^    inline Scalar coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::Replicate
coeff	Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	Eigen/src/Core/ReturnByValue.h	/^    const Unusable& coeff(Index,Index) const { return *reinterpret_cast<const Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeff	Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::Reverse
coeff	Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType coeff(Index row, Index col) const$/;"	f	class:Eigen::Reverse
coeff	Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i) const$/;"	f	class:Eigen::Select
coeff	Eigen/src/Core/Select.h	/^    const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::Select
coeff	Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SelfAdjointView
coeff	Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index index) const$/;"	f	class:Eigen::TransposeImpl
coeff	Eigen/src/Core/Transpose.h	/^    inline CoeffReturnType coeff(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl
coeff	Eigen/src/Core/Transpositions.h	/^    inline const Index& coeff(Index i) const { return indices().coeff(i); }$/;"	f	class:Eigen::TranspositionsBase
coeff	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const  { return derived().coeff(row,col); }$/;"	f	class:Eigen::TriangularBase
coeff	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::TriangularView
coeff	Eigen/src/Core/VectorwiseOp.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index i, Index j) const$/;"	f	class:Eigen::PartialReduxExpr
coeff	Eigen/src/Core/VectorwiseOp.h	/^    const Scalar coeff(Index index) const$/;"	f	class:Eigen::PartialReduxExpr
coeff	Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct
coeff	Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct
coeff	Eigen/src/Eigen2Support/Minor.h	/^    inline const Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::Minor
coeff	Eigen/src/Geometry/Homogeneous.h	/^    inline Scalar coeff(Index row, Index col=0) const$/;"	f	class:Eigen::Homogeneous
coeff	Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeff(_Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeff	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::MappedSparseMatrix
coeff	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(int index) const$/;"	f	class:Eigen::BlockImpl
coeff	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar coeff(int row, int col) const$/;"	f	class:Eigen::BlockImpl
coeff	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseMatrix
coeff	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index i) const$/;"	f	class:Eigen::SparseVector
coeff	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar coeff(Index row, Index col) const$/;"	f	class:Eigen::SparseVector
coeffByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType coeffByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ArrayWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::MatrixWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::ArrayWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::MatrixWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper
coeffRef	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper
coeffRef	Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/Block.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/Block.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
coeffRef	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeffRef	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::CwiseUnaryViewImpl
coeffRef	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRef(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index idx)$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline Scalar& coeffRef(Index row, Index)$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index idx) const$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Diagonal.h	/^    inline const Scalar& coeffRef(Index row, Index) const$/;"	f	class:Eigen::Diagonal
coeffRef	Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Flagged
coeffRef	Eigen/src/Core/Flagged.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Flagged
coeffRef	Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::Flagged
coeffRef	Eigen/src/Core/Flagged.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::Flagged
coeffRef	Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	Eigen/src/Core/ForceAlignedAccess.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::ForceAlignedAccess
coeffRef	Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/MapBase.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
coeffRef	Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::NestByValue
coeffRef	Eigen/src/Core/NestByValue.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::NestByValue
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index index)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
coeffRef	Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index i) const$/;"	f	namespace:Eigen
coeffRef	Eigen/src/Core/ProductBase.h	/^    const Scalar& coeffRef(Index row, Index col) const$/;"	f	namespace:Eigen
coeffRef	Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	Eigen/src/Core/ReturnByValue.h	/^    Unusable& coeffRef(Index,Index) { return *reinterpret_cast<Unusable*>(this); }$/;"	f	class:Eigen::ReturnByValue
coeffRef	Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::Reverse
coeffRef	Eigen/src/Core/Reverse.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Reverse
coeffRef	Eigen/src/Core/SelfAdjointView.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfAdjointView
coeffRef	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar& coeffRef(Index row, Index col) const$/;"	f	class:Eigen::SelfCwiseBinaryOp
coeffRef	Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::SwapWrapper
coeffRef	Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index index)$/;"	f	class:Eigen::SwapWrapper
coeffRef	Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::SwapWrapper
coeffRef	Eigen/src/Core/Swap.h	/^    inline Scalar& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::SwapWrapper
coeffRef	Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index index)$/;"	f	class:Eigen::TransposeImpl
coeffRef	Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue& coeffRef(Index rowId, Index colId)$/;"	f	class:Eigen::TransposeImpl
coeffRef	Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index index) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	Eigen/src/Core/Transpose.h	/^    inline const Scalar& coeffRef(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl
coeffRef	Eigen/src/Core/Transpositions.h	/^    inline Index& coeffRef(Index i) { return indices().coeffRef(i); }$/;"	f	class:Eigen::TranspositionsBase
coeffRef	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col) { return derived().coeffRef(row,col); }$/;"	f	class:Eigen::TriangularBase
coeffRef	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::TriangularView
coeffRef	Eigen/src/Eigen2Support/Minor.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::Minor
coeffRef	Eigen/src/SparseCore/AmbiVector.h	/^_Scalar& AmbiVector<_Scalar,_Index>::coeffRef(_Index i)$/;"	f	class:Eigen::internal::AmbiVector
coeffRef	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::MappedSparseMatrix
coeffRef	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(int index)$/;"	f	class:Eigen::BlockImpl
coeffRef	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar& coeffRef(int row, int col)$/;"	f	class:Eigen::BlockImpl
coeffRef	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
coeffRef	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index i)$/;"	f	class:Eigen::SparseVector
coeffRef	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& coeffRef(Index row, Index col)$/;"	f	class:Eigen::SparseVector
coeffRefByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    coeffRefByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::DenseCoeffsBase
coeffSeparator	Eigen/src/Core/IO.h	/^  std::string coeffSeparator;$/;"	m	struct:Eigen::IOFormat
coeff_visitor	Eigen/src/Core/Visitor.h	/^struct coeff_visitor$/;"	s	namespace:Eigen::internal
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline CoefficientsType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrix
coeffs	Eigen/src/Core/BandMatrix.h	/^    inline const CoefficientsType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::internal::BandMatrixWrapper
coeffs	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Quaternion
coeffs	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Quaternion
coeffs	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Scaling
coeffs	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  const VectorType& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Scaling
coeffs	Eigen/src/Geometry/Hyperplane.h	/^  inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	Eigen/src/Geometry/Hyperplane.h	/^  inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Hyperplane
coeffs	Eigen/src/Geometry/Quaternion.h	/^    inline Coefficients& coeffs() { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs; }$/;"	f	class:Eigen::Map
coeffs	Eigen/src/Geometry/Quaternion.h	/^    inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Map
coeffs	Eigen/src/Geometry/Quaternion.h	/^  inline Coefficients& coeffs() { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	Eigen/src/Geometry/Quaternion.h	/^  inline const Coefficients& coeffs() const { return m_coeffs;}$/;"	f	class:Eigen::Quaternion
coeffs	Eigen/src/Geometry/Quaternion.h	/^  inline const typename internal::traits<Derived>::Coefficients& coeffs() const { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
coeffs	Eigen/src/Geometry/Quaternion.h	/^  inline typename internal::traits<Derived>::Coefficients& coeffs() { return derived().coeffs(); }$/;"	f	class:Eigen::QuaternionBase
cofactor_3x3	Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_3x3(const MatrixType& m)$/;"	f	namespace:Eigen::internal
cofactor_4x4	Eigen/src/LU/Inverse.h	/^inline typename MatrixType::Scalar cofactor_4x4(const MatrixType& matrix)$/;"	f	namespace:Eigen::internal
col	Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,Dynamic,1> col(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
col	Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::all_unroller::__anon320
col	Eigen/src/Core/BooleanRedux.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::any_unroller::__anon321
col	Eigen/src/Core/CoreIterators.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::DenseBase::InnerIterator
col	Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon279
col	Eigen/src/Core/SelfAdjointView.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon280
col	Eigen/src/Core/TriangularMatrix.h	/^    col = (UnrollCount-1) \/ Derived1::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon241
col	Eigen/src/Core/Visitor.h	/^    col = (UnrollCount-1) \/ Derived::RowsAtCompileTime,$/;"	e	enum:Eigen::internal::visitor_impl::__anon229
col	Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
col	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
col	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::BlockImpl::InnerIterator
col	Eigen/src/SparseCore/SparseBlock.h	/^        inline Index col() const { return IsRowMajor ? this->index() : m_outer; }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseBlock.h	/^      inline Index col()    const { return Base::col()   - m_block.m_startCol.value(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index col()    const { return Base::col()   - m_block.m_startCol.value(); }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
col	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index col()    const { return IsRowMajor ? index() : 0; }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return Lhs::IsRowMajor ? index() : m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_lhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
col	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index col() const { return m_rhsIter.col(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
col	Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index col() const { return Transpose ? Base::index() : m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
col	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
col	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
col	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index col() const { return IsRowMajor ? index() : m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator
col	Eigen/src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index col() const { return Base::row(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return (MatrixType::Flags&RowMajorBit ? this->index() : Base::outer()); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
col	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index col() const { return Base::col(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
col	Eigen/src/SparseCore/SparseUtil.h	/^  const Index& col() const { return m_col; }$/;"	f	class:Eigen::Triplet
col	Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::InnerIterator
col	Eigen/src/SparseCore/SparseVector.h	/^    inline Index col() const { return IsColVector ? 0 : index(); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
col	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index col() const { return m_outer; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
col	Eigen/src/plugins/BlockMethods.h	/^inline ColXpr col(Index i)$/;"	f
col	Eigen/src/plugins/BlockMethods.h	/^inline ConstColXpr col(Index i) const$/;"	f
colDL	srLib/SceneGraph/Model3DS.h	/^	GLuint	colDL;$/;"	m	class:Model3DS
colIndexByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index colIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
colIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* colIndexPtr()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* colIndexPtr() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colOffset	Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index colOffset() const { return m_index.value()>0 ? m_index.value() : 0; }$/;"	f	class:Eigen::Diagonal
colPivHouseholderQr	Eigen/src/QR/ColPivHouseholderQR.h	/^MatrixBase<Derived>::colPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
colStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index colStride() const$/;"	f	class:Eigen::DenseCoeffsBase
colToSup	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* colToSup()  { return m_col_to_sup; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colToSup	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* colToSup() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
colamd	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static bool colamd(Index n_row, Index n_col, Index Alen, Index *A, Index *p, double knobs[COLAMD_KNOBS], Index stats[COLAMD_STATS])$/;"	f	namespace:internal
colamd_c	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline Index colamd_c(Index n_col) $/;"	f	namespace:internal
colamd_col	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^struct colamd_col$/;"	s	namespace:internal
colamd_r	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline Index  colamd_r(Index n_row)$/;"	f	namespace:internal
colamd_recommended	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^inline Index colamd_recommended ( Index nnz, Index n_row, Index n_col)$/;"	f	namespace:internal
colamd_set_defaults	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline void colamd_set_defaults(double knobs[COLAMD_KNOBS])$/;"	f	namespace:internal
colblk	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index colblk; \/\/ The minimum column dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues
colearColor	srLib/SceneGraph/Camera.h	/^	GLdouble		colearColor[4];$/;"	m	class:Camera
coletree	Eigen/src/SparseCore/SparseColEtree.h	/^int coletree(const MatrixType& mat, IndexVector& parent, IndexVector& firstRowElt, typename MatrixType::Index *perm=0)$/;"	f	namespace:Eigen::internal
collision_	Example/DracoP1/draco.h	/^  std::vector<srCollision*> collision_;$/;"	m	class:srDraco
color	srLib/SceneGraph/Leaf.h	/^		float       color[4];$/;"	m	struct:Lines::PTY
color	srLib/SceneGraph/Leaf.h	/^		float       color[4];$/;"	m	struct:Strip::PTY
color	srLib/SceneGraph/Leaf.h	/^	float          color[4];$/;"	m	class:Strip
color	srLib/SceneGraph/Leaf.h	/^	float       color[4];$/;"	m	class:Lines
color	srLib/SceneGraph/Model3DS.h	/^		Color4i	color;$/;"	m	struct:Model3DS::Material
colormap	srLib/SceneGraph/gl2ps.c	/^  GL2PSrgba *colormap, lastrgba, threshold, bgcolor;$/;"	m	struct:__anon15	file:
colormode	srLib/SceneGraph/gl2ps.c	/^  GLint format, sort, options, colorsize, colormode, buffersize;$/;"	m	struct:__anon15	file:
colorsize	srLib/SceneGraph/gl2ps.c	/^  GLint format, sort, options, colorsize, colormode, buffersize;$/;"	m	struct:__anon15	file:
cols	Eigen/src/Cholesky/LDLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LDLT
cols	Eigen/src/Cholesky/LLT.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::LLT
cols	Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index cols() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase
cols	Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ArrayWrapper
cols	Eigen/src/Core/ArrayWrapper.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::MatrixWrapper
cols	Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrix
cols	Eigen/src/Core/BandMatrix.h	/^    inline Index cols() const { return m_coeffs.cols(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
cols	Eigen/src/Core/Block.h	/^    inline Index cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense
cols	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const {$/;"	f	class:Eigen::CwiseBinaryOp
cols	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
cols	Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_xpr.cols(); }$/;"	f	class:Eigen::CwiseUnaryOp
cols	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::CwiseUnaryView
cols	Eigen/src/Core/DenseStorage.h	/^    DenseIndex cols() const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/DenseStorage.h	/^    DenseIndex cols(void) const {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/DenseStorage.h	/^    DenseIndex cols(void) const {return m_cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/DenseStorage.h	/^    static DenseIndex cols(void) {return _Cols;}$/;"	f	class:Eigen::DenseStorage
cols	Eigen/src/Core/Diagonal.h	/^    inline Index cols() const { return 1; }$/;"	f	class:Eigen::Diagonal
cols	Eigen/src/Core/DiagonalMatrix.h	/^    inline Index cols() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
cols	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::DiagonalProduct
cols	Eigen/src/Core/EigenBase.h	/^  inline Index cols() const { return derived().cols(); }$/;"	f	struct:Eigen::EigenBase
cols	Eigen/src/Core/Flagged.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Flagged
cols	Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::ForceAlignedAccess
cols	Eigen/src/Core/MapBase.h	/^    inline Index cols() const { return m_cols.value(); }$/;"	f	class:Eigen::MapBase
cols	Eigen/src/Core/NestByValue.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::NestByValue
cols	Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
cols	Eigen/src/Core/PermutationMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
cols	Eigen/src/Core/PermutationMatrix.h	/^    inline int cols() const { return m_permutation.cols(); }$/;"	f	class:Eigen::Transpose
cols	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_storage.cols(); }$/;"	f	class:Eigen::PlainObjectBase
cols	Eigen/src/Core/ProductBase.h	/^      eigen_assert(this->rows() == 1 && this->cols() == 1);$/;"	t	class:Eigen::ProductBase
cols	Eigen/src/Core/Replicate.h	/^    inline Index cols() const { return m_matrix.cols() * m_colFactor.value(); }$/;"	f	class:Eigen::Replicate
cols	Eigen/src/Core/ReturnByValue.h	/^    inline Index cols() const { return static_cast<const Derived*>(this)->cols(); }$/;"	f	class:Eigen::ReturnByValue
cols	Eigen/src/Core/Reverse.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Reverse
cols	Eigen/src/Core/Select.h	/^    Index cols() const { return m_condition.cols(); }$/;"	f	class:Eigen::Select
cols	Eigen/src/Core/SelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfAdjointView
cols	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
cols	Eigen/src/Core/SolveTriangular.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
cols	Eigen/src/Core/Swap.h	/^    inline Index cols() const { return m_expression.cols(); }$/;"	f	class:Eigen::SwapWrapper
cols	Eigen/src/Core/Transpose.h	/^    inline Index cols() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Transpose
cols	Eigen/src/Core/Transpositions.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
cols	Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::TriangularBase
cols	Eigen/src/Core/TriangularMatrix.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::TriangularView
cols	Eigen/src/Core/VectorwiseOp.h	/^    Index cols() const { return (Direction==Horizontal ? 1 : m_matrix.cols()); }$/;"	f	class:Eigen::PartialReduxExpr
cols	Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::CoeffBasedProduct
cols	Eigen/src/Eigen2Support/Minor.h	/^    inline Index cols() const { return m_matrix.cols() - 1; }$/;"	f	class:Eigen::Minor
cols	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index cols() const { return m_hess.packedMatrix().cols(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
cols	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
cols	Eigen/src/Geometry/Homogeneous.h	/^    inline Index cols() const { return m_matrix.cols() + (int(Direction)==Horizontal ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
cols	Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
cols	Eigen/src/Geometry/Homogeneous.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
cols	Eigen/src/Householder/HouseholderSequence.h	/^    Index cols() const { return rows(); }$/;"	f	class:Eigen::HouseholderSequence
cols	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index cols() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
cols	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::IncompleteLUT
cols	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index cols() const { return mp_matrix ? mp_matrix->cols() : 0; }$/;"	f	class:Eigen::IterativeSolverBase
cols	Eigen/src/LU/FullPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::FullPivLU
cols	Eigen/src/LU/Inverse.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::inverse_impl
cols	Eigen/src/LU/PartialPivLU.h	/^    inline Index cols() const { return m_lu.cols(); }$/;"	f	class:Eigen::PartialPivLU
cols	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PastixBase
cols	Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index cols() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
cols	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::ColPivHouseholderQR
cols	Eigen/src/QR/FullPivHouseholderQR.h	/^    Index cols() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
cols	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::FullPivHouseholderQR
cols	Eigen/src/QR/HouseholderQR.h	/^    inline Index cols() const { return m_qr.cols(); }$/;"	f	class:Eigen::HouseholderQR
cols	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index cols() const { return m_cR->ncol; }$/;"	f	class:Eigen::SPQR
cols	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct
cols	Eigen/src/SVD/JacobiSVD.h	/^    inline Index cols() const { return m_cols; }$/;"	f	class:Eigen::JacobiSVD
cols	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
cols	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
cols	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsRowMajor ? m_matrix.cols() : m_outerSize.value(); }$/;"	f	class:Eigen::BlockImpl
cols	Eigen/src/SparseCore/SparseBlock.h	/^    inline int cols() const { return m_blockCols.value(); }$/;"	f	class:Eigen::BlockImpl
cols	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return Tr ? m_lhs.cols() : m_rhs.cols(); }$/;"	f	class:Eigen::SparseDenseOuterProduct
cols	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseDiagonalProduct
cols	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index cols() const { return IsRowMajor ? m_innerSize : m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
cols	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index cols() const { return derived().cols(); }$/;"	f	class:Eigen::SparseMatrixBase
cols	Eigen/src/SparseCore/SparsePermutation.h	/^    inline int cols() const { return m_matrix.cols(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
cols	Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index cols() const { return m_rhs.cols(); }$/;"	f	class:Eigen::SparseSparseProduct
cols	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSelfAdjointView
cols	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
cols	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseTriangularView
cols	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index cols() const { return IsColVector ? 1 : m_size; }$/;"	f	class:Eigen::SparseVector
cols	Eigen/src/SparseCore/SparseView.h	/^  inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SparseView
cols	Eigen/src/SparseLU/SparseLU.h	/^    inline Index cols() const { return m_mat.cols(); }$/;"	f	class:Eigen::SparseLU
cols	Eigen/src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
cols	Eigen/src/SparseLU/SparseLU.h	/^  Index cols() { return m_mapL.cols(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
cols	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index cols() { return m_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
cols	Eigen/src/SparseQR/SparseQR.h	/^    inline Index cols() const { return m_pmat.cols();}$/;"	f	class:Eigen::SparseQR
cols	Eigen/src/SparseQR/SparseQR.h	/^  inline Index cols() const { return (std::min)(m_qr.rows(),m_qr.cols()); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
cols	Eigen/src/SparseQR/SparseQR.h	/^  inline Index cols() const { return m_other.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct
cols	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index cols() const { return m_matrix.cols(); }$/;"	f	class:Eigen::SuperLUBase
cols	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index cols() const { return m_copyMatrix.cols(); }$/;"	f	class:Eigen::UmfPackLU
cols	Eigen/src/misc/Image.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::image_retval_base
cols	Eigen/src/misc/Kernel.h	/^  inline Index cols() const { return m_cols; }$/;"	f	struct:Eigen::internal::kernel_retval_base
cols	Eigen/src/misc/Solve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base
cols	Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess
cols	Eigen/src/misc/SparseSolve.h	/^  inline Index cols() const { return m_rhs.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
colsPermutation	Eigen/src/QR/ColPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::ColPivHouseholderQR
colsPermutation	Eigen/src/QR/FullPivHouseholderQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::FullPivHouseholderQR
colsPermutation	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    PermutationType colsPermutation() const$/;"	f	class:Eigen::SPQR
colsPermutation	Eigen/src/SparseLU/SparseLU.h	/^    inline const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseLU
colsPermutation	Eigen/src/SparseQR/SparseQR.h	/^    const PermutationType& colsPermutation() const$/;"	f	class:Eigen::SparseQR
cols_select	Eigen/src/Core/GeneralProduct.h	/^    cols_select = product_size_category<Cols,MaxCols>::value,$/;"	e	enum:Eigen::internal::product_type::__anon284
column_bmod	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^Index SparseLUImpl<Scalar,Index>::column_bmod(const Index jcol, const Index nseg, BlockScalarVector dense, ScalarVector& tempv, BlockIndexVector segrep, BlockIndexVector repfnz, Index fpanelc, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
column_dfs	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^Index SparseLUImpl<Scalar,Index>::column_dfs(const Index m, const Index jcol, IndexVector& perm_r, Index maxsuper, Index& nseg,  BlockIndexVector lsub_col, IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
column_dfs_traits	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  column_dfs_traits(Index jcol, Index& jsuper, typename SparseLUImpl<Scalar, Index>::GlobalLU_t& glu, SparseLUImpl<Scalar, Index>& luImpl)$/;"	f	struct:Eigen::internal::column_dfs_traits
column_dfs_traits	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^struct column_dfs_traits : no_assignment_operator$/;"	s	namespace:Eigen::internal
colwise	Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise() const$/;"	f	class:Eigen::DenseBase
colwise	Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::colwise()$/;"	f	class:Eigen::DenseBase
complex_schur_reduce_to_hessenberg	Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg$/;"	s	namespace:Eigen::internal
complex_schur_reduce_to_hessenberg	Eigen/src/Eigenvalues/ComplexSchur.h	/^struct complex_schur_reduce_to_hessenberg<MatrixType, false>$/;"	s	namespace:Eigen::internal
compress	srLib/SceneGraph/gl2ps.c	/^  GL2PScompress *compress;$/;"	m	struct:__anon15	file:
compute	Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LDLT
compute	Eigen/src/Cholesky/LLT.h	/^LLT<MatrixType,_UpLo>& LLT<MatrixType,_UpLo>::compute(const MatrixType& a)$/;"	f	class:Eigen::LLT
compute	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& compute(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
compute	Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::SVD
compute	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^ComplexEigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
compute	Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::ComplexSchur
compute	Eigen/src/Eigenvalues/EigenSolver.h	/^EigenSolver<MatrixType>::compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::EigenSolver
compute	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^GeneralizedEigenSolver<MatrixType>::compute(const MatrixType& A, const MatrixType& B, bool computeEigenvectors)$/;"	f	class:Eigen::GeneralizedEigenSolver
compute	Eigen/src/Eigenvalues/GeneralizedSelfAdjointEigenSolver.h	/^compute(const MatrixType& matA, const MatrixType& matB, int options)$/;"	f	class:Eigen::GeneralizedSelfAdjointEigenSolver
compute	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HessenbergDecomposition& compute(const MatrixType& matrix)$/;"	f	class:Eigen::HessenbergDecomposition
compute	Eigen/src/Eigenvalues/RealQZ.h	/^    RealQZ<MatrixType>& RealQZ<MatrixType>::compute(const MatrixType& A_in, const MatrixType& B_in, bool computeQZ)$/;"	f	class:Eigen::RealQZ
compute	Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::compute(const MatrixType& matrix, bool computeU)$/;"	f	class:Eigen::RealSchur
compute	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matA, const MatrixType& matB, bool computeEigenvectors = true)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    void compute(const MatrixType& matrix, bool computeEigenvectors)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::compute(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
compute	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Tridiagonalization& compute(const MatrixType& matrix)$/;"	f	class:Eigen::Tridiagonalization
compute	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& compute(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
compute	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& compute(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
compute	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    IncompleteLUT<Scalar>& compute(const MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
compute	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& compute(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
compute	Eigen/src/LU/FullPivLU.h	/^FullPivLU<MatrixType>& FullPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivLU
compute	Eigen/src/LU/PartialPivLU.h	/^PartialPivLU<MatrixType>& PartialPivLU<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::PartialPivLU
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
compute	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::compute(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
compute	Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::compute(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
compute	Eigen/src/QR/ColPivHouseholderQR.h	/^ColPivHouseholderQR<MatrixType>& ColPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::ColPivHouseholderQR
compute	Eigen/src/QR/FullPivHouseholderQR.h	/^FullPivHouseholderQR<MatrixType>& FullPivHouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::FullPivHouseholderQR
compute	Eigen/src/QR/HouseholderQR.h	/^HouseholderQR<MatrixType>& HouseholderQR<MatrixType>::compute(const MatrixType& matrix)$/;"	f	class:Eigen::HouseholderQR
compute	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void compute(const _MatrixType& matrix)$/;"	f	class:Eigen::SPQR
compute	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& compute(const MatrixType& matrix)$/;"	f	class:Eigen::JacobiSVD
compute	Eigen/src/SVD/JacobiSVD.h	/^JacobiSVD<MatrixType, QRPreconditioner>::compute(const MatrixType& matrix, unsigned int computationOptions)$/;"	f	class:Eigen::JacobiSVD
compute	Eigen/src/SVD/UpperBidiagonalization.h	/^UpperBidiagonalization<_MatrixType>& UpperBidiagonalization<_MatrixType>::compute(const _MatrixType& matrix)$/;"	f	class:Eigen::internal::UpperBidiagonalization
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholesky
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLDLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLDLT
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialLLT& compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialLLT
compute	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SimplicialCholeskyBase
compute	Eigen/src/SparseLU/SparseLU.h	/^    void compute (const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
compute	Eigen/src/SparseQR/SparseQR.h	/^    void compute(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
compute	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void compute(const MatrixType& matrix)$/;"	f	class:Eigen::SuperLUBase
compute	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void compute(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
computeDirect	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^::computeDirect(const MatrixType& matrix, int options)$/;"	f	class:Eigen::SelfAdjointEigenSolver
computeFromHessenberg	Eigen/src/Eigenvalues/ComplexSchur.h	/^ComplexSchur<MatrixType>& ComplexSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ, bool computeU)$/;"	f	class:Eigen::ComplexSchur
computeFromHessenberg	Eigen/src/Eigenvalues/RealSchur.h	/^RealSchur<MatrixType>& RealSchur<MatrixType>::computeFromHessenberg(const HessMatrixType& matrixH, const OrthMatrixType& matrixQ,  bool computeU)$/;"	f	class:Eigen::RealSchur
computeImage	Eigen/src/Eigen2Support/LU.h	/^    void computeImage(ImageMatrixType *result) const$/;"	f	class:Eigen::LU
computeInverse	Eigen/src/Core/MatrixBase.h	/^    void computeInverse(MatrixBase<ResultType> *result) const {$/;"	f	class:Eigen::MatrixBase
computeInverse	Eigen/src/Eigen2Support/LU.h	/^    inline void computeInverse(ResultType *result) const$/;"	f	class:Eigen::LU
computeInverseAndDetWithCheck	Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseAndDetWithCheck($/;"	f	class:Eigen::MatrixBase
computeInverseWithCheck	Eigen/src/LU/Inverse.h	/^inline void MatrixBase<Derived>::computeInverseWithCheck($/;"	f	class:Eigen::MatrixBase
computeKernel	Eigen/src/Eigen2Support/LU.h	/^    void computeKernel(KernelMatrixType *result) const$/;"	f	class:Eigen::LU
computeNormOfT	Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Scalar RealSchur<MatrixType>::computeNormOfT()$/;"	f	class:Eigen::RealSchur
computeNorms	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::computeNorms()$/;"	f	class:Eigen::RealQZ
computePositiveUnitary	Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computePositiveUnitary(UnitaryType *positive,$/;"	f	class:Eigen::SVD
computeProductBlockingSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void computeProductBlockingSizes(SizeType& k, SizeType& m, SizeType& n)$/;"	f	namespace:Eigen::internal
computeProductBlockingSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^void computeProductBlockingSizes(SizeType& k, SizeType& m, SizeType& n)$/;"	f	namespace:Eigen::internal
computeRoots	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void computeRoots(const MatrixType& m, VectorType& roots)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
computeRotationScaling	Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform
computeRotationScaling	Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeRotationScaling(RotationType *rotation, ScalingType *scaling) const$/;"	f	class:Eigen::SVD
computeRotationScaling	Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeRotationScaling(RotationMatrixType *rotation, ScalingMatrixType *scaling) const$/;"	f	class:Eigen::Transform
computeScalingRotation	Eigen/src/Eigen2Support/Geometry/Transform.h	/^void Transform<Scalar,Dim>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform
computeScalingRotation	Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeScalingRotation(ScalingType *scaling, RotationType *rotation) const$/;"	f	class:Eigen::SVD
computeScalingRotation	Eigen/src/Geometry/Transform.h	/^void Transform<Scalar,Dim,Mode,Options>::computeScalingRotation(ScalingMatrixType *scaling, RotationMatrixType *rotation) const$/;"	f	class:Eigen::Transform
computeShift	Eigen/src/Eigenvalues/ComplexSchur.h	/^typename ComplexSchur<MatrixType>::ComplexScalar ComplexSchur<MatrixType>::computeShift(Index iu, Index iter)$/;"	f	class:Eigen::ComplexSchur
computeShift	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::computeShift(Index iu, Index iter, Scalar& exshift, Vector3s& shiftInfo)$/;"	f	class:Eigen::RealSchur
computeU	Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeU() const { return m_computeFullU || m_computeThinU; }$/;"	f	class:Eigen::JacobiSVD
computeUnitaryPositive	Eigen/src/Eigen2Support/SVD.h	/^void SVD<MatrixType>::computeUnitaryPositive(UnitaryType *unitary,$/;"	f	class:Eigen::SVD
computeV	Eigen/src/SVD/JacobiSVD.h	/^    inline bool computeV() const { return m_computeFullV || m_computeThinV; }$/;"	f	class:Eigen::JacobiSVD
compute_inverse	Eigen/src/LU/Inverse.h	/^struct compute_inverse$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse	Eigen/src/LU/Inverse.h	/^struct compute_inverse<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check { \/* nothing! general case not supported. *\/ };$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 1>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 2>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 3>$/;"	s	namespace:Eigen::internal
compute_inverse_and_det_with_check	Eigen/src/LU/Inverse.h	/^struct compute_inverse_and_det_with_check<MatrixType, ResultType, 4>$/;"	s	namespace:Eigen::internal
compute_inverse_size2_helper	Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size2_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size3_helper	Eigen/src/LU/Inverse.h	/^inline void compute_inverse_size3_helper($/;"	f	namespace:Eigen::internal
compute_inverse_size4	Eigen/src/LU/Inverse.h	/^struct compute_inverse_size4$/;"	s	namespace:Eigen::internal
compute_inverse_size4	Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, double, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
compute_inverse_size4	Eigen/src/LU/arch/Inverse_SSE.h	/^struct compute_inverse_size4<Architecture::SSE, float, MatrixType, ResultType>$/;"	s	namespace:Eigen::internal
conditionMatrix	Eigen/src/Core/Select.h	/^    const ConditionMatrixType& conditionMatrix() const$/;"	f	class:Eigen::Select
conditional	Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	s	namespace:Eigen::internal
conditional	Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	s	namespace:Eigen::internal
conditional_aligned_delete	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_delete_auto	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline void conditional_aligned_delete_auto(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	Eigen/src/Core/util/Memory.h	/^template<> inline void conditional_aligned_free<false>(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_free	Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_malloc<false>(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_malloc	Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_new_auto	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_new_auto(size_t size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	Eigen/src/Core/util/Memory.h	/^template<> inline void* conditional_aligned_realloc<false>(void* ptr, size_t new_size, size_t)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc	Eigen/src/Core/util/Memory.h	/^template<bool Align> inline void* conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
conditional_aligned_realloc_new_auto	Eigen/src/Core/util/Memory.h	/^template<typename T, bool Align> inline T* conditional_aligned_realloc_new_auto(T* pts, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen::internal
conf	Example/DracoP1/Draco_Dyn_environment.h	/^    std::vector<double> conf;$/;"	m	struct:state
conj	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(conj, Scalar) conj(const Scalar& x)$/;"	f	namespace:Eigen::numext
conj_expr_if	Eigen/src/Core/products/SelfadjointRank2Update.h	/^template<bool Cond, typename T> struct conj_expr_if$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet1cd, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet1cd, Packet2d, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet2cf, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2cf, Packet4f, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet2d, Packet1cd, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct conj_helper<Packet4f, Packet2cf, false,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^struct conj_helper$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<RealScalar, std::complex<RealScalar>, false,Conj>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar,bool Conj> struct conj_helper<std::complex<RealScalar>, RealScalar, Conj,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, false,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,false>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename RealScalar> struct conj_helper<std::complex<RealScalar>, std::complex<RealScalar>, true,true>$/;"	s	namespace:Eigen::internal
conj_helper	Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct conj_helper<Scalar,Scalar,false,false>$/;"	s	namespace:Eigen::internal
conj_if	Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<false> {$/;"	s	namespace:Eigen::internal
conj_if	Eigen/src/Core/util/BlasUtil.h	/^template<> struct conj_if<true> {$/;"	s	namespace:Eigen::internal
conj_impl	Eigen/src/Core/MathFunctions.h	/^struct conj_impl$/;"	s	namespace:Eigen::internal
conj_impl	Eigen/src/Core/MathFunctions.h	/^struct conj_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
conj_retval	Eigen/src/Core/MathFunctions.h	/^struct conj_retval$/;"	s	namespace:Eigen::internal
conjugate	Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<MatrixConjugateReturnType,Mode> conjugate()$/;"	f	class:Eigen::TriangularView
conjugate	Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<MatrixConjugateReturnType,Mode> conjugate() const$/;"	f	class:Eigen::TriangularView
conjugate	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::conjugate() const$/;"	f	class:Eigen::Quaternion
conjugate	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::conjugate() const$/;"	f	class:Eigen::QuaternionBase
conjugate	Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType conjugate() const$/;"	f	class:Eigen::HouseholderSequence
conjugate	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^conjugate() const$/;"	f
conjugate	srLib/LieGroup/LieGroup.h	/^	Quaternion& conjugate()                                 \/\/ Q.conjugate()$/;"	f	union:Quaternion
conjugate_gradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^void conjugate_gradient(const MatrixType& mat, const Rhs& rhs, Dest& x,$/;"	f	namespace:Eigen::internal
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex nbRows, DenseIndex)$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex size, DenseIndex, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) { m_rows = nbRows; m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex nbRows, DenseIndex) { m_rows = nbRows; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex, DenseIndex, DenseIndex nbCols) { m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/DenseStorage.h	/^    void conservativeResize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index nbRows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(Index size)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResize(NoChange_t, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
conservativeResize	Eigen/src/SparseCore/SparseMatrix.h	/^    void conservativeResize(Index rows, Index cols) $/;"	f	class:Eigen::SparseMatrix
conservativeResizeLike	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void conservativeResizeLike(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
conservative_resize_like_impl	Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl$/;"	s	namespace:Eigen::internal
conservative_resize_like_impl	Eigen/src/Core/PlainObjectBase.h	/^struct conservative_resize_like_impl<Derived,OtherDerived,true>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_impl	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^static void conservative_sparse_sparse_product_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,ColMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
conservative_sparse_sparse_product_selector	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^struct conservative_sparse_sparse_product_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
const	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define const$/;"	d	file:
const_blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^    const_blas_data_mapper(const Scalar* data, Index stride) : m_data(data), m_stride(stride) {}$/;"	f	class:Eigen::internal::const_blas_data_mapper
const_blas_data_mapper	Eigen/src/Core/util/BlasUtil.h	/^class const_blas_data_mapper$/;"	c	namespace:Eigen::internal
const_cast_derived	Eigen/src/Core/EigenBase.h	/^  inline Derived& const_cast_derived() const$/;"	f	struct:Eigen::EigenBase
const_cast_derived	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& const_cast_derived() const$/;"	f	class:Eigen::SparseMatrixBase
const_derived	Eigen/src/Core/EigenBase.h	/^  inline const Derived& const_derived() const$/;"	f	struct:Eigen::EigenBase
const_pointer	Eigen/src/Core/util/Memory.h	/^  typedef const T*        const_pointer;$/;"	t	class:Eigen::aligned_allocator
const_pointer	Eigen/src/StlSupport/details.h	/^    typedef const T*  const_pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
const_reference	Eigen/src/Core/util/Memory.h	/^  typedef const T&        const_reference;$/;"	t	class:Eigen::aligned_allocator
const_reference	Eigen/src/StlSupport/details.h	/^    typedef const T&  const_reference;$/;"	t	class:Eigen::aligned_allocator_indirection
construct	Eigen/src/Core/Ref.h	/^    void construct(const Expression& expr, internal::false_type)$/;"	f	class:Eigen::Ref
construct	Eigen/src/Core/Ref.h	/^    void construct(const Expression& expr,internal::true_type)$/;"	f	class:Eigen::Ref
construct	Eigen/src/Core/Ref.h	/^  void construct(Expression& expr)$/;"	f	class:Eigen::RefBase
construct_elements_of_array	Eigen/src/Core/util/Memory.h	/^template<typename T> inline T* construct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
construct_from_matrix	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  struct construct_from_matrix$/;"	s	class:Eigen::Transform
construct_from_matrix	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  template<typename OtherDerived> struct construct_from_matrix<OtherDerived, true>$/;"	s	class:Eigen::Transform
constructor_without_unaligned_array_assert	Eigen/src/Core/DenseStorage.h	/^struct constructor_without_unaligned_array_assert {};$/;"	s	namespace:Eigen::internal
contains	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
contains	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool contains(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox
contains	Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
contains	Eigen/src/Geometry/AlignedBox.h	/^  inline bool contains(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
contains	srLib/LieGroup/_array.h	/^	bool contains(const TYPE &value)$/;"	f	class:_array
copyCoeff	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyCoeff	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyCoeff	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyCoeff	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyCoeff(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyCoeff	Eigen/src/Core/Swap.h	/^    void copyCoeff(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyCoeff	Eigen/src/Core/Swap.h	/^    void copyCoeff(Index rowId, Index colId, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyCoeff	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE void copyCoeff(Index row, Index col, Other& other)$/;"	f	class:Eigen::TriangularBase
copyCoeffByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyCoeffByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyPacket	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyPacket	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copyPacket	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyPacket	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    void copyPacket(Index row, Index col, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfCwiseBinaryOp
copyPacket	Eigen/src/Core/Swap.h	/^    void copyPacket(Index index, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyPacket	Eigen/src/Core/Swap.h	/^    void copyPacket(Index rowId, Index colId, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::SwapWrapper
copyPacketByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void copyPacketByOuterInner(Index outer, Index inner, const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseCoeffsBase
copy_bool	Eigen/src/Core/util/Macros.h	/^    inline bool copy_bool(bool b) { return b; }$/;"	f	namespace:Eigen::internal
copy_to_ucol	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^Index SparseLUImpl<Scalar,Index>::copy_to_ucol(const Index jcol, const Index nseg, IndexVector& segrep, BlockIndexVector repfnz ,IndexVector& perm_r, BlockScalarVector dense, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
corner	Eigen/src/Eigen2Support/Block.h	/^  ::corner(CornerType type, Index cRows, Index cCols)$/;"	f	class:Eigen::DenseBase
corner	Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type) const$/;"	f	class:Eigen::DenseBase
corner	Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type)$/;"	f	class:Eigen::DenseBase
corner	Eigen/src/Eigen2Support/Block.h	/^DenseBase<Derived>::corner(CornerType type, Index cRows, Index cCols) const$/;"	f	class:Eigen::DenseBase
corner	Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType corner(CornerType corner) const$/;"	f	class:Eigen::AlignedBox
cos	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cos() const$/;"	f	class:Eigen::Cwise
cos	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cos() const$/;"	f
count	Eigen/src/Core/BooleanRedux.h	/^inline typename DenseBase<Derived>::Index DenseBase<Derived>::count() const$/;"	f	class:Eigen::DenseBase
count	Eigen/src/Core/VectorwiseOp.h	/^    const PartialReduxExpr<ExpressionType, internal::member_count<Index>, Direction> count() const$/;"	f	class:Eigen::VectorwiseOp
count_dof	srLib/srExt/srExt_System.cpp	/^int srExt::srExtSystem::count_dof(bool count_weld) const$/;"	f	class:srExt::srExtSystem
count_dof	srLib/srExt/srExt_System.cpp	/^int srExt::srExtSystem::count_dof(srJoint * _joint, srLink * const _destination) const$/;"	f	class:srExt::srExtSystem
count_dof	srLib/srExt/srExt_System.cpp	/^int srExt::srExtSystem::count_dof(srLink * _link, srLink * const _destination) const$/;"	f	class:srExt::srExtSystem
count_dof	srLib/srExt/srExtension.cpp	/^int srExt::count_dof(srJoint * _joint, srLink * const _destination)$/;"	f	class:srExt
count_dof	srLib/srExt/srExtension.cpp	/^int srExt::count_dof(srLink * _link, srLink * const _destination)$/;"	f	class:srExt
count_dof	srLib/srExt/srExtension.cpp	/^int srExt::count_dof(srSystem * _system)$/;"	f	class:srExt
count_joint	srLib/srExt/srExt_System.cpp	/^int srExt::srExtSystem::count_joint(srJoint::JOINTTYPE _actType) const$/;"	f	class:srExt::srExtSystem
count_joint	srLib/srExt/srExtension.cpp	/^int srExt::count_joint(srSystem * _system, srJoint::JOINTTYPE _actType)$/;"	f	class:srExt
countnz	Eigen/src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,Index>::countnz(const Index n, Index& nnzL, Index& nnzU, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
cpuid_is_vendor	Eigen/src/Core/util/Memory.h	/^inline bool cpuid_is_vendor(int abcd[4], const int vendor[3])$/;"	f	namespace:Eigen::internal
cross	Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross	Eigen/src/Geometry/OrthoMethods.h	/^VectorwiseOp<ExpressionType,Direction>::cross(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
cross3	Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::cross3(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
cross3_impl	Eigen/src/Geometry/OrthoMethods.h	/^struct cross3_impl {$/;"	s	namespace:Eigen::internal
cross3_impl	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct cross3_impl<Architecture::SSE,VectorLhs,VectorRhs,float,true>$/;"	s	namespace:Eigen::internal
cross_product_return_type	Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> struct cross_product_return_type {$/;"	s	class:Eigen::MatrixBase
cs_tdfs	Eigen/src/OrderingMethods/Amd.h	/^Index cs_tdfs(Index j, Index k, Index *head, const Index *next, Index *post, Index *stack)$/;"	f	namespace:Eigen::internal
cs_wclear	Eigen/src/OrderingMethods/Amd.h	/^static int cs_wclear (Index mark, Index lemax, Index *w, Index n)$/;"	f	namespace:Eigen::internal
cube	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::cube() const$/;"	f	class:Eigen::Cwise
cube	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^cube() const$/;"	f
cullPoints	srLib/srDyn/srCollisionPair.cpp	/^void cullPoints (int n, SR_REAL p[], int m, int i0, int iret[])$/;"	f
culled	srLib/SceneGraph/gl2ps.c	/^  char boundary, offset, culled;$/;"	m	struct:__anon11	file:
curr_conf_	Example/DracoP1/Draco_Dyn_environment.h	/^        std::vector<double> curr_conf_;$/;"	m	class:Draco_Dyn_environment
curr_jvel_	Example/DracoP1/Draco_Dyn_environment.h	/^        std::vector<double> curr_jvel_;$/;"	m	class:Draco_Dyn_environment
cwise	Eigen/src/Eigen2Support/Cwise.h	/^inline Cwise<Derived> MatrixBase<Derived>::cwise()$/;"	f	class:Eigen::MatrixBase
cwise	Eigen/src/Eigen2Support/Cwise.h	/^inline const Cwise<Derived> MatrixBase<Derived>::cwise() const$/;"	f	class:Eigen::MatrixBase
cwiseAbs	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs() const { return derived(); }$/;"	f
cwiseAbs2	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseAbs2() const { return derived(); }$/;"	f
cwiseEqual	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseEqual	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseEqual(const Scalar& s) const$/;"	f
cwiseInverse	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseInverse() const { return derived(); }$/;"	f
cwiseMax	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMax	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMax(const Scalar &other) const$/;"	f
cwiseMin	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseMin	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseMin(const Scalar &other) const$/;"	f
cwiseNotEqual	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseNotEqual(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseProduct	Eigen/src/Core/MatrixBase.h	/^    cwiseProduct(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
cwiseProduct	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::cwiseProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
cwiseProduct	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseProduct(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseQuotient	Eigen/src/plugins/MatrixCwiseBinaryOps.h	/^cwiseQuotient(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
cwiseSqrt	Eigen/src/plugins/MatrixCwiseUnaryOps.h	/^cwiseSqrt() const { return derived(); }$/;"	f
dAccdp	srLib/srExt/srExt_System.h	/^			Eigen::MatrixXd dVdp, dVdotdp, dFdp, dAccdp;$/;"	m	struct:srExt::srExtSystem::linkState
dBoxBox__MARK7	srLib/srDyn/srCollisionPair.cpp	/^int dBoxBox__MARK7(const dVector3 p1, const dMatrix3 R1, const dVector3 side1,$/;"	f
dClosestLineBoxPoints	srLib/srDyn/srCollisionPair.cpp	/^void dClosestLineBoxPoints (const dVector3 p1, const dVector3 p2,$/;"	f
dColDetBoxSphere__MARK7	srLib/srDyn/srCollisionPair.cpp	/^int dColDetBoxSphere__MARK7(SR_REAL r0, const SE3 &T0,$/;"	f
dColDetSphereBox__MARK7	srLib/srDyn/srCollisionPair.cpp	/^int dColDetSphereBox__MARK7(SR_REAL r0, const SE3 &T0,$/;"	f
dContactGeom	srLib/srDyn/srCollisionPair.cpp	/^struct dContactGeom$/;"	s	file:
dFdp	srLib/srExt/srExt_System.h	/^			Eigen::MatrixXd dVdp, dVdotdp, dFdp, dAccdp;$/;"	m	struct:srExt::srExtSystem::linkState
dFdp	srLib/srExt/srExtension.h	/^		Eigen::MatrixXd dVdp, dVdotdp, dFdp;$/;"	m	struct:srExt::linkState
dLineClosestApproach	srLib/srDyn/srCollisionPair.cpp	/^void dLineClosestApproach (const dVector3 pa, const dVector3 ua,$/;"	f
dMULTIPLY0_331	srLib/srDyn/srCollisionPair.cpp	/^inline void dMULTIPLY0_331(SR_REAL *A, const SR_REAL *B, const SR_REAL *C)$/;"	f
dMULTIPLY1_331	srLib/srDyn/srCollisionPair.cpp	/^inline void dMULTIPLY1_331(SR_REAL *A, const SR_REAL *B, const SR_REAL *C)$/;"	f
dMULTIPLYOP0_331	srLib/srDyn/srCollisionPair.cpp	/^#define dMULTIPLYOP0_331(/;"	d	file:
dMULTIPLYOP1_331	srLib/srDyn/srCollisionPair.cpp	/^#define dMULTIPLYOP1_331(/;"	d	file:
dMatrix3	srLib/srDyn/srCollisionPair.cpp	/^typedef SR_REAL dMatrix3[12];$/;"	t	file:
dPAD_BK	srLib/srDyn/srISLAND.cpp	/^#define dPAD_BK(/;"	d	file:
dRand	srLib/srDyn/srISLAND.cpp	/^unsigned long dRand()$/;"	f
dRandInt	srLib/srDyn/srISLAND.cpp	/^int dRandInt (int n)$/;"	f
dRecip	srLib/srDyn/srCollisionPair.cpp	/^#define dRecip(/;"	d	file:
dSetValue_BK	srLib/srDyn/srISLAND.cpp	/^#define dSetValue_BK(/;"	d	file:
dSetZero_BK	srLib/srDyn/srISLAND.cpp	/^#define dSetZero_BK(/;"	d	file:
dSphereSphere__MARK7	srLib/srDyn/srCollisionPair.cpp	/^int dSphereSphere__MARK7(SR_REAL r0, const Vec3 &c0,$/;"	f
dTdp	srLib/srExt/srExt_System.h	/^			std::vector<Eigen::Matrix4d, Eigen::aligned_allocator<Eigen::Matrix4d>>	dTdp;$/;"	m	struct:srExt::srExtSystem::linkState
dVdotdp	srLib/srExt/srExt_System.h	/^			Eigen::MatrixXd dVdp, dVdotdp, dFdp, dAccdp;$/;"	m	struct:srExt::srExtSystem::linkState
dVdotdp	srLib/srExt/srExtension.h	/^		Eigen::MatrixXd dVdp, dVdotdp, dFdp;$/;"	m	struct:srExt::linkState
dVdp	srLib/srExt/srExt_System.h	/^			Eigen::MatrixXd dVdp, dVdotdp, dFdp, dAccdp;$/;"	m	struct:srExt::srExtSystem::linkState
dVdp	srLib/srExt/srExtension.h	/^		Eigen::MatrixXd dVdp, dVdotdp, dFdp;$/;"	m	struct:srExt::linkState
dVector3	srLib/srDyn/srCollisionPair.cpp	/^typedef SR_REAL dVector3[4];$/;"	t	file:
dad	srLib/srExt/srExt_LieGroup.h	/^	Eigen::Vector6d dad(const _se3& s, const _dse3& t)$/;"	f	namespace:srExt
data	Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.const_cast_derived().data(); }$/;"	f	class:Eigen::ArrayWrapper
data	Eigen/src/Core/ArrayWrapper.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.const_cast_derived().data(); }$/;"	f	class:Eigen::MatrixWrapper
data	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::ArrayWrapper
data	Eigen/src/Core/ArrayWrapper.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::MatrixWrapper
data	Eigen/src/Core/CwiseUnaryView.h	/^    inline Scalar* data() { return &coeffRef(0); }$/;"	f	class:Eigen::CwiseUnaryViewImpl
data	Eigen/src/Core/CwiseUnaryView.h	/^    inline const Scalar* data() const { return &coeff(0); }$/;"	f	class:Eigen::CwiseUnaryViewImpl
data	Eigen/src/Core/DenseStorage.h	/^    T *data() { return 0; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    T *data() { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    T *data() { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    const T *data() const { return 0; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    const T *data() const { return m_data.array; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/DenseStorage.h	/^    const T *data() const { return m_data; }$/;"	f	class:Eigen::DenseStorage
data	Eigen/src/Core/Diagonal.h	/^    inline ScalarWithConstIfNotLvalue* data() { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	Eigen/src/Core/Diagonal.h	/^    inline const Scalar* data() const { return &(m_matrix.const_cast_derived().coeffRef(rowOffset(), colOffset())); }$/;"	f	class:Eigen::Diagonal
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE  Scalar* data() { eigen_internal_assert(false && "should never be called"); return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return 0; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/GeneralProduct.h	/^  EIGEN_STRONG_INLINE Scalar* data() { return m_data.array; }$/;"	f	struct:Eigen::internal::gemv_static_vector_if
data	Eigen/src/Core/MapBase.h	/^    inline ScalarWithConstIfNotLvalue* data() { return this->m_data; } \/\/ no const-cast here so non-const-correct code will give a compile error$/;"	f	class:Eigen::MapBase
data	Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return m_data; }$/;"	f	class:Eigen::MapBase
data	Eigen/src/Core/MapBase.h	/^    inline const Scalar* data() const { return this->m_data; }$/;"	f	class:Eigen::MapBase
data	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Scalar *data()$/;"	f	class:Eigen::PlainObjectBase
data	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE const Scalar *data() const$/;"	f	class:Eigen::PlainObjectBase
data	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
data	Eigen/src/Core/Swap.h	/^    inline ScalarWithConstIfNotLvalue* data() { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper
data	Eigen/src/Core/Swap.h	/^    inline const Scalar* data() const { return m_expression.data(); }$/;"	f	class:Eigen::SwapWrapper
data	Eigen/src/Core/Transpose.h	/^    inline ScalarWithConstIfNotLvalue* data() { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	Eigen/src/Core/Transpose.h	/^    inline const Scalar* data() const { return derived().nestedExpression().data(); }$/;"	f	class:Eigen::TransposeImpl
data	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	Eigen/src/Geometry/Transform.h	/^  Scalar* data() { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	Eigen/src/Geometry/Transform.h	/^  const Scalar* data() const { return m_matrix.data(); }$/;"	f	class:Eigen::Transform
data	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseMatrix
data	Eigen/src/SparseCore/SparseVector.h	/^    inline Storage& data() { return m_data; }$/;"	f	class:Eigen::SparseVector
data	Eigen/src/SparseCore/SparseVector.h	/^    inline const Storage& data() const { return m_data; }$/;"	f	class:Eigen::SparseVector
data	srLib/SceneGraph/gl2ps.c	/^  } data;$/;"	m	struct:__anon11	typeref:union:__anon11::__anon12	file:
dcomplex	Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<double> dcomplex;$/;"	t	namespace:Eigen
deallocate	Eigen/src/Core/util/Memory.h	/^  void deallocate(pointer p, size_type \/*num*\/)$/;"	f	class:Eigen::aligned_allocator
debug	Eigen/src/Core/Assign.h	/^  static void debug()$/;"	f	struct:Eigen::internal::assign_traits
debug	Eigen/src/Core/GeneralProduct.h	/^  static void debug()$/;"	f	struct:Eigen::internal::product_type
dec	Eigen/src/misc/Image.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::image_retval_base
dec	Eigen/src/misc/Kernel.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::kernel_retval_base
dec	Eigen/src/misc/Solve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::solve_retval_base
dec	Eigen/src/misc/SparseSolve.h	/^  inline const DecompositionType& dec() const { return m_dec; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
decrement_size	Eigen/src/Householder/Householder.h	/^template<int n> struct decrement_size$/;"	s	namespace:Eigen::internal
defaultEvalTo	Eigen/src/misc/SparseSolve.h	/^    inline void defaultEvalTo(SparseMatrix<DestScalar,DestOptions,DestIndex>& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
default_packet_traits	Eigen/src/Core/GenericPacketMath.h	/^struct default_packet_traits$/;"	s	namespace:Eigen::internal
default_prunning_func	Eigen/src/SparseCore/SparseMatrix.h	/^    default_prunning_func(const Scalar& ref, const RealScalar& eps) : reference(ref), epsilon(eps) {}$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
default_prunning_func	Eigen/src/SparseCore/SparseMatrix.h	/^  struct default_prunning_func {$/;"	s	class:Eigen::SparseMatrix
degree	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index degree ;  \/* number of principal & non-principal columns in row *\/$/;"	m	union:internal::Colamd_Row::__anon353
degree_next	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index degree_next ; \/* next column, if col is in a degree list *\/$/;"	m	union:internal::colamd_col::__anon352
dense_xpr_base_dispatcher_for_doxygen	Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
dense_xpr_base_dispatcher_for_doxygen	Eigen/src/Core/PlainObjectBase.h	/^struct dense_xpr_base_dispatcher_for_doxygen<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
depth	srLib/srDyn/srCollisionPair.cpp	/^	SR_REAL depth;$/;"	m	struct:dContactGeom	file:
depth_select	Eigen/src/Core/GeneralProduct.h	/^    depth_select = product_size_category<Depth,MaxDepth>::value$/;"	e	enum:Eigen::internal::product_type::__anon284
deque	Eigen/src/StlSupport/StdDeque.h	/^  class deque<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
deque_base	Eigen/src/StlSupport/StdDeque.h	/^                Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > deque_base;$/;"	t	class:std::deque
derivative	srMath/Interpolation.h	/^	BSpline<-1, -1, Dimension> BSpline<CoefficientN, OrderK, Dimension>::derivative() const$/;"	f	class:srMath::BSpline
derived	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::CholmodBase
derived	Eigen/src/CholmodSupport/CholmodSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::CholmodBase
derived	Eigen/src/Core/DiagonalMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	Eigen/src/Core/DiagonalMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::DiagonalBase
derived	Eigen/src/Core/EigenBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	Eigen/src/Core/EigenBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	struct:Eigen::EigenBase
derived	Eigen/src/Core/Transpositions.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	Eigen/src/Core/Transpositions.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TranspositionsBase
derived	Eigen/src/Core/TriangularMatrix.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	Eigen/src/Core/TriangularMatrix.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::TriangularBase
derived	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	Eigen/src/Geometry/RotationBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	Eigen/src/Geometry/RotationBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::RotationBase
derived	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase
derived	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::IterativeSolverBase
derived	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PastixBase
derived	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PastixBase
derived	Eigen/src/PardisoSupport/PardisoSupport.h	/^    Derived& derived()$/;"	f	class:Eigen::PardisoImpl
derived	Eigen/src/PardisoSupport/PardisoSupport.h	/^    const Derived& derived() const$/;"	f	class:Eigen::PardisoImpl
derived	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SimplicialCholeskyBase
derived	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SparseMatrixBase
derived	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    Derived& derived() { return *static_cast<Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase
derived	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    const Derived& derived() const { return *static_cast<const Derived*>(this); }$/;"	f	class:Eigen::SuperLUBase
description	srLib/SceneGraph/gl2ps.c	/^  const char *description;$/;"	m	struct:__anon16	file:
dest	srLib/SceneGraph/gl2ps.c	/^  Bytef *dest, *src, *start;$/;"	m	struct:__anon13	file:
destLen	srLib/SceneGraph/gl2ps.c	/^  uLongf destLen, srcLen;$/;"	m	struct:__anon13	file:
destruct_elements_of_array	Eigen/src/Core/util/Memory.h	/^template<typename T> inline void destruct_elements_of_array(T *ptr, size_t size)$/;"	f	namespace:Eigen::internal
detect_super_cols	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static void detect_super_cols$/;"	f	namespace:internal
determinant	Eigen/src/Core/PermutationMatrix.h	/^    Index determinant() const$/;"	f	class:Eigen::PermutationBase
determinant	Eigen/src/Core/TriangularMatrix.h	/^    Scalar determinant() const$/;"	f	class:Eigen::TriangularView
determinant	Eigen/src/LU/Determinant.h	/^inline typename internal::traits<Derived>::Scalar MatrixBase<Derived>::determinant() const$/;"	f	class:Eigen::MatrixBase
determinant	Eigen/src/LU/FullPivLU.h	/^typename internal::traits<MatrixType>::Scalar FullPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::FullPivLU
determinant	Eigen/src/LU/PartialPivLU.h	/^typename internal::traits<MatrixType>::Scalar PartialPivLU<MatrixType>::determinant() const$/;"	f	class:Eigen::PartialPivLU
determinant	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialCholesky
determinant	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLDLT
determinant	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Scalar determinant() const$/;"	f	class:Eigen::SimplicialLLT
determinant	Eigen/src/SparseLU/SparseLU.h	/^    Scalar determinant()$/;"	f	class:Eigen::SparseLU
determinant	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^typename SuperLU<MatrixType>::Scalar SuperLU<MatrixType>::determinant() const$/;"	f	class:Eigen::SuperLU
determinant	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^typename UmfPackLU<MatrixType>::Scalar UmfPackLU<MatrixType>::determinant() const$/;"	f	class:Eigen::UmfPackLU
determinant_impl	Eigen/src/LU/Determinant.h	/^> struct determinant_impl$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 1>$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 2>$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 3>$/;"	s	namespace:Eigen::internal
determinant_impl	Eigen/src/LU/Determinant.h	/^template<typename Derived> struct determinant_impl<Derived, 4>$/;"	s	namespace:Eigen::internal
dfs_kernel	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,Index>::dfs_kernel(const Index jj, IndexVector& perm_r,$/;"	f	class:Eigen::internal::SparseLUImpl
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,Dynamic> diagonal(Index i)$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline Block<CoefficientsType,1,SizeAtCompileTime> diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,Dynamic> diagonal(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    inline const Block<const CoefficientsType,1,SizeAtCompileTime> diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    template<int N> inline const typename DiagonalIntReturnType<N>::Type diagonal() const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/BandMatrix.h	/^    template<int N> inline typename DiagonalIntReturnType<N>::Type diagonal()$/;"	f	class:Eigen::internal::BandMatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal() const$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal()$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index) const$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/Diagonal.h	/^MatrixBase<Derived>::diagonal(Index index)$/;"	f	class:Eigen::MatrixBase
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalWrapper
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline DiagonalVectorType& diagonal() { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return derived().diagonal(); }$/;"	f	class:Eigen::DiagonalBase
diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    inline const DiagonalVectorType& diagonal() const { return m_diagonal; }$/;"	f	class:Eigen::DiagonalMatrix
diagonal	Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,0> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct
diagonal	Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,DiagonalIndex> diagonal() const$/;"	f	class:Eigen::CoeffBasedProduct
diagonal	Eigen/src/Core/products/CoeffBasedProduct.h	/^    const Diagonal<const LazyCoeffBasedProductType,Dynamic> diagonal(Index index) const$/;"	f	class:Eigen::CoeffBasedProduct
diagonal	Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::diagonal() const$/;"	f	class:Eigen::Tridiagonalization
diagonal	Eigen/src/Geometry/AlignedBox.h	/^  inline CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> diagonal() const$/;"	f	class:Eigen::AlignedBox
diagonal	Eigen/src/SparseCore/SparseMatrix.h	/^    const Diagonal<const SparseMatrix> diagonal() const { return *this; }$/;"	f	class:Eigen::SparseMatrix
diagonalLength	Eigen/src/Core/BandMatrix.h	/^    inline Index diagonalLength(Index i) const$/;"	f	class:Eigen::internal::BandMatrixBase
diagonalSize	Eigen/src/Core/MatrixBase.h	/^    inline Index diagonalSize() const { return (std::min)(rows(),cols()); }$/;"	f	class:Eigen::MatrixBase
diffInvDyn	srLib/srExt/srExt_System.cpp	/^Eigen::MatrixXd srExt::srExtSystem::diffInvDyn(const Eigen::MatrixXd & _dqdp, const Eigen::MatrixXd & _dqdotdp, const Eigen::MatrixXd & _dqddotdp)$/;"	f	class:srExt::srExtSystem
diffInvDyn	srLib/srExt/srExtension.cpp	/^MatrixXd srExt::diffInvDyn(srSystem* _system, const Eigen::MatrixXd& _dqdp, const Eigen::MatrixXd& _dqdotdp, const Eigen::MatrixXd& _dqddotdp)$/;"	f	class:srExt
diffInvDyn_fast	srLib/srExt/srExtension.cpp	/^Eigen::MatrixXd srExt::diffInvDyn_fast(srSystem * _system, const Eigen::MatrixXd & _dqdp, const Eigen::MatrixXd & _dqdotdp, const Eigen::MatrixXd & _dqddotdp)$/;"	f	class:srExt
diffInvDyn_fast2	srLib/srExt/srExtension.cpp	/^Eigen::MatrixXd srExt::diffInvDyn_fast2(srSystem * _system, const Eigen::MatrixXd & _dqdp, const Eigen::MatrixXd & _dqdotdp, const Eigen::MatrixXd & _dqddotdp)$/;"	f	class:srExt
difference_type	Eigen/src/Core/util/Memory.h	/^  typedef std::ptrdiff_t  difference_type;$/;"	t	class:Eigen::aligned_allocator
difference_type	Eigen/src/StlSupport/details.h	/^    typedef ptrdiff_t difference_type;$/;"	t	class:Eigen::aligned_allocator_indirection
diffuse	srLib/SceneGraph/Light.h	/^	float			diffuse[4];$/;"	m	class:Light
diffuse	srLib/SceneGraph/Shader.h	/^	float			diffuse[4];$/;"	m	class:Shader
dim	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline int dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size()-1 : AmbientDimAtCompileTime; }$/;"	f	class:Eigen::AlignedBox
dim	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline int dim() const { return int(AmbientDimAtCompileTime)==Dynamic ? m_coeffs.size()-1 : int(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane
dim	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  inline int dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine
dim	Eigen/src/Geometry/AlignedBox.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_min.size() : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::AlignedBox
dim	Eigen/src/Geometry/Hyperplane.h	/^  inline Index dim() const { return AmbientDimAtCompileTime==Dynamic ? m_coeffs.size()-1 : Index(AmbientDimAtCompileTime); }$/;"	f	class:Eigen::Hyperplane
dim	Eigen/src/Geometry/ParametrizedLine.h	/^  inline Index dim() const { return m_direction.size(); }$/;"	f	class:Eigen::ParametrizedLine
dimensionOfKernel	Eigen/src/LU/FullPivLU.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivLU
dimensionOfKernel	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::ColPivHouseholderQR
dimensionOfKernel	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index dimensionOfKernel() const$/;"	f	class:Eigen::FullPivHouseholderQR
direct_selfadjoint_eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType,int Size,bool IsComplex> struct direct_selfadjoint_eigenvalues$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,2,false>$/;"	s	namespace:Eigen::internal
direct_selfadjoint_eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^template<typename SolverType> struct direct_selfadjoint_eigenvalues<SolverType,3,false>$/;"	s	namespace:Eigen::internal
direction	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& direction() { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
direction	Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& direction() const { return m_direction; }$/;"	f	class:Eigen::ParametrizedLine
distance	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { return ei_sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine
distance	Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar distance(const VectorType& p) const { using std::sqrt; return sqrt(squaredDistance(p)); }$/;"	f	class:Eigen::ParametrizedLine
doComputeEigenvectors	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::doComputeEigenvectors(const RealScalar& matrixnorm)$/;"	f	class:Eigen::ComplexEigenSolver
doComputeEigenvectors	Eigen/src/Eigenvalues/EigenSolver.h	/^void EigenSolver<MatrixType>::doComputeEigenvectors()$/;"	f	class:Eigen::EigenSolver
dot	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
dot	Eigen/src/Geometry/Quaternion.h	/^  template<class OtherDerived> inline Scalar dot(const QuaternionBase<OtherDerived>& other) const { return coeffs().dot(other.coeffs()); }$/;"	f	class:Eigen::QuaternionBase
dot	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::dot(const SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
dot	srLib/LieGroup/LieGroup.cpp	/^SR_REAL dot(const Quaternion& p, const Quaternion& q)$/;"	f
dot_nocheck	Eigen/src/Core/Dot.h	/^struct dot_nocheck$/;"	s	namespace:Eigen::internal
dot_nocheck	Eigen/src/Core/Dot.h	/^struct dot_nocheck<T, U, true>$/;"	s	namespace:Eigen::internal
dparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<RealScalar,IPARM_SIZE,1>& dparm()$/;"	f	class:Eigen::PastixBase
dparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    double& dparm(int idxparam)$/;"	f	class:Eigen::PastixBase
drawCameraFocus	srLib/SceneGraph/Camera.cpp	/^void Camera::drawCameraFocus(double height)$/;"	f	class:Camera
drawOpenCylinder	srLib/SceneGraph/Leaf.cpp	/^void Capsule::drawOpenCylinder()$/;"	f	class:Capsule
drawOpenDome	srLib/SceneGraph/Leaf.cpp	/^void DomeBase::drawOpenDome()$/;"	f	class:DomeBase
drawstyleBEHIND_EDGE	srLib/srg/srgGeometryDraw.h	/^	drawstyleBEHIND_EDGE	= 4		\/\/ Back feature line$/;"	e	enum:srgDrawStyle
drawstyleEDGE	srLib/srg/srgGeometryDraw.h	/^	drawstyleEDGE			= 3,	\/\/ Feature line$/;"	e	enum:srgDrawStyle
drawstyleFILL	srLib/srg/srgGeometryDraw.h	/^	drawstyleFILL			= 0,	\/\/ Volume$/;"	e	enum:srgDrawStyle
drawstyleLINE	srLib/srg/srgGeometryDraw.h	/^	drawstyleLINE			= 1,	\/\/ Wire frame$/;"	e	enum:srgDrawStyle
drawstyleSILHOUETTE	srLib/srg/srgGeometryDraw.h	/^	drawstyleSILHOUETTE		= 2,	\/\/ Out-line$/;"	e	enum:srgDrawStyle
dse3	srLib/LieGroup/LieGroup.h	/^class dse3$/;"	c
dse3	srMath/SE3.h	/^	typedef Vector6 dse3;$/;"	t	namespace:srMath
dso3	srMath/SO3.h	/^	typedef Vector3 dso3;$/;"	t	namespace:srMath
dummy	srLib/srDyn/srLink.h	/^	int dummy[10];$/;"	m	class:srLink
dumpMemory	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::CholmodBase
dumpMemory	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void dumpMemory(Stream& s)$/;"	f	class:Eigen::SimplicialCholeskyBase
dumpMemory	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void dumpMemory(Stream& \/*s*\/)$/;"	f	class:Eigen::SuperLUBase
dx	srLib/SceneGraph/Camera.h	/^	double			dx;$/;"	m	class:Camera
dy	srLib/SceneGraph/Camera.h	/^	double			dy;$/;"	m	class:Camera
edgePointList	srLib/SceneGraph/Leaf.h	/^	vector<vector<Vec3>>		edgePointList;$/;"	m	class:varianceStrap
ei_abs	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs (const T& x) { using std::abs; return abs(x); }$/;"	f	namespace:Eigen
ei_abs2	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_abs2(const T& x) { return numext::abs2(x); }$/;"	f	namespace:Eigen
ei_aligned_delete	Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline void ei_aligned_delete(T *ptr, size_t size)$/;"	f	namespace:Eigen
ei_aligned_free	Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_aligned_free(void *ptr) { internal::aligned_free(ptr); }$/;"	f	namespace:Eigen
ei_aligned_malloc	Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_malloc(size_t size) { return internal::aligned_malloc(size); }$/;"	f	namespace:Eigen
ei_aligned_new	Eigen/src/Eigen2Support/Memory.h	/^template<typename T> inline T* ei_aligned_new(size_t size)$/;"	f	namespace:Eigen
ei_aligned_realloc	Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_aligned_realloc(void *ptr, size_t new_size, size_t old_size) { return internal::aligned_realloc(ptr, new_size, old_size); }$/;"	f	namespace:Eigen
ei_assert	Eigen/src/Eigen2Support/Macros.h	/^#define ei_assert /;"	d
ei_atan2	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_atan2(const T& x,const T& y) { using std::atan2; return atan2(x,y); }$/;"	f	namespace:Eigen
ei_cleantype	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	s	namespace:Eigen
ei_cleantype	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_cleantype	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	s	namespace:Eigen
ei_conditional_aligned_free	Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void ei_conditional_aligned_free(void *ptr)$/;"	f	namespace:Eigen
ei_conditional_aligned_malloc	Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_malloc(size_t size)$/;"	f	namespace:Eigen
ei_conditional_aligned_realloc	Eigen/src/Eigen2Support/Memory.h	/^template<bool Align> inline void* ei_conditional_aligned_realloc(void* ptr, size_t new_size, size_t old_size)$/;"	f	namespace:Eigen
ei_conj	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_conj(const T& x) { return numext::conj(x); }$/;"	f	namespace:Eigen
ei_cos	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_cos (const T& x) { using std::cos;  return cos(x); }$/;"	f	namespace:Eigen
ei_declare_aligned_stack_constructed_variable	Eigen/src/Core/util/Memory.h	/^  #define ei_declare_aligned_stack_constructed_variable(/;"	d
ei_exp	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_exp (const T& x) { using std::exp;  return exp(x); }$/;"	f	namespace:Eigen
ei_handmade_aligned_free	Eigen/src/Eigen2Support/Memory.h	/^inline void  ei_handmade_aligned_free(void *ptr) { internal::handmade_aligned_free(ptr); }$/;"	f	namespace:Eigen
ei_handmade_aligned_malloc	Eigen/src/Eigen2Support/Memory.h	/^inline void* ei_handmade_aligned_malloc(size_t size) { return internal::handmade_aligned_malloc(size); }$/;"	f	namespace:Eigen
ei_imag	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_imag(const T& x) { return numext::imag(x); }$/;"	f	namespace:Eigen
ei_internal_assert	Eigen/src/Eigen2Support/Macros.h	/^#define ei_internal_assert /;"	d
ei_isApprox	Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen
ei_isApproxOrLessThan	Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen
ei_isMuchSmallerThan	Eigen/src/Eigen2Support/MathFunctions.h	/^inline bool ei_isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen
ei_is_same_type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_is_same_type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_log	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_log (const T& x) { using std::log;  return log(x); }$/;"	f	namespace:Eigen
ei_meta_false	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	s	namespace:Eigen
ei_meta_if	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	s	namespace:Eigen
ei_meta_if	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	s	namespace:Eigen
ei_meta_sqrt	Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c
ei_meta_true	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	s	namespace:Eigen
ei_pow	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_pow (const T& x,const T& y) { return numext::pow(x,y); }$/;"	f	namespace:Eigen
ei_quaternion_assign_impl	Eigen/src/Eigen2Support/Geometry/All.h	/^#define ei_quaternion_assign_impl /;"	d
ei_quaternion_assign_impl	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ei_quaternion_assign_impl$/;"	d
ei_quaternion_assign_impl	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,3,3>$/;"	s	namespace:Eigen
ei_quaternion_assign_impl	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^struct ei_quaternion_assign_impl<Other,4,1>$/;"	s	namespace:Eigen
ei_quaternion_product	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^ei_quaternion_product(const Quaternion<Scalar>& a, const Quaternion<Scalar>& b)$/;"	f	namespace:Eigen
ei_random	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random () { return internal::random<T>(); }$/;"	f	namespace:Eigen
ei_random	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_random (const T& x, const T& y) { return internal::random(x, y); }$/;"	f	namespace:Eigen
ei_real	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline typename NumTraits<T>::Real ei_real(const T& x) { return numext::real(x); }$/;"	f	namespace:Eigen
ei_sin	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sin (const T& x) { using std::sin;  return sin(x); }$/;"	f	namespace:Eigen
ei_sqrt	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T ei_sqrt(const T& x) { using std::sqrt; return sqrt(x); }$/;"	f	namespace:Eigen
ei_toRotationMatrix	Eigen/src/Eigen2Support/Geometry/All.h	/^#define ei_toRotationMatrix /;"	d
ei_toRotationMatrix	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ei_toRotationMatrix$/;"	d
ei_toRotationMatrix	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> ei_toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen
ei_toRotationMatrix	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> ei_toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen
ei_toRotationMatrix	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& ei_toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen
ei_traits	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^template<typename _Scalar> struct ei_traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^template<typename _Scalar> struct ei_traits<Quaternion<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^template<typename _Scalar> struct ei_traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen
ei_traits	Eigen/src/Eigen2Support/Meta.h	/^struct ei_traits : internal::traits<T>$/;"	s	namespace:Eigen
ei_transform_product_impl	Eigen/src/Eigen2Support/Geometry/All.h	/^#define ei_transform_product_impl /;"	d
ei_transform_product_impl	Eigen/src/Eigen2Support/Geometry/All.h	/^#undef ei_transform_product_impl$/;"	d
ei_transform_product_impl	Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen
ei_transform_product_impl	Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,1>$/;"	s	namespace:Eigen
ei_transform_product_impl	Eigen/src/Eigen2Support/Geometry/Transform.h	/^struct ei_transform_product_impl<Other,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen
ei_unconst	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	s	namespace:Eigen
ei_unconst	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	s	namespace:Eigen
ei_unconst	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	s	namespace:Eigen
ei_unconst	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	s	namespace:Eigen
ei_unpointer	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	s	namespace:Eigen
ei_unref	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	s	namespace:Eigen
eigen2_dot	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::eigen2_dot(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
eigen2_dot	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar eigen2_dot(const Quaternion& other) const { return m_coeffs.eigen2_dot(other.m_coeffs); }$/;"	f	class:Eigen::Quaternion
eigen2_lu	Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::eigen2_lu() const$/;"	f	class:Eigen::MatrixBase
eigen2_part_return_type	Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type$/;"	s	namespace:Eigen::internal
eigen2_part_return_type	Eigen/src/Core/TriangularMatrix.h	/^struct eigen2_part_return_type<MatrixType, SelfAdjoint>$/;"	s	namespace:Eigen::internal
eigen2_product_return_type	Eigen/src/Core/TriangularMatrix.h	/^    struct eigen2_product_return_type$/;"	s	class:Eigen::TriangularView
eigen_assert	Eigen/src/Core/util/Macros.h	/^#define eigen_assert(/;"	d
eigen_internal_assert	Eigen/src/Core/util/Macros.h	/^#define eigen_internal_assert(/;"	d
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, double *vals, int *perm, int * invp, double *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, float *vals, int *perm, int * invp, float *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<double> *vals, int *perm, int * invp, std::complex<double> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_pastix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void eigen_pastix(pastix_data_t **pastix_data, int pastix_comm, int n, int *ptr, int *idx, std::complex<float> *vals, int *perm, int * invp, std::complex<float> *x, int nbrhs, int *iparm, double *dparm)$/;"	f	namespace:Eigen::internal
eigen_plain_assert	Eigen/src/Core/util/Macros.h	/^    #define eigen_plain_assert(/;"	d
eigen_plain_assert	Eigen/src/Core/util/Macros.h	/^  #define eigen_plain_assert(/;"	d
eigen_unaligned_array_assert_workaround_gcc47	Eigen/src/Core/DenseStorage.h	/^  EIGEN_ALWAYS_INLINE PtrType eigen_unaligned_array_assert_workaround_gcc47(PtrType array) { return array; }$/;"	f	namespace:Eigen::internal
eigenvalues	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvalues	Eigen/src/Eigenvalues/EigenSolver.h	/^    const EigenvalueType& eigenvalues() const$/;"	f	class:Eigen::EigenSolver
eigenvalues	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    EigenvalueType eigenvalues() const$/;"	f	class:Eigen::GeneralizedEigenSolver
eigenvalues	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::eigenvalues() const$/;"	f	class:Eigen::MatrixBase
eigenvalues	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::eigenvalues() const$/;"	f	class:Eigen::SelfAdjointView
eigenvalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const RealVectorType& eigenvalues() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
eigenvalues_selector	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector$/;"	s	namespace:Eigen::internal
eigenvalues_selector	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^struct eigenvalues_selector<Derived, false>$/;"	s	namespace:Eigen::internal
eigenvectors	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    const EigenvectorType& eigenvectors() const$/;"	f	class:Eigen::ComplexEigenSolver
eigenvectors	Eigen/src/Eigenvalues/EigenSolver.h	/^typename EigenSolver<MatrixType>::EigenvectorsType EigenSolver<MatrixType>::eigenvectors() const$/;"	f	class:Eigen::EigenSolver
eigenvectors	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    const EigenvectorsType& eigenvectors() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
elseMatrix	Eigen/src/Core/Select.h	/^    const ElseMatrixType& elseMatrix() const$/;"	f	class:Eigen::Select
emptyIdxLU	Eigen/src/SparseLU/SparseLU_Memory.h	/^enum {emptyIdxLU = -1};$/;"	e	enum:Eigen::internal::__anon348
enable_if	Eigen/src/Core/util/Meta.h	/^template<typename T> struct enable_if<true,T>$/;"	s	namespace:Eigen::internal
end	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end() const$/;"	f	class:Eigen::MatrixBase
end	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end()$/;"	f	class:Eigen::MatrixBase
end	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size) const$/;"	f	class:Eigen::MatrixBase
end	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::end(Index size)$/;"	f	class:Eigen::MatrixBase
endFill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void endFill() {}$/;"	f	class:Eigen::SparseVector
endViewport	srLib/SceneGraph/gl2ps.c	/^  GLint (*endViewport)(void);$/;"	m	struct:__anon16	file:
entities	tinyxml2/tinyxml2.cpp	/^static const Entity entities[NUM_ENTITIES] = {$/;"	m	namespace:tinyxml2	file:
eps_div	srLib/srDyn/srISLAND.h	/^	SR_REAL eps_div;$/;"	m	struct:PGSOption
eps_ea	srLib/srDyn/srISLAND.h	/^	SR_REAL eps_ea;$/;"	m	struct:PGSOption
eps_res	srLib/srDyn/srISLAND.h	/^	SR_REAL eps_res;$/;"	m	struct:PGSOption
epsilon	Eigen/src/SparseCore/SparseMatrix.h	/^    RealScalar epsilon;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
erp_closedloop	srLib/srDyn/srClosedLoopConstraint.cpp	/^SR_REAL ClosedLoop::erp_closedloop = 0.8;$/;"	m	class:ClosedLoop	file:
erp_closedloop	srLib/srDyn/srClosedLoopConstraint.h	/^	static SR_REAL erp_closedloop;$/;"	m	class:ClosedLoop
erp_contact	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL ContactConstraint::erp_contact = 0.8;$/;"	m	class:ContactConstraint	file:
erp_contact	srLib/srDyn/srContactConstraint.h	/^	static SR_REAL erp_contact;$/;"	m	class:ContactConstraint
erp_jointpositionlimit	srLib/srDyn/srJointConstraint.cpp	/^SR_REAL JointConstraint::erp_jointpositionlimit = 0.8;$/;"	m	class:JointConstraint	file:
erp_jointpositionlimit	srLib/srDyn/srJointConstraint.h	/^	static SR_REAL erp_jointpositionlimit;$/;"	m	class:JointConstraint
error	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar error() const$/;"	f	class:Eigen::IterativeSolverBase
essentialVector	Eigen/src/Householder/HouseholderSequence.h	/^    const EssentialVectorType essentialVector(Index k) const$/;"	f	class:Eigen::HouseholderSequence
essentialVector	Eigen/src/Householder/HouseholderSequence.h	/^  static inline const EssentialVectorType essentialVector(const HouseholderSequenceType& h, Index k)$/;"	f	struct:Eigen::internal::hseq_side_dependent_impl
etree_find	Eigen/src/SparseCore/SparseColEtree.h	/^Index etree_find (Index i, IndexVector& pp)$/;"	f	namespace:Eigen::internal
eulerAngles	Eigen/src/Geometry/EulerAngles.h	/^MatrixBase<Derived>::eulerAngles(Index a0, Index a1, Index a2) const$/;"	f	class:Eigen::MatrixBase
eval	Eigen/src/Core/DenseBase.h	/^    EIGEN_STRONG_INLINE EvalReturnType eval() const$/;"	f	class:Eigen::DenseBase
eval	Eigen/src/Core/PermutationMatrix.h	/^    PlainPermutationType eval() const { return *this; }$/;"	f	class:Eigen::Transpose
eval	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline const typename internal::eval<Derived>::type eval() const$/;"	f	class:Eigen::SparseMatrixBase
eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct eval<T,Sparse>$/;"	s	namespace:Eigen::internal
evalTo	Eigen/src/Cholesky/LDLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/Cholesky/LLT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/CholmodSupport/CholmodSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/Core/ArrayWrapper.h	/^    inline void evalTo(Dest& dst) const { dst = m_expression; }$/;"	f	class:Eigen::ArrayWrapper
evalTo	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& evalTo(ActualDerived& dst, const ActualOtherDerived& other) { Transpose<ActualDerived> dstTrans(dst); other.evalTo(dstTrans); return dst; }$/;"	f	struct:Eigen::internal::assign_selector
evalTo	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& evalTo(ActualDerived& dst, const ActualOtherDerived& other) { other.evalTo(dst); return dst; }$/;"	f	struct:Eigen::internal::assign_selector
evalTo	Eigen/src/Core/BandMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::internal::BandMatrixBase
evalTo	Eigen/src/Core/DenseBase.h	/^    template<typename Dest> inline void evalTo(Dest& ) const$/;"	f	class:Eigen::DenseBase
evalTo	Eigen/src/Core/DiagonalMatrix.h	/^inline void DiagonalBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase
evalTo	Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
evalTo	Eigen/src/Core/GeneralProduct.h	/^    inline void evalTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct
evalTo	Eigen/src/Core/PermutationMatrix.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
evalTo	Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::PermutationBase
evalTo	Eigen/src/Core/PermutationMatrix.h	/^    void evalTo(MatrixBase<DenseDerived>& other) const$/;"	f	class:Eigen::Transpose
evalTo	Eigen/src/Core/ProductBase.h	/^    inline void evalTo(Dest& dst) const { dst.setZero(); scaleAndAddTo(dst, Scalar(1)); }$/;"	f	class:ScaledProduct
evalTo	Eigen/src/Core/ReturnByValue.h	/^    inline void evalTo(Dest& dst) const$/;"	f	class:Eigen::ReturnByValue
evalTo	Eigen/src/Core/SolveTriangular.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::triangular_solve_retval
evalTo	Eigen/src/Core/Transpositions.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
evalTo	Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
evalTo	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
evalTo	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
evalTo	Eigen/src/Geometry/Homogeneous.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
evalTo	Eigen/src/Householder/HouseholderSequence.h	/^    template<typename DestType> inline void evalTo(DestType& dst) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	Eigen/src/Householder/HouseholderSequence.h	/^    void evalTo(Dest& dst, Workspace& workspace) const$/;"	f	class:Eigen::HouseholderSequence
evalTo	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval
evalTo	Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval
evalTo	Eigen/src/LU/FullPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/LU/Inverse.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::inverse_impl
evalTo	Eigen/src/LU/PartialPivLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/PardisoSupport/PardisoSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/QR/ColPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/QR/FullPivHouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	Eigen/src/QR/FullPivHouseholderQR.h	/^  void evalTo(ResultType& result, WorkVectorType& workspace) const$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
evalTo	Eigen/src/QR/HouseholderQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  void evalTo(ResType& res) const$/;"	f	struct:Eigen::SPQR_QProduct
evalTo	Eigen/src/SVD/JacobiSVD.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/SparseCore/SparseMatrixBase.h	/^    void evalTo(MatrixBase<DenseDerived>& dst) const$/;"	f	class:Eigen::SparseMatrixBase
evalTo	Eigen/src/SparseCore/SparsePermutation.h	/^    template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
evalTo	Eigen/src/SparseCore/SparseProduct.h	/^    void evalTo(Dest& result) const$/;"	f	class:Eigen::SparseSparseProduct
evalTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar,int StorageOrder> void evalTo(SparseMatrix<DestScalar,StorageOrder,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView
evalTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestScalar> void evalTo(DynamicSparseMatrix<DestScalar,ColMajor,Index>& _dest) const$/;"	f	class:Eigen::SparseSelfAdjointView
evalTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename DestType,unsigned int DestUpLo> void evalTo(SparseSelfAdjointView<DestType,DestUpLo>& dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
evalTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    void evalTo(SparseMatrix<DestScalar,Options,DstIndex>& _dest) const$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
evalTo	Eigen/src/SparseLU/SparseLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SparseLU/SparseLU.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(MatrixBase<Dest>& dest) const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
evalTo	Eigen/src/SparseQR/SparseQR.h	/^  template<typename Dest> void evalTo(SparseMatrixBase<Dest>& dest) const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
evalTo	Eigen/src/SparseQR/SparseQR.h	/^  void evalTo(DesType& res) const$/;"	f	struct:Eigen::SparseQR_QProduct
evalTo	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval
evalTo	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename Dest> void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval
evalTo	Eigen/src/misc/Image.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::image_retval_base
evalTo	Eigen/src/misc/Kernel.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::kernel_retval_base
evalTo	Eigen/src/misc/Solve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_base
evalTo	Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::solve_retval_with_guess
evalTo	Eigen/src/misc/SparseSolve.h	/^  template<typename Dest> inline void evalTo(Dest& dst) const$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
evalToLazy	Eigen/src/Core/TriangularMatrix.h	/^void TriangularBase<Derived>::evalToLazy(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::TriangularBase
exp	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::exp() const$/;"	f	class:Eigen::Cwise
exp	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^exp() const$/;"	f
exp	srLib/LieGroup/LieGroup.cpp	/^Quaternion& Quaternion::exp()$/;"	f	class:Quaternion
expand	Eigen/src/SparseLU/SparseLU_Memory.h	/^Index  SparseLUImpl<Scalar,Index>::expand(VectorType& vec, Index& length, Index nbElts, Index keep_prev, Index& num_expansions) $/;"	f	class:Eigen::internal::SparseLUImpl
expression	Eigen/src/Core/NoAlias.h	/^    ExpressionType& expression() const$/;"	f	class:Eigen::NoAlias
expression	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& expression() const $/;"	f	class:Eigen::SelfCwiseBinaryOp
expression	Eigen/src/Core/Swap.h	/^    ExpressionType& expression() const { return m_expression; }$/;"	f	class:Eigen::SwapWrapper
extend	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
extend	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const VectorType& p)$/;"	f	class:Eigen::AlignedBox
extend	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const AlignedBox& b)$/;"	f	class:Eigen::AlignedBox
extend	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& extend(const MatrixBase<Derived>& p)$/;"	f	class:Eigen::AlignedBox
extendedTo	Eigen/src/Core/VectorwiseOp.h	/^    extendedTo(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
extendedToOpposite	Eigen/src/Core/VectorwiseOp.h	/^    extendedToOpposite(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
exteriorDistance	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline Scalar exteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox
exteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
exteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^  inline NonInteger exteriorDistance(const MatrixBase<Derived>& p) const$/;"	f	class:Eigen::AlignedBox
extgs_stack	srLib/SceneGraph/gl2ps.c	/^  int extgs_stack; \/* graphics state object number *\/$/;"	m	struct:__anon15	file:
extract	Eigen/src/Core/Transpose.h	/^  static inline const XprType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return Base::extract(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extract	Eigen/src/Core/util/BlasUtil.h	/^  static inline ExtractType extract(const XprType& x) { return x; }$/;"	f	struct:Eigen::internal::blas_traits
extractData	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLUBase<MatrixType,Derived>::extractData() const$/;"	f	class:Eigen::SuperLUBase
extractData	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^void UmfPackLU<MatrixType>::extractData() const$/;"	f	class:Eigen::UmfPackLU
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return Base::extractScalarFactor(x.nestedExpression()); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x) { return conj(Base::extractScalarFactor(x.nestedExpression())); }$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline Scalar extractScalarFactor(const XprType& x)$/;"	f	struct:Eigen::internal::blas_traits
extractScalarFactor	Eigen/src/Core/util/BlasUtil.h	/^  static inline const Scalar extractScalarFactor(const XprType&) { return Scalar(1); }$/;"	f	struct:Eigen::internal::blas_traits
extract_data	Eigen/src/Core/util/BlasUtil.h	/^template<typename T> const typename T::Scalar* extract_data(const T& m)$/;"	f	namespace:Eigen::internal
extract_data_selector	Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector {$/;"	s	namespace:Eigen::internal
extract_data_selector	Eigen/src/Core/util/BlasUtil.h	/^struct extract_data_selector<T,false> {$/;"	s	namespace:Eigen::internal
extract_kernel	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline bool extract_kernel(MatrixType& mat, Ref<VectorType> res, Ref<VectorType> representative)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
facet	srLib/common/srSTL.h	/^		facet()$/;"	f	class:srSTL::facet
facet	srLib/common/srSTL.h	/^	class facet$/;"	c	namespace:srSTL
factor	Eigen/src/Geometry/Scaling.h	/^  inline Scalar& factor() { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	Eigen/src/Geometry/Scaling.h	/^  inline const Scalar& factor() const { return m_factor; }$/;"	f	class:Eigen::UniformScaling
factor	srLib/SceneGraph/gl2ps.c	/^  GLint factor;$/;"	m	struct:__anon11	file:
factorize	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::CholmodBase
factorize	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    DiagonalPreconditioner& factorize(const MatType& mat)$/;"	f	class:Eigen::DiagonalPreconditioner
factorize	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    IdentityPreconditioner& factorize(const MatrixType& ) { return *this; }$/;"	f	class:Eigen::IdentityPreconditioner
factorize	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::factorize(const _MatrixType& amat)$/;"	f	class:Eigen::IncompleteLUT
factorize	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& factorize(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLDLT
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLLT
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void factorize(const MatrixType& matrix)$/;"	f	class:Eigen::PastixLU
factorize	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::factorize(ColSpMatrix& mat)$/;"	f	class:Eigen::PastixBase
factorize	Eigen/src/PardisoSupport/PardisoSupport.h	/^Derived& PardisoImpl<Derived>::factorize(const MatrixType& a)$/;"	f	class:Eigen::PardisoImpl
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholesky
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialCholeskyBase
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLDLT
factorize	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    void factorize(const MatrixType& a)$/;"	f	class:Eigen::SimplicialLLT
factorize	Eigen/src/SparseLU/SparseLU.h	/^void SparseLU<MatrixType, OrderingType>::factorize(const MatrixType& matrix)$/;"	f	class:Eigen::SparseLU
factorize	Eigen/src/SparseQR/SparseQR.h	/^void SparseQR<MatrixType,OrderingType>::factorize(const MatrixType& mat)$/;"	f	class:Eigen::SparseQR
factorize	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperILU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperILU
factorize	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^void SuperLU<MatrixType>::factorize(const MatrixType& a)$/;"	f	class:Eigen::SuperLU
factorize	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize(const InputMatrixType& matrix)$/;"	f	class:Eigen::UmfPackLU
factorize_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void factorize_impl()$/;"	f	class:Eigen::UmfPackLU
factorize_preordered	Eigen/src/SparseCholesky/SimplicialCholesky_impl.h	/^void SimplicialCholeskyBase<Derived>::factorize_preordered(const CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
false_type	Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
features	build/CMakeFiles/feature_tests.c	/^  const char features[] = {"\\n"$/;"	v
features	build/CMakeFiles/feature_tests.cxx	/^  const char features[] = {"\\n"$/;"	v
feedback	srLib/SceneGraph/gl2ps.c	/^  GLfloat *feedback, offset[2], lastlinewidth;$/;"	m	struct:__anon15	file:
file_extension	srLib/SceneGraph/gl2ps.c	/^  const char *file_extension;$/;"	m	struct:__anon16	file:
filename	srLib/SceneGraph/gl2ps.c	/^  char *title, *producer, *filename;$/;"	m	struct:__anon15	file:
fill	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE void DenseBase<Derived>::fill(const Scalar& val)$/;"	f	class:Eigen::DenseBase
fill	Eigen/src/Core/TriangularMatrix.h	/^    void fill(const Scalar& value) { setConstant(value); }$/;"	f	class:Eigen::TriangularView
fill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index i)$/;"	f	class:Eigen::SparseVector
fill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fill(Index r, Index c)$/;"	f	class:Eigen::SparseVector
fillfactor	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index fillfactor; \/\/ The estimated fills factors for L and U, compared with A$/;"	m	struct:Eigen::internal::perfvalues
fillrand	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index i)$/;"	f	class:Eigen::SparseVector
fillrand	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED Scalar& fillrand(Index r, Index c)$/;"	f	class:Eigen::SparseVector
finalize	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void finalize()$/;"	f	class:Eigen::SparseMatrix
finalize	Eigen/src/SparseCore/SparseVector.h	/^    inline void finalize() {}$/;"	f	class:Eigen::SparseVector
find	srLib/LieGroup/_array.h	/^	int find(const TYPE &value) const$/;"	f	class:_array
findSmallDiagEntry	Eigen/src/Eigenvalues/RealQZ.h	/^    inline typename MatrixType::Index RealQZ<MatrixType>::findSmallDiagEntry(Index f, Index l)$/;"	f	class:Eigen::RealQZ
findSmallSubdiagEntry	Eigen/src/Eigenvalues/RealQZ.h	/^    inline typename MatrixType::Index RealQZ<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealQZ
findSmallSubdiagEntry	Eigen/src/Eigenvalues/RealSchur.h	/^inline typename MatrixType::Index RealSchur<MatrixType>::findSmallSubdiagEntry(Index iu)$/;"	f	class:Eigen::RealSchur
find_next	srLib/LieGroup/_array.h	/^	int find_next(const TYPE &value, int idx) const$/;"	f	class:_array
find_ordering	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static Index find_ordering \/* return the number of garbage collections *\/$/;"	f	namespace:internal
find_pop	srLib/LieGroup/_array.h	/^	void find_pop(const TYPE &value)$/;"	f	class:_array
finished	Eigen/src/Core/CommaInitializer.h	/^  inline XprType& finished() {$/;"	f	struct:Eigen::CommaInitializer
first	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket first;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket
first_aligned	Eigen/src/Core/DenseCoeffsBase.h	/^static inline typename Derived::Index first_aligned(const Derived& m)$/;"	f	namespace:Eigen::internal
first_aligned	Eigen/src/Core/util/Memory.h	/^static inline Index first_aligned(const Scalar* array, Index size)$/;"	f	namespace:Eigen::internal
first_aligned_impl	Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl$/;"	s	namespace:Eigen::internal
first_aligned_impl	Eigen/src/Core/DenseCoeffsBase.h	/^struct first_aligned_impl<Derived, false>$/;"	s	namespace:Eigen::internal
first_column	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index first_column ;\/* first column in row (used in garbage collection) *\/$/;"	m	union:internal::Colamd_Row::__anon354
first_multiple	Eigen/src/Core/util/Memory.h	/^inline static Index first_multiple(Index size, Index base)$/;"	f	namespace:Eigen::internal
fitHyperplane	Eigen/src/Eigen2Support/LeastSquares.h	/^void fitHyperplane(int numPoints,$/;"	f	namespace:Eigen
fixed_joint_	Example/DracoP1/draco.h	/^  std::vector<srWeldJoint*> fixed_joint_;$/;"	m	class:srDraco
fixed_joint_idx_map_	Example/DracoP1/draco.h	/^  std::map<std::string, int> fixed_joint_idx_map_;$/;"	m	class:srDraco
fixupL	Eigen/src/SparseLU/SparseLU_Utils.h	/^void SparseLUImpl<Scalar,Index>::fixupL(const Index n, const IndexVector& perm_r, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
flagged	Eigen/src/Core/Flagged.h	/^DenseBase<Derived>::flagged() const$/;"	f	class:Eigen::DenseBase
flags	Eigen/src/Core/IO.h	/^  int flags;$/;"	m	struct:Eigen::IOFormat
floor_log2	Eigen/src/Core/MathFunctions.h	/^struct floor_log2 {};$/;"	s	namespace:Eigen::internal
floor_log2	Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_bogus>$/;"	s	namespace:Eigen::internal
floor_log2	Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_down>$/;"	s	namespace:Eigen::internal
floor_log2	Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_move_up>$/;"	s	namespace:Eigen::internal
floor_log2	Eigen/src/Core/MathFunctions.h	/^struct floor_log2<n, lower, upper, floor_log2_terminate>$/;"	s	namespace:Eigen::internal
floor_log2_bogus	Eigen/src/Core/MathFunctions.h	/^  floor_log2_bogus$/;"	e	enum:Eigen::internal::__anon206
floor_log2_move_down	Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_down,$/;"	e	enum:Eigen::internal::__anon206
floor_log2_move_up	Eigen/src/Core/MathFunctions.h	/^  floor_log2_move_up,$/;"	e	enum:Eigen::internal::__anon206
floor_log2_selector	Eigen/src/Core/MathFunctions.h	/^template<unsigned int n, int lower, int upper> struct floor_log2_selector$/;"	s	namespace:Eigen::internal
floor_log2_terminate	Eigen/src/Core/MathFunctions.h	/^  floor_log2_terminate,$/;"	e	enum:Eigen::internal::__anon206
focus_vec	srLib/SceneGraph/Camera.h	/^	Vec3			focus_vec;$/;"	m	class:Camera
font_stack	srLib/SceneGraph/gl2ps.c	/^  int font_stack; \/* font object number *\/$/;"	m	struct:__anon15	file:
fontname	srLib/SceneGraph/gl2ps.c	/^  char *str, *fontname;$/;"	m	struct:__anon9	file:
fontno	srLib/SceneGraph/gl2ps.c	/^  int gsno, fontno, imno, shno, maskshno, trgroupno;$/;"	m	struct:__anon14	file:
fontobjno	srLib/SceneGraph/gl2ps.c	/^  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;$/;"	m	struct:__anon14	file:
fontsize	srLib/SceneGraph/gl2ps.c	/^  GLshort fontsize;$/;"	m	struct:__anon9	file:
force	srLib/SceneGraph/Leaf.h	/^	dse3		force;$/;"	m	class:ForceVector
forceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccess	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccess()$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf() const$/;"	f	class:Eigen::MatrixBase
forceAlignedAccessIf	Eigen/src/Core/ForceAlignedAccess.h	/^MatrixBase<Derived>::forceAlignedAccessIf()$/;"	f	class:Eigen::MatrixBase
format	Eigen/src/Core/IO.h	/^DenseBase<Derived>::format(const IOFormat& fmt) const$/;"	f	class:Eigen::DenseBase
format	srLib/SceneGraph/gl2ps.c	/^  GLenum format, type;$/;"	m	struct:__anon10	file:
format	srLib/SceneGraph/gl2ps.c	/^  GLint format, sort, options, colorsize, colormode, buffersize;$/;"	m	struct:__anon15	file:
fortran_to_c_numbering	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  void fortran_to_c_numbering (MatrixType& mat)$/;"	f	namespace:Eigen::internal
frames	srLib/SceneGraph/Leaf.h	/^	vector<SE3>			frames;$/;"	m	class:Tube
fromEigenVec	srLib/srExt/srExt_LieGroup.h	/^	SRtype fromEigenVec(const MatrixType& _vec)$/;"	f	namespace:srExt
fromPositionOrientationScale	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform
fromPositionOrientationScale	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::fromPositionOrientationScale(const MatrixBase<PositionDerived> &position,$/;"	f	class:Eigen::Transform
fromRotationMatrix	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D
fromRotationMatrix	Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
fromRotationMatrix	Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>& Rotation2D<Scalar>::fromRotationMatrix(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::Rotation2D
front	srLib/SceneGraph/gl2ps.c	/^  GL2PSbsptree *front, *back;$/;"	m	struct:_GL2PSbsptree	file:
front	srLib/SceneGraph/gl2ps.c	/^  GL2PSbsptree2d *front, *back;$/;"	m	struct:_GL2PSbsptree2d	file:
fsincos	srMath/Common.h	/^	static void fsincos(Real theta, \/\/\/< Angle in radians $/;"	f	namespace:srMath
fullPivHouseholderQr	Eigen/src/QR/FullPivHouseholderQR.h	/^MatrixBase<Derived>::fullPivHouseholderQr() const$/;"	f	class:Eigen::MatrixBase
fullPivLu	Eigen/src/LU/FullPivLU.h	/^MatrixBase<Derived>::fullPivLu() const$/;"	f	class:Eigen::MatrixBase
func	srMath/Function.cpp	/^	VectorX AffineFunction::func(const VectorX & x) const$/;"	f	class:srMath::AffineFunction
func	srMath/Function.cpp	/^	VectorX AugmentedFunction::func(const VectorX& x) const$/;"	f	class:srMath::AugmentedFunction
func	srMath/Function.cpp	/^	VectorX MultiplyConstFunction::func(const VectorX & x) const$/;"	f	class:srMath::MultiplyConstFunction
func	srMath/Function.cpp	/^	VectorX QuadraticFunction::func(const VectorX & x) const$/;"	f	class:srMath::QuadraticFunction
func	srMath/Function.h	/^		VectorX func(const VectorX& x) const { return VectorX(); }$/;"	f	class:srMath::EmptyFunction
functor	Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseBinaryOp
functor	Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseNullaryOp
functor	Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryOp
functor	Eigen/src/Core/CwiseUnaryView.h	/^    const ViewOp& functor() const { return m_functor; }$/;"	f	class:Eigen::CwiseUnaryView
functor	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& functor() const $/;"	f	class:Eigen::SelfCwiseBinaryOp
functor_has_linear_access	Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_has_linear_access	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_is_product_like { enum { ret = 0 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_is_product_like	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_quotient_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs2_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_abs_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_acos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_add_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_asin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_binary_pow_op<Scalar,OtherScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cast_op<Scalar,NewType> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cmp_op<Scalar, cmp> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conj_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_conjugate_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_constant_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cos_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_cube_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_difference_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_exp_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_hypot_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_identity_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_imag_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_inverse_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_log_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_max_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_min_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple2_op<Scalar1,Scalar2> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_multiple_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_opposite_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_pow_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_product_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient1_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_quotient_op<LhsScalar,RhsScalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_real_ref_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sin_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sqrt_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_square_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_sum_op<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<scalar_tan_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_compose<T0,T1,T2> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::binary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder1st<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::binder2nd<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::divides<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::greater_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::less<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::less_equal<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_and<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_not<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::logical_or<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::minus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::multiplies<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::not_equal_to<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::plus<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::project1st<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::project2nd<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::select1st<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::select2nd<std::pair<T0,T1> > >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_compose<T0,T1> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^struct functor_traits<std::unary_negate<T> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct functor_traits< linspaced_op<Scalar,RandomAccess> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_and_op> {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Functors.h	/^template<> struct functor_traits<scalar_boolean_or_op> {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Random.h	/^struct functor_traits<scalar_random_op<Scalar> >$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Visitor.h	/^struct functor_traits<max_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
functor_traits	Eigen/src/Core/Visitor.h	/^struct functor_traits<min_coeff_visitor<Scalar> > {$/;"	s	namespace:Eigen::internal
fval	srMath/Interpolation.h	/^	Eigen::Matrix<Real, Dimension, 1> BSpline<CoefficientN, OrderK, Dimension>::fval(const Real& x)$/;"	f	class:srMath::BSpline
fwdKin	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::fwdKin(const Vec3 & _gravity)$/;"	f	class:srExt::srExtSystem
fwdKin	srLib/srExt/srExtension.cpp	/^void srExt::fwdKin(srSystem* _system, const Vec3& _gravity)$/;"	f	class:srExt
g	srLib/SceneGraph/Leaf.h	/^	double				r, g, b, alpha;$/;"	m	class:Polygon
g	srLib/SceneGraph/Leaf.h	/^	double g;$/;"	m	class:ColorPoint
g	srLib/SceneGraph/Leaf.h	/^	double g;$/;"	m	class:ColorPointGroup
g	srLib/SceneGraph/Model3DS.h	/^		unsigned char g;$/;"	m	struct:Model3DS::Color4i
gDyn_env	Example/DracoP1/simulation_draco.cpp	/^Draco_Dyn_environment* gDyn_env = new Draco_Dyn_environment();$/;"	v
gGround	Example/MobileRobots/MobileRobots.cpp	/^Ground gGround;$/;"	v
gPlate	Example/MobileRobots/MobileRobots.cpp	/^srSystem	gPlate;$/;"	v
gPlateCollision	Example/MobileRobots/MobileRobots.cpp	/^srCollision	gPlateCollision;$/;"	v
gPlateLink	Example/MobileRobots/MobileRobots.cpp	/^srLink		gPlateLink;$/;"	v
gSpace	Example/MobileRobots/MobileRobots.cpp	/^srSpace gSpace;$/;"	v
gUphill	Example/MobileRobots/MobileRobots.cpp	/^srLink		gUphill;			\/\/ link for uphill obstacle$/;"	v
gUphillCollision	Example/MobileRobots/MobileRobots.cpp	/^srCollision	gUphillCollision;	\/\/ collision for uphill obstacle$/;"	v
gUphillSystem	Example/MobileRobots/MobileRobots.cpp	/^srSystem	gUphillSystem;		\/\/ system for uphill obstacle$/;"	v
garbage_collection	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static Index garbage_collection  \/* returns the new value of pfree *\/$/;"	f	namespace:internal
gebp_kernel	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gebp_kernel$/;"	s	namespace:Eigen::internal
gebp_madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void gebp_madd(const CJ& cj, A& a, B& b, C& c, T& t)$/;"	f	namespace:Eigen::internal
gebp_madd_selector	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename A, typename B, typename C, typename T> struct gebp_madd_selector {$/;"	s	namespace:Eigen::internal
gebp_madd_selector	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  template<typename CJ, typename T> struct gebp_madd_selector<CJ,T,T,T,T> {$/;"	s	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits$/;"	c	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<RealScalar, std::complex<RealScalar>, false, _ConjRhs >$/;"	c	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, RealScalar, _ConjLhs, false>$/;"	c	namespace:Eigen::internal
gebp_traits	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^class gebp_traits<std::complex<RealScalar>, std::complex<RealScalar>, _ConjLhs, _ConjRhs >$/;"	c	namespace:Eigen::internal
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex \/*rows*\/, DenseIndex \/*cols*\/, DenseIndex \/*depth*\/)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    gemm_blocking_space(DenseIndex rows, DenseIndex cols, DenseIndex depth)$/;"	f	class:Eigen::internal::gemm_blocking_space
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, false>$/;"	c	namespace:Eigen::internal
gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class gemm_blocking_space<StorageOrder,_LhsScalar,_RhsScalar,MaxRows, MaxCols, MaxDepth, KcFactor, true>$/;"	c	namespace:Eigen::internal
gemm_functor	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  gemm_functor(const Lhs& lhs, const Rhs& rhs, Dest& dest, const Scalar& actualAlpha,$/;"	f	struct:Eigen::internal::gemm_functor
gemm_functor	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct gemm_functor$/;"	s	namespace:Eigen::internal
gemm_pack_lhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_lhs$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, ColMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemm_pack_rhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^struct gemm_pack_rhs<Scalar, Index, nr, RowMajor, Conjugate, PanelMode>$/;"	s	namespace:Eigen::internal
gemv_selector	Eigen/src/Core/GeneralProduct.h	/^struct gemv_selector<OnTheLeft,StorageOrder,BlasCompatible>$/;"	s	namespace:Eigen::internal
gemv_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,ColMajor,true>$/;"	s	namespace:Eigen::internal
gemv_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,false>$/;"	s	namespace:Eigen::internal
gemv_selector	Eigen/src/Core/GeneralProduct.h	/^template<> struct gemv_selector<OnTheRight,RowMajor,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,Dynamic,true>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,false>$/;"	s	namespace:Eigen::internal
gemv_static_vector_if	Eigen/src/Core/GeneralProduct.h	/^struct gemv_static_vector_if<Scalar,Size,MaxSize,true>$/;"	s	namespace:Eigen::internal
general_det3_helper	Eigen/src/LU/Inverse.h	/^inline const typename Derived::Scalar general_det3_helper$/;"	f	namespace:Eigen::internal
general_matrix_matrix_product	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_product	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct general_matrix_matrix_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_rankupdate	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^struct general_matrix_matrix_rankupdate :$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,ColMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_matrix_triangular_product	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_matrix_matrix_triangular_product<Index,LhsScalar,LhsStorageOrder,ConjugateLhs,RhsScalar,RhsStorageOrder,ConjugateRhs,RowMajor,UpLo,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product	Eigen/src/Core/products/GeneralMatrixVector.h	/^struct general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>$/;"	s	namespace:Eigen::internal
general_matrix_vector_product_gemv	Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^struct general_matrix_vector_product_gemv :$/;"	s	namespace:Eigen::internal
general_product_to_triangular_selector	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,false>$/;"	s	namespace:Eigen
general_product_to_triangular_selector	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct general_product_to_triangular_selector<MatrixType,ProductType,UpLo,true>$/;"	s	namespace:Eigen
generic_aligned_realloc	Eigen/src/Core/util/Memory.h	/^inline void* generic_aligned_realloc(void* ptr, size_t size, size_t old_size)$/;"	f	namespace:Eigen::internal
get	Eigen/src/SparseCore/SparseDenseProduct.h	/^    static Scalar get(const _RhsNested &rhs, Index outer, Dense = Dense())$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
get	Eigen/src/SparseCore/SparseDenseProduct.h	/^    static Scalar get(const _RhsNested &rhs, Index outer, Sparse = Sparse())$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
getA	srMath/Function.h	/^		const MatrixX& getA() const { return _A; }$/;"	f	class:srMath::AffineFunction
getCameraMatrix	srLib/SceneGraph/Camera.cpp	/^SE3 Camera::getCameraMatrix()$/;"	f	class:Camera
getCollision	srLib/common/srRobot.cpp	/^srCollision* srRobot::getCollision(string collisionname)$/;"	f	class:srRobot
getControlPoints	srMath/Interpolation.h	/^		const Eigen::Matrix<Real, Dimension, ((CoefficientN == -1) ? -1 : CoefficientN)>& getControlPoints() const { return _controlPoints; }$/;"	f	class:srMath::BSpline
getJoint	srLib/common/srRobot.cpp	/^srJoint* srRobot::getJoint(string jointname)$/;"	f	class:srRobot
getJointValue	srLib/srExt/srExt_System.cpp	/^Eigen::VectorXd srExt::srExtSystem::getJointValue(bool count_weld) const$/;"	f	class:srExt::srExtSystem
getJointValue	srLib/srExt/srExt_System.cpp	/^Eigen::VectorXd srExt::srExtSystem::getJointValue(srLink * const _endEffector, srLink * _baseLink) const$/;"	f	class:srExt::srExtSystem
getJointValue	srLib/srExt/srExtension.cpp	/^VectorXd srExt::getJointValue(srLink * const _endEffector, srLink * _baseLink)$/;"	f	class:srExt
getKnots	srMath/Interpolation.h	/^		const Eigen::Matrix<Real, ((OrderK == -1) || (CoefficientN == -1) ? -1 : CoefficientN + OrderK), 1>& getKnots() const { return _knots; }$/;"	f	class:srMath::BSpline
getL	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits
getL	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits
getL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixL getL(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::traits
getLink	srLib/common/srRobot.cpp	/^srLink* srRobot::getLink(string linkname)$/;"	f	class:srRobot
getMatrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLDLT
getMatrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLLT
getMatrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void getMatrix(const MatrixType& matrix)$/;"	f	class:Eigen::PardisoLU
getMaxIterations	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexEigenSolver
getMaxIterations	Eigen/src/Eigenvalues/ComplexSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::ComplexSchur
getMaxIterations	Eigen/src/Eigenvalues/EigenSolver.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::EigenSolver
getMaxIterations	Eigen/src/Eigenvalues/RealSchur.h	/^    Index getMaxIterations()$/;"	f	class:Eigen::RealSchur
getNormal	srLib/SceneGraph/Leaf.cpp	/^Vec3 varianceStrap::getNormal(int row, int col)$/;"	f	class:varianceStrap
getPosition	srMath/SE3.cpp	/^	const Vector3& SE3::getPosition() const$/;"	f	class:srMath::SE3
getRotation	srMath/SE3.cpp	/^	const SO3& SE3::getRotation() const$/;"	f	class:srMath::SE3
getScreeShot	srLib/SceneGraph/SceneGraphRenderer.h	/^	static bool getScreeShot() {return bScreenShot; }$/;"	f	class:SceneGraphRenderer
getU	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	Eigen/src/Cholesky/LDLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LDLT_Traits
getU	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	Eigen/src/Cholesky/LLT.h	/^  static inline MatrixU getU(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::LLT_Traits
getU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^  static inline MatrixU getU(const MatrixType& m) { return m.adjoint(); }$/;"	f	struct:Eigen::internal::traits
getX	srMath/SO3.cpp	/^	Vector3 SO3::getX() const$/;"	f	class:srMath::SO3
getY	srMath/SO3.cpp	/^	Vector3 SO3::getY() const$/;"	f	class:srMath::SO3
getZ	srMath/SO3.cpp	/^	Vector3 SO3::getZ() const$/;"	f	class:srMath::SO3
get_at	srLib/LieGroup/_array.h	/^	TYPE& get_at(int i)$/;"	f	class:_array
get_factor	Eigen/src/Core/util/BlasUtil.h	/^template<typename From,typename To> struct get_factor {$/;"	s	namespace:Eigen::internal
get_factor	Eigen/src/Core/util/BlasUtil.h	/^template<typename Scalar> struct get_factor<Scalar,typename NumTraits<Scalar>::Real> {$/;"	s	namespace:Eigen::internal
get_size	srLib/LieGroup/_array.h	/^	int get_size(void) const$/;"	f	class:_array
get_symmetrized_graph	Eigen/src/MetisSupport/MetisSupport.h	/^  void get_symmetrized_graph(const MatrixType& A)$/;"	f	class:Eigen::MetisOrdering
getb	srMath/Function.h	/^		const VectorX& getb() const { return _b; }$/;"	f	class:srMath::AffineFunction
gird	srMath/Common.h	/^	static VectorX gird(Real start, Real end, unsigned int N)$/;"	f	namespace:srMath
gl2ps	srLib/SceneGraph/gl2ps.c	/^static GL2PScontext *gl2ps = NULL;$/;"	v	file:
gl2psAdaptVertexForBlending	srLib/SceneGraph/gl2ps.c	/^static void gl2psAdaptVertexForBlending(GL2PSvertex *v)$/;"	f	file:
gl2psAddBoundaryInList	srLib/SceneGraph/gl2ps.c	/^static void gl2psAddBoundaryInList(GL2PSprimitive *prim, GL2PSlist *list)$/;"	f	file:
gl2psAddInBspImageTree	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psAddInBspImageTree(GL2PSprimitive *prim, GL2PSbsptree2d **tree)$/;"	f	file:
gl2psAddInImageTree	srLib/SceneGraph/gl2ps.c	/^static void gl2psAddInImageTree(void *data)$/;"	f	file:
gl2psAddIndex	srLib/SceneGraph/gl2ps.c	/^static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb,$/;"	f	file:
gl2psAddPlanesInBspTreeImage	srLib/SceneGraph/gl2ps.c	/^static void gl2psAddPlanesInBspTreeImage(GL2PSprimitive *prim,$/;"	f	file:
gl2psAddPolyPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts,$/;"	f	file:
gl2psAddPrimitiveInList	srLib/SceneGraph/gl2ps.c	/^static void gl2psAddPrimitiveInList(GL2PSprimitive *prim, GL2PSlist *list)$/;"	f	file:
gl2psAddText	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psAddText(GLint type, const char *str, const char *fontname,$/;"	f	file:
gl2psAllocCompress	srLib/SceneGraph/gl2ps.c	/^static int gl2psAllocCompress(unsigned int srcsize)$/;"	f	file:
gl2psAssignTriangleProperties	srLib/SceneGraph/gl2ps.c	/^static void gl2psAssignTriangleProperties(GL2PStriangle *t)$/;"	f	file:
gl2psBeginPage	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,$/;"	f
gl2psBeginViewport	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4])$/;"	f
gl2psBlendFunc	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psBlendFunc(GLenum sfactor, GLenum dfactor)$/;"	f
gl2psBuildBspTree	srLib/SceneGraph/gl2ps.c	/^static void gl2psBuildBspTree(GL2PSbsptree *tree, GL2PSlist *primitives)$/;"	f	file:
gl2psBuildPolygonBoundary	srLib/SceneGraph/gl2ps.c	/^static void gl2psBuildPolygonBoundary(GL2PSbsptree *tree)$/;"	f	file:
gl2psCheckPoint	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psCheckPoint(GL2PSxyz point, GL2PSplane plane)$/;"	f	file:
gl2psCheckPrimitive	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psCheckPrimitive(GL2PSprimitive *prim, GL2PSplane plane)$/;"	f	file:
gl2psClosePDFDataStream	srLib/SceneGraph/gl2ps.c	/^static int gl2psClosePDFDataStream(void)$/;"	f	file:
gl2psCompareDepth	srLib/SceneGraph/gl2ps.c	/^static int gl2psCompareDepth(const void *a, const void *b)$/;"	f	file:
gl2psComparePointPlane	srLib/SceneGraph/gl2ps.c	/^static GLfloat gl2psComparePointPlane(GL2PSxyz point, GL2PSplane plane)$/;"	f	file:
gl2psComputeTightBoundingBox	srLib/SceneGraph/gl2ps.c	/^static void gl2psComputeTightBoundingBox(void *data)$/;"	f	file:
gl2psConvertPixmapToPNG	srLib/SceneGraph/gl2ps.c	/^static void gl2psConvertPixmapToPNG(GL2PSimage *pixmap, GL2PSlist *png)$/;"	f	file:
gl2psCopyPixmap	srLib/SceneGraph/gl2ps.c	/^static GL2PSimage *gl2psCopyPixmap(GL2PSimage *im)$/;"	f	file:
gl2psCopyPrimitive	srLib/SceneGraph/gl2ps.c	/^static GL2PSprimitive *gl2psCopyPrimitive(GL2PSprimitive *p)$/;"	f	file:
gl2psCopyText	srLib/SceneGraph/gl2ps.c	/^static GL2PSstring *gl2psCopyText(GL2PSstring *t)$/;"	f	file:
gl2psCreateSplitPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psCreateSplitPrimitive(GL2PSprimitive *parent, GL2PSplane plane,$/;"	f	file:
gl2psCreateSplitPrimitive2D	srLib/SceneGraph/gl2ps.c	/^static GL2PSprimitive *gl2psCreateSplitPrimitive2D(GL2PSprimitive *parent,$/;"	f	file:
gl2psCutEdge	srLib/SceneGraph/gl2ps.c	/^static void gl2psCutEdge(GL2PSvertex *a, GL2PSvertex *b, GL2PSplane plane,$/;"	f	file:
gl2psDeflate	srLib/SceneGraph/gl2ps.c	/^static int gl2psDeflate(void)$/;"	f	file:
gl2psDisable	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psDisable(GLint mode)$/;"	f
gl2psDivideQuad	srLib/SceneGraph/gl2ps.c	/^static void gl2psDivideQuad(GL2PSprimitive *quad,$/;"	f	file:
gl2psDrawImageMap	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psDrawImageMap(GLsizei width, GLsizei height,$/;"	f
gl2psDrawPixels	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,$/;"	f
gl2psEPS	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend gl2psEPS = {$/;"	v	file:
gl2psEnable	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psEnable(GLint mode)$/;"	f
gl2psEncodeBase64Block	srLib/SceneGraph/gl2ps.c	/^static void gl2psEncodeBase64Block(unsigned char in[3], unsigned char out[4], int len)$/;"	f	file:
gl2psEndPage	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psEndPage(void)$/;"	f
gl2psEndPostScriptLine	srLib/SceneGraph/gl2ps.c	/^static void gl2psEndPostScriptLine(void)$/;"	f	file:
gl2psEndSVGLine	srLib/SceneGraph/gl2ps.c	/^static void gl2psEndSVGLine(void)$/;"	f	file:
gl2psEndViewport	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psEndViewport(void)$/;"	f
gl2psFillTriangleFromPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psFillTriangleFromPrimitive(GL2PStriangle *t, GL2PSprimitive *p,$/;"	f	file:
gl2psFindRoot	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psFindRoot(GL2PSlist *primitives, GL2PSprimitive **root)$/;"	f	file:
gl2psFree	srLib/SceneGraph/gl2ps.c	/^static void gl2psFree(void *ptr)$/;"	f	file:
gl2psFreeBspImageTree	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreeBspImageTree(GL2PSbsptree2d **tree)$/;"	f	file:
gl2psFreeBspTree	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreeBspTree(GL2PSbsptree **tree)$/;"	f	file:
gl2psFreeCompress	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreeCompress(void)$/;"	f	file:
gl2psFreeImagemap	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreeImagemap(GL2PSimagemap *list)$/;"	f	file:
gl2psFreePixmap	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreePixmap(GL2PSimage *im)$/;"	f	file:
gl2psFreePrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreePrimitive(void *data)$/;"	f	file:
gl2psFreeText	srLib/SceneGraph/gl2ps.c	/^static void gl2psFreeText(GL2PSstring *text)$/;"	f	file:
gl2psGetFileExtension	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API const char *gl2psGetFileExtension(GLint format)$/;"	f
gl2psGetFileFormat	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psGetFileFormat()$/;"	f
gl2psGetFormatDescription	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API const char *gl2psGetFormatDescription(GLint format)$/;"	f
gl2psGetIndex	srLib/SceneGraph/gl2ps.c	/^static GLshort gl2psGetIndex(GLshort i, GLshort num)$/;"	f	file:
gl2psGetNormal	srLib/SceneGraph/gl2ps.c	/^static void gl2psGetNormal(GLfloat *a, GLfloat *b, GLfloat *c)$/;"	f	file:
gl2psGetOptions	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psGetOptions(GLint *options)$/;"	f
gl2psGetPlane	srLib/SceneGraph/gl2ps.c	/^static void gl2psGetPlane(GL2PSprimitive *prim, GL2PSplane plane)$/;"	f	file:
gl2psGetPlaneFromPoints	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psGetPlaneFromPoints(GL2PSxyz a, GL2PSxyz b, GL2PSplane plane)$/;"	f	file:
gl2psGetRGB	srLib/SceneGraph/gl2ps.c	/^static GLfloat gl2psGetRGB(GL2PSimage *im, GLuint x, GLuint y,$/;"	f	file:
gl2psGetVertex	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psGetVertex(GL2PSvertex *v, GLfloat *p)$/;"	f	file:
gl2psGreater	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psGreater(GLfloat f1, GLfloat f2)$/;"	f	file:
gl2psInitTriangle	srLib/SceneGraph/gl2ps.c	/^static void gl2psInitTriangle(GL2PStriangle *t)$/;"	f	file:
gl2psLess	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psLess(GLfloat f1, GLfloat f2)$/;"	f	file:
gl2psLineWidth	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psLineWidth(GLfloat value)$/;"	f
gl2psListAction	srLib/SceneGraph/gl2ps.c	/^static void gl2psListAction(GL2PSlist *list, void (*action)(void *data))$/;"	f	file:
gl2psListActionInverse	srLib/SceneGraph/gl2ps.c	/^static void gl2psListActionInverse(GL2PSlist *list, void (*action)(void *data))$/;"	f	file:
gl2psListAdd	srLib/SceneGraph/gl2ps.c	/^static void gl2psListAdd(GL2PSlist *list, void *data)$/;"	f	file:
gl2psListCreate	srLib/SceneGraph/gl2ps.c	/^static GL2PSlist *gl2psListCreate(GLint n, GLint incr, GLint size)$/;"	f	file:
gl2psListDelete	srLib/SceneGraph/gl2ps.c	/^static void gl2psListDelete(GL2PSlist *list)$/;"	f	file:
gl2psListEncodeBase64	srLib/SceneGraph/gl2ps.c	/^static void gl2psListEncodeBase64(GL2PSlist *list)$/;"	f	file:
gl2psListNbr	srLib/SceneGraph/gl2ps.c	/^static int gl2psListNbr(GL2PSlist *list)$/;"	f	file:
gl2psListPointer	srLib/SceneGraph/gl2ps.c	/^static void *gl2psListPointer(GL2PSlist *list, GLint idx)$/;"	f	file:
gl2psListRead	srLib/SceneGraph/gl2ps.c	/^static void gl2psListRead(GL2PSlist *list, int index, void *data)$/;"	f	file:
gl2psListRealloc	srLib/SceneGraph/gl2ps.c	/^static void gl2psListRealloc(GL2PSlist *list, GLint n)$/;"	f	file:
gl2psListReset	srLib/SceneGraph/gl2ps.c	/^static void gl2psListReset(GL2PSlist *list)$/;"	f	file:
gl2psListSort	srLib/SceneGraph/gl2ps.c	/^static void gl2psListSort(GL2PSlist *list,$/;"	f	file:
gl2psMalloc	srLib/SceneGraph/gl2ps.c	/^static void *gl2psMalloc(size_t size)$/;"	f	file:
gl2psMsg	srLib/SceneGraph/gl2ps.c	/^static void gl2psMsg(GLint level, const char *fmt, ...)$/;"	f	file:
gl2psNorm	srLib/SceneGraph/gl2ps.c	/^static GLfloat gl2psNorm(GLfloat *a)$/;"	f	file:
gl2psOpenPDFDataStream	srLib/SceneGraph/gl2ps.c	/^static int gl2psOpenPDFDataStream(void)$/;"	f	file:
gl2psOpenPDFDataStreamWritePreface	srLib/SceneGraph/gl2ps.c	/^static int gl2psOpenPDFDataStreamWritePreface(void)$/;"	f	file:
gl2psPDF	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend gl2psPDF = {$/;"	v	file:
gl2psPDFRectHull	srLib/SceneGraph/gl2ps.c	/^static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax,$/;"	f	file:
gl2psPDFgroupListDelete	srLib/SceneGraph/gl2ps.c	/^static void gl2psPDFgroupListDelete(void)$/;"	f	file:
gl2psPDFgroupListInit	srLib/SceneGraph/gl2ps.c	/^static void gl2psPDFgroupListInit(void)$/;"	f	file:
gl2psPDFgroupListWriteFontResources	srLib/SceneGraph/gl2ps.c	/^static int gl2psPDFgroupListWriteFontResources(void)$/;"	f	file:
gl2psPDFgroupListWriteGStateResources	srLib/SceneGraph/gl2ps.c	/^static int gl2psPDFgroupListWriteGStateResources(void)$/;"	f	file:
gl2psPDFgroupListWriteMainStream	srLib/SceneGraph/gl2ps.c	/^static void gl2psPDFgroupListWriteMainStream(void)$/;"	f	file:
gl2psPDFgroupListWriteObjects	srLib/SceneGraph/gl2ps.c	/^static int gl2psPDFgroupListWriteObjects(int entryoffs)$/;"	f	file:
gl2psPDFgroupListWriteShaderResources	srLib/SceneGraph/gl2ps.c	/^static int gl2psPDFgroupListWriteShaderResources(void)$/;"	f	file:
gl2psPDFgroupListWriteVariableResources	srLib/SceneGraph/gl2ps.c	/^static int gl2psPDFgroupListWriteVariableResources(void)$/;"	f	file:
gl2psPDFgroupListWriteXObjectResources	srLib/SceneGraph/gl2ps.c	/^static int gl2psPDFgroupListWriteXObjectResources(void)$/;"	f	file:
gl2psPDFgroupObjectInit	srLib/SceneGraph/gl2ps.c	/^static void gl2psPDFgroupObjectInit(GL2PSpdfgroup *gro)$/;"	f	file:
gl2psPDFstacksInit	srLib/SceneGraph/gl2ps.c	/^static void gl2psPDFstacksInit(void)$/;"	f	file:
gl2psPGF	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend gl2psPGF = {$/;"	v	file:
gl2psPGFTextAlignment	srLib/SceneGraph/gl2ps.c	/^static const char *gl2psPGFTextAlignment(int align)$/;"	f	file:
gl2psPS	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend gl2psPS = {$/;"	v	file:
gl2psParseFeedbackBuffer	srLib/SceneGraph/gl2ps.c	/^static void gl2psParseFeedbackBuffer(GLint used)$/;"	f	file:
gl2psParseStipplePattern	srLib/SceneGraph/gl2ps.c	/^static void gl2psParseStipplePattern(GLushort pattern, GLint factor,$/;"	f	file:
gl2psPointSize	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psPointSize(GLfloat value)$/;"	f
gl2psPrintGzipFooter	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintGzipFooter(void)$/;"	f	file:
gl2psPrintGzipHeader	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintGzipHeader(void)$/;"	f	file:
gl2psPrintPDFBeginViewport	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPDFBeginViewport(GLint viewport[4])$/;"	f	file:
gl2psPrintPDFCatalog	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFCatalog(void)$/;"	f	file:
gl2psPrintPDFCompressorType	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFCompressorType(void)$/;"	f	file:
gl2psPrintPDFDataStreamLength	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFDataStreamLength(int val)$/;"	f	file:
gl2psPrintPDFEndViewport	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psPrintPDFEndViewport(void)$/;"	f	file:
gl2psPrintPDFFillColor	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFFillColor(GL2PSrgba rgba)$/;"	f	file:
gl2psPrintPDFFinalPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPDFFinalPrimitive(void)$/;"	f	file:
gl2psPrintPDFFooter	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPDFFooter(void)$/;"	f	file:
gl2psPrintPDFGSObject	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFGSObject(void)$/;"	f	file:
gl2psPrintPDFHeader	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPDFHeader(void)$/;"	f	file:
gl2psPrintPDFInfo	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFInfo(void)$/;"	f	file:
gl2psPrintPDFLineWidth	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFLineWidth(GLfloat lw)$/;"	f	file:
gl2psPrintPDFOpenPage	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFOpenPage(void)$/;"	f	file:
gl2psPrintPDFPages	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFPages(void)$/;"	f	file:
gl2psPrintPDFPixmap	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFPixmap(int obj, int childobj, GL2PSimage *im, int gray)$/;"	f	file:
gl2psPrintPDFPixmapStreamData	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFPixmapStreamData(GL2PSimage *im,$/;"	f	file:
gl2psPrintPDFPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPDFPrimitive(void *data)$/;"	f	file:
gl2psPrintPDFShader	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles,$/;"	f	file:
gl2psPrintPDFShaderExtGS	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderExtGS(int obj, int childobj)$/;"	f	file:
gl2psPrintPDFShaderMask	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderMask(int obj, int childobj)$/;"	f	file:
gl2psPrintPDFShaderSimpleExtGS	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderSimpleExtGS(int obj, GLfloat alpha)$/;"	f	file:
gl2psPrintPDFShaderStreamData	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle,$/;"	f	file:
gl2psPrintPDFShaderStreamDataAlpha	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex,$/;"	f	file:
gl2psPrintPDFShaderStreamDataCoord	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex,$/;"	f	file:
gl2psPrintPDFShaderStreamDataRGB	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFShaderStreamDataRGB(GL2PSvertex *vertex,$/;"	f	file:
gl2psPrintPDFStrokeColor	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFStrokeColor(GL2PSrgba rgba)$/;"	f	file:
gl2psPrintPDFText	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPDFText(int obj, GL2PSstring *s, int fontnumber)$/;"	f	file:
gl2psPrintPGFBeginViewport	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFBeginViewport(GLint viewport[4])$/;"	f	file:
gl2psPrintPGFColor	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFColor(GL2PSrgba rgba)$/;"	f	file:
gl2psPrintPGFDash	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFDash(GLushort pattern, GLint factor)$/;"	f	file:
gl2psPrintPGFEndViewport	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psPrintPGFEndViewport(void)$/;"	f	file:
gl2psPrintPGFFinalPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFFinalPrimitive(void)$/;"	f	file:
gl2psPrintPGFFooter	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFFooter(void)$/;"	f	file:
gl2psPrintPGFHeader	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFHeader(void)$/;"	f	file:
gl2psPrintPGFPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPGFPrimitive(void *data)$/;"	f	file:
gl2psPrintPostScriptBeginViewport	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptBeginViewport(GLint viewport[4])$/;"	f	file:
gl2psPrintPostScriptColor	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptColor(GL2PSrgba rgba)$/;"	f	file:
gl2psPrintPostScriptDash	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintPostScriptDash(GLushort pattern, GLint factor, const char *str)$/;"	f	file:
gl2psPrintPostScriptEndViewport	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psPrintPostScriptEndViewport(void)$/;"	f	file:
gl2psPrintPostScriptFinalPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptFinalPrimitive(void)$/;"	f	file:
gl2psPrintPostScriptFooter	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptFooter(void)$/;"	f	file:
gl2psPrintPostScriptHeader	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptHeader(void)$/;"	f	file:
gl2psPrintPostScriptImagemap	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptImagemap(GLfloat x, GLfloat y,$/;"	f	file:
gl2psPrintPostScriptPixmap	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptPixmap(GLfloat x, GLfloat y, GL2PSimage *im)$/;"	f	file:
gl2psPrintPostScriptPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintPostScriptPrimitive(void *data)$/;"	f	file:
gl2psPrintPrimitives	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psPrintPrimitives(void)$/;"	f	file:
gl2psPrintSVGBeginViewport	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGBeginViewport(GLint viewport[4])$/;"	f	file:
gl2psPrintSVGDash	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGDash(GLushort pattern, GLint factor)$/;"	f	file:
gl2psPrintSVGEndViewport	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psPrintSVGEndViewport(void)$/;"	f	file:
gl2psPrintSVGFinalPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGFinalPrimitive(void)$/;"	f	file:
gl2psPrintSVGFooter	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGFooter(void)$/;"	f	file:
gl2psPrintSVGHeader	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGHeader(void)$/;"	f	file:
gl2psPrintSVGPixmap	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGPixmap(GLfloat x, GLfloat y, GL2PSimage *pixmap)$/;"	f	file:
gl2psPrintSVGPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGPrimitive(void *data)$/;"	f	file:
gl2psPrintSVGSmoothTriangle	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintSVGSmoothTriangle(GL2PSxyz xyz[3], GL2PSrgba rgba[3])$/;"	f	file:
gl2psPrintTeXBeginViewport	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintTeXBeginViewport(GLint viewport[4])$/;"	f	file:
gl2psPrintTeXEndViewport	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psPrintTeXEndViewport(void)$/;"	f	file:
gl2psPrintTeXFinalPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintTeXFinalPrimitive(void)$/;"	f	file:
gl2psPrintTeXFooter	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintTeXFooter(void)$/;"	f	file:
gl2psPrintTeXHeader	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintTeXHeader(void)$/;"	f	file:
gl2psPrintTeXPrimitive	srLib/SceneGraph/gl2ps.c	/^static void gl2psPrintTeXPrimitive(void *data)$/;"	f	file:
gl2psPrintf	srLib/SceneGraph/gl2ps.c	/^static int gl2psPrintf(const char* fmt, ...)$/;"	f	file:
gl2psPsca	srLib/SceneGraph/gl2ps.c	/^static GLfloat gl2psPsca(GLfloat *a, GLfloat *b)$/;"	f	file:
gl2psPutPDFImage	srLib/SceneGraph/gl2ps.c	/^static void gl2psPutPDFImage(GL2PSimage *image, int cnt, GLfloat x, GLfloat y)$/;"	f	file:
gl2psPutPDFSpecial	srLib/SceneGraph/gl2ps.c	/^static void gl2psPutPDFSpecial(GL2PSstring *text)$/;"	f	file:
gl2psPutPDFText	srLib/SceneGraph/gl2ps.c	/^static void gl2psPutPDFText(GL2PSstring *text, int cnt, GLfloat x, GLfloat y)$/;"	f	file:
gl2psPvec	srLib/SceneGraph/gl2ps.c	/^static void gl2psPvec(GLfloat *a, GLfloat *b, GLfloat *c)$/;"	f	file:
gl2psRealloc	srLib/SceneGraph/gl2ps.c	/^static void *gl2psRealloc(void *ptr, size_t size)$/;"	f	file:
gl2psReallocCompress	srLib/SceneGraph/gl2ps.c	/^static void *gl2psReallocCompress(unsigned int srcsize)$/;"	f	file:
gl2psRescaleAndOffset	srLib/SceneGraph/gl2ps.c	/^static void gl2psRescaleAndOffset(void)$/;"	f	file:
gl2psResetPostScriptColor	srLib/SceneGraph/gl2ps.c	/^static void gl2psResetPostScriptColor(void)$/;"	f	file:
gl2psSVG	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend gl2psSVG = {$/;"	v	file:
gl2psSVGGetColorString	srLib/SceneGraph/gl2ps.c	/^static void gl2psSVGGetColorString(GL2PSrgba rgba, char str[32])$/;"	f	file:
gl2psSVGGetCoordsAndColors	srLib/SceneGraph/gl2ps.c	/^static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts,$/;"	f	file:
gl2psSameColor	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psSameColor(GL2PSrgba rgba1, GL2PSrgba rgba2)$/;"	f	file:
gl2psSameColorThreshold	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psSameColorThreshold(int n, GL2PSrgba rgba[],$/;"	f	file:
gl2psSamePosition	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psSamePosition(GL2PSxyz p1, GL2PSxyz p2)$/;"	f	file:
gl2psSetLastColor	srLib/SceneGraph/gl2ps.c	/^static void gl2psSetLastColor(GL2PSrgba rgba)$/;"	f	file:
gl2psSetOptions	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psSetOptions(GLint options)$/;"	f
gl2psSetupCompress	srLib/SceneGraph/gl2ps.c	/^static void gl2psSetupCompress(void)$/;"	f	file:
gl2psSortOutTrianglePDFgroup	srLib/SceneGraph/gl2ps.c	/^static void gl2psSortOutTrianglePDFgroup(GL2PSpdfgroup *gro)$/;"	f	file:
gl2psSpecial	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str)$/;"	f
gl2psSplitPrimitive	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane,$/;"	f	file:
gl2psSplitPrimitive2D	srLib/SceneGraph/gl2ps.c	/^static void gl2psSplitPrimitive2D(GL2PSprimitive *prim,$/;"	f	file:
gl2psSupportedBlendMode	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psSupportedBlendMode(GLenum sfactor, GLenum dfactor)$/;"	f	file:
gl2psTEX	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend gl2psTEX = {$/;"	v	file:
gl2psTestSplitPrimitive	srLib/SceneGraph/gl2ps.c	/^static GLint gl2psTestSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane)$/;"	f	file:
gl2psText	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, GLshort fontsize)$/;"	f
gl2psTextOpt	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,$/;"	f
gl2psTextOptColor	srLib/SceneGraph/gl2ps.c	/^GL2PSDLL_API GLint gl2psTextOptColor(const char *str, const char *fontname,$/;"	f
gl2psTraverseBspTree	srLib/SceneGraph/gl2ps.c	/^static void gl2psTraverseBspTree(GL2PSbsptree *tree, GL2PSxyz eye, GLfloat epsilon,$/;"	f	file:
gl2psTrianglesFirst	srLib/SceneGraph/gl2ps.c	/^static int gl2psTrianglesFirst(const void *a, const void *b)$/;"	f	file:
gl2psUserFlushPNG	srLib/SceneGraph/gl2ps.c	/^static void gl2psUserFlushPNG(png_structp png_ptr)$/;"	f	file:
gl2psUserWritePNG	srLib/SceneGraph/gl2ps.c	/^static void gl2psUserWritePNG(png_structp png_ptr, png_bytep data, png_size_t length)$/;"	f	file:
gl2psVertsSameColor	srLib/SceneGraph/gl2ps.c	/^static GLboolean gl2psVertsSameColor(const GL2PSprimitive *prim)$/;"	f	file:
gl2psWriteBigEndian	srLib/SceneGraph/gl2ps.c	/^static int gl2psWriteBigEndian(unsigned long data, int bytes)$/;"	f	file:
gl2psWriteBigEndianCompress	srLib/SceneGraph/gl2ps.c	/^static int gl2psWriteBigEndianCompress(unsigned long data, int bytes)$/;"	f	file:
gl2psWriteByte	srLib/SceneGraph/gl2ps.c	/^static void gl2psWriteByte(unsigned char byte)$/;"	f	file:
gl2psbackends	srLib/SceneGraph/gl2ps.c	/^static GL2PSbackend *gl2psbackends[] = {$/;"	v	file:
glMakeDisplayList	srLib/SceneGraph/Group.cpp	/^void Group::glMakeDisplayList()$/;"	f	class:Group
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void ColorPoint::glMakeDisplayList()$/;"	f	class:ColorPoint
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void ColorPointGroup::glMakeDisplayList()$/;"	f	class:ColorPointGroup
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void Grid::glMakeDisplayList(){$/;"	f	class:Grid
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void Line::glMakeDisplayList()$/;"	f	class:Line
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void Polygon::glMakeDisplayList()$/;"	f	class:Polygon
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void STLNode::glMakeDisplayList()$/;"	f	class:STLNode
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void Sphere::glMakeDisplayList()$/;"	f	class:Sphere
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void TDSNode::glMakeDisplayList()$/;"	f	class:TDSNode
glMakeDisplayList	srLib/SceneGraph/Leaf.cpp	/^void Tube::glMakeDisplayList()$/;"	f	class:Tube
glMakeDisplayList	srLib/SceneGraph/node.h	/^	virtual void	glMakeDisplayList() {}$/;"	f	class:Node
glRender	srLib/SceneGraph/Camera.cpp	/^void Camera::glRender()$/;"	f	class:Camera
glRender	srLib/SceneGraph/Group.cpp	/^void Group::glRender()$/;"	f	class:Group
glRender	srLib/SceneGraph/Leaf.cpp	/^void Arrow::glRender()$/;"	f	class:Arrow
glRender	srLib/SceneGraph/Leaf.cpp	/^void Box::glRender()$/;"	f	class:Box
glRender	srLib/SceneGraph/Leaf.cpp	/^void Capsule::glRender()$/;"	f	class:Capsule
glRender	srLib/SceneGraph/Leaf.cpp	/^void ColorPoint::glRender()$/;"	f	class:ColorPoint
glRender	srLib/SceneGraph/Leaf.cpp	/^void ColorPointGroup::glRender()$/;"	f	class:ColorPointGroup
glRender	srLib/SceneGraph/Leaf.cpp	/^void Coordinate::glRender()$/;"	f	class:Coordinate
glRender	srLib/SceneGraph/Leaf.cpp	/^void Cylinder::glRender()$/;"	f	class:Cylinder
glRender	srLib/SceneGraph/Leaf.cpp	/^void Ellipsoid::glRender()$/;"	f	class:Ellipsoid
glRender	srLib/SceneGraph/Leaf.cpp	/^void Font::glRender()$/;"	f	class:Font
glRender	srLib/SceneGraph/Leaf.cpp	/^void ForceVector::glRender()$/;"	f	class:ForceVector
glRender	srLib/SceneGraph/Leaf.cpp	/^void Grid::glRender()$/;"	f	class:Grid
glRender	srLib/SceneGraph/Leaf.cpp	/^void HalfSphere::glRender()$/;"	f	class:HalfSphere
glRender	srLib/SceneGraph/Leaf.cpp	/^void Line::glRender()$/;"	f	class:Line
glRender	srLib/SceneGraph/Leaf.cpp	/^void Lines::glRender()$/;"	f	class:Lines
glRender	srLib/SceneGraph/Leaf.cpp	/^void NothingRenderLeaf::glRender()$/;"	f	class:NothingRenderLeaf
glRender	srLib/SceneGraph/Leaf.cpp	/^void Polygon::glRender()$/;"	f	class:Polygon
glRender	srLib/SceneGraph/Leaf.cpp	/^void STLNode::glRender()$/;"	f	class:STLNode
glRender	srLib/SceneGraph/Leaf.cpp	/^void Sphere::glRender()$/;"	f	class:Sphere
glRender	srLib/SceneGraph/Leaf.cpp	/^void Strip::glRender()$/;"	f	class:Strip
glRender	srLib/SceneGraph/Leaf.cpp	/^void TDSNode::glRender()$/;"	f	class:TDSNode
glRender	srLib/SceneGraph/Leaf.cpp	/^void Tube::glRender()$/;"	f	class:Tube
glRender	srLib/SceneGraph/Leaf.cpp	/^void varianceStrap2D::glRender()$/;"	f	class:varianceStrap2D
glRender	srLib/SceneGraph/Leaf.cpp	/^void varianceStrap::glRender()$/;"	f	class:varianceStrap
glRender	srLib/SceneGraph/Light.cpp	/^void Light::glRender()$/;"	f	class:Light
glRender	srLib/SceneGraph/Shader.cpp	/^void Shader::glRender()$/;"	f	class:Shader
glRender	srLib/SceneGraph/Texture.cpp	/^void Texture::glRender()$/;"	f	class:Texture
global_math_functions_filtering_base	Eigen/src/Core/MathFunctions.h	/^struct global_math_functions_filtering_base$/;"	s	namespace:Eigen::internal
globalpoint	srLib/srDyn/srContactConstraint.h	/^	Vec3	globalpoint;$/;"	m	struct:Contact
grabInput	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
grabInput_impl	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput_impl(MatrixType& A)$/;"	f	class:Eigen::IterativeSolverBase
grabInput_impl	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void grabInput_impl(const EigenBase<InputDerived>& A)$/;"	f	class:Eigen::IterativeSolverBase
grabMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLDLT
grabMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLLT
grabMatrix	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void grabMatrix(const MatrixType& matrix, ColSpMatrix& out)$/;"	f	class:Eigen::PastixLU
grapInput	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput(const InputMatrixType& mat)$/;"	f	class:Eigen::UmfPackLU
grapInput_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput_impl(const InputMatrixType& mat, internal::false_type)$/;"	f	class:Eigen::UmfPackLU
grapInput_impl	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void grapInput_impl(const InputMatrixType& mat, internal::true_type)$/;"	f	class:Eigen::UmfPackLU
gsno	srLib/SceneGraph/gl2ps.c	/^  int gsno, fontno, imno, shno, maskshno, trgroupno;$/;"	m	struct:__anon14	file:
gsobjno	srLib/SceneGraph/gl2ps.c	/^  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;$/;"	m	struct:__anon14	file:
h1	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int		SceneGraphRenderer::h1 = 0;$/;"	m	class:SceneGraphRenderer	file:
h1	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	int		h1;$/;"	m	class:SceneGraphRenderer
h2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int		SceneGraphRenderer::h2 = 0;$/;"	m	class:SceneGraphRenderer	file:
h2	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	int		h2;$/;"	m	class:SceneGraphRenderer
hCoeffs	Eigen/src/QR/ColPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::ColPivHouseholderQR
hCoeffs	Eigen/src/QR/FullPivHouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::FullPivHouseholderQR
hCoeffs	Eigen/src/QR/HouseholderQR.h	/^    const HCoeffsType& hCoeffs() const { return m_hCoeffs; }$/;"	f	class:Eigen::HouseholderQR
handmade_aligned_free	Eigen/src/Core/util/Memory.h	/^inline void handmade_aligned_free(void *ptr)$/;"	f	namespace:Eigen::internal
handmade_aligned_malloc	Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_malloc(std::size_t size)$/;"	f	namespace:Eigen::internal
handmade_aligned_realloc	Eigen/src/Core/util/Memory.h	/^inline void* handmade_aligned_realloc(void* ptr, std::size_t size, std::size_t = 0)$/;"	f	namespace:Eigen::internal
hasNaN	Eigen/src/Core/BooleanRedux.h	/^inline bool DenseBase<Derived>::hasNaN() const$/;"	f	class:Eigen::DenseBase
has_direct_access	Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { has_direct_access = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon146
has_direct_access	Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename Derived> struct has_direct_access$/;"	s	namespace:Eigen::internal
has_none	Eigen/src/Core/util/Meta.h	/^struct has_none {int a[1];};$/;"	s	namespace:Eigen::internal
has_std_result_type	Eigen/src/Core/util/Meta.h	/^struct has_std_result_type {int a[2];};$/;"	s	namespace:Eigen::internal
has_tr1_result	Eigen/src/Core/util/Meta.h	/^struct has_tr1_result {int a[3];};$/;"	s	namespace:Eigen::internal
has_write_access	Eigen/src/Core/util/ForwardDeclarations.h	/^         has_write_access = (traits<Derived>::Flags & LvalueBit) ? 1 : 0,$/;"	e	enum:Eigen::internal::accessors_level::__anon146
hash	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index hash ;  \/* hash value, if col is not in a degree list *\/$/;"	m	union:internal::colamd_col::__anon351
hash_next	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index hash_next ;   \/* next column, if col is in a hash list *\/$/;"	m	union:internal::colamd_col::__anon352
head	Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType head(Index n) const$/;"	f
head	Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType head(Index n)$/;"	f
head	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type head(Index n = N) const$/;"	f
head	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type head(Index n = N)$/;"	f
header	srLib/SceneGraph/gl2ps.c	/^  GLboolean header;$/;"	m	struct:__anon15	file:
headhash	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index headhash ;  \/* head of a hash bucket, if col is at the head of *\/$/;"	m	union:internal::colamd_col::__anon351
heap_relax_snode	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^void SparseLUImpl<Scalar,Index>::heap_relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl
height	srLib/SceneGraph/Leaf.h	/^	double height;$/;"	m	class:Capsule
height	srLib/SceneGraph/Leaf.h	/^	double height;$/;"	m	class:Cylinder
height	srLib/SceneGraph/gl2ps.c	/^  GLsizei width, height;$/;"	m	struct:__anon10	file:
hessenbergTriangular	Eigen/src/Eigenvalues/RealQZ.h	/^    void RealQZ<MatrixType>::hessenbergTriangular()$/;"	f	class:Eigen::RealQZ
history_state_	Example/DracoP1/Draco_Dyn_environment.h	/^        std::vector<state> history_state_;$/;"	m	class:Draco_Dyn_environment
hnormalized	Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::hnormalized() const$/;"	f	class:Eigen::MatrixBase
hnormalized	Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::hnormalized() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous	Eigen/src/Geometry/Homogeneous.h	/^MatrixBase<Derived>::homogeneous() const$/;"	f	class:Eigen::MatrixBase
homogeneous	Eigen/src/Geometry/Homogeneous.h	/^VectorwiseOp<ExpressionType,Direction>::homogeneous() const$/;"	f	class:Eigen::VectorwiseOp
homogeneous_left_product_impl	Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_left_product_impl(const Lhs& lhs, const MatrixType& rhs)$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
homogeneous_left_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs>$/;"	s	namespace:Eigen::internal
homogeneous_right_product_impl	Eigen/src/Geometry/Homogeneous.h	/^  homogeneous_right_product_impl(const MatrixType& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
homogeneous_right_product_impl	Eigen/src/Geometry/Homogeneous.h	/^struct homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs>$/;"	s	namespace:Eigen::internal
householder	Eigen/src/SVD/UpperBidiagonalization.h	/^    const MatrixType& householder() const { return m_householder; }$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderCoefficients	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const CoeffVectorType& householderCoefficients() const$/;"	f	class:Eigen::HessenbergDecomposition
householderCoefficients	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline CoeffVectorType householderCoefficients() const$/;"	f	class:Eigen::Tridiagonalization
householderQ	Eigen/src/QR/ColPivHouseholderQR.h	/^  ::householderQ() const$/;"	f	class:Eigen::ColPivHouseholderQR
householderQ	Eigen/src/QR/HouseholderQR.h	/^    HouseholderSequenceType householderQ() const$/;"	f	class:Eigen::HouseholderQR
householderQr	Eigen/src/QR/HouseholderQR.h	/^MatrixBase<Derived>::householderQr() const$/;"	f	class:Eigen::MatrixBase
householderSequence	Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType> householderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
householderU	Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderUSequenceType householderU() const$/;"	f	class:Eigen::internal::UpperBidiagonalization
householderV	Eigen/src/SVD/UpperBidiagonalization.h	/^    const HouseholderVSequenceType householderV() \/\/ const here gives nasty errors and i'm lazy$/;"	f	class:Eigen::internal::UpperBidiagonalization
householder_qr_inplace_blocked	Eigen/src/QR/HouseholderQR.h	/^struct householder_qr_inplace_blocked$/;"	s	namespace:Eigen::internal
householder_qr_inplace_unblocked	Eigen/src/QR/HouseholderQR.h	/^void householder_qr_inplace_unblocked(MatrixQR& mat, HCoeffs& hCoeffs, typename MatrixQR::Scalar* tempData = 0)$/;"	f	namespace:Eigen::internal
hseq_side_dependent_impl	Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl$/;"	s	namespace:Eigen::internal
hseq_side_dependent_impl	Eigen/src/Householder/HouseholderSequence.h	/^struct hseq_side_dependent_impl<VectorsType, CoeffsType, OnTheRight>$/;"	s	namespace:Eigen::internal
hypot	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(hypot, Scalar) hypot(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext
hypotNorm	Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::hypotNorm() const$/;"	f	class:Eigen::MatrixBase
hypotNorm	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_hypotNorm,RealScalar>::Type hypotNorm() const$/;"	f	class:Eigen::VectorwiseOp
hypot_impl	Eigen/src/Core/MathFunctions.h	/^struct hypot_impl$/;"	s	namespace:Eigen::internal
hypot_retval	Eigen/src/Core/MathFunctions.h	/^struct hypot_retval$/;"	s	namespace:Eigen::internal
icc_11_workaround	Eigen/src/Geometry/Transform.h	/^  template<int OtherMode,int OtherOptions> struct icc_11_workaround$/;"	s	class:Eigen::Transform
id	srLib/SceneGraph/Model3DS.h	/^		unsigned short id;	\/\/ The chunk's id$/;"	m	struct:Model3DS::ChunkHeader
identity	srLib/LieGroup/LieGroup.h	/^	Quaternion& identity()                                  \/\/ Q.identity()$/;"	f	union:Quaternion
ignore_unused_variable	Eigen/src/Core/util/Macros.h	/^    template<typename T> void ignore_unused_variable(const T&) {}$/;"	f	namespace:Eigen::internal
im_stack	srLib/SceneGraph/gl2ps.c	/^  int im_stack; \/* image object number *\/$/;"	m	struct:__anon15	file:
imag	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag, Scalar) imag(const Scalar& x)$/;"	f	namespace:Eigen::numext
imag	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() const { return derived(); }$/;"	f
imag	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^imag() { return derived(); }$/;"	f
imag_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_default_impl$/;"	s	namespace:Eigen::internal
imag_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
imag_impl	Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> struct imag_impl : imag_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
imag_ref	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) imag_ref(Scalar& x)$/;"	f	namespace:Eigen::numext
imag_ref	Eigen/src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(imag_ref, Scalar) >::type imag_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext
imag_ref_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl$/;"	s	namespace:Eigen::internal
imag_ref_default_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
imag_ref_impl	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_impl : imag_ref_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
imag_ref_retval	Eigen/src/Core/MathFunctions.h	/^struct imag_ref_retval$/;"	s	namespace:Eigen::internal
imag_retval	Eigen/src/Core/MathFunctions.h	/^struct imag_retval$/;"	s	namespace:Eigen::internal
image	Eigen/src/Eigen2Support/LU.h	/^    const ImageResultType image() const$/;"	f	class:Eigen::LU
image	Eigen/src/LU/FullPivLU.h	/^      image(const MatrixType& originalMatrix) const$/;"	f	class:Eigen::FullPivLU
image	srLib/SceneGraph/gl2ps.c	/^    GL2PSimage *image;$/;"	m	union:__anon11::__anon12	file:
image	srLib/SceneGraph/gl2ps.c	/^  GL2PSimage *image;$/;"	m	struct:_GL2PSimagemap	file:
image_retval	Eigen/src/LU/FullPivLU.h	/^struct image_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
image_retval_base	Eigen/src/misc/Image.h	/^  image_retval_base(const DecompositionType& dec, const MatrixType& originalMatrix)$/;"	f	struct:Eigen::internal::image_retval_base
image_retval_base	Eigen/src/misc/Image.h	/^template<typename _DecompositionType> struct image_retval_base$/;"	s	namespace:Eigen::internal
imagemap_head	srLib/SceneGraph/gl2ps.c	/^  GL2PSimagemap *imagemap_head;$/;"	m	struct:__anon15	file:
imagemap_tail	srLib/SceneGraph/gl2ps.c	/^  GL2PSimagemap *imagemap_tail;$/;"	m	struct:__anon15	file:
imagetree	srLib/SceneGraph/gl2ps.c	/^  GL2PSbsptree2d *imagetree;$/;"	m	struct:__anon15	file:
imno	srLib/SceneGraph/gl2ps.c	/^  int gsno, fontno, imno, shno, maskshno, trgroupno;$/;"	m	struct:__anon14	file:
imobjno	srLib/SceneGraph/gl2ps.c	/^  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;$/;"	m	struct:__anon14	file:
impl	Eigen/src/Core/Functors.h	/^  const linspaced_op_impl<Scalar,RandomAccess> impl;$/;"	m	struct:Eigen::internal::linspaced_op
incr	srLib/SceneGraph/gl2ps.c	/^  GLint nmax, size, incr, n;$/;"	m	struct:__anon6	file:
incrementToNonZero	Eigen/src/SparseCore/SparseView.h	/^  void incrementToNonZero()$/;"	f	class:Eigen::SparseView::InnerIterator
index	Eigen/src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_inner; }$/;"	f	class:Eigen::DenseBase::InnerIterator
index	Eigen/src/Core/Diagonal.h	/^    int index() const$/;"	f	class:Eigen::Diagonal
index	Eigen/src/Core/Redux.h	/^    index = Start * packet_traits<typename Derived::Scalar>::size,$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon335
index	Eigen/src/SparseCore/AmbiVector.h	/^      Index index;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
index	Eigen/src/SparseCore/AmbiVector.h	/^    Index index() const { return m_cachedIndex; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
index	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index& index(size_t i) { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Index& index(size_t i) const { return m_indices[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
index	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
index	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index index() const { return m_matrix.innerIndexPtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
index	Eigen/src/SparseCore/SparseBlock.h	/^      inline Index index()  const { return Base::index() - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
index	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index index()  const { return Base::index() - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
index	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index index()  const { return m_outerPos - (IsRowMajor ? m_block.m_startCol.value() : m_block.m_startRow.value()); }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_id; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_lhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
index	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index index() const { return m_rhsIter.index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
index	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
index	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index index() const { return m_indices[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
index	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index index() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
index	Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator
index	Eigen/src/SparseCore/SparseVector.h	/^    inline Index index() const { return m_data.index(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
index	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index index() const { return m_matrix.rowIndex()[m_idrow]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
indexPtr	Eigen/src/SparseCore/CompressedStorage.h	/^    Index* indexPtr() { return m_indices; }$/;"	f	class:Eigen::internal::CompressedStorage
indexPtr	Eigen/src/SparseCore/CompressedStorage.h	/^    const Index* indexPtr() const { return m_indices; }$/;"	f	class:Eigen::internal::CompressedStorage
indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::PermutationBase
indices	Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/PermutationMatrix.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationMatrix
indices	Eigen/src/Core/PermutationMatrix.h	/^    indices() const { return m_indices; }$/;"	f	class:Eigen::PermutationWrapper
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	Eigen/src/Core/Transpositions.h	/^    IndicesType& indices() { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return derived().indices(); }$/;"	f	class:Eigen::TranspositionsBase
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Map
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::Transpositions
indices	Eigen/src/Core/Transpositions.h	/^    const IndicesType& indices() const { return m_indices; }$/;"	f	class:Eigen::TranspositionsWrapper
info	Eigen/src/Cholesky/LDLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LDLT
info	Eigen/src/Cholesky/LLT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::LLT
info	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::CholmodBase
info	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexEigenSolver
info	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ComplexSchur
info	Eigen/src/Eigenvalues/EigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::EigenSolver
info	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::GeneralizedEigenSolver
info	Eigen/src/Eigenvalues/RealQZ.h	/^      ComputationInfo info() const$/;"	f	class:Eigen::RealQZ
info	Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::RealSchur
info	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
info	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::IncompleteLUT
info	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ComputationInfo info() const$/;"	f	class:Eigen::IterativeSolverBase
info	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PastixBase
info	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::PardisoImpl
info	Eigen/src/QR/ColPivHouseholderQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::ColPivHouseholderQR
info	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SPQR
info	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SimplicialCholeskyBase
info	Eigen/src/SparseLU/SparseLU.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseLU
info	Eigen/src/SparseQR/SparseQR.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SparseQR
info	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::SuperLUBase
info	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ComputationInfo info() const$/;"	f	class:Eigen::UmfPackLU
info_arch	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_arch	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_compiler	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_compiler	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_cray	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";$/;"	v
info_cray	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";$/;"	v
info_language_dialect_default	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^const char* info_language_dialect_default =$/;"	v
info_language_dialect_default	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^const char* info_language_dialect_default = "INFO" ":" "dialect_default["$/;"	v
info_platform	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_platform	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_simulate	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";$/;"	v
info_simulate	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";$/;"	v
info_simulate_version	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const info_simulate_version[] = {$/;"	v
info_simulate_version	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_simulate_version[] = {$/;"	v
info_version	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const info_version[] = {$/;"	v
info_version	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_version[] = {$/;"	v
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodDecomposition
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLDLT
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSimplicialLLT
init	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void init()$/;"	f	class:Eigen::CholmodSupernodalLLT
init	Eigen/src/Core/Block.h	/^    void init()$/;"	f	class:Eigen::internal::BlockImpl_dense
init	Eigen/src/Core/Visitor.h	/^  inline void init(const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::coeff_visitor
init	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  void init()$/;"	f	class:Eigen::IterativeSolverBase
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLDLT
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLLT
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    void init()$/;"	f	class:Eigen::PastixLU
init	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^void PastixBase<Derived>::init()$/;"	f	class:Eigen::PastixBase
init	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(double estimatedDensity)$/;"	f	class:Eigen::internal::AmbiVector
init	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::init(int mode)$/;"	f	class:Eigen::internal::AmbiVector
init	Eigen/src/SparseCore/SparseProduct.h	/^    void init()$/;"	f	class:Eigen::SparseSparseProduct
init	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperILU
init	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLU
init	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void init()$/;"	f	class:Eigen::SuperLUBase
init	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void init()$/;"	f	class:Eigen::UmfPackLU
initAcc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(AccPacket& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(DoublePacket& p)$/;"	f	class:Eigen::internal::gebp_traits
initAcc	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void initAcc(Scalar& p) { p = Scalar(0); }$/;"	f	class:Eigen::internal::gebp_traits
initAssignment	Eigen/src/SparseCore/SparseMatrix.h	/^    void initAssignment(const Other& other)$/;"	f	class:Eigen::SparseMatrix
initFactorization	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void initFactorization(const MatrixType& a)$/;"	f	class:Eigen::SuperLUBase
initFrancisQRStep	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::initFrancisQRStep(Index il, Index iu, const Vector3s& shiftInfo, Index& im, Vector3s& firstHouseholderVector)$/;"	f	class:Eigen::RealSchur
initParallel	Eigen/src/Core/products/Parallelizer.h	/^inline void initParallel()$/;"	f	namespace:Eigen
initParallelSession	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void initParallelSession() const$/;"	f	struct:Eigen::internal::gemm_functor
init_rows_cols	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static Index init_rows_cols  \/* returns true if OK, or false otherwise *\/$/;"	f	namespace:internal
init_scoring	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static void init_scoring$/;"	f	namespace:internal
initializeCamera	srLib/SceneGraph/Camera.cpp	/^void Camera::initializeCamera()$/;"	f	class:Camera
initperfvalues	Eigen/src/SparseLU/SparseLU.h	/^    void initperfvalues()$/;"	f	class:Eigen::SparseLU
inner	Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon29
inner	Eigen/src/Core/Assign.h	/^    inner = Index % Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon30
inner	Eigen/src/Core/Redux.h	/^    inner = Start % Derived::InnerSizeAtCompileTime$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon333
inner	Eigen/src/Core/Redux.h	/^    inner = index % int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon335
inner	Eigen/src/Core/Stride.h	/^    inline Index inner() const { return m_inner.value(); }$/;"	f	class:Eigen::Stride
innerInd	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *innerInd;$/;"	m	struct:Eigen::SluMatrix::__anon458
innerIndexPtr	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix
innerIndexPtr	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_innerIndices; }$/;"	f	class:Eigen::MappedSparseMatrix
innerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* innerIndexPtr()$/;"	f	class:Eigen::BlockImpl
innerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* innerIndexPtr() const$/;"	f	class:Eigen::BlockImpl
innerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerIndexPtr() { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerIndexPtr() const { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseMatrix
innerIndexPtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index* innerIndexPtr() { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseVector
innerIndexPtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Index* innerIndexPtr() const { return m_data.indexPtr(); }$/;"	f	class:Eigen::SparseVector
innerNonZeroPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* innerNonZeroPtr() { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeroPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* innerNonZeroPtr() const { return m_innerNonZeros; }$/;"	f	class:Eigen::SparseMatrix
innerNonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    Eigen::Map<Matrix<Index,Dynamic,1> > innerNonZeros() { return Eigen::Map<Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix
innerNonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    const  Eigen::Map<const Matrix<Index,Dynamic,1> > innerNonZeros() const { return Eigen::Map<const Matrix<Index,Dynamic,1> >(m_innerNonZeros, m_innerNonZeros?m_outerSize:0); }$/;"	f	class:Eigen::SparseMatrix
innerSize	Eigen/src/Core/DenseBase.h	/^    Index innerSize() const$/;"	f	class:Eigen::DenseBase
innerSize	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
innerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index innerSize() const { return m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
innerSize	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index innerSize() const { return (int(Flags)&RowMajorBit) ? this->cols() : this->rows(); }$/;"	f	class:Eigen::SparseMatrixBase
innerSize	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index innerSize() const { return m_size; }$/;"	f	class:Eigen::SparseVector
innerSize	Eigen/src/SparseCore/SparseView.h	/^  inline Index innerSize() const { return m_matrix.innerSize(); }$/;"	f	class:Eigen::SparseView
innerStride	Eigen/src/Core/Array.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Array
innerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ArrayWrapper
innerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::MatrixWrapper
innerStride	Eigen/src/Core/Block.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense
innerStride	Eigen/src/Core/CwiseUnaryView.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
innerStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
innerStride	Eigen/src/Core/Diagonal.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Diagonal
innerStride	Eigen/src/Core/Flagged.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::Flagged
innerStride	Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
innerStride	Eigen/src/Core/Map.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Map
innerStride	Eigen/src/Core/Matrix.h	/^    inline Index innerStride() const { return 1; }$/;"	f	class:Eigen::Matrix
innerStride	Eigen/src/Core/NestByValue.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::NestByValue
innerStride	Eigen/src/Core/Ref.h	/^  inline Index innerStride() const$/;"	f	class:Eigen::RefBase
innerStride	Eigen/src/Core/Reverse.h	/^    inline Index innerStride() const$/;"	f	class:Eigen::Reverse
innerStride	Eigen/src/Core/SelfAdjointView.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfAdjointView
innerStride	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
innerStride	Eigen/src/Core/Swap.h	/^    inline Index innerStride() const { return m_expression.innerStride(); }$/;"	f	class:Eigen::SwapWrapper
innerStride	Eigen/src/Core/Transpose.h	/^    inline Index innerStride() const { return derived().nestedExpression().innerStride(); }$/;"	f	class:Eigen::TransposeImpl
innerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return derived().innerStride(); }$/;"	f	class:Eigen::TriangularBase
innerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index innerStride() const { return m_matrix.innerStride(); }$/;"	f	class:Eigen::TriangularView
innerTube_pointsList	srLib/SceneGraph/Leaf.h	/^	vector<vector<Vec3>>		innerTube_pointsList;$/;"	m	class:Tube
innerVector	Eigen/src/SparseCore/SparseBlock.h	/^const typename SparseMatrixBase<Derived>::ConstInnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer) const$/;"	f	class:Eigen::SparseMatrixBase
innerVector	Eigen/src/SparseCore/SparseBlock.h	/^typename SparseMatrixBase<Derived>::InnerVectorReturnType SparseMatrixBase<Derived>::innerVector(Index outer)$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	Eigen/src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize) const$/;"	f	class:Eigen::SparseMatrixBase
innerVectors	Eigen/src/SparseCore/SparseBlock.h	/^SparseMatrixBase<Derived>::innerVectors(Index outerStart, Index outerSize)$/;"	f	class:Eigen::SparseMatrixBase
inner_radius	srLib/SceneGraph/Leaf.h	/^	double						inner_radius;$/;"	m	class:Tube
inner_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time$/;"	s	namespace:Eigen::internal
inner_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct inner_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
inplace_decomposition	Eigen/src/Cholesky/LLT.h	/^  static bool inplace_decomposition(MatrixType& m)$/;"	f	struct:Eigen::internal::LLT_Traits
inplace_transpose_selector	Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,false> { \/\/ non square matrix$/;"	s	namespace:Eigen::internal
inplace_transpose_selector	Eigen/src/Core/Transpose.h	/^struct inplace_transpose_selector<MatrixType,true> { \/\/ square matrix$/;"	s	namespace:Eigen::internal
insert	Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insert	Eigen/src/SparseCore/SparseVector.h	/^    Scalar& insert(Index i)$/;"	f	class:Eigen::SparseVector
insert	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insert(Index row, Index col)$/;"	f	class:Eigen::SparseVector
insert	Eigen/src/StlSupport/StdDeque.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::deque
insert	Eigen/src/StlSupport/StdDeque.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::deque
insert	Eigen/src/StlSupport/StdList.h	/^    iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::list
insert	Eigen/src/StlSupport/StdList.h	/^    void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::list
insert	Eigen/src/StlSupport/StdVector.h	/^  iterator insert(const_iterator position, const value_type& x)$/;"	f	class:std::vector
insert	Eigen/src/StlSupport/StdVector.h	/^  void insert(const_iterator position, size_type new_size, const value_type& x)$/;"	f	class:std::vector
insertBack	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBack(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertBack	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBack(Index i)$/;"	f	class:Eigen::SparseVector
insertBackByOuterInner	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackByOuterInner	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& insertBackByOuterInner(Index outer, Index inner)$/;"	f	class:Eigen::SparseVector
insertBackByOuterInnerUnordered	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& insertBackByOuterInnerUnordered(Index outer, Index inner)$/;"	f	class:Eigen::SparseMatrix
insertBackUncompressed	Eigen/src/SparseCore/SparseMatrix.h	/^    EIGEN_STRONG_INLINE Scalar& insertBackUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertByOuterInner	Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar& insertByOuterInner(Index j, Index i)$/;"	f	class:Eigen::SparseMatrix
insertCompressed	Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_Index>::Scalar& SparseMatrix<_Scalar,_Options,_Index>::insertCompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
insertUncompressed	Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE typename SparseMatrix<_Scalar,_Options,_Index>::Scalar& SparseMatrix<_Scalar,_Options,_Index>::insertUncompressed(Index row, Index col)$/;"	f	class:Eigen::SparseMatrix
interface_	Example/DracoP1/Draco_Dyn_environment.h	/^        Interface* interface_;$/;"	m	class:Draco_Dyn_environment
internal	Eigen/src/Cholesky/LDLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Cholesky/LLT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Cholesky/LLT.h	/^namespace internal{$/;"	n	namespace:Eigen
internal	Eigen/src/Cholesky/LLT_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/CholmodSupport/CholmodSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Array.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ArrayWrapper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Assign.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Assign_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/BandMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Block.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/BooleanRedux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseNullaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseUnaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/CwiseUnaryView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DenseBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DenseCoeffsBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DenseStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Diagonal.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DiagonalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/DiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Dot.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Flagged.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ForceAlignedAccess.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Functors.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Fuzzy.h	/^namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/Core/GeneralProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/GenericPacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/GlobalFunctions.h	/^  namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/Core/IO.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Map.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Matrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/NestByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/PermutationMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/PlainObjectBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ProductBase.h	/^namespace internal {$/;"	n
internal	Eigen/src/Core/ProductBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Random.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Redux.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Ref.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Replicate.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/ReturnByValue.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Reverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Select.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/SelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/SelfCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/SolveTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/StableNorm.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Swap.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Transpose.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Transpositions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/TriangularMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/VectorBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/VectorwiseOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/Visitor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AltiVec/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/NEON/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/NEON/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/Complex.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/MathFunctions.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/arch/SSE/PacketMath.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/CoeffBasedProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrixTriangular_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/GeneralMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/Parallelizer.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/SelfadjointRank2Update.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularSolverMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularSolverMatrix_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/products/TriangularSolverVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/BlasUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Constants.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/ForwardDeclarations.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/MKL_support.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Macros.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Macros.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/Meta.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/StaticAssert.h	/^    namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Core/util/XprHelper.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigen2Support/Minor.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/ComplexSchur.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Eigenvalues/Tridiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/AngleAxis.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Homogeneous.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/OrthoMethods.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Quaternion.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Rotation2D.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/RotationBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Transform.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/Umeyama.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Geometry/arch/Geometry_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Householder/BlockHouseholder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Householder/Householder.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Householder/HouseholderSequence.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/Jacobi/Jacobi.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/Determinant.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/FullPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/Inverse.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/PartialPivLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/PartialPivLU_MKL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/LU/arch/Inverse_SSE.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/OrderingMethods/Amd.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^namespace internal {$/;"	n
internal	Eigen/src/OrderingMethods/Ordering.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/PardisoSupport/PardisoSupport.h	/^namespace internal$/;"	n	namespace:Eigen
internal	Eigen/src/QR/ColPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/FullPivHouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/HouseholderQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/QR/HouseholderQR_MKL.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SVD/JacobiSVD.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SVD/UpperBidiagonalization.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/AmbiVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/CompressedStorage.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/MappedSparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseBlock.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseColEtree.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseDenseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparsePermutation.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseProduct.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseTriangularView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseUtil.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseVector.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/SparseView.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseCore/TriangularSolver.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLUImpl.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_Memory.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_Structs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_Utils.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_column_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_copy_to_ucol.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_heap_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_pivotL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_pruneL.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SparseQR/SparseQR.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/StlSupport/details.h	/^  namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/Image.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/Kernel.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/Solve.h	/^namespace internal {$/;"	n	namespace:Eigen
internal	Eigen/src/misc/SparseSolve.h	/^namespace internal {$/;"	n	namespace:Eigen
intersectRectQuad	srLib/srDyn/srCollisionPair.cpp	/^static int intersectRectQuad (SR_REAL h[2], SR_REAL p[8], SR_REAL ret[16])$/;"	f	file:
intersection	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other)$/;"	f	class:Eigen::Hyperplane
intersection	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim>::intersection(const Hyperplane<_Scalar, _AmbientDim>& hyperplane)$/;"	f	class:Eigen::ParametrizedLine
intersection	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox intersection(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
intersection	Eigen/src/Geometry/Hyperplane.h	/^  VectorType intersection(const Hyperplane& other) const$/;"	f	class:Eigen::Hyperplane
intersection	Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersection(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionParameter	Eigen/src/Geometry/ParametrizedLine.h	/^inline _Scalar ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionParameter(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersectionPoint	Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::intersectionPoint(const Hyperplane<_Scalar, _AmbientDim, OtherOptions>& hyperplane) const$/;"	f	class:Eigen::ParametrizedLine
intersects	Eigen/src/Geometry/AlignedBox.h	/^  inline bool intersects(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
invAdMat	srLib/srExt/srExt_LieGroup.cpp	/^Eigen::Matrix6d srExt::invAdMat(const SE3 & _T)$/;"	f	class:srExt
invDyn	srLib/srExt/srExt_System.cpp	/^Eigen::VectorXd srExt::srExtSystem::invDyn(const Vec3 & _gravity) const$/;"	f	class:srExt::srExtSystem
invDyn	srLib/srExt/srExtension.cpp	/^Eigen::VectorXd srExt::invDyn(srSystem * _system, const Vec3 & _gravity)$/;"	f	class:srExt
invEulerZYX	srMath/SO3.cpp	/^	Vector3 SO3::invEulerZYX(const SO3& R)$/;"	f	class:srMath::SO3
invEulerZYZ	srMath/SO3.cpp	/^	Vector3 SO3::invEulerZYZ(const SO3& R)$/;"	f	class:srMath::SO3
invKin	srLib/srExt/srExt_System.cpp	/^Eigen::VectorXd srExt::srExtSystem::invKin(srLink * const _endEffector, const SE3 & _T, srLink * _baseLink, double _tol)$/;"	f	class:srExt::srExtSystem
invKin	srLib/srExt/srExtension.cpp	/^VectorXd srExt::invKin(srLink * const _endEffector, const SE3& _T, srLink * _baseLink, double _tol)$/;"	f	class:srExt
inverse	Eigen/src/Core/DiagonalMatrix.h	/^    inverse() const$/;"	f	class:Eigen::DiagonalBase
inverse	Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> inverse() const$/;"	f	class:Eigen::PermutationBase
inverse	Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> inverse() const$/;"	f	class:Eigen::TranspositionsBase
inverse	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::inverse() const$/;"	f	class:Eigen::Cwise
inverse	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis
inverse	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::inverse() const$/;"	f	class:Eigen::Quaternion
inverse	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D
inverse	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase
inverse	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling inverse() const$/;"	f	class:Eigen::Scaling
inverse	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::inverse(TransformTraits traits) const$/;"	f	class:Eigen::Transform
inverse	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation
inverse	Eigen/src/Geometry/AngleAxis.h	/^  AngleAxis inverse() const$/;"	f	class:Eigen::AngleAxis
inverse	Eigen/src/Geometry/Quaternion.h	/^inline Quaternion<typename internal::traits<Derived>::Scalar> QuaternionBase<Derived>::inverse() const$/;"	f	class:Eigen::QuaternionBase
inverse	Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D inverse() const { return -m_angle; }$/;"	f	class:Eigen::Rotation2D
inverse	Eigen/src/Geometry/RotationBase.h	/^    inline Derived inverse() const { return derived().inverse(); }$/;"	f	class:Eigen::RotationBase
inverse	Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling inverse() const$/;"	f	class:Eigen::UniformScaling
inverse	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::inverse(TransformTraits hint) const$/;"	f	class:Eigen::Transform
inverse	Eigen/src/Geometry/Translation.h	/^  Translation inverse() const { return Translation(-m_coeffs); }$/;"	f	class:Eigen::Translation
inverse	Eigen/src/Householder/HouseholderSequence.h	/^    ConjugateReturnType inverse() const { return adjoint(); }$/;"	f	class:Eigen::HouseholderSequence
inverse	Eigen/src/LU/FullPivLU.h	/^    inline const internal::solve_retval<FullPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::FullPivLU
inverse	Eigen/src/LU/Inverse.h	/^inline const internal::inverse_impl<Derived> MatrixBase<Derived>::inverse() const$/;"	f	class:Eigen::MatrixBase
inverse	Eigen/src/LU/PartialPivLU.h	/^    inline const internal::solve_retval<PartialPivLU,typename MatrixType::IdentityReturnType> inverse() const$/;"	f	class:Eigen::PartialPivLU
inverse	Eigen/src/QR/ColPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::ColPivHouseholderQR
inverse	Eigen/src/QR/FullPivHouseholderQR.h	/^    inverse() const$/;"	f	class:Eigen::FullPivHouseholderQR
inverse	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^inverse() const$/;"	f
inverse	srMath/SE3.cpp	/^	SE3 SE3::inverse() const$/;"	f	class:srMath::SE3
inverse	srMath/SO3.cpp	/^	SO3 SO3::inverse() const$/;"	f	class:srMath::SO3
inverse_impl	Eigen/src/LU/Inverse.h	/^  inverse_impl(const MatrixType& matrix)$/;"	f	struct:Eigen::internal::inverse_impl
inverse_impl	Eigen/src/LU/Inverse.h	/^struct inverse_impl : public ReturnByValue<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
invert	srLib/LieGroup/LieGroup.cpp	/^Quaternion& Quaternion::invert()$/;"	f	class:Quaternion
iparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    Array<Index,IPARM_SIZE,1>& iparm()$/;"	f	class:Eigen::PastixBase
iparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int& iparm(int idxparam)$/;"	f	class:Eigen::PastixBase
isApprox	Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const DiagonalBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase
isApprox	Eigen/src/Core/DiagonalMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::DiagonalBase
isApprox	Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isApprox($/;"	f	class:Eigen::DenseBase
isApprox	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(bool x, bool y, bool)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApprox	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApprox(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApprox	Eigen/src/Core/MathFunctions.h	/^inline bool isApprox(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApprox	Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView
isApprox	Eigen/src/Core/TriangularMatrix.h	/^    bool isApprox(const TriangularView<OtherMatrixType, Mode>& other, typename NumTraits<Scalar>::Real precision = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::TriangularView
isApprox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AlignedBox
isApprox	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::AngleAxis
isApprox	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Hyperplane
isApprox	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::ParametrizedLine
isApprox	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  bool isApprox(const Quaternion& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Quaternion
isApprox	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Rotation2D
isApprox	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  bool isApprox(const Scaling& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Scaling
isApprox	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  bool isApprox(const Transform& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Transform
isApprox	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  bool isApprox(const Translation& other, typename NumTraits<Scalar>::Real prec = precision<Scalar>()) const$/;"	f	class:Eigen::Translation
isApprox	Eigen/src/Geometry/AlignedBox.h	/^  bool isApprox(const AlignedBox& other, const RealScalar& prec = ScalarTraits::dummy_precision()) const$/;"	f	class:Eigen::AlignedBox
isApprox	Eigen/src/Geometry/AngleAxis.h	/^  bool isApprox(const AngleAxis& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::AngleAxis
isApprox	Eigen/src/Geometry/Hyperplane.h	/^  bool isApprox(const Hyperplane<Scalar,AmbientDimAtCompileTime,OtherOptions>& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Hyperplane
isApprox	Eigen/src/Geometry/ParametrizedLine.h	/^  bool isApprox(const ParametrizedLine& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::ParametrizedLine
isApprox	Eigen/src/Geometry/Quaternion.h	/^  bool isApprox(const QuaternionBase<OtherDerived>& other, const RealScalar& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::QuaternionBase
isApprox	Eigen/src/Geometry/Rotation2D.h	/^  bool isApprox(const Rotation2D& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Rotation2D
isApprox	Eigen/src/Geometry/Scaling.h	/^  bool isApprox(const UniformScaling& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::UniformScaling
isApprox	Eigen/src/Geometry/Transform.h	/^  bool isApprox(const Transform& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Transform
isApprox	Eigen/src/Geometry/Translation.h	/^  bool isApprox(const Translation& other, const typename NumTraits<Scalar>::Real& prec = NumTraits<Scalar>::dummy_precision()) const$/;"	f	class:Eigen::Translation
isApprox	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const MatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase
isApprox	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isApprox(const SparseMatrixBase<OtherDerived>& other,$/;"	f	class:Eigen::SparseMatrixBase
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isApproxOrLessThan(const bool& x, const bool& y, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isApproxOrLessThan	Eigen/src/Core/MathFunctions.h	/^inline bool isApproxOrLessThan(const Scalar& x, const Scalar& y,$/;"	f	namespace:Eigen::internal
isApproxToConstant	Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isApproxToConstant$/;"	f	class:Eigen::DenseBase
isApprox_selector	Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector$/;"	s	namespace:Eigen::internal
isApprox_selector	Eigen/src/Core/Fuzzy.h	/^struct isApprox_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isCompressed	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    bool isCompressed() const { return true; }$/;"	f	class:Eigen::MappedSparseMatrix
isCompressed	Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool isCompressed() const { return m_innerNonZeros==0; }$/;"	f	class:Eigen::SparseMatrix
isConstant	Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isConstant$/;"	f	class:Eigen::DenseBase
isDiagonal	Eigen/src/Core/DiagonalMatrix.h	/^bool MatrixBase<Derived>::isDiagonal(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isEmpty	Eigen/src/Geometry/AlignedBox.h	/^  inline bool isEmpty() const { return (m_min.array() > m_max.array()).any(); }$/;"	f	class:Eigen::AlignedBox
isFullRank	Eigen/src/Eigen2Support/QR.h	/^    bool isFullRank() const {$/;"	f	class:Eigen::QR
isIdentity	Eigen/src/Core/CwiseNullaryOp.h	/^bool MatrixBase<Derived>::isIdentity$/;"	f	class:Eigen::MatrixBase
isInjective	Eigen/src/LU/FullPivLU.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivLU
isInjective	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInjective	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isInvertible	Eigen/src/LU/FullPivLU.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivLU
isInvertible	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::ColPivHouseholderQR
isInvertible	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isInvertible() const$/;"	f	class:Eigen::FullPivHouseholderQR
isLowerTriangular	Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isLowerTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isMuchSmallerThan	Eigen/src/Core/Fuzzy.h	/^bool DenseBase<Derived>::isMuchSmallerThan($/;"	f	class:Eigen::DenseBase
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y, const RealScalar& prec)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const Scalar& x, const Scalar&, const RealScalar&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_default_impl
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^  static inline bool isMuchSmallerThan(const bool& x, const bool&, const bool&)$/;"	f	struct:Eigen::internal::scalar_fuzzy_impl
isMuchSmallerThan	Eigen/src/Core/MathFunctions.h	/^inline bool isMuchSmallerThan(const Scalar& x, const OtherScalar& y,$/;"	f	namespace:Eigen::internal
isMuchSmallerThan_object_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_object_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_object_selector<Derived, OtherDerived, true>$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector$/;"	s	namespace:Eigen::internal
isMuchSmallerThan_scalar_selector	Eigen/src/Core/Fuzzy.h	/^struct isMuchSmallerThan_scalar_selector<Derived, true>$/;"	s	namespace:Eigen::internal
isNegative	Eigen/src/Cholesky/LDLT.h	/^    inline bool isNegative(void) const$/;"	f	class:Eigen::LDLT
isNull	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline bool isNull() const { return (m_min.cwise() > m_max).any(); }$/;"	f	class:Eigen::AlignedBox
isNull	Eigen/src/Geometry/AlignedBox.h	/^  inline bool isNull() const { return isEmpty(); }$/;"	f	class:Eigen::AlignedBox
isOnes	Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isOnes$/;"	f	class:Eigen::DenseBase
isOrthogonal	Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isOrthogonal$/;"	f	class:Eigen::MatrixBase
isPositive	Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositive() const$/;"	f	class:Eigen::LDLT
isPositiveDefinite	Eigen/src/Cholesky/LDLT.h	/^    inline bool isPositiveDefinite() const$/;"	f	class:Eigen::LDLT
isPositiveDefinite	Eigen/src/Cholesky/LLT.h	/^    bool isPositiveDefinite() const { return true; }$/;"	f	class:Eigen::LLT
isRValue	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool isRValue() const { return m_isRValue; }$/;"	f	class:Eigen::SparseMatrixBase
isSurjective	Eigen/src/LU/FullPivLU.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivLU
isSurjective	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::ColPivHouseholderQR
isSurjective	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline bool isSurjective() const$/;"	f	class:Eigen::FullPivHouseholderQR
isSymmetric	Eigen/src/SparseLU/SparseLU.h	/^    void isSymmetric(bool sym)$/;"	f	class:Eigen::SparseLU
isUnitary	Eigen/src/Core/Dot.h	/^bool MatrixBase<Derived>::isUnitary(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isUpperTriangular	Eigen/src/Core/TriangularMatrix.h	/^bool MatrixBase<Derived>::isUpperTriangular(const RealScalar& prec) const$/;"	f	class:Eigen::MatrixBase
isVector	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline bool isVector() const { return rows()==1 || cols()==1; }$/;"	f	class:Eigen::SparseMatrixBase
isZero	Eigen/src/Core/CwiseNullaryOp.h	/^bool DenseBase<Derived>::isZero(const RealScalar& prec) const$/;"	f	class:Eigen::DenseBase
is_arithmetic	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	s	namespace:Eigen::internal
is_arithmetic	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	s	namespace:Eigen::internal
is_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_const	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
is_diagonal	Eigen/src/Core/util/Meta.h	/^template<typename T, int S> struct is_diagonal<DiagonalMatrix<T,S> >$/;"	s	namespace:Eigen
is_diagonal	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal$/;"	s	namespace:Eigen
is_diagonal	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalBase<T> >$/;"	s	namespace:Eigen
is_diagonal	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_diagonal<DiagonalWrapper<T> >$/;"	s	namespace:Eigen
is_large	Eigen/src/Core/GeneralProduct.h	/^  enum { is_large = MaxSize == Dynamic ||$/;"	e	enum:Eigen::internal::product_size_category::__anon282
is_malloc_allowed	Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed() { return is_malloc_allowed_impl(false); }$/;"	f	namespace:Eigen::internal
is_malloc_allowed_impl	Eigen/src/Core/util/Memory.h	/^inline bool is_malloc_allowed_impl(bool update, bool new_value = false)$/;"	f	namespace:Eigen::internal
is_row_major	Eigen/src/Core/GeneralProduct.h	/^    template<typename T> struct is_row_major : internal::conditional<(int(T::Flags)&RowMajorBit), internal::true_type, internal::false_type>::type {};$/;"	s	class:Eigen::GeneralProduct
is_same	Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	s	namespace:Eigen::internal
is_same	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
isfinite	Eigen/src/Core/MathFunctions.h	/^template<typename T> bool (isfinite)(const T& x)$/;"	f	namespace:Eigen::numext
itemData	tinyxml2/tinyxml2.h	/^        char    itemData[ITEM_SIZE];$/;"	m	union:tinyxml2::MemPoolT::Item
items	tinyxml2/tinyxml2.h	/^        Item items[ITEMS_PER_BLOCK];$/;"	m	struct:tinyxml2::MemPoolT::Block
iterations	Eigen/src/Eigenvalues/RealQZ.h	/^      Index iterations() const$/;"	f	class:Eigen::RealQZ
iterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int iterations() const$/;"	f	class:Eigen::IterativeSolverBase
itermax	srLib/srDyn/srISLAND.h	/^	int itermax;$/;"	m	struct:PGSOption
jacobiSvd	Eigen/src/SVD/JacobiSVD.h	/^MatrixBase<Derived>::jacobiSvd(unsigned int computationOptions) const$/;"	f	class:Eigen::MatrixBase
jointtype	srLib/srDyn/srJointConstraint.h	/^	srJoint::JOINTTYPE	jointtype;$/;"	m	class:JointConstraint
jvel	Example/DracoP1/Draco_Dyn_environment.h	/^    std::vector<double> jvel;$/;"	m	struct:state
kc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex kc() const { return m_kc; }$/;"	f	class:Eigen::internal::level3_blocking
keep_diag	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    struct keep_diag {$/;"	s	class:Eigen::IncompleteLUT
keep_diag	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    struct keep_diag {$/;"	s	class:Eigen::SimplicialCholeskyBase
kernel	Eigen/src/LU/FullPivLU.h	/^    inline const internal::kernel_retval<FullPivLU> kernel() const$/;"	f	class:Eigen::FullPivLU
kernel_retval	Eigen/src/LU/FullPivLU.h	/^struct kernel_retval<FullPivLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
kernel_retval_base	Eigen/src/misc/Kernel.h	/^  kernel_retval_base(const DecompositionType& dec)$/;"	f	struct:Eigen::internal::kernel_retval_base
kernel_retval_base	Eigen/src/misc/Kernel.h	/^template<typename _DecompositionType> struct kernel_retval_base$/;"	s	namespace:Eigen::internal
keyboard2Overloading	srLib/SceneGraph/SceneGraphRenderer.h	/^	virtual		void	keyboard2Overloading(unsigned char key, int x, int y) {}$/;"	f	class:SceneGraphRenderer
keyboardFunc	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::keyboardFunc( unsigned char key, int x, int y )$/;"	f	class:SceneGraphRenderer
keyboardFunc2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::keyboardFunc2( unsigned char key, int x, int y )$/;"	f	class:SceneGraphRenderer
keyboardOverloading	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::keyboardOverloading(unsigned char key, int x, int y)$/;"	f	class:SceneGraphRenderer
l1CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l1CacheSize()$/;"	f	namespace:Eigen
l2CacheSize	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t l2CacheSize()$/;"	f	namespace:Eigen
lambda	srLib/srDyn/srClosedLoopConstraint.h	/^	SR_REAL	lambda[6];$/;"	m	class:ClosedLoop
lambda	srLib/srDyn/srContactConstraint.h	/^	SR_REAL	lambda[3];$/;"	m	struct:Contact
lambda	srLib/srDyn/srJointConstraint.h	/^	SR_REAL	lambda;$/;"	m	class:JointConstraint
lastCoeff	Eigen/src/SparseCore/SparseBlock.h	/^    const Scalar& lastCoeff() const$/;"	f	class:Eigen::BlockImpl
lastErrorMessage	Eigen/src/SparseLU/SparseLU.h	/^    std::string lastErrorMessage() const$/;"	f	class:Eigen::SparseLU
lastErrorMessage	Eigen/src/SparseQR/SparseQR.h	/^    std::string lastErrorMessage() const { return m_lastError; }$/;"	f	class:Eigen::SparseQR
lastfactor	srLib/SceneGraph/gl2ps.c	/^  GLint viewport[4], blendfunc[2], lastfactor;$/;"	m	struct:__anon15	file:
lastlinewidth	srLib/SceneGraph/gl2ps.c	/^  GLfloat *feedback, offset[2], lastlinewidth;$/;"	m	struct:__anon15	file:
lastpattern	srLib/SceneGraph/gl2ps.c	/^  GLushort lastpattern;$/;"	m	struct:__anon15	file:
lastrgba	srLib/SceneGraph/gl2ps.c	/^  GL2PSrgba *colormap, lastrgba, threshold, bgcolor;$/;"	m	struct:__anon15	file:
lastvertex	srLib/SceneGraph/gl2ps.c	/^  GL2PSvertex lastvertex;$/;"	m	struct:__anon15	file:
lazy	Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::lazy() const$/;"	f	class:Eigen::MatrixBase
lazyAssign	Eigen/src/Core/Assign.h	/^  ::lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
lazyAssign	Eigen/src/Core/MatrixBase.h	/^    Derived& lazyAssign(const Flagged<OtherDerived, 0, EvalBeforeAssigningBit>& other)$/;"	f	class:Eigen::MatrixBase
lazyAssign	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& lazyAssign(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::PlainObjectBase
lazyAssign	Eigen/src/Core/ProductBase.h	/^Derived& MatrixBase<Derived>::lazyAssign(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:MatrixBase
lazyAssign	Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::lazyAssign(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
lazyAssign	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE SelfCwiseBinaryOp& lazyAssign(const DenseBase<RhsDerived>& rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp
lazyAssign	Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
lazyAssign	Eigen/src/Core/TriangularMatrix.h	/^void TriangularView<MatrixType, Mode>::lazyAssign(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
lazyProduct	Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::lazyProduct(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
lda	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon458::__anon459
ldlt	Eigen/src/Cholesky/LDLT.h	/^MatrixBase<Derived>::ldlt() const$/;"	f	class:Eigen::MatrixBase
ldlt	Eigen/src/Cholesky/LDLT.h	/^SelfAdjointView<MatrixType, UpLo>::ldlt() const$/;"	f	class:Eigen::SelfAdjointView
ldlt_inplace	Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Lower>$/;"	s	namespace:Eigen::internal
ldlt_inplace	Eigen/src/Cholesky/LDLT.h	/^template<> struct ldlt_inplace<Upper>$/;"	s	namespace:Eigen::internal
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr leftCols(Index n)$/;"	f
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr leftCols(Index n) const$/;"	f
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type leftCols(Index n = N) const$/;"	f
leftCols	Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type leftCols(Index n = N)$/;"	f
leftPos	srLib/SceneGraph/Leaf.h	/^		Vec3        leftPos;$/;"	m	struct:Strip::PTY
len	srLib/SceneGraph/Model3DS.h	/^		unsigned long  len;	\/\/ The length of the chunk$/;"	m	struct:Model3DS::ChunkHeader
length	Eigen/src/Householder/HouseholderSequence.h	/^    Index length() const { return m_length; }  \/**< \\brief Returns the length of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
length	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  Index length ;  \/* number of principal columns in this row *\/$/;"	m	struct:internal::Colamd_Row
length	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  Index length ;  \/* number of rows in this column *\/$/;"	m	struct:internal::colamd_col
length	srLib/LieGroup/LieGroup.h	/^	SR_REAL length() const                                   \/\/ d = Q.length()$/;"	f	union:Quaternion
length	tinyxml2/tinyxml2.cpp	/^    int length;$/;"	m	struct:tinyxml2::Entity	file:
level3_blocking	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    level3_blocking()$/;"	f	class:Eigen::internal::level3_blocking
level3_blocking	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^class level3_blocking$/;"	c	namespace:Eigen::internal
lhs	Eigen/src/Core/CwiseBinaryOp.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CwiseBinaryOp
lhs	Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::CoeffBasedProduct
lhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct
lhs	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseDiagonalProduct
lhs	Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _LhsNested& lhs() const { return m_lhs; }$/;"	f	class:Eigen::SparseSparseProduct
lifetime	srLib/srDyn/srContactConstraint.h	/^	int		lifetime;$/;"	m	struct:Contact
lifetime	srLib/srDyn/srJointConstraint.h	/^	int		lifetime;$/;"	m	class:JointConstraint
lineWidth	srLib/SceneGraph/Leaf.h	/^	GLdouble	lineWidth;$/;"	m	class:Coordinate
lineWidth	srLib/SceneGraph/Leaf.h	/^	double		lineWidth;$/;"	m	class:Lines
linear	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform
linear	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline LinearPart linear() { return m_matrix.template block<Dim,Dim>(0,0); }$/;"	f	class:Eigen::Transform
linear	Eigen/src/Geometry/Transform.h	/^  inline ConstLinearPart linear() const { return ConstLinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linear	Eigen/src/Geometry/Transform.h	/^  inline LinearPart linear() { return LinearPart(m_matrix,0,0); }$/;"	f	class:Eigen::Transform
linearExt	Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt()$/;"	f	class:Eigen::Transform
linearExt	Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,Dim> linearExt() const$/;"	f	class:Eigen::Transform
linearRegression	Eigen/src/Eigen2Support/LeastSquares.h	/^void linearRegression(int numPoints,$/;"	f	namespace:Eigen
linkState	srLib/srExt/srExt_System.h	/^		struct linkState$/;"	s	class:srExt::srExtSystem
linkState	srLib/srExt/srExtension.h	/^	struct linkState$/;"	s	namespace:srExt
link_	Example/DracoP1/draco.h	/^  std::vector<srLink*> link_;$/;"	m	class:srDraco
link_idx_map_	Example/DracoP1/draco.h	/^  std::map<std::string, int> link_idx_map_;$/;"	m	class:srDraco
linkpair_for_closedloop	srLib/srDyn/srSystem.h	/^	struct linkpair_for_closedloop$/;"	s	class:srSystem
linspaced_op	Eigen/src/Core/Functors.h	/^  linspaced_op(const Scalar& low, const Scalar& high, DenseIndex num_steps) : impl((num_steps==1 ? high : low), (num_steps==1 ? Scalar() : (high-low)\/Scalar(num_steps-1))) {}$/;"	f	struct:Eigen::internal::linspaced_op
linspaced_op	Eigen/src/Core/Functors.h	/^template <typename Scalar, bool RandomAccess> struct linspaced_op$/;"	s	namespace:Eigen::internal
linspaced_op_impl	Eigen/src/Core/Functors.h	/^  linspaced_op_impl(const Scalar& low, const Scalar& step) :$/;"	f	struct:Eigen::internal::linspaced_op_impl
linspaced_op_impl	Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,false>$/;"	s	namespace:Eigen::internal
linspaced_op_impl	Eigen/src/Core/Functors.h	/^struct linspaced_op_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
list	Eigen/src/StlSupport/StdList.h	/^  class list<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
listID	srLib/SceneGraph/Leaf.h	/^	int listID;$/;"	m	class:Leaf
list_base	Eigen/src/StlSupport/StdList.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > list_base;$/;"	t	class:std::list
lit	srLib/SceneGraph/Model3DS.h	/^	bool	lit;				\/\/ True: the model is lit$/;"	m	class:Model3DS
llt	Eigen/src/Cholesky/LLT.h	/^MatrixBase<Derived>::llt() const$/;"	f	class:Eigen::MatrixBase
llt	Eigen/src/Cholesky/LLT.h	/^SelfAdjointView<MatrixType, UpLo>::llt() const$/;"	f	class:Eigen::SelfAdjointView
llt_inplace	Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Lower>$/;"	s	namespace:Eigen::internal
llt_inplace	Eigen/src/Cholesky/LLT.h	/^template<typename Scalar> struct llt_inplace<Scalar, Upper>$/;"	s	namespace:Eigen::internal
llt_rank_update_lower	Eigen/src/Cholesky/LLT.h	/^static typename MatrixType::Index llt_rank_update_lower(MatrixType& mat, const VectorType& vec, const typename MatrixType::RealScalar& sigma)$/;"	f	namespace:Eigen::internal
loadLhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadLhs(const LhsScalar* a, LhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, DoublePacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, ResPacket& dest) const { dest = *b; }$/;"	f	class:Eigen::internal::gebp_traits
loadRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void loadRhs(const RhsScalar* b, RhsPacket& dest) const$/;"	f	class:Eigen::internal::gebp_traits
localFrame	srLib/SceneGraph/Leaf.h	/^	SE3				localFrame;$/;"	m	class:TDSNode
localFrame	srLib/SceneGraph/Leaf.h	/^	SE3			localFrame;$/;"	m	class:STLNode
localFrame	srLib/SceneGraph/Transformation.h	/^	SE3		localFrame;$/;"	m	class:Transformation
localpoint_Left	srLib/srDyn/srContactConstraint.h	/^	Vec3	localpoint_Left;$/;"	m	struct:Contact
localpoint_Right	srLib/srDyn/srContactConstraint.h	/^	Vec3	localpoint_Right;$/;"	m	struct:Contact
log	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::log() const$/;"	f	class:Eigen::Cwise
log	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^log() const$/;"	f
log	srLib/LieGroup/LieGroup.cpp	/^Quaternion& Quaternion::log()$/;"	f	class:Quaternion
logAbsDeterminant	Eigen/src/QR/ColPivHouseholderQR.h	/^typename MatrixType::RealScalar ColPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::ColPivHouseholderQR
logAbsDeterminant	Eigen/src/QR/FullPivHouseholderQR.h	/^typename MatrixType::RealScalar FullPivHouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::FullPivHouseholderQR
logAbsDeterminant	Eigen/src/QR/HouseholderQR.h	/^typename MatrixType::RealScalar HouseholderQR<MatrixType>::logAbsDeterminant() const$/;"	f	class:Eigen::HouseholderQR
logAbsDeterminant	Eigen/src/SparseLU/SparseLU.h	/^     Scalar logAbsDeterminant() const$/;"	f	class:Eigen::SparseLU
lpNorm	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::lpNorm() const$/;"	f	class:Eigen::MatrixBase
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector$/;"	s	namespace:Eigen::internal
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 1>$/;"	s	namespace:Eigen::internal
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, 2>$/;"	s	namespace:Eigen::internal
lpNorm_selector	Eigen/src/Core/Dot.h	/^struct lpNorm_selector<Derived, Infinity>$/;"	s	namespace:Eigen::internal
lsub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector lsub; \/\/ Compressed row indices of L rectangular supernodes. $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
lu	Eigen/src/Eigen2Support/LU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase
lu	Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::lu() const$/;"	f	class:Eigen::MatrixBase
lusup	Eigen/src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  lusup; \/\/ nonzero values of L ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
mCollision	srLib/common/srRobot.h	/^		map < string, srCollision* > mCollision;$/;"	m	class:srrobot::srRobot
mJoint	srLib/common/srRobot.h	/^		map < string, srJoint* > mJoint;$/;"	m	class:srrobot::srRobot
mLink	srLib/common/srRobot.h	/^		map < string, srLink* > mLink;$/;"	m	class:srrobot::srRobot
m_AInertia	srLib/srDyn/srLink.h	/^	AInertia	m_AInertia;$/;"	m	class:srLink
m_Acc	srLib/srDyn/srLink.h	/^	se3			m_Acc;$/;"	m	class:srLink
m_Acc	srLib/srDyn/srState.h	/^	Vec3	m_Acc;			\/\/ so3$/;"	m	class:srBallState
m_AccLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	m_AccLimit[2];$/;"	m	class:srExtRevoluteJoint
m_ActType	srLib/srDyn/srJoint.h	/^	ACTTYPE	m_ActType;$/;"	m	class:srJoint
m_Active	srLib/srDyn/srSpring.h	/^	SR_REAL	m_Active;$/;"	m	class:srSpring
m_AllConstraints	srLib/srDyn/srISLAND.h	/^	ConstraintPtrArray				m_AllConstraints;$/;"	m	class:ISLAND
m_AspectRatio	srLib/srg/srgCamera.h	/^	double			m_AspectRatio;$/;"	m	class:srgCamera
m_Axis	srLib/srDyn/srBallJoint.h	/^	se3		m_Axis[3];$/;"	m	class:srBallJoint
m_Axis	srLib/srDyn/srPrismaticJoint.h	/^	se3		m_Axis;$/;"	m	class:srPrismaticJoint
m_Axis	srLib/srDyn/srRevoluteJoint.h	/^	se3		m_Axis;$/;"	m	class:srRevoluteJoint
m_Axis1	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_Axis1;$/;"	m	class:srUniversalJoint
m_Axis2	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_Axis2;$/;"	m	class:srUniversalJoint
m_Baked_ClosedLoops	srLib/srDyn/srDYN.h	/^	ClosedLoopArray						m_Baked_ClosedLoops;		\/\/ closed loop constraint objects$/;"	m	class:srDYN
m_Baked_ContactConstraints	srLib/srDyn/srDYN.h	/^	ContactConstraintArray				m_Baked_ContactConstraints;	\/\/ contact constraint objects$/;"	m	class:srDYN
m_Baked_JointConstraints	srLib/srDyn/srDYN.h	/^	JointConstraintArray				m_Baked_JointConstraints;	\/\/ joint constraint objects$/;"	m	class:srDYN
m_BaseLink	srLib/srDyn/srSystem.h	/^	srLink *	 m_BaseLink;$/;"	m	class:srSystem
m_BaseLinkType	srLib/srDyn/srSystem.h	/^	BASELINKTYPE m_BaseLinkType;$/;"	m	class:srSystem
m_Bias	srLib/srDyn/srLink.h	/^	dse3		m_Bias;$/;"	m	class:srLink
m_Body	Example/MobileRobots/MobileRobots.h	/^	srLink			m_Body;	$/;"	m	class:MobileRobot
m_BodyCollision	Example/MobileRobots/MobileRobots.h	/^	srCollision		m_BodyCollision;$/;"	m	class:MobileRobot
m_BoundingRadius	srLib/srDyn/srCollision.h	/^	SR_REAL	m_BoundingRadius;$/;"	m	class:srCollision
m_BoundingRadius	srLib/srDyn/srGeometryInfo.h	/^	float	m_BoundingRadius;$/;"	m	class:srGeometryInfo
m_C	srLib/srDyn/srLinearSpring.h	/^	SR_REAL	m_C;$/;"	m	class:srLinearSpring
m_COM	srLib/srDyn/srSystem.h	/^	Vec3	m_COM;$/;"	m	class:srSystem
m_Caster	Example/MobileRobots/MobileRobots.h	/^	srLink			m_Caster;$/;"	m	class:MobileRobot
m_CasterCollision	Example/MobileRobots/MobileRobots.h	/^	srCollision 	m_CasterCollision;$/;"	m	class:MobileRobot
m_CasterFixation	Example/MobileRobots/MobileRobots.h	/^	srWeldJoint 	m_CasterFixation;$/;"	m	class:MobileRobot
m_ChildJoints	srLib/srDyn/srLink.h	/^	_array<srJoint*>		m_ChildJoints;$/;"	m	class:srLink
m_ChildLink	srLib/srDyn/srJoint.h	/^	srLink*	m_ChildLink;$/;"	m	class:srJoint
m_ChildLinkToJoint	srLib/srDyn/srJoint.h	/^	SE3		m_ChildLinkToJoint;$/;"	m	class:srJoint
m_ChildLinks	srLib/srDyn/srLink.h	/^	_array<srLink*> m_ChildLinks;$/;"	m	class:srLink
m_CollisionPairArray	srLib/srDyn/srDYN.h	/^	CollisionPairArray					m_CollisionPairArray;$/;"	m	class:srDYN
m_Collisions	srLib/srDyn/srLink.h	/^	_array<srCollision*>	m_Collisions;$/;"	m	class:srLink
m_Collisions	srLib/srDyn/srSpace.h	/^	_array<srCollision*>				m_Collisions;	$/;"	m	class:srSpace
m_Color	srLib/srDyn/srGeometryInfo.h	/^	float	m_Color[4];$/;"	m	class:srGeometryInfo
m_Command	srLib/srDyn/srState.h	/^	Vec3	m_Command;$/;"	m	class:srBallState
m_ConstraintImpulse	srLib/srDyn/srLink.h	/^	dse3		m_ConstraintImpulse;$/;"	m	class:srLink
m_CoulombCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL m_CoulombCoeff;$/;"	m	class:srExtRevoluteJoint
m_CurrentLength	srLib/srDyn/srLinearSpring.h	/^	SR_REAL	m_CurrentLength;$/;"	m	class:srLinearSpring
m_Damping	srLib/srDyn/srLink.h	/^	SR_REAL	m_Damping;$/;"	m	class:srLink
m_Data	srLib/SceneGraph/Bitmap.h	/^	BYTE*	m_Data;$/;"	m	class:_Bitmap
m_Data	srLib/srg/srgBitmap.h	/^	BYTE*	m_Data;$/;"	m	class:_Bitmap
m_DelVel	srLib/srDyn/srLink.h	/^	se3			m_DelVel;$/;"	m	class:srLink
m_DelVel	srLib/srDyn/srState.h	/^	Vec3	m_DelVel;$/;"	m	class:srBallState
m_DetectedValue	srLib/srDyn/srIRSensor.h	/^	SR_REAL	m_DetectedValue;$/;"	m	class:srIRSensor
m_DetectedValue	srLib/srDyn/srRangeFinder.h	/^	SR_REAL	m_DetectedValue[MAX_SPOT];$/;"	m	class:srRangeFinder
m_DetectedValue	srLib/srDyn/srTouchSensor.h	/^	bool	m_DetectedValue;$/;"	m	class:srTouchSensor
m_Dimension	srLib/srDyn/srGeometryInfo.h	/^	Vec3	m_Dimension;$/;"	m	class:srGeometryInfo
m_DirectionalVector	srLib/srDyn/srLinearSpring.h	/^	Vec3	m_DirectionalVector;$/;"	m	class:srLinearSpring
m_DynType	srLib/srDyn/srLink.h	/^	DYNTYPE		m_DynType;$/;"	m	class:srLink
m_E	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index *m_E; \/\/ The permutation applied to columns$/;"	m	class:Eigen::SPQR
m_EulerAngle	srLib/srDyn/srEntity.h	/^	InvVec3		m_EulerAngle;$/;"	m	class:srEntity
m_EulerAngle	srLib/srDyn/srState.h	/^	InvVec3	m_EulerAngle;$/;"	m	class:srBallState
m_ExtForce	srLib/srDyn/srLink.h	/^	dse3		m_ExtForce;$/;"	m	class:srLink
m_FPS_dyn_fixed	srLib/srDyn/srSpace.h	/^	SR_REAL								m_FPS_dyn_fixed;$/;"	m	class:srSpace
m_FPS_fixed	srLib/srDyn/srDYN.h	/^	SR_REAL								m_FPS_fixed; \/\/ frame per second  ( : 1\/timestep )$/;"	m	class:srDYN
m_FS_AIS	srLib/srDyn/srBallJoint.h	/^	dse3	m_FS_AIS[3];$/;"	m	class:srBallJoint
m_FS_AIS	srLib/srDyn/srPrismaticJoint.h	/^	dse3	m_FS_AIS;$/;"	m	class:srPrismaticJoint
m_FS_AIS	srLib/srDyn/srRevoluteJoint.h	/^	dse3	m_FS_AIS;$/;"	m	class:srRevoluteJoint
m_FS_AISPinv	srLib/srDyn/srBallJoint.h	/^	dse3	m_FS_AISPinv[3];$/;"	m	class:srBallJoint
m_FS_AIS_1	srLib/srDyn/srUniversalJoint.h	/^	dse3			 m_FS_AIS_1, m_FS_AIS_2;$/;"	m	class:srUniversalJoint
m_FS_AIS_2	srLib/srDyn/srUniversalJoint.h	/^	dse3			 m_FS_AIS_1, m_FS_AIS_2;$/;"	m	class:srUniversalJoint
m_FS_AI_med	srLib/srDyn/srUniversalJoint.h	/^	AInertia		 m_FS_AI_med;$/;"	m	class:srUniversalJoint
m_FS_Force	srLib/srDyn/srJoint.h	/^	dse3	m_FS_Force;$/;"	m	class:srJoint
m_FS_Force_SE3	srLib/srDyn/srJoint.h	/^	SE3		m_FS_Force_SE3;$/;"	m	class:srJoint
m_FS_K	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_FS_K;$/;"	m	class:srPrismaticJoint
m_FS_K	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_FS_K;$/;"	m	class:srRevoluteJoint
m_FS_K_1	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_FS_K_1, m_FS_K_2;$/;"	m	class:srUniversalJoint
m_FS_K_2	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_FS_K_1, m_FS_K_2;$/;"	m	class:srUniversalJoint
m_FS_LocalVelocity	srLib/srDyn/srJoint.h	/^	se3		m_FS_LocalVelocity;$/;"	m	class:srJoint
m_FS_LocalVelocity_1	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_FS_LocalVelocity_1, m_FS_LocalVelocity_2;$/;"	m	class:srUniversalJoint
m_FS_LocalVelocity_2	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_FS_LocalVelocity_1, m_FS_LocalVelocity_2;$/;"	m	class:srUniversalJoint
m_FS_SE3	srLib/srDyn/srJoint.h	/^	SE3		m_FS_SE3;$/;"	m	class:srJoint
m_FS_SE3_1	srLib/srDyn/srUniversalJoint.h	/^	SE3				 m_FS_SE3_1, m_FS_SE3_2;$/;"	m	class:srUniversalJoint
m_FS_SE3_2	srLib/srDyn/srUniversalJoint.h	/^	SE3				 m_FS_SE3_1, m_FS_SE3_2;$/;"	m	class:srUniversalJoint
m_FS_Screw	srLib/srDyn/srBallJoint.h	/^	se3		m_FS_Screw[3];$/;"	m	class:srBallJoint
m_FS_Screw	srLib/srDyn/srPrismaticJoint.h	/^	se3		m_FS_Screw;$/;"	m	class:srPrismaticJoint
m_FS_Screw	srLib/srDyn/srRevoluteJoint.h	/^	se3		m_FS_Screw;$/;"	m	class:srRevoluteJoint
m_FS_Screw1	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_FS_Screw1, m_FS_Screw2;$/;"	m	class:srUniversalJoint
m_FS_Screw2	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_FS_Screw1, m_FS_Screw2;$/;"	m	class:srUniversalJoint
m_FS_T	srLib/srDyn/srBallJoint.h	/^	Vec3	m_FS_T;$/;"	m	class:srBallJoint
m_FS_T	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_FS_T;$/;"	m	class:srPrismaticJoint
m_FS_T	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_FS_T;$/;"	m	class:srRevoluteJoint
m_FS_T1	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_FS_T1, m_FS_T2;$/;"	m	class:srUniversalJoint
m_FS_T2	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_FS_T1, m_FS_T2;$/;"	m	class:srUniversalJoint
m_FS_W	srLib/srDyn/srBallJoint.h	/^	se3		m_FS_W;$/;"	m	class:srBallJoint
m_FS_W	srLib/srDyn/srPrismaticJoint.h	/^	se3		m_FS_W;$/;"	m	class:srPrismaticJoint
m_FS_W	srLib/srDyn/srRevoluteJoint.h	/^	se3		m_FS_W;$/;"	m	class:srRevoluteJoint
m_FS_W1	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_FS_W1, m_FS_W2;$/;"	m	class:srUniversalJoint
m_FS_W2	srLib/srDyn/srUniversalJoint.h	/^	se3				 m_FS_W1, m_FS_W2;$/;"	m	class:srUniversalJoint
m_Filename	srLib/srDyn/srGeometryInfo.h	/^	char	m_Filename[2048];$/;"	m	class:srGeometryInfo
m_Force	srLib/srDyn/srLinearSpring.h	/^	Vec3	m_Force;$/;"	m	class:srLinearSpring
m_Frame	srLib/srDyn/srEntity.h	/^	SE3			m_Frame;$/;"	m	class:srEntity
m_Friction	srLib/srDyn/srLink.h	/^	SR_REAL	m_Friction;$/;"	m	class:srLink
m_GearRatio	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL m_GearRatio;$/;"	m	class:srExtRevoluteJoint
m_GeomInfo	srLib/srDyn/srEntity.h	/^	srGeometryInfo	m_GeomInfo;$/;"	m	class:srEntity
m_Gravity	srLib/srDyn/srSpace.h	/^	Vec3					m_Gravity;$/;"	m	class:srSpace
m_Ground	Example/DracoP1/Ground.h	/^    srLink*		m_Ground;$/;"	m	class:Ground
m_Ground	Example/MobileRobots/Ground.h	/^	srLink*		m_Ground;$/;"	m	class:Ground
m_H	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_H;  \/\/The householder vectors$/;"	m	class:Eigen::SPQR
m_HPinv	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index *m_HPinv; \/\/ The row permutation of H$/;"	m	class:Eigen::SPQR
m_HTau	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_dense *m_HTau; \/\/ The Householder coefficients$/;"	m	class:Eigen::SPQR
m_Height	srLib/SceneGraph/Bitmap.h	/^	int		m_Height;$/;"	m	class:_Bitmap
m_Height	srLib/SceneGraph/Texture3DS.h	/^	int		m_Height;			\/\/ Texture's height$/;"	m	class:Texture3DS
m_Height	srLib/srg/srgBitmap.h	/^	int		m_Height;$/;"	m	class:_Bitmap
m_History	srLib/srDyn/srLink.h	/^	_array<SE3>	m_History;$/;"	m	class:srLink
m_History	srLib/srDyn/srState.h	/^	_array<SO3>	m_History;$/;"	m	class:srBallState
m_History	srLib/srDyn/srState.h	/^	_array<_state>	m_History;$/;"	m	class:srUniversalState
m_History	srLib/srDyn/srState.h	/^	_array<float>	m_History;$/;"	m	class:srRevoluteState
m_ID	srLib/srDyn/srISLAND.h	/^	srSystem*						m_ID;$/;"	m	class:ISLAND
m_IR	Example/MobileRobots/MobileRobots.h	/^	srIRSensor		m_IR;$/;"	m	class:MobileRobot
m_Idx_State	srLib/srDyn/srUniversalJoint.h	/^	int				 m_Idx_State[2];$/;"	m	class:srUniversalJoint
m_Imp	srLib/srDyn/srState.h	/^	Vec3	m_Imp;$/;"	m	class:srBallState
m_Inertia	srLib/srDyn/srLink.h	/^	Inertia		m_Inertia;$/;"	m	class:srLink
m_InitAcc	srLib/srDyn/srState.h	/^	Vec3	m_InitAcc;$/;"	m	class:srBallState
m_InitFrame	srLib/srDyn/srLink.h	/^	SE3		m_InitFrame;$/;"	m	class:srLink
m_InitPos	srLib/srDyn/srState.h	/^	SO3		m_InitPos;$/;"	m	class:srBallState
m_InitTorque	srLib/srDyn/srState.h	/^	Vec3	m_InitTorque;$/;"	m	class:srBallState
m_InitValue	srLib/srDyn/srState.h	/^	float	m_InitValue[2][4];$/;"	m	class:srUniversalState
m_InitValue	srLib/srDyn/srState.h	/^	float	m_InitValue[4];$/;"	m	class:srRevoluteState
m_InitVel	srLib/srDyn/srLink.h	/^	se3		m_InitVel;$/;"	m	class:srLink
m_InitVel	srLib/srDyn/srState.h	/^	Vec3	m_InitVel;$/;"	m	class:srBallState
m_InitialLength	srLib/srDyn/srLinearSpring.h	/^	SR_REAL	m_InitialLength;$/;"	m	class:srLinearSpring
m_IsAccLimited	srLib/srExt/srExt_RevoluteJoint.h	/^	bool m_IsAccLimited;$/;"	m	class:srExtRevoluteJoint
m_IsBaseLink	srLib/srDyn/srLink.h	/^	bool					m_IsBaseLink;$/;"	m	class:srLink
m_IsDeviceOn	srLib/srDyn/srJoint.h	/^	bool	m_IsDeviceOn;$/;"	m	class:srJoint
m_IsGearRatioSet	srLib/srExt/srExt_RevoluteJoint.h	/^	bool m_IsGearRatioSet;$/;"	m	class:srExtRevoluteJoint
m_IsLonelySystem	srLib/srDyn/srSystem.h	/^	bool		m_IsLonelySystem;$/;"	m	class:srSystem
m_IsMaxRPMSet	srLib/srExt/srExt_RevoluteJoint.h	/^	bool m_IsMaxRPMSet;$/;"	m	class:srExtRevoluteJoint
m_IsMotorParameters	srLib/srExt/srExt_RevoluteJoint.h	/^	bool m_IsMotorParameters;$/;"	m	class:srExtRevoluteJoint
m_IsPosLimited	srLib/srDyn/srBallJoint.h	/^	bool	m_IsPosLimited[2];$/;"	m	class:srBallJoint
m_IsPosLimited	srLib/srDyn/srPrismaticJoint.h	/^	bool	m_IsPosLimited;$/;"	m	class:srPrismaticJoint
m_IsPosLimited	srLib/srDyn/srRevoluteJoint.h	/^	bool	m_IsPosLimited;$/;"	m	class:srRevoluteJoint
m_IsPosLimited	srLib/srDyn/srUniversalJoint.h	/^	bool	m_IsPosLimited[2];$/;"	m	class:srUniversalJoint
m_IsSelfCollision	srLib/srDyn/srSystem.h	/^	bool	m_IsSelfCollision;$/;"	m	class:srSystem
m_IsVelLimited	srLib/srExt/srExt_RevoluteJoint.h	/^	bool m_IsVelLimited;$/;"	m	class:srExtRevoluteJoint
m_JointType	srLib/srDyn/srJoint.h	/^	JOINTTYPE m_JointType;$/;"	m	class:srJoint
m_Joints	srLib/srDyn/srSpace.h	/^	_array<srJoint*>					m_Joints;		$/;"	m	class:srSpace
m_K	srLib/srDyn/srLinearSpring.h	/^	SR_REAL	m_K;$/;"	m	class:srLinearSpring
m_KIN_Collisions	srLib/srDyn/srSystem.h	/^	_array<srCollision*>	m_KIN_Collisions;$/;"	m	class:srSystem
m_KIN_Joints	srLib/srDyn/srSystem.h	/^	_array<srJoint*>		m_KIN_Joints;$/;"	m	class:srSystem
m_KIN_Links	srLib/srDyn/srSystem.h	/^	_array<srLink*>			m_KIN_Links;$/;"	m	class:srSystem
m_KIN_Sensors	srLib/srDyn/srSystem.h	/^	_array<srSensor*>		m_KIN_Sensors;$/;"	m	class:srSystem
m_LDLT	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_LDLT;$/;"	m	class:Eigen::SimplicialCholesky
m_L_Link	srLib/srDyn/srSystem.h	/^	srLink *	m_L_Link;$/;"	m	class:srSystem
m_L_Link_Inertia	srLib/srDyn/srSystem.h	/^	AInertia	m_L_Link_Inertia;$/;"	m	class:srSystem
m_L_Link_InvInertia	srLib/srDyn/srSystem.h	/^	AInertia	m_L_Link_InvInertia;$/;"	m	class:srSystem
m_LeftLink	srLib/srDyn/srSpring.h	/^	srLink*	m_LeftLink;$/;"	m	class:srSpring
m_LeftLinkToSpring	srLib/srDyn/srSpring.h	/^	SE3		m_LeftLinkToSpring;$/;"	m	class:srSpring
m_LeftMotor	Example/MobileRobots/MobileRobots.h	/^	srRevoluteJoint	m_LeftMotor;$/;"	m	class:MobileRobot
m_LeftPosition	srLib/srDyn/srLinearSpring.h	/^	Vec3	m_LeftPosition;$/;"	m	class:srLinearSpring
m_LeftWheel	Example/MobileRobots/MobileRobots.h	/^	srLink			m_LeftWheel;$/;"	m	class:MobileRobot
m_LeftWheelCollision	Example/MobileRobots/MobileRobots.h	/^	srCollision		m_LeftWheelCollision;$/;"	m	class:MobileRobot
m_Links	srLib/srDyn/srSpace.h	/^	_array<srLink*>						m_Links;		$/;"	m	class:srSpace
m_LocalFrame	srLib/srDyn/srCollision.h	/^	SE3		m_LocalFrame;$/;"	m	class:srCollision
m_LocalFrame	srLib/srDyn/srGeometryInfo.h	/^	SE3		m_LocalFrame;$/;"	m	class:srGeometryInfo
m_LocalFrame	srLib/srDyn/srSensor.h	/^	SE3		m_LocalFrame;$/;"	m	class:srSensor
m_Lstore	Eigen/src/SparseLU/SparseLU.h	/^    SCMatrix m_Lstore; \/\/ The lower triangular matrix (supernodal)$/;"	m	class:Eigen::SparseLU
m_M	srLib/srDyn/srLink.h	/^	SE3			m_M;$/;"	m	class:srLink
m_MassPairs	srLib/srDyn/srDYN.h	/^	MassPairArray		m_MassPairs;	\/\/ temporary..$/;"	m	class:srDYN
m_MaxRPM	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL m_MaxRPM;$/;"	m	class:srExtRevoluteJoint
m_MaxRange	srLib/srDyn/srIRSensor.h	/^	SR_REAL	m_MaxRange;$/;"	m	class:srIRSensor
m_MaxRange	srLib/srDyn/srRangeFinder.h	/^	SR_REAL	m_MaxRange;$/;"	m	class:srRangeFinder
m_MexpSq	srLib/srDyn/srLink.h	/^	SE3			m_MexpSq;$/;"	m	class:srLink
m_MinRange	srLib/srDyn/srIRSensor.h	/^	SR_REAL	m_MinRange;$/;"	m	class:srIRSensor
m_MinRange	srLib/srDyn/srRangeFinder.h	/^	SR_REAL	m_MinRange;$/;"	m	class:srRangeFinder
m_Model	srLib/SceneGraph/Leaf.h	/^	Model3DS*		m_Model;$/;"	m	class:TDSNode
m_Model	srLib/SceneGraph/Leaf.h	/^	ModelSTL*	m_Model;$/;"	m	class:STLNode
m_Name	srLib/srDyn/srObject.h	/^	char	m_Name[1024];$/;"	m	class:srObject
m_Name	srLib/srDyn/srObject.h	/^	wstring m_Name;$/;"	m	class:srObject
m_NumSpots	srLib/srDyn/srRangeFinder.h	/^	int		m_NumSpots;		$/;"	m	class:srRangeFinder
m_Objects	srLib/srDyn/srIRSensor.h	/^	_array<srCollision*>	m_Objects;$/;"	m	class:srIRSensor
m_Objects	srLib/srDyn/srRangeFinder.h	/^	_array<srCollision*>	m_Objects;$/;"	m	class:srRangeFinder
m_Objects	srLib/srDyn/srTouchSensor.h	/^	_array<srCollision*>	m_Objects;$/;"	m	class:srTouchSensor
m_Offset	srLib/srDyn/srBallJoint.h	/^	SO3			 m_Offset;$/;"	m	class:srBallJoint
m_Orientation	srLib/srDyn/srEntity.h	/^	SO3			m_Orientation;$/;"	m	class:srEntity
m_P	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ Fill-reducing permutation$/;"	m	class:Eigen::IncompleteLUT
m_P	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_P;     \/\/ the permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_P	srLib/srDyn/srBallJoint.h	/^	SR_REAL	m_P[9];$/;"	m	class:srBallJoint
m_PGSOption	srLib/srDyn/srDYN.h	/^	PGSOption							m_PGSOption;$/;"	m	class:srDYN
m_ParentJoint	srLib/srDyn/srLink.h	/^	srJoint*		 m_ParentJoint;$/;"	m	class:srLink
m_ParentLink	srLib/srDyn/srJoint.h	/^	srLink*	m_ParentLink;$/;"	m	class:srJoint
m_ParentLink	srLib/srDyn/srLink.h	/^	srLink*			 m_ParentLink;$/;"	m	class:srLink
m_ParentLinkToJoint	srLib/srDyn/srJoint.h	/^	SE3		m_ParentLinkToJoint;$/;"	m	class:srJoint
m_Pinv	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ Inverse permutation$/;"	m	class:Eigen::IncompleteLUT
m_Pinv	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    PermutationMatrix<Dynamic,Dynamic,Index> m_Pinv;  \/\/ the inverse permutation$/;"	m	class:Eigen::SimplicialCholeskyBase
m_Pinv	srLib/srDyn/srBallJoint.h	/^	SR_REAL	m_Pinv[9];$/;"	m	class:srBallJoint
m_Plane	Example/DracoP1/Ground.h	/^    srCollision*m_Plane;$/;"	m	class:Ground
m_Plane	Example/MobileRobots/Ground.h	/^	srCollision*m_Plane;$/;"	m	class:Ground
m_PosErrVel	srLib/srDyn/srState.h	/^	Vec3	m_PosErrVel;$/;"	m	class:srBallState
m_PosLimit	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_PosLimit[2];$/;"	m	class:srPrismaticJoint
m_PosLimit	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_PosLimit[2];$/;"	m	class:srRevoluteJoint
m_PosLimit_1	srLib/srDyn/srBallJoint.h	/^	SR_REAL	m_PosLimit_1;$/;"	m	class:srBallJoint
m_PosLimit_1	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL	m_PosLimit_1[2];$/;"	m	class:srUniversalJoint
m_PosLimit_2	srLib/srDyn/srBallJoint.h	/^	SR_REAL	m_PosLimit_2[2];$/;"	m	class:srBallJoint
m_PosLimit_2	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL	m_PosLimit_2[2];$/;"	m	class:srUniversalJoint
m_Position	srLib/srDyn/srEntity.h	/^	Vec3		m_Position;		\/\/ Position$/;"	m	class:srEntity
m_Possible_ISLAND_IDs	srLib/srDyn/srDYN.h	/^	SystemPtrArray						m_Possible_ISLAND_IDs;$/;"	m	class:srDYN
m_PriorityIndex	srLib/srDyn/srJoint.h	/^	int		m_PriorityIndex;$/;"	m	class:srJoint
m_ProjMat	srLib/srg/srgCamera.h	/^	SE3				m_ProjMat;$/;"	m	class:srgCamera
m_Q	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_Q	Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_Q;               \/\/ The orthogonal reflectors$/;"	m	class:Eigen::SparseQR
m_R	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable MatrixType m_R; \/\/ The sparse matrix R in Eigen format$/;"	m	class:Eigen::SPQR
m_R	Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_R;               \/\/ The triangular factor matrix$/;"	m	class:Eigen::SparseQR
m_RF	Example/MobileRobots/MobileRobots.h	/^	srRangeFinder	m_RF;$/;"	m	class:MobileRobot
m_RGBA	srLib/srg/srgColor.h	/^	union { SRGBA sRGBA; float m_RGBA[4]; };$/;"	m	union:srgColor::__anon3
m_Range	srLib/srDyn/srTouchSensor.h	/^	SR_REAL	m_Range;$/;"	m	class:srTouchSensor
m_ResRad	srLib/srDyn/srRangeFinder.h	/^	SR_REAL	m_ResRad;$/;"	m	class:srRangeFinder
m_Resistance	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL m_Resistance;$/;"	m	class:srExtRevoluteJoint
m_Resolution	srLib/srDyn/srRangeFinder.h	/^	SR_REAL	m_Resolution;$/;"	m	class:srRangeFinder
m_Restitution	srLib/srDyn/srLink.h	/^	SR_REAL	m_Restitution;$/;"	m	class:srLink
m_RightLink	srLib/srDyn/srSpring.h	/^	srLink* m_RightLink;$/;"	m	class:srSpring
m_RightLinkToSpring	srLib/srDyn/srSpring.h	/^	SE3		m_RightLinkToSpring;$/;"	m	class:srSpring
m_RightMotor	Example/MobileRobots/MobileRobots.h	/^	srRevoluteJoint	m_RightMotor;$/;"	m	class:MobileRobot
m_RightPosition	srLib/srDyn/srLinearSpring.h	/^	Vec3	m_RightPosition;$/;"	m	class:srLinearSpring
m_RightWheel	Example/MobileRobots/MobileRobots.h	/^	srLink			m_RightWheel;$/;"	m	class:MobileRobot
m_RightWheelCollision	Example/MobileRobots/MobileRobots.h	/^	srCollision		m_RightWheelCollision;$/;"	m	class:MobileRobot
m_RollPitchLimit	srLib/srDyn/srState.h	/^	SR_REAL	m_RollPitchLimit;$/;"	m	class:srBallState
m_RotorInertia	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL m_RotorInertia;$/;"	m	class:srExtRevoluteJoint
m_S	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_SO3Pos	srLib/srDyn/srState.h	/^	SO3		m_SO3Pos;		\/\/ ball joint orientation$/;"	m	class:srBallState
m_SensorType	srLib/srDyn/srSensor.h	/^	SENSORTYPE m_SensorType;$/;"	m	class:srSensor
m_Sensors	srLib/srDyn/srLink.h	/^	_array<srSensor*>		m_Sensors;$/;"	m	class:srLink
m_Sensors	srLib/srDyn/srSpace.h	/^	_array<srSensor*>					m_Sensors;		$/;"	m	class:srSpace
m_Simulation_Time	srLib/srDyn/srSpace.h	/^	SR_REAL								m_Simulation_Time;$/;"	m	class:srSpace
m_Space	Example/DracoP1/Draco_Dyn_environment.h	/^        srSpace*	m_Space;$/;"	m	class:Draco_Dyn_environment
m_Spread	srLib/srDyn/srRangeFinder.h	/^	int		m_Spread;$/;"	m	class:srRangeFinder
m_SpreadRad	srLib/srDyn/srRangeFinder.h	/^	SR_REAL	m_SpreadRad;$/;"	m	class:srRangeFinder
m_Springs	srLib/srDyn/srSpace.h	/^	_array<srSpring*>					m_Springs;$/;"	m	class:srSpace
m_State	srLib/srDyn/srBallJoint.h	/^	srBallState	m_State;$/;"	m	class:srBallJoint
m_State	srLib/srDyn/srPrismaticJoint.h	/^	srPrismaticState	m_State;$/;"	m	class:srPrismaticJoint
m_State	srLib/srDyn/srRevoluteJoint.h	/^	srRevoluteState	m_State;$/;"	m	class:srRevoluteJoint
m_State	srLib/srDyn/srUniversalJoint.h	/^	srUniversalState	m_State;$/;"	m	class:srUniversalJoint
m_State	srLib/srDyn/srWeldJoint.h	/^	srWeldState	m_State;$/;"	m	class:srWeldJoint
m_States	srLib/srDyn/srSpace.h	/^	_array<srState*>					m_States;$/;"	m	class:srSpace
m_Systems	srLib/srDyn/srSpace.h	/^	_array<srSystem*>					m_Systems;$/;"	m	class:srSpace
m_T	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_TextureName	srLib/SceneGraph/Texture3DS.h	/^	char*	m_TextureName;		\/\/ The textures name$/;"	m	class:Texture3DS
m_Timestep_dyn_fixed	srLib/srDyn/srSpace.h	/^	SR_REAL					m_Timestep_dyn_fixed;$/;"	m	class:srSpace
m_Timestep_fixed	srLib/srDyn/srDYN.h	/^	SR_REAL								m_Timestep_fixed;$/;"	m	class:srDYN
m_Torque	srLib/srDyn/srState.h	/^	Vec3	m_Torque;		\/\/ dso3$/;"	m	class:srBallState
m_TorqueConstant	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	m_TorqueConstant;$/;"	m	class:srExtRevoluteJoint
m_TorqueLimit	srLib/srDyn/srBallJoint.h	/^	SR_REAL	m_TorqueLimit[3][2];$/;"	m	class:srBallJoint
m_TorqueLimit	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_TorqueLimit[2];$/;"	m	class:srPrismaticJoint
m_TorqueLimit	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_TorqueLimit[2];$/;"	m	class:srRevoluteJoint
m_TorqueLimit	srLib/srDyn/srState.h	/^	SR_REAL	m_TorqueLimit;$/;"	m	class:srBallState
m_TorqueLimit_1	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL	m_TorqueLimit_1[2];$/;"	m	class:srUniversalJoint
m_TorqueLimit_2	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL	m_TorqueLimit_2[2];$/;"	m	class:srUniversalJoint
m_Type	srLib/srDyn/srGeometryInfo.h	/^	SHAPETYPE	m_Type;$/;"	m	class:srGeometryInfo
m_UF_id	srLib/srDyn/srSystem.h	/^	srSystem *	m_UF_id;$/;"	m	class:srSystem
m_UF_idx	srLib/srDyn/srSystem.h	/^	int			m_UF_idx;$/;"	m	class:srSystem
m_UF_sz	srLib/srDyn/srSystem.h	/^	int			m_UF_sz;$/;"	m	class:srSystem
m_UserExtForce	srLib/srDyn/srLink.h	/^	dse3		m_UserExtForce;$/;"	m	class:srLink
m_Ustore	Eigen/src/SparseLU/SparseLU.h	/^    MappedSparseMatrix<Scalar,ColMajor,Index> m_Ustore; \/\/ The upper triangular matrix$/;"	m	class:Eigen::SparseLU
m_Vel	srLib/srDyn/srLink.h	/^	se3			m_Vel;$/;"	m	class:srLink
m_Vel	srLib/srDyn/srState.h	/^	Vec3	m_Vel;			\/\/ so3$/;"	m	class:srBallState
m_VelLimit	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL	m_VelLimit[2];$/;"	m	class:srExtRevoluteJoint
m_Vel_PosErr	srLib/srDyn/srLink.h	/^	se3			m_Vel_PosErr;$/;"	m	class:srLink
m_ViscousCoeff	srLib/srExt/srExt_RevoluteJoint.h	/^	SR_REAL m_ViscousCoeff;$/;"	m	class:srExtRevoluteJoint
m_Width	srLib/SceneGraph/Bitmap.h	/^	int		m_Width;$/;"	m	class:_Bitmap
m_Width	srLib/SceneGraph/Texture3DS.h	/^	int		m_Width;			\/\/ Texture's width$/;"	m	class:Texture3DS
m_Width	srLib/srg/srgBitmap.h	/^	int		m_Width;$/;"	m	class:_Bitmap
m_YawLimit	srLib/srDyn/srState.h	/^	SR_REAL	m_YawLimit[2];$/;"	m	class:srBallState
m_Z	Eigen/src/Eigenvalues/RealQZ.h	/^      MatrixType m_S, m_T, m_Q, m_Z;$/;"	m	class:Eigen::RealQZ
m_ZMP	srLib/srDyn/srSystem.h	/^	Vec3	m_ZMP;$/;"	m	class:srSystem
m_actualAlpha	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Scalar m_actualAlpha;$/;"	m	struct:Eigen::internal::gemm_functor
m_adjoint	Eigen/src/SVD/JacobiSVD.h	/^  TransposeTypeWithSameStorageOrder m_adjoint;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_allocatedElements	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedElements;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_allocatedSize;$/;"	m	class:Eigen::internal::AmbiVector
m_allocatedSize	Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_allocatedSize;$/;"	m	class:Eigen::internal::CompressedStorage
m_allow_tol	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_allow_tol; \/\/ Allow to use some tolerance during numerical factorization.$/;"	m	class:Eigen::SPQR
m_alpha	Eigen/src/Core/ProductBase.h	/^    Scalar m_alpha;$/;"	m	class:ScaledProduct
m_alphas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ComplexVectorType m_alphas;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_analysisIsOk	Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::CholmodBase
m_analysisIsOk	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_analysisIsOk	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_analysisIsOk	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::PastixBase
m_analysisIsOk	Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_analysisIsOk	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SPQR
m_analysisIsOk	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_analysisIsOk	Eigen/src/SparseLU/SparseLU.h	/^    bool m_analysisIsOk;$/;"	m	class:Eigen::SparseLU
m_analysisIsOk	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::SuperLUBase
m_analysisIsOk	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_analysisIsOk;$/;"	m	class:Eigen::UmfPackLU
m_analysisIsok	Eigen/src/SparseQR/SparseQR.h	/^    bool m_analysisIsok;$/;"	m	class:Eigen::SparseQR
m_angle	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis
m_angle	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D
m_angle	Eigen/src/Geometry/AngleAxis.h	/^  Scalar m_angle;$/;"	m	class:Eigen::AngleAxis
m_angle	Eigen/src/Geometry/Rotation2D.h	/^  Scalar m_angle;$/;"	m	class:Eigen::Rotation2D
m_axis	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis
m_axis	Eigen/src/Geometry/AngleAxis.h	/^  Vector3 m_axis;$/;"	m	class:Eigen::AngleAxis
m_bALLOCATED	srLib/srDyn/srDYN.h	/^	bool								m_bALLOCATED;$/;"	m	class:srDYN
m_bExcited	srLib/srDyn/srSystem.h	/^	bool		m_bExcited;$/;"	m	class:srSystem
m_bGroupsRendered	srLib/SceneGraph/SceneGraphRenderer.cpp	/^map<int, bool>				SceneGraphRenderer::m_bGroupsRendered;$/;"	m	class:SceneGraphRenderer	file:
m_bGroupsRendered	srLib/SceneGraph/SceneGraphRenderer.h	/^	static								map<int, bool>			m_bGroupsRendered;$/;"	m	class:SceneGraphRenderer
m_bLookBack	srLib/srg/srgCamera.h	/^	bool	m_bLookBack;$/;"	m	class:srgCamera
m_bRollPitchLimit	srLib/srDyn/srState.h	/^	bool	m_bRollPitchLimit;$/;"	m	class:srBallState
m_bYawLimit	srLib/srDyn/srState.h	/^	bool	m_bYawLimit;$/;"	m	class:srBallState
m_base	Eigen/src/Core/Functors.h	/^  mutable Packet m_base;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_begin	Eigen/src/SparseCore/SparseBlock.h	/^      Index m_begin;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator
m_betas	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    VectorType m_betas;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_bidiagonal	Eigen/src/SVD/UpperBidiagonalization.h	/^    BidiagonalType m_bidiagonal;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_block	Eigen/src/SparseCore/SparseBlock.h	/^      const BlockType& m_block;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator
m_block	Eigen/src/SparseCore/SparseBlock.h	/^    const BlockType& m_block;$/;"	m	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
m_blockA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    LhsScalar* m_blockA;$/;"	m	class:Eigen::internal::level3_blocking
m_blockB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockB;$/;"	m	class:Eigen::internal::level3_blocking
m_blockCols	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_blockCols	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_blockCols;$/;"	m	class:Eigen::BlockImpl
m_blockRows	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_blockRows	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_blockRows;$/;"	m	class:Eigen::BlockImpl
m_blockW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    RhsScalar* m_blockW;$/;"	m	class:Eigen::internal::level3_blocking
m_blocking	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    BlockingType& m_blocking;$/;"	m	struct:Eigen::internal::gemm_functor
m_buffer	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar* m_buffer;$/;"	m	class:Eigen::internal::AmbiVector
m_c	Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_cR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_sparse *m_cR; \/\/ The sparse R factor in cholmod format$/;"	m	class:Eigen::SPQR
m_cachedIndex	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_cachedIndex;          \/\/ current coordinate$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_cachedValue	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_cachedValue;       \/\/ current value$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_camera	srLib/SceneGraph/SceneGraphRenderer.cpp	/^Camera* SceneGraphRenderer::m_camera = NULL;$/;"	m	class:SceneGraphRenderer	file:
m_camera	srLib/SceneGraph/SceneGraphRenderer.h	/^	static Camera* m_camera;$/;"	m	class:SceneGraphRenderer
m_camera2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^Camera*  SceneGraphRenderer::m_camera2 = NULL;$/;"	m	class:SceneGraphRenderer	file:
m_camera2	srLib/SceneGraph/SceneGraphRenderer.h	/^	static Camera* m_camera2;$/;"	m	class:SceneGraphRenderer
m_cc	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable cholmod_common m_cc; \/\/ Workspace and parameters$/;"	m	class:Eigen::SPQR
m_cholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable cholmod_common m_cholmod;$/;"	m	class:Eigen::CholmodBase
m_cholmodFactor	Eigen/src/CholmodSupport/CholmodSupport.h	/^    cholmod_factor* m_cholmodFactor;$/;"	m	class:Eigen::CholmodBase
m_cinfo	srLib/srDyn/srISLAND.h	/^	ConstraintInfo					m_cinfo;$/;"	m	class:ISLAND
m_coeffs	Eigen/src/Core/BandMatrix.h	/^    CoefficientsType m_coeffs;$/;"	m	class:Eigen::internal::BandMatrix
m_coeffs	Eigen/src/Core/BandMatrix.h	/^    const CoefficientsType& m_coeffs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_coeffs	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane
m_coeffs	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion
m_coeffs	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Scaling
m_coeffs	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation
m_coeffs	Eigen/src/Geometry/Hyperplane.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Hyperplane
m_coeffs	Eigen/src/Geometry/Quaternion.h	/^    Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	Eigen/src/Geometry/Quaternion.h	/^    const Coefficients m_coeffs;$/;"	m	class:Eigen::Map
m_coeffs	Eigen/src/Geometry/Quaternion.h	/^  Coefficients m_coeffs;$/;"	m	class:Eigen::Quaternion
m_coeffs	Eigen/src/Geometry/Translation.h	/^  VectorType m_coeffs;$/;"	m	class:Eigen::Translation
m_coeffs	Eigen/src/Householder/HouseholderSequence.h	/^    typename CoeffsType::Nested m_coeffs;$/;"	m	class:Eigen::HouseholderSequence
m_col	Eigen/src/Core/CommaInitializer.h	/^  Index m_col;              \/\/ current col id$/;"	m	struct:Eigen::CommaInitializer
m_col	Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor
m_col	Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet
m_col	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_col; \/\/ Number of columns $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_colFactor	Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, ColFactor> m_colFactor;$/;"	m	class:Eigen::Replicate
m_colSqNorms	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealRowVectorType m_colSqNorms;$/;"	m	class:Eigen::ColPivHouseholderQR
m_col_to_sup	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_col_to_sup; \/\/ col_to_sup[j] is the supernode number to which column j belongs$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_cols	Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::CwiseNullaryOp
m_cols	Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_cols;$/;"	m	class:Eigen::DenseStorage
m_cols	Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, ColsAtCompileTime> m_cols;$/;"	m	class:Eigen::MapBase
m_cols	Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_cols	Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_cols	Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_colsPermutation	Eigen/src/QR/ColPivHouseholderQR.h	/^    PermutationType m_colsPermutation;$/;"	m	class:Eigen::ColPivHouseholderQR
m_colsTranspositions	Eigen/src/LU/FullPivLU.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_colsTranspositions	Eigen/src/QR/ColPivHouseholderQR.h	/^    IntRowVectorType m_colsTranspositions;$/;"	m	class:Eigen::ColPivHouseholderQR
m_cols_permutation	Eigen/src/QR/FullPivHouseholderQR.h	/^    PermutationType m_cols_permutation;$/;"	m	class:Eigen::FullPivHouseholderQR
m_cols_transpositions	Eigen/src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_cols_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_comm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_comm; \/\/ The MPI communicator identifier$/;"	m	class:Eigen::PastixBase
m_computationOptions	Eigen/src/SVD/JacobiSVD.h	/^    unsigned int m_computationOptions;$/;"	m	class:Eigen::JacobiSVD
m_computeFullU	Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD
m_computeFullV	Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD
m_computeQZ	Eigen/src/Eigenvalues/RealQZ.h	/^      bool m_computeQZ;$/;"	m	class:Eigen::RealQZ
m_computeThinU	Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullU, m_computeThinU;$/;"	m	class:Eigen::JacobiSVD
m_computeThinV	Eigen/src/SVD/JacobiSVD.h	/^    bool m_computeFullV, m_computeThinV;$/;"	m	class:Eigen::JacobiSVD
m_condition	Eigen/src/Core/Select.h	/^    typename ConditionMatrixType::Nested m_condition;$/;"	m	class:Eigen::Select
m_conservative	Eigen/src/SparseCore/SparseProduct.h	/^    bool m_conservative;$/;"	m	class:Eigen::SparseSparseProduct
m_copyMatrix	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  MatrixType m_copyMatrix;$/;"	m	class:Eigen::IterativeSolverBase
m_copyMatrix	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    UmfpackMatrixType m_copyMatrix;$/;"	m	class:Eigen::UmfPackLU
m_countPerCol	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerCol;$/;"	m	class:Eigen::SparseSelfAdjointView
m_countPerRow	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    mutable VectorI m_countPerRow;$/;"	m	class:Eigen::SparseSelfAdjointView
m_currentBlockRows	Eigen/src/Core/CommaInitializer.h	/^  Index m_currentBlockRows; \/\/ current block height$/;"	m	struct:Eigen::CommaInitializer
m_currentEl	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_currentEl;            \/\/ the current element in sparse\/linked-list mode$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_dFOVy	srLib/srg/srgCamera.h	/^	double			m_dFOVy;$/;"	m	class:srgCamera
m_dFar	srLib/srg/srgCamera.h	/^	double			m_dNear, m_dFar;$/;"	m	class:srgCamera
m_dNear	srLib/srg/srgCamera.h	/^	double			m_dNear, m_dFar;$/;"	m	class:srgCamera
m_data	Eigen/src/Core/DenseStorage.h	/^    T *m_data;$/;"	m	class:Eigen::DenseStorage
m_data	Eigen/src/Core/DenseStorage.h	/^    internal::plain_array<T,Size,_Options> m_data;$/;"	m	class:Eigen::DenseStorage
m_data	Eigen/src/Core/GeneralProduct.h	/^  internal::plain_array<Scalar,EIGEN_SIZE_MIN_PREFER_FIXED(Size,MaxSize),0> m_data;$/;"	m	struct:Eigen::internal::gemv_static_vector_if
m_data	Eigen/src/Core/MapBase.h	/^    PointerType m_data;$/;"	m	class:Eigen::MapBase
m_data	Eigen/src/Core/util/BlasUtil.h	/^    Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::blas_data_mapper
m_data	Eigen/src/Core/util/BlasUtil.h	/^    const Scalar* EIGEN_RESTRICT m_data;$/;"	m	class:Eigen::internal::const_blas_data_mapper
m_data	Eigen/src/SparseCore/SparseMatrix.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseMatrix
m_data	Eigen/src/SparseCore/SparseVector.h	/^    Storage m_data;$/;"	m	class:Eigen::SparseVector
m_data	Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::InnerIterator
m_data	Eigen/src/SparseCore/SparseVector.h	/^    const internal::CompressedStorage<Scalar,Index>& m_data;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator
m_dblLength	srLib/srg/srgCamera.h	/^	double				m_dblLength;$/;"	m	class:srgCamera
m_deallocate	Eigen/src/Core/util/Memory.h	/^    bool m_deallocate;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_dec	Eigen/src/misc/Image.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::image_retval_base
m_dec	Eigen/src/misc/Kernel.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_dec	Eigen/src/misc/Solve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_base
m_dec	Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::solve_retval_with_guess
m_dec	Eigen/src/misc/SparseSolve.h	/^    const DecompositionType& m_dec;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base
m_dest	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    Dest& m_dest;$/;"	m	struct:Eigen::internal::gemm_functor
m_detPermC	Eigen/src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU
m_detPermR	Eigen/src/SparseLU/SparseLU.h	/^    Index m_detPermR, m_detPermC; \/\/ Determinants of the permutation matrices$/;"	m	class:Eigen::SparseLU
m_det_p	Eigen/src/LU/PartialPivLU.h	/^    Index m_det_p;$/;"	m	class:Eigen::PartialPivLU
m_det_pq	Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU
m_det_pq	Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::ColPivHouseholderQR
m_det_pq	Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_det_pq;$/;"	m	class:Eigen::FullPivHouseholderQR
m_diag	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorType m_diag;                                \/\/ the diagonal coefficients (LDLT mode)$/;"	m	class:Eigen::SimplicialCholeskyBase
m_diagSize	Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalVectorType m_diagonal;$/;"	m	class:Eigen::DiagonalMatrix
m_diagonal	Eigen/src/Core/DiagonalMatrix.h	/^    typename DiagonalVectorType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalWrapper
m_diagonal	Eigen/src/Core/DiagonalProduct.h	/^    typename DiagonalType::Nested m_diagonal;$/;"	m	class:Eigen::DiagonalProduct
m_diagpivotthresh	Eigen/src/SparseLU/SparseLU.h	/^    RealScalar m_diagpivotthresh; \/\/ Specifies the threshold used for a diagonal entry to be an acceptable pivot$/;"	m	class:Eigen::SparseLU
m_direction	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_direction	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_dparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<double,DPARM_SIZE,1> m_dparm; \/\/ Scalar vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_droptol	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    RealScalar m_droptol;$/;"	m	class:Eigen::IncompleteLUT
m_eigenvectorsOk	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::ComplexEigenSolver
m_eigenvectorsOk	Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::EigenSolver
m_eigenvectorsOk	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_eigenvectorsOk	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_eigenvectorsOk;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivalues	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivalues	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenvalueType m_eivalues;$/;"	m	class:Eigen::EigenSolver
m_eivalues	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    RealVectorType m_eivalues;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_eivec	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_eivec;$/;"	m	class:Eigen::ComplexEigenSolver
m_eivec	Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::EigenSolver
m_eivec	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    MatrixType m_eivec;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_eivec	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    EigenvectorsType m_eivec;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_else	Eigen/src/Core/Select.h	/^    typename ElseMatrixType::Nested m_else;$/;"	m	class:Eigen::Select
m_end	Eigen/src/Core/CoreIterators.h	/^    const Index m_end;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_end	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_end;$/;"	m	class:Eigen::internal::AmbiVector
m_end	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_end	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_end;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_end	Eigen/src/SparseCore/SparseBlock.h	/^    Index m_end;$/;"	m	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
m_end	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_end;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_end	Eigen/src/SparseCore/SparseVector.h	/^    const Index m_end;$/;"	m	class:Eigen::SparseVector::InnerIterator
m_endidrow	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_endidrow;                       \/\/ End index of row indices of the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_endidval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_endidval;                 \/\/ End of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_epsilon	Eigen/src/SparseCore/AmbiVector.h	/^    RealScalar m_epsilon;       \/\/ epsilon used to prune zero coefficients$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_epsilon	Eigen/src/SparseCore/SparseView.h	/^  typename NumTraits<Scalar>::Real m_epsilon;$/;"	m	class:Eigen::SparseView
m_error	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable RealScalar m_error;$/;"	m	class:Eigen::IterativeSolverBase
m_etree	Eigen/src/SparseLU/SparseLU.h	/^    IndexVector m_etree; \/\/ Column elimination tree $/;"	m	class:Eigen::SparseLU
m_etree	Eigen/src/SparseQR/SparseQR.h	/^    IndexVector m_etree;            \/\/ Column elimination tree$/;"	m	class:Eigen::SparseQR
m_exponent	Eigen/src/Core/Functors.h	/^  const Scalar m_exponent;$/;"	m	struct:Eigen::internal::scalar_pow_op
m_expression	Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::ArrayWrapper
m_expression	Eigen/src/Core/ArrayWrapper.h	/^    NestedExpressionType m_expression;$/;"	m	class:Eigen::MatrixWrapper
m_expression	Eigen/src/Core/CoreIterators.h	/^    const Derived& m_expression;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_expression	Eigen/src/Core/ForceAlignedAccess.h	/^    const ExpressionType& m_expression;$/;"	m	class:Eigen::ForceAlignedAccess
m_expression	Eigen/src/Core/NestByValue.h	/^    const ExpressionType m_expression;$/;"	m	class:Eigen::NestByValue
m_expression	Eigen/src/Core/NoAlias.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::NoAlias
m_expression	Eigen/src/Core/Swap.h	/^    ExpressionType& m_expression;$/;"	m	class:Eigen::SwapWrapper
m_extractedDataAreDirty	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::SuperLUBase
m_extractedDataAreDirty	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable bool m_extractedDataAreDirty;$/;"	m	class:Eigen::UmfPackLU
m_fMinFocusLength	srLib/srg/srgCamera.cpp	/^const float srgCamera::m_fMinFocusLength = RGL_CAMERA_MIN_FOCUSLENGTH;$/;"	m	class:srgCamera	file:
m_fMinFocusLength	srLib/srg/srgCamera.h	/^	static const float	m_fMinFocusLength;$/;"	m	class:srgCamera
m_factor	Eigen/src/Geometry/Scaling.h	/^  Scalar m_factor;$/;"	m	class:Eigen::UniformScaling
m_factor	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Scalar m_factor;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator
m_factorizationIsOk	Eigen/src/CholmodSupport/CholmodSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::CholmodBase
m_factorizationIsOk	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::IncompleteLUT
m_factorizationIsOk	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_factorizationIsOk	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::PastixBase
m_factorizationIsOk	Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_factorizationIsOk	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SPQR
m_factorizationIsOk	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_factorizationIsOk	Eigen/src/SparseLU/SparseLU.h	/^    bool m_factorizationIsOk;$/;"	m	class:Eigen::SparseLU
m_factorizationIsOk	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::SuperLUBase
m_factorizationIsOk	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    int m_factorizationIsOk;$/;"	m	class:Eigen::UmfPackLU
m_factorizationIsok	Eigen/src/SparseQR/SparseQR.h	/^    bool m_factorizationIsok;$/;"	m	class:Eigen::SparseQR
m_fillfactor	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    int m_fillfactor;$/;"	m	class:Eigen::IncompleteLUT
m_firstRowElt	Eigen/src/SparseQR/SparseQR.h	/^    IndexVector m_firstRowElt;      \/\/ First element in each row$/;"	m	class:Eigen::SparseQR
m_format	Eigen/src/Core/IO.h	/^    IOFormat m_format;$/;"	m	class:Eigen::WithFormat
m_functor	Eigen/src/Core/CwiseBinaryOp.h	/^    const BinaryOp m_functor;$/;"	m	class:Eigen::CwiseBinaryOp
m_functor	Eigen/src/Core/CwiseNullaryOp.h	/^    const NullaryOp m_functor;$/;"	m	class:Eigen::CwiseNullaryOp
m_functor	Eigen/src/Core/CwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOp
m_functor	Eigen/src/Core/CwiseUnaryView.h	/^    ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryView
m_functor	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::SelfCwiseBinaryOp
m_functor	Eigen/src/Core/VectorwiseOp.h	/^    const MemberOp m_functor;$/;"	m	class:Eigen::PartialReduxExpr
m_functor	Eigen/src/Core/VectorwiseOp.h	/^  const BinaryOp m_functor;$/;"	m	struct:Eigen::internal::member_redux
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryFunc& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_functor	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const BinaryOp& m_functor;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::InnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const UnaryOp m_functor;$/;"	m	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::InnerIterator
m_functor	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    const ViewOp m_functor;$/;"	m	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
m_global_iter	Eigen/src/Eigenvalues/RealQZ.h	/^      Index m_global_iter;$/;"	m	class:Eigen::RealQZ
m_glu	Eigen/src/SparseLU/SparseLU.h	/^    typename Base::GlobalLU_t m_glu; $/;"	m	class:Eigen::SparseLU
m_glu	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  typename SparseLUImpl<Scalar, Index>::GlobalLU_t& m_glu;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_ground	Example/DracoP1/Draco_Dyn_environment.h	/^        Ground*	m_ground;$/;"	m	class:Draco_Dyn_environment
m_groups	srLib/SceneGraph/SceneGraphRenderer.cpp	/^map<int,Group*>		SceneGraphRenderer::m_groups;$/;"	m	class:SceneGraphRenderer	file:
m_groups	srLib/SceneGraph/SceneGraphRenderer.h	/^	static								map<int,Group*>		m_groups;$/;"	m	class:SceneGraphRenderer
m_guess	Eigen/src/misc/SparseSolve.h	/^    const typename Guess::Nested m_guess;$/;"	m	struct:Eigen::internal::solve_retval_with_guess
m_hCoeffs	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::HessenbergDecomposition
m_hCoeffs	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    CoeffVectorType m_hCoeffs;$/;"	m	class:Eigen::Tridiagonalization
m_hCoeffs	Eigen/src/QR/ColPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::ColPivHouseholderQR
m_hCoeffs	Eigen/src/QR/FullPivHouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::FullPivHouseholderQR
m_hCoeffs	Eigen/src/QR/FullPivHouseholderQR.h	/^  typename HCoeffsType::Nested m_hCoeffs;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_hCoeffs	Eigen/src/QR/HouseholderQR.h	/^    HCoeffsType m_hCoeffs;$/;"	m	class:Eigen::HouseholderQR
m_hcoeffs	Eigen/src/SparseQR/SparseQR.h	/^    ScalarVector m_hcoeffs;         \/\/ The Householder coefficients$/;"	m	class:Eigen::SparseQR
m_hess	Eigen/src/Eigenvalues/ComplexSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::ComplexSchur
m_hess	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const HessenbergDecomposition<MatrixType>& m_hess;$/;"	m	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
m_hess	Eigen/src/Eigenvalues/RealSchur.h	/^    HessenbergDecomposition<MatrixType> m_hess;$/;"	m	class:Eigen::RealSchur
m_householder	Eigen/src/SVD/UpperBidiagonalization.h	/^    MatrixType m_householder;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_id	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_id	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_id	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Index m_id;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_id	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_id	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_id;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_id	Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::InnerIterator
m_id	Eigen/src/SparseCore/SparseVector.h	/^    Index m_id;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator
m_idrow	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idrow;                          \/\/ Index to browse the row indices $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_idval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_idval;                          \/\/ Index to browse the values in the current column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_index	Eigen/src/Core/Diagonal.h	/^    const internal::variable_if_dynamicindex<Index, DiagIndex> m_index;$/;"	m	class:Eigen::Diagonal
m_index	Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_index;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_indexPtr	Eigen/src/MetisSupport/MetisSupport.h	/^    IndexVector m_indexPtr; \/\/ Pointer to the adjacenccy list of each row\/column$/;"	m	class:Eigen::MetisOrdering
m_indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	Eigen/src/Core/PermutationMatrix.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::PermutationMatrix
m_indices	Eigen/src/Core/PermutationMatrix.h	/^    typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::PermutationWrapper
m_indices	Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Map
m_indices	Eigen/src/Core/Transpositions.h	/^    IndicesType m_indices;$/;"	m	class:Eigen::Transpositions
m_indices	Eigen/src/Core/Transpositions.h	/^    const typename IndicesType::Nested m_indices;$/;"	m	class:Eigen::TranspositionsWrapper
m_indices	Eigen/src/SparseCore/CompressedStorage.h	/^    Index* m_indices;$/;"	m	class:Eigen::internal::CompressedStorage
m_indices	Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_indices	Eigen/src/SparseCore/SparseMatrix.h	/^    const Index* m_indices;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_info	Eigen/src/Cholesky/LLT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::LLT
m_info	Eigen/src/CholmodSupport/CholmodSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::CholmodBase
m_info	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::ComplexSchur
m_info	Eigen/src/Eigenvalues/RealQZ.h	/^      ComputationInfo m_info;$/;"	m	class:Eigen::RealQZ
m_info	Eigen/src/Eigenvalues/RealSchur.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::RealSchur
m_info	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_info	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::IncompleteLUT
m_info	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable ComputationInfo m_info;$/;"	m	class:Eigen::IterativeSolverBase
m_info	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable ComputationInfo m_info; $/;"	m	class:Eigen::PastixBase
m_info	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ComputationInfo m_info;$/;"	m	class:Eigen::PardisoImpl
m_info	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SPQR
m_info	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_info	Eigen/src/SparseLU/SparseLU.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseLU
m_info	Eigen/src/SparseQR/SparseQR.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SparseQR
m_info	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::SuperLUBase
m_info	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable ComputationInfo m_info;$/;"	m	class:Eigen::UmfPackLU
m_initialized	Eigen/src/PardisoSupport/PardisoSupport.h	/^    bool m_initialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::PardisoImpl
m_initisOk	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    int m_initisOk; $/;"	m	class:Eigen::PastixBase
m_inner	Eigen/src/Core/CoreIterators.h	/^    Index m_inner;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_inner	Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, InnerStrideAtCompileTime> m_inner;$/;"	m	class:Eigen::Stride
m_innerIndex	Eigen/src/SparseCore/SparseBlock.h	/^    Index m_innerIndex;$/;"	m	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
m_innerIndexPtr	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_innerIndexPtr;$/;"	m	class:Eigen::UmfPackLU
m_innerIndices	Eigen/src/MetisSupport/MetisSupport.h	/^    IndexVector m_innerIndices; \/\/ Adjacency list $/;"	m	class:Eigen::MetisOrdering
m_innerIndices	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_innerIndices;$/;"	m	class:Eigen::MappedSparseMatrix
m_innerNonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_innerNonZeros;     \/\/ optional, if null then the data is compressed$/;"	m	class:Eigen::SparseMatrix
m_innerSize	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_innerSize;$/;"	m	class:Eigen::MappedSparseMatrix
m_innerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_innerSize;$/;"	m	class:Eigen::SparseMatrix
m_interPacket	Eigen/src/Core/Functors.h	/^  const Packet m_interPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_invdiag	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Vector m_invdiag;$/;"	m	class:Eigen::DiagonalPreconditioner
m_invp	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_invp;  \/\/ Inverse permutation vector$/;"	m	class:Eigen::PastixBase
m_iparm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<int,IPARM_SIZE,1> m_iparm; \/\/ integer vector for the input parameters$/;"	m	class:Eigen::PastixBase
m_iparm	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable ParameterType m_iparm;$/;"	m	class:Eigen::PardisoImpl
m_isAllocated	Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD
m_isDense	Eigen/src/SparseCore/AmbiVector.h	/^    bool m_isDense;             \/\/ mode of the vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_isEtreeOk	Eigen/src/SparseQR/SparseQR.h	/^    bool m_isEtreeOk;               \/\/ whether the elimination tree match the initial input matrix$/;"	m	class:Eigen::SparseQR
m_isInitialized	Eigen/src/Cholesky/LDLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LDLT
m_isInitialized	Eigen/src/Cholesky/LLT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::LLT
m_isInitialized	Eigen/src/CholmodSupport/CholmodSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::CholmodBase
m_isInitialized	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexEigenSolver
m_isInitialized	Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::ComplexSchur
m_isInitialized	Eigen/src/Eigenvalues/EigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::EigenSolver
m_isInitialized	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_isInitialized	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HessenbergDecomposition
m_isInitialized	Eigen/src/Eigenvalues/RealQZ.h	/^      bool m_isInitialized;$/;"	m	class:Eigen::RealQZ
m_isInitialized	Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::RealSchur
m_isInitialized	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_isInitialized	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::Tridiagonalization
m_isInitialized	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::DiagonalPreconditioner
m_isInitialized	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::IncompleteLUT
m_isInitialized	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable bool m_isInitialized, m_analysisIsOk, m_factorizationIsOk;$/;"	m	class:Eigen::IterativeSolverBase
m_isInitialized	Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_isInitialized	Eigen/src/LU/PartialPivLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PartialPivLU
m_isInitialized	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::PastixBase
m_isInitialized	Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_isInitialized	Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_isInitialized	Eigen/src/QR/HouseholderQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::HouseholderQR
m_isInitialized	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SPQR
m_isInitialized	Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD
m_isInitialized	Eigen/src/SVD/UpperBidiagonalization.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::internal::UpperBidiagonalization
m_isInitialized	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_isInitialized	Eigen/src/SparseLU/SparseLU.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SparseLU
m_isInitialized	Eigen/src/SparseQR/SparseQR.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SparseQR
m_isInitialized	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::SuperLUBase
m_isInitialized	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    bool m_isInitialized;$/;"	m	class:Eigen::UmfPackLU
m_isQSorted	Eigen/src/SparseQR/SparseQR.h	/^    bool m_isQSorted;               \/\/ whether Q is sorted or not$/;"	m	class:Eigen::SparseQR
m_isRUpToDate	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable bool m_isRUpToDate;$/;"	m	class:Eigen::SPQR
m_isRValue	Eigen/src/SparseCore/SparseMatrixBase.h	/^    bool m_isRValue;$/;"	m	class:Eigen::SparseMatrixBase
m_islands	srLib/srDyn/srDYN.h	/^	ISLANDArray							m_islands;$/;"	m	class:srDYN
m_iterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  mutable int m_iterations;$/;"	m	class:Eigen::IterativeSolverBase
m_jcol	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_jcol	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  Index m_jcol;$/;"	m	struct:Eigen::internal::panel_dfs_traits
m_joint_map	srLib/srExt/srExt_System.h	/^		std::map<std::string, srJoint*>	m_joint_map;$/;"	m	class:srExt::srExtSystem
m_joint_name_idx_map	srLib/srExt/srExt_System.h	/^		std::map<std::string, int>	m_joint_name_idx_map;$/;"	m	class:srExt::srExtSystem
m_jsuper_ref	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  Index& m_jsuper_ref;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_kc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_kc;$/;"	m	class:Eigen::internal::level3_blocking
m_l	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::SuperLUBase
m_l	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_l;$/;"	m	class:Eigen::UmfPackLU
m_lastError	Eigen/src/SparseLU/SparseLU.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseLU
m_lastError	Eigen/src/SparseQR/SparseQR.h	/^    std::string m_lastError;$/;"	m	class:Eigen::SparseQR
m_length	Eigen/src/Householder/HouseholderSequence.h	/^    Index m_length;$/;"	m	class:Eigen::HouseholderSequence
m_lhs	Eigen/src/Core/CwiseBinaryOp.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_lhs	Eigen/src/Core/ProductBase.h	/^    LhsNested m_lhs;$/;"	m	namespace:Eigen
m_lhs	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<LhsNested>::type m_lhs;$/;"	m	class:Eigen::CoeffBasedProduct
m_lhs	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Lhs& m_lhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_lhs	Eigen/src/Geometry/Homogeneous.h	/^  typename LhsMatrixTypeCleaned::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_lhs	Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_lhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_lhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDenseOuterProduct
m_lhs	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseDiagonalProduct
m_lhs	Eigen/src/SparseCore/SparseProduct.h	/^    LhsNested m_lhs;$/;"	m	class:Eigen::SparseSparseProduct
m_lhsIter	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    LhsIterator m_lhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_link_map	srLib/srExt/srExt_System.h	/^		std::map<std::string, srLink*>	m_link_map;$/;"	m	class:srExt::srExtSystem
m_link_state_map	srLib/srExt/srExt_System.h	/^		std::map<srLink*, linkState>	m_link_state_map;$/;"	m	class:srExt::srExtSystem
m_linkpairs_for_closedloop	srLib/srDyn/srSystem.h	/^	_array<linkpair_for_closedloop>	m_linkpairs_for_closedloop;$/;"	m	class:srSystem
m_llCurrent	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llCurrent;$/;"	m	class:Eigen::internal::AmbiVector
m_llSize	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llSize;$/;"	m	class:Eigen::internal::AmbiVector
m_llStart	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_llStart;$/;"	m	class:Eigen::internal::AmbiVector
m_low	Eigen/src/Core/Functors.h	/^  const Scalar m_low;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_lowPacket	Eigen/src/Core/Functors.h	/^  const Packet m_lowPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_lu	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    FactorType m_lu;$/;"	m	class:Eigen::IncompleteLUT
m_lu	Eigen/src/LU/FullPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::FullPivLU
m_lu	Eigen/src/LU/PartialPivLU.h	/^    MatrixType m_lu;$/;"	m	class:Eigen::PartialPivLU
m_luImpl	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  SparseLUImpl<Scalar, Index>& m_luImpl;$/;"	m	struct:Eigen::internal::column_dfs_traits
m_mapL	Eigen/src/SparseLU/SparseLU.h	/^  const MappedSupernodalType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixLReturnType
m_mapL	Eigen/src/SparseLU/SparseLU.h	/^  const MatrixLType& m_mapL;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType
m_mapU	Eigen/src/SparseLU/SparseLU.h	/^  const MatrixUType& m_mapU;$/;"	m	struct:Eigen::SparseLUMatrixUReturnType
m_marker	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  Index* m_marker;$/;"	m	struct:Eigen::internal::panel_dfs_traits
m_mat	Eigen/src/SparseLU/SparseLU.h	/^    NCMatrix m_mat; \/\/ The input (permuted ) matrix $/;"	m	class:Eigen::SparseLU
m_matCameraInvFrame	srLib/srg/srgCamera.h	/^	double			m_matCameraInvFrame[16];$/;"	m	class:srgCamera
m_matS	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    MatrixType m_matS;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_matT	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matT	Eigen/src/Eigenvalues/EigenSolver.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::EigenSolver
m_matT	Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matT;$/;"	m	class:Eigen::RealSchur
m_matU	Eigen/src/Eigen2Support/SVD.h	/^    MatrixUType m_matU;$/;"	m	class:Eigen::SVD
m_matU	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexMatrixType m_matT, m_matU;$/;"	m	class:Eigen::ComplexSchur
m_matU	Eigen/src/Eigenvalues/RealSchur.h	/^    MatrixType m_matU;$/;"	m	class:Eigen::RealSchur
m_matUisUptodate	Eigen/src/Eigenvalues/ComplexSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::ComplexSchur
m_matUisUptodate	Eigen/src/Eigenvalues/RealSchur.h	/^    bool m_matUisUptodate;$/;"	m	class:Eigen::RealSchur
m_matV	Eigen/src/Eigen2Support/SVD.h	/^    MatrixVType m_matV;$/;"	m	class:Eigen::SVD
m_matX	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    EigenvectorType m_matX;$/;"	m	class:Eigen::ComplexEigenSolver
m_matrix	Eigen/src/Cholesky/LDLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LDLT
m_matrix	Eigen/src/Cholesky/LLT.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::LLT
m_matrix	Eigen/src/Core/CwiseUnaryView.h	/^    typename internal::nested<MatrixType>::type m_matrix;$/;"	m	class:Eigen::CwiseUnaryView
m_matrix	Eigen/src/Core/Diagonal.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Diagonal
m_matrix	Eigen/src/Core/DiagonalProduct.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::DiagonalProduct
m_matrix	Eigen/src/Core/Flagged.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Flagged
m_matrix	Eigen/src/Core/IO.h	/^    const typename ExpressionType::Nested m_matrix;$/;"	m	class:Eigen::WithFormat
m_matrix	Eigen/src/Core/PermutationMatrix.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval
m_matrix	Eigen/src/Core/Replicate.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::Replicate
m_matrix	Eigen/src/Core/Reverse.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Reverse
m_matrix	Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SelfAdjointView
m_matrix	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    Lhs& m_matrix;$/;"	m	class:Eigen::SelfCwiseBinaryOp
m_matrix	Eigen/src/Core/Transpose.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Transpose
m_matrix	Eigen/src/Core/Transpositions.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval
m_matrix	Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::TriangularView
m_matrix	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::VectorwiseOp
m_matrix	Eigen/src/Core/VectorwiseOp.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::PartialReduxExpr
m_matrix	Eigen/src/Eigen2Support/Cwise.h	/^    ExpressionTypeNested m_matrix;$/;"	m	class:Eigen::Cwise
m_matrix	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform
m_matrix	Eigen/src/Eigen2Support/Minor.h	/^    const typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Minor
m_matrix	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::HessenbergDecomposition
m_matrix	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixType m_matrix;$/;"	m	class:Eigen::Tridiagonalization
m_matrix	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
m_matrix	Eigen/src/Geometry/Homogeneous.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::Homogeneous
m_matrix	Eigen/src/Geometry/Transform.h	/^  MatrixType m_matrix;$/;"	m	class:Eigen::Transform
m_matrix	Eigen/src/LU/Inverse.h	/^  MatrixTypeNested m_matrix;$/;"	m	struct:Eigen::internal::inverse_impl
m_matrix	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable SparseMatrixType m_matrix;$/;"	m	class:Eigen::PardisoImpl
m_matrix	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    CholMatrixType m_matrix;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_matrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_matrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const MappedSparseMatrix& m_matrix;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_matrix	Eigen/src/SparseCore/SparseBlock.h	/^    typename SparseMatrixType::Nested m_matrix;$/;"	m	class:Eigen::BlockImpl
m_matrix	Eigen/src/SparseCore/SparseBlock.h	/^    typename XprType::Nested m_matrix;$/;"	m	class:Eigen::BlockImpl
m_matrix	Eigen/src/SparseCore/SparsePermutation.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval
m_matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    typename MatrixType::Nested m_matrix;$/;"	m	class:Eigen::SparseSelfAdjointView
m_matrix	Eigen/src/SparseCore/SparseTriangularView.h	/^    MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseTriangularView
m_matrix	Eigen/src/SparseCore/SparseView.h	/^  MatrixTypeNested m_matrix;$/;"	m	class:Eigen::SparseView
m_matrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const MappedSuperNodalMatrix& m_matrix; \/\/ Supernodal lower triangular matrix $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_matrix	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_matrix;  \/\/ copy of the factorized matrix$/;"	m	class:Eigen::SuperLUBase
m_matrixU	Eigen/src/SVD/JacobiSVD.h	/^    MatrixUType m_matrixU;$/;"	m	class:Eigen::JacobiSVD
m_matrixV	Eigen/src/SVD/JacobiSVD.h	/^    MatrixVType m_matrixV;$/;"	m	class:Eigen::JacobiSVD
m_max	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_max	Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_maxIterations	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    static const int m_maxIterations = 30;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_maxIterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int m_maxIterations;$/;"	m	class:Eigen::IterativeSolverBase
m_maxIterationsPerRow	Eigen/src/Eigenvalues/ComplexSchur.h	/^    static const int m_maxIterationsPerRow = 30;$/;"	m	class:Eigen::ComplexSchur
m_maxIterationsPerRow	Eigen/src/Eigenvalues/RealSchur.h	/^    static const int m_maxIterationsPerRow = 40;$/;"	m	class:Eigen::RealSchur
m_maxIters	Eigen/src/Eigenvalues/ComplexSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::ComplexSchur
m_maxIters	Eigen/src/Eigenvalues/RealQZ.h	/^      Index m_maxIters;$/;"	m	class:Eigen::RealQZ
m_maxIters	Eigen/src/Eigenvalues/RealSchur.h	/^    Index m_maxIters;$/;"	m	class:Eigen::RealSchur
m_maxpivot	Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_maxpivot	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_maxpivot	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_mc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_mc;$/;"	m	class:Eigen::internal::level3_blocking
m_min	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_min	Eigen/src/Geometry/AlignedBox.h	/^  VectorType m_min, m_max;$/;"	m	class:Eigen::AlignedBox
m_mode	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_mode;$/;"	m	class:Eigen::internal::AmbiVector
m_msglvl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_nApproachRateInv	srLib/srg/srgCamera.cpp	/^const int	srgCamera::m_nApproachRateInv = RGL_CAMERA_APPROACH_INV_RATE;$/;"	m	class:srgCamera	file:
m_nApproachRateInv	srLib/srg/srgCamera.h	/^	static const int	m_nApproachRateInv;$/;"	m	class:srgCamera
m_nConstraints	srLib/srDyn/srISLAND.h	/^	int								m_nConstraints;$/;"	m	class:ISLAND
m_nPossible_ISLAND_IDs	srLib/srDyn/srDYN.h	/^	int									m_nPossible_ISLAND_IDs;$/;"	m	class:srDYN
m_nSubstep_render_fixed	srLib/srDyn/srSpace.h	/^	int						m_nSubstep_render_fixed;$/;"	m	class:srSpace
m_name	srLib/SceneGraph/Leaf.h	/^	char			m_name[_MAX_PATH];$/;"	m	class:TDSNode
m_name	srLib/SceneGraph/Leaf.h	/^	char		m_name[_MAX_PATH];$/;"	m	class:STLNode
m_nc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_nc;$/;"	m	class:Eigen::internal::level3_blocking
m_nislands	srLib/srDyn/srDYN.h	/^	int									m_nislands;$/;"	m	class:srDYN
m_nnz	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_nnz;$/;"	m	class:Eigen::MappedSparseMatrix
m_nnzL	Eigen/src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU
m_nnzU	Eigen/src/SparseLU/SparseLU.h	/^    Index m_nnzL, m_nnzU; \/\/ Nonzeros in L and U factors$/;"	m	class:Eigen::SparseLU
m_nonZerosPerCol	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_nonZerosPerCol;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_nonzeroSingularValues	Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_nonzero_pivots	Eigen/src/LU/FullPivLU.h	/^    Index m_det_pq, m_nonzero_pivots;$/;"	m	class:Eigen::FullPivLU
m_nonzero_pivots	Eigen/src/QR/ColPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::ColPivHouseholderQR
m_nonzero_pivots	Eigen/src/QR/FullPivHouseholderQR.h	/^    Index m_nonzero_pivots;$/;"	m	class:Eigen::FullPivHouseholderQR
m_nonzeropivots	Eigen/src/SparseQR/SparseQR.h	/^    Index m_nonzeropivots;          \/\/ Number of non zero pivots found $/;"	m	class:Eigen::SparseQR
m_normOfS	Eigen/src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ
m_normOfT	Eigen/src/Eigenvalues/RealQZ.h	/^      Scalar m_normOfT, m_normOfS;$/;"	m	class:Eigen::RealQZ
m_nsuper	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_nsuper; \/\/ Number of supernodes $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_numeric;$/;"	m	class:Eigen::UmfPackLU
m_nzval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* m_nzval; \/\/array of nonzero values packed by column$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_nzval_colptr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_nzval_colptr; \/\/nzval_colptr[j] Stores the location in nzval[] which starts column j $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_object	Eigen/src/Core/Ref.h	/^    TPlainObjectType m_object;$/;"	m	class:Eigen::Ref
m_ordering	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    int m_ordering; \/\/ Ordering method to use, see SPQR's manual$/;"	m	class:Eigen::SPQR
m_origin	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_origin	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType m_origin, m_direction;$/;"	m	class:Eigen::ParametrizedLine
m_originalMatrix	Eigen/src/Eigen2Support/LU.h	/^    const MatrixType& m_originalMatrix;$/;"	m	class:Eigen::LU
m_originalMatrix	Eigen/src/misc/Image.h	/^    const MatrixType& m_originalMatrix;$/;"	m	struct:Eigen::internal::image_retval_base
m_other	Eigen/src/Core/Functors.h	/^  Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_inverse_mult_op
m_other	Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_add_op
m_other	Eigen/src/Core/Functors.h	/^  const Scalar m_other;$/;"	m	struct:Eigen::internal::scalar_constant_op
m_other	Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar2>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple2_op
m_other	Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_multiple_op
m_other	Eigen/src/Core/Functors.h	/^  typename add_const_on_value_type<typename NumTraits<Scalar>::Nested>::type m_other;$/;"	m	struct:Eigen::internal::scalar_quotient1_op
m_other	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const Derived& m_other; $/;"	m	struct:Eigen::SPQR_QProduct
m_other	Eigen/src/SparseQR/SparseQR.h	/^  const Derived& m_other;$/;"	m	struct:Eigen::SparseQR_QProduct
m_outer	Eigen/src/Core/CoreIterators.h	/^    const Index m_outer;$/;"	m	class:Eigen::DenseBase::InnerIterator
m_outer	Eigen/src/Core/Stride.h	/^    internal::variable_if_dynamic<Index, OuterStrideAtCompileTime> m_outer;$/;"	m	class:Eigen::Stride
m_outer	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_outer	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_outer	Eigen/src/SparseCore/SparseBlock.h	/^         Index m_outer;$/;"	m	class:Eigen::BlockImpl::InnerIterator
m_outer	Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::BlockImpl::InnerIterator
m_outer	Eigen/src/SparseCore/SparseBlock.h	/^        Index m_outer;$/;"	m	class:Eigen::BlockImpl::ReverseInnerIterator
m_outer	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const Index m_outer;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_outer	Eigen/src/SparseCore/SparseDenseProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::SparseDenseOuterProduct::InnerIterator
m_outer	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    Index m_outer;$/;"	m	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
m_outer	Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_outer	Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_outer;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_outer	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_outer;                    \/\/ Current column $/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_outerIndex	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index*  m_outerIndex;$/;"	m	class:Eigen::MappedSparseMatrix
m_outerIndex	Eigen/src/SparseCore/SparseMatrix.h	/^    Index* m_outerIndex;$/;"	m	class:Eigen::SparseMatrix
m_outerIndexPtr	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const int* m_outerIndexPtr;$/;"	m	class:Eigen::UmfPackLU
m_outerPos	Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerPos;$/;"	m	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
m_outerSize	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Index   m_outerSize;$/;"	m	class:Eigen::MappedSparseMatrix
m_outerSize	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, OuterSize> m_outerSize;$/;"	m	class:Eigen::BlockImpl
m_outerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    Index m_outerSize;$/;"	m	class:Eigen::SparseMatrix
m_outerStart	Eigen/src/SparseCore/SparseBlock.h	/^    Index m_outerStart;$/;"	m	class:Eigen::BlockImpl
m_outerStride	Eigen/src/Core/Block.h	/^    Index m_outerStride;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_outputPerm_c	Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_outputPerm_c; \/\/ The final column permutation$/;"	m	class:Eigen::SparseQR
m_p	Eigen/src/LU/FullPivLU.h	/^    PermutationPType m_p;$/;"	m	class:Eigen::FullPivLU
m_p	Eigen/src/LU/PartialPivLU.h	/^    PermutationType m_p;$/;"	m	class:Eigen::PartialPivLU
m_p	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::SuperLUBase
m_p	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntColVectorType m_p;$/;"	m	class:Eigen::UmfPackLU
m_pLink	srLib/srDyn/srCollision.h	/^	srLink* m_pLink;$/;"	m	class:srCollision
m_pLink	srLib/srDyn/srSensor.h	/^	srLink* m_pLink;$/;"	m	class:srSensor
m_pPstate	srLib/srDyn/srJointConstraint.h	/^	srPrismaticState *	m_pPstate;$/;"	m	class:JointConstraint
m_pRstate	srLib/srDyn/srJointConstraint.h	/^	srRevoluteState  *	m_pRstate;$/;"	m	class:JointConstraint
m_pSceneGraph	srLib/SceneGraph/SceneGraphRenderer.cpp	/^SceneGraphRenderer* SceneGraphRenderer::m_pSceneGraph = NULL;$/;"	m	class:SceneGraphRenderer	file:
m_pSceneGraph	srLib/SceneGraph/SceneGraphRenderer.h	/^	static SceneGraphRenderer*		m_pSceneGraph;$/;"	m	class:SceneGraphRenderer
m_pSystem	srLib/srDyn/srJoint.h	/^	srSystem * m_pSystem;$/;"	m	class:srJoint
m_pSystem	srLib/srDyn/srLink.h	/^	srSystem*				m_pSystem;$/;"	m	class:srLink
m_pUstate	srLib/srDyn/srJointConstraint.h	/^	srUniversalState *	m_pUstate;$/;"	m	class:JointConstraint
m_packetStep	Eigen/src/Core/Functors.h	/^  const Packet m_packetStep;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_parent	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    VectorXi m_parent;                                \/\/ elimination tree$/;"	m	class:Eigen::SimplicialCholeskyBase
m_pastixdata	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable pastix_data_t *m_pastixdata; \/\/ Data structure for pastix$/;"	m	class:Eigen::PastixBase
m_perfv	Eigen/src/SparseLU/SparseLU.h	/^    internal::perfvalues<Index> m_perfv; $/;"	m	class:Eigen::SparseLU
m_perm	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable Matrix<Index,Dynamic,1> m_perm;  \/\/ Permutation vector$/;"	m	class:Eigen::PastixBase
m_perm	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable IntColVectorType m_perm;$/;"	m	class:Eigen::PardisoImpl
m_perm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const Perm& m_perm;$/;"	m	class:Eigen::SparseSymmetricPermutationProduct
m_perm_c	Eigen/src/SparseLU/SparseLU.h	/^    PermutationType m_perm_c; \/\/ Column permutation $/;"	m	class:Eigen::SparseLU
m_perm_c	Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_perm_c;       \/\/ Fill-reducing  Column  permutation$/;"	m	class:Eigen::SparseQR
m_perm_r	Eigen/src/SparseLU/SparseLU.h	/^    PermutationType m_perm_r ; \/\/ Row permutation$/;"	m	class:Eigen::SparseLU
m_permutation	Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	class:Eigen::Transpose
m_permutation	Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_matrix_product_retval
m_permutation	Eigen/src/SparseCore/SparsePermutation.h	/^    const PermutationType& m_permutation;$/;"	m	struct:Eigen::internal::permut_sparsematrix_product_retval
m_pfnFS_Transfrom	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_Transfrom)(void);$/;"	m	class:srBallJoint
m_pfnFS_UpdateAIS_K	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateAIS_K)(const AInertia& AI);$/;"	m	class:srBallJoint
m_pfnFS_UpdateAIS_K	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateAIS_K)(const AInertia& AI);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateAIS_K	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateAIS_K)(const AInertia& AI);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateAIS_K	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateAIS_K)(const AInertia& AI);$/;"	m	class:srUniversalJoint
m_pfnFS_UpdateAIS_K_P	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateAIS_K_P)(AInertia& AIjari, const AInertia& AI);$/;"	m	class:srBallJoint
m_pfnFS_UpdateAIS_K_P	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateAIS_K_P)(AInertia& AIjari, const AInertia& AI);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateAIS_K_P	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateAIS_K_P)(AInertia& AIjari, const AInertia& AI);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateAIS_K_P	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateAIS_K_P)(AInertia& AIjari, const AInertia& AI);$/;"	m	class:srUniversalJoint
m_pfnFS_UpdateBiasImp	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateBiasImp)(dse3& Cias, const dse3& Bias);$/;"	m	class:srBallJoint
m_pfnFS_UpdateBiasImp	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateBiasImp)(dse3& Cias, const dse3& Bias);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateBiasImp	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateBiasImp)(dse3& Cias, const dse3& Bias);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateBiasImp	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateBiasImp)(dse3& Cias, const dse3& Bias);$/;"	m	class:srUniversalJoint
m_pfnFS_UpdateBiasforce	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateBiasforce)(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V);$/;"	m	class:srBallJoint
m_pfnFS_UpdateBiasforce	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateBiasforce)(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateBiasforce	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateBiasforce)(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateBiasforce	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateBiasforce)(dse3& Cias, const dse3& Bias, const AInertia& AI, const se3& V);$/;"	m	class:srUniversalJoint
m_pfnFS_UpdateForce	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateForce)(const dse3& F);$/;"	m	class:srBallJoint
m_pfnFS_UpdateForce	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateForce)(const dse3& F);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateForce	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateForce)(const dse3& F);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateForce	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateForce)(const dse3& F);$/;"	m	class:srUniversalJoint
m_pfnFS_UpdateLocalAcc	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateLocalAcc)(se3& jari, const se3& DV);$/;"	m	class:srBallJoint
m_pfnFS_UpdateLocalAcc	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateLocalAcc)(se3& jari, const se3& DV);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateLocalAcc	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateLocalAcc)(se3& jari, const se3& DV);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateLocalAcc	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateLocalAcc)(se3& jari, const se3& DV);$/;"	m	class:srUniversalJoint
m_pfnFS_UpdateLocalDelVel	srLib/srDyn/srBallJoint.h	/^	void	(srBallJoint::*m_pfnFS_UpdateLocalDelVel)(se3& jari, const se3& DV);$/;"	m	class:srBallJoint
m_pfnFS_UpdateLocalDelVel	srLib/srDyn/srPrismaticJoint.h	/^	void	(srPrismaticJoint::*m_pfnFS_UpdateLocalDelVel)(se3& jari, const se3& DV);$/;"	m	class:srPrismaticJoint
m_pfnFS_UpdateLocalDelVel	srLib/srDyn/srRevoluteJoint.h	/^	void	(srRevoluteJoint::*m_pfnFS_UpdateLocalDelVel)(se3& jari, const se3& DV);$/;"	m	class:srRevoluteJoint
m_pfnFS_UpdateLocalDelVel	srLib/srDyn/srUniversalJoint.h	/^	void	(srUniversalJoint::*m_pfnFS_UpdateLocalDelVel)(se3& jari, const se3& DV);$/;"	m	class:srUniversalJoint
m_pfn_DetectedCB	srLib/srDyn/srTouchSensor.h	/^	void	(*m_pfn_DetectedCB)(void* pVoid);$/;"	m	class:srTouchSensor
m_pfn_NarrowPhase_Algoritm	srLib/srDyn/srContactConstraint.h	/^	int		(CollisionPair::*m_pfn_NarrowPhase_Algoritm)();$/;"	m	class:CollisionPair
m_pfn_RayDetect	srLib/srDyn/srCollision.h	/^	bool	(srCollision::*m_pfn_RayDetect)(Vec3& point, Vec3& direction, SR_REAL& range, SR_REAL& dist);$/;"	m	class:srCollision
m_pfn_RoughCheck_Algoritm	srLib/srDyn/srContactConstraint.h	/^	bool	(CollisionPair::*m_pfn_RoughCheck_Algoritm)();$/;"	m	class:CollisionPair
m_pfn_SonarDetect	srLib/srDyn/srCollision.h	/^	bool	(srCollision::*m_pfn_SonarDetect)(SE3& T0, SR_REAL & range, SR_REAL & angle, bool & res);$/;"	m	class:srCollision
m_pfn_TouchDetect	srLib/srDyn/srCollision.h	/^	bool	(srCollision::*m_pfn_TouchDetect)(Vec3& position, SR_REAL radius, Vec3& point, Vec3& normal, SR_REAL& penetration);$/;"	m	class:srCollision
m_pfn_USER_CONTROL	srLib/srDyn/srSpace.h	/^	void	(*m_pfn_USER_CONTROL)();$/;"	m	class:srSpace
m_pfn_applyimpulse	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_applyimpulse)(int _idx);$/;"	m	class:ContactConstraint
m_pfn_applyimpulse	srLib/srDyn/srJointConstraint.h	/^	void	(JointConstraint::*m_pfn_applyimpulse)(int _idx);$/;"	m	class:JointConstraint
m_pfn_applyimpulse_Left	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_applyimpulse_Left)(int _idx);$/;"	m	class:ContactConstraint
m_pfn_applyimpulse_Right	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_applyimpulse_Right)(int _idx);$/;"	m	class:ContactConstraint
m_pfn_diffkin_integrateposition	srLib/srDyn/srSystem.h	/^	void		(srSystem::*m_pfn_diffkin_integrateposition)(SR_REAL & _step);$/;"	m	class:srSystem
m_pfn_diffkin_linkvelocitypropagation	srLib/srDyn/srSystem.h	/^	void		(srSystem::*m_pfn_diffkin_linkvelocitypropagation)();$/;"	m	class:srSystem
m_pfn_dyn_forwarddynamics_set00	srLib/srDyn/srSystem.h	/^	void		(srSystem::*m_pfn_dyn_forwarddynamics_set00)(SR_REAL & _step);$/;"	m	class:srSystem
m_pfn_dyn_impulsedynamics_set00	srLib/srDyn/srSystem.h	/^	void		(srSystem::*m_pfn_dyn_impulsedynamics_set00)(SR_REAL & _fps);$/;"	m	class:srSystem
m_pfn_dyn_integrateposition_set00	srLib/srDyn/srSystem.h	/^	void		(srSystem::*m_pfn_dyn_integrateposition_set00)(SR_REAL & _step);$/;"	m	class:srSystem
m_pfn_excite	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_excite)();$/;"	m	class:ContactConstraint
m_pfn_find_constraint	srLib/srDyn/srContactConstraint.h	/^	srSystem*	(ContactConstraint::*m_pfn_find_constraint)();$/;"	m	class:ContactConstraint
m_pfn_getInformation	srLib/srDyn/srJointConstraint.h	/^	void	(JointConstraint::*m_pfn_getInformation)(ConstraintInfo * info);$/;"	m	class:JointConstraint
m_pfn_getdelvelocity	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_getdelvelocity)(SR_REAL * sjari);$/;"	m	class:ContactConstraint
m_pfn_getdelvelocity	srLib/srDyn/srJointConstraint.h	/^	void	(JointConstraint::*m_pfn_getdelvelocity)(SR_REAL * sjari);$/;"	m	class:JointConstraint
m_pfn_getrelvelocity	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_getrelvelocity)(SR_REAL * sjari);$/;"	m	class:ContactConstraint
m_pfn_inspect_jointstate	srLib/srDyn/srJointConstraint.h	/^	bool	(JointConstraint::*m_pfn_inspect_jointstate)();$/;"	m	class:JointConstraint
m_pfn_setimpulse	srLib/srDyn/srJointConstraint.h	/^	void	(JointConstraint::*m_pfn_setimpulse)(SR_REAL * _lambda);$/;"	m	class:JointConstraint
m_pfn_unexcite	srLib/srDyn/srContactConstraint.h	/^	void	(ContactConstraint::*m_pfn_unexcite)();$/;"	m	class:ContactConstraint
m_pfn_unexcite	srLib/srDyn/srJointConstraint.h	/^	void	(JointConstraint::*m_pfn_unexcite)();$/;"	m	class:JointConstraint
m_pfn_unite	srLib/srDyn/srContactConstraint.h	/^	void		(ContactConstraint::*m_pfn_unite)();$/;"	m	class:ContactConstraint
m_pfn_updateframe	srLib/srDyn/srJoint.h	/^	void			(srJoint::*m_pfn_updateframe)();$/;"	m	class:srJoint
m_pivotperm	Eigen/src/SparseQR/SparseQR.h	/^    PermutationType m_pivotperm;    \/\/ The permutation for rank revealing$/;"	m	class:Eigen::SparseQR
m_pmat	Eigen/src/SparseQR/SparseQR.h	/^    QRMatrixType m_pmat;            \/\/ Temporary matrix$/;"	m	class:Eigen::SparseQR
m_precision	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_precision;$/;"	m	class:Eigen::FullPivHouseholderQR
m_preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner m_preconditioner;$/;"	m	class:Eigen::IterativeSolverBase
m_prescribedThreshold	Eigen/src/LU/FullPivLU.h	/^    RealScalar m_maxpivot, m_prescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_prescribedThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::ColPivHouseholderQR
m_prescribedThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar m_prescribedThreshold, m_maxpivot;$/;"	m	class:Eigen::FullPivHouseholderQR
m_prescribedThreshold	Eigen/src/SVD/JacobiSVD.h	/^    RealScalar m_prescribedThreshold;$/;"	m	class:Eigen::JacobiSVD
m_prod	Eigen/src/Core/ProductBase.h	/^    const NestedProduct& m_prod;$/;"	m	class:ScaledProduct
m_pt	Eigen/src/PardisoSupport/PardisoSupport.h	/^    mutable void *m_pt[64];$/;"	m	class:Eigen::PardisoImpl
m_ptr	Eigen/src/Core/util/Memory.h	/^    T* m_ptr;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_pvDetectedData	srLib/srDyn/srTouchSensor.h	/^	void*	m_pvDetectedData;$/;"	m	class:srTouchSensor
m_q	Eigen/src/LU/FullPivLU.h	/^    PermutationQType m_q;$/;"	m	class:Eigen::FullPivLU
m_q	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::SuperLUBase
m_q	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable IntRowVectorType m_q;$/;"	m	class:Eigen::UmfPackLU
m_qr	Eigen/src/QR/ColPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::ColPivHouseholderQR
m_qr	Eigen/src/QR/FullPivHouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::FullPivHouseholderQR
m_qr	Eigen/src/QR/FullPivHouseholderQR.h	/^  typename MatrixType::Nested m_qr;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_qr	Eigen/src/QR/HouseholderQR.h	/^    MatrixType m_qr;$/;"	m	class:Eigen::HouseholderQR
m_qr	Eigen/src/SVD/JacobiSVD.h	/^  QRType m_qr;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_qr	Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQReturnType
m_qr	Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQRMatrixQTransposeReturnType
m_qr	Eigen/src/SparseQR/SparseQR.h	/^  const SparseQRType& m_qr;$/;"	m	struct:Eigen::SparseQR_QProduct
m_qr_precond_morecols	Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows> m_qr_precond_morecols;$/;"	m	class:Eigen::JacobiSVD
m_qr_precond_morerows	Eigen/src/SVD/JacobiSVD.h	/^    internal::qr_preconditioner_impl<MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols> m_qr_precond_morerows;$/;"	m	class:Eigen::JacobiSVD
m_rC	srLib/srDyn/srBallJoint.h	/^	SR_REAL			 m_rC;$/;"	m	class:srBallJoint
m_rC	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_rC;$/;"	m	class:srPrismaticJoint
m_rC	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_rC;$/;"	m	class:srRevoluteJoint
m_rC	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_rC[2];$/;"	m	class:srUniversalJoint
m_rCommand	srLib/srDyn/srState.h	/^	SR_REAL	m_rCommand[2];		$/;"	m	class:srUniversalState
m_rCommand	srLib/srDyn/srState.h	/^	SR_REAL m_rCommand;$/;"	m	class:srRevoluteState
m_rDelVel	srLib/srDyn/srState.h	/^	SR_REAL	m_rDelVel[2];$/;"	m	class:srUniversalState
m_rDelVel	srLib/srDyn/srState.h	/^	SR_REAL m_rDelVel;$/;"	m	class:srRevoluteState
m_rImp	srLib/srDyn/srState.h	/^	SR_REAL	m_rImp[2];$/;"	m	class:srUniversalState
m_rImp	srLib/srDyn/srState.h	/^	SR_REAL m_rImp;$/;"	m	class:srRevoluteState
m_rK	srLib/srDyn/srBallJoint.h	/^	SR_REAL			 m_rK;$/;"	m	class:srBallJoint
m_rK	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_rK;$/;"	m	class:srPrismaticJoint
m_rK	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_rK;$/;"	m	class:srRevoluteJoint
m_rK	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_rK[2];$/;"	m	class:srUniversalJoint
m_rOffset	srLib/srDyn/srPrismaticJoint.h	/^	SR_REAL	m_rOffset;$/;"	m	class:srPrismaticJoint
m_rOffset	srLib/srDyn/srRevoluteJoint.h	/^	SR_REAL	m_rOffset;$/;"	m	class:srRevoluteJoint
m_rOffset	srLib/srDyn/srUniversalJoint.h	/^	SR_REAL			 m_rOffset[2];$/;"	m	class:srUniversalJoint
m_rPosErrVel	srLib/srDyn/srState.h	/^	SR_REAL	m_rPosErrVel[2];$/;"	m	class:srUniversalState
m_rPosErrVel	srLib/srDyn/srState.h	/^	SR_REAL m_rPosErrVel;$/;"	m	class:srRevoluteState
m_rValue	srLib/srDyn/srState.h	/^	SR_REAL	m_rValue[2][4];	$/;"	m	class:srUniversalState
m_rValue	srLib/srDyn/srState.h	/^	SR_REAL m_rValue[4];$/;"	m	class:srRevoluteState
m_rank	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    mutable Index m_rank; \/\/ The rank of the matrix$/;"	m	class:Eigen::SPQR
m_rank	Eigen/src/misc/Image.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::image_retval_base
m_rank	Eigen/src/misc/Kernel.h	/^    Index m_rank, m_cols;$/;"	m	struct:Eigen::internal::kernel_retval_base
m_realQZ	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    RealQZ<MatrixType> m_realQZ;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_realSchur	Eigen/src/Eigenvalues/EigenSolver.h	/^    RealSchur<MatrixType> m_realSchur;$/;"	m	class:Eigen::EigenSolver
m_reference	Eigen/src/SparseCore/SparseView.h	/^  Scalar m_reference;$/;"	m	class:Eigen::SparseView
m_result	Eigen/src/Core/ProductBase.h	/^    mutable PlainObject m_result;$/;"	m	namespace:Eigen
m_result	Eigen/src/Core/products/CoeffBasedProduct.h	/^    mutable PlainObject m_result;$/;"	m	class:Eigen::CoeffBasedProduct
m_returnOne	Eigen/src/SparseCore/SparseTriangularView.h	/^    bool m_returnOne;$/;"	m	class:Eigen::SparseTriangularView::InnerIterator
m_rhs	Eigen/src/Core/CwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::CwiseBinaryOp
m_rhs	Eigen/src/Core/ProductBase.h	/^    RhsNested m_rhs;$/;"	m	namespace:Eigen
m_rhs	Eigen/src/Core/SolveTriangular.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_rhs	Eigen/src/Core/products/CoeffBasedProduct.h	/^    typename internal::add_const_on_value_type<RhsNested>::type m_rhs;$/;"	m	class:Eigen::CoeffBasedProduct
m_rhs	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    const Rhs& m_rhs;$/;"	m	struct:Eigen::internal::gemm_functor
m_rhs	Eigen/src/Geometry/Homogeneous.h	/^  typename MatrixType::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_left_product_impl
m_rhs	Eigen/src/Geometry/Homogeneous.h	/^  typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::homogeneous_right_product_impl
m_rhs	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_rhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDenseOuterProduct
m_rhs	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseDiagonalProduct
m_rhs	Eigen/src/SparseCore/SparseProduct.h	/^    RhsNested m_rhs;$/;"	m	class:Eigen::SparseSparseProduct
m_rhs	Eigen/src/misc/Solve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_base
m_rhs	Eigen/src/misc/SparseSolve.h	/^    const typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::solve_retval_with_guess
m_rhs	Eigen/src/misc/SparseSolve.h	/^    typename Rhs::Nested m_rhs;$/;"	m	struct:Eigen::internal::sparse_solve_retval_base
m_rhsIter	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    RhsIterator m_rhsIter;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_root	srLib/SceneGraph/SceneGraphRenderer.cpp	/^Node* SceneGraphRenderer::m_root = NULL;$/;"	m	class:SceneGraphRenderer	file:
m_root	srLib/SceneGraph/SceneGraphRenderer.h	/^	static Node* m_root;$/;"	m	class:SceneGraphRenderer
m_root2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^Node*  SceneGraphRenderer::m_root2 = NULL;$/;"	m	class:SceneGraphRenderer	file:
m_root2	srLib/SceneGraph/SceneGraphRenderer.h	/^	static Node* m_root2;$/;"	m	class:SceneGraphRenderer
m_row	Eigen/src/Core/CommaInitializer.h	/^  Index m_row;              \/\/ current row id$/;"	m	struct:Eigen::CommaInitializer
m_row	Eigen/src/Eigen2Support/Minor.h	/^    const Index m_row, m_col;$/;"	m	class:Eigen::Minor
m_row	Eigen/src/SparseCore/SparseUtil.h	/^  Index m_row, m_col;$/;"	m	class:Eigen::Triplet
m_row	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index m_row; \/\/ Number of rows$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rowFactor	Eigen/src/Core/Replicate.h	/^    const internal::variable_if_dynamic<Index, RowFactor> m_rowFactor;$/;"	m	class:Eigen::Replicate
m_rowind	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_rowind; \/\/ Array of compressed row indices of rectangular supernodes$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rowind_colptr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_rowind_colptr; \/\/rowind_colptr[j] stores the location in rowind[] which starts column j$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_rows	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrix
m_rows	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Rows>   m_rows;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_rows	Eigen/src/Core/CwiseNullaryOp.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::CwiseNullaryOp
m_rows	Eigen/src/Core/DenseStorage.h	/^    DenseIndex m_rows;$/;"	m	class:Eigen::DenseStorage
m_rows	Eigen/src/Core/MapBase.h	/^    const internal::variable_if_dynamic<Index, RowsAtCompileTime> m_rows;$/;"	m	class:Eigen::MapBase
m_rows	Eigen/src/SVD/JacobiSVD.h	/^    Index m_nonzeroSingularValues, m_rows, m_cols, m_diagSize;$/;"	m	class:Eigen::JacobiSVD
m_rowsTranspositions	Eigen/src/LU/FullPivLU.h	/^    IntColVectorType m_rowsTranspositions;$/;"	m	class:Eigen::FullPivLU
m_rowsTranspositions	Eigen/src/LU/PartialPivLU.h	/^    TranspositionType m_rowsTranspositions;$/;"	m	class:Eigen::PartialPivLU
m_rowsTranspositions	Eigen/src/QR/FullPivHouseholderQR.h	/^  typename IntDiagSizeVectorType::Nested m_rowsTranspositions;$/;"	m	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
m_rows_transpositions	Eigen/src/QR/FullPivHouseholderQR.h	/^    IntDiagSizeVectorType m_rows_transpositions;$/;"	m	class:Eigen::FullPivHouseholderQR
m_s	Eigen/src/Jacobi/Jacobi.h	/^    Scalar m_c, m_s;$/;"	m	class:Eigen::JacobiRotation
m_sCameraFrame	srLib/srg/srgCamera.h	/^	SE3					m_sCameraFrame;$/;"	m	class:srgCamera
m_sCameraInvFrame	srLib/srg/srgCamera.h	/^	SE3					m_sCameraInvFrame;$/;"	m	class:srgCamera
m_scale	Eigen/src/Core/GeneralProduct.h	/^      Scalar m_scale;$/;"	m	struct:Eigen::GeneralProduct::adds
m_scaledMatrix	Eigen/src/SVD/JacobiSVD.h	/^    MatrixType m_scaledMatrix;$/;"	m	class:Eigen::JacobiSVD
m_schur	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexSchur<MatrixType> m_schur;$/;"	m	class:Eigen::ComplexEigenSolver
m_shift	Eigen/src/Householder/HouseholderSequence.h	/^    Index m_shift;$/;"	m	class:Eigen::HouseholderSequence
m_shiftOffset	Eigen/src/CholmodSupport/CholmodSupport.h	/^    RealScalar m_shiftOffset[2];$/;"	m	class:Eigen::CholmodBase
m_shiftOffset	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftOffset;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_shiftScale	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    RealScalar m_shiftScale;$/;"	m	class:Eigen::SimplicialCholeskyBase
m_sigma	Eigen/src/Eigen2Support/SVD.h	/^    SingularValuesType m_sigma;$/;"	m	class:Eigen::SVD
m_sign	Eigen/src/Cholesky/LDLT.h	/^    internal::SignMatrix m_sign;$/;"	m	class:Eigen::LDLT
m_singularValues	Eigen/src/SVD/JacobiSVD.h	/^    SingularValuesType m_singularValues;$/;"	m	class:Eigen::JacobiSVD
m_size	Eigen/src/Core/util/Memory.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::aligned_stack_memory_handler
m_size	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    mutable int m_size; \/\/ Size of the matrix $/;"	m	class:Eigen::PastixBase
m_size	Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_size;$/;"	m	class:Eigen::PardisoImpl
m_size	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_size;$/;"	m	class:Eigen::internal::AmbiVector
m_size	Eigen/src/SparseCore/CompressedStorage.h	/^    size_t m_size;$/;"	m	class:Eigen::internal::CompressedStorage
m_size	Eigen/src/SparseCore/SparseVector.h	/^    Index m_size;$/;"	m	class:Eigen::SparseVector
m_sizeA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeA;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizeB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeB;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sizeW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    DenseIndex m_sizeW;$/;"	m	class:Eigen::internal::gemm_blocking_space
m_sluA	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluA;$/;"	m	class:Eigen::SuperLUBase
m_sluB	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_sluBerr	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluCscale	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluEqued	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable char m_sluEqued;$/;"	m	class:Eigen::SuperLUBase
m_sluEtree	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable std::vector<int> m_sluEtree;$/;"	m	class:Eigen::SuperLUBase
m_sluFerr	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluFerr, m_sluBerr;$/;"	m	class:Eigen::SuperLUBase
m_sluL	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluOptions	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable superlu_options_t m_sluOptions;$/;"	m	class:Eigen::SuperLUBase
m_sluRscale	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable Matrix<RealScalar,Dynamic,1> m_sluRscale, m_sluCscale;$/;"	m	class:Eigen::SuperLUBase
m_sluStat	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperLUStat_t m_sluStat;$/;"	m	class:Eigen::SuperLUBase
m_sluU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SuperMatrix m_sluL, m_sluU;$/;"	m	class:Eigen::SuperLUBase
m_sluX	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable SluMatrix m_sluB, m_sluX;$/;"	m	class:Eigen::SuperLUBase
m_spqr	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr; $/;"	m	struct:Eigen::SPQR_QProduct
m_spqr	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQReturnType
m_spqr	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  const SPQRType& m_spqr;$/;"	m	struct:Eigen::SPQRMatrixQTransposeReturnType
m_srDYN	srLib/srDyn/srSpace.h	/^	srDYN								m_srDYN;$/;"	m	class:srSpace
m_start	Eigen/src/SparseCore/AmbiVector.h	/^    Index m_start;$/;"	m	class:Eigen::internal::AmbiVector
m_start	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::InnerIterator
m_start	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
m_start	Eigen/src/SparseCore/SparseMatrix.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_start	Eigen/src/SparseCore/SparseVector.h	/^    const Index m_start;$/;"	m	class:Eigen::SparseVector::ReverseInnerIterator
m_startCol	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_startCol	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::ColsAtCompileTime == 1 ? 0 : Dynamic> m_startCol;$/;"	m	class:Eigen::BlockImpl
m_startRow	Eigen/src/Core/Block.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_startRow	Eigen/src/SparseCore/SparseBlock.h	/^    const internal::variable_if_dynamic<Index, XprType::RowsAtCompileTime == 1 ? 0 : Dynamic> m_startRow;$/;"	m	class:Eigen::BlockImpl
m_startidval	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_startidval;               \/\/ Start of the column value$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_staticA	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 LhsScalar m_staticA[SizeA];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticB	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticB[SizeB];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_staticW	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    EIGEN_ALIGN16 RhsScalar m_staticW[SizeW];$/;"	m	class:Eigen::internal::gemm_blocking_space
m_step	Eigen/src/Core/Functors.h	/^  const Scalar m_step;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_stepPacket	Eigen/src/Core/Functors.h	/^  const Packet m_stepPacket;$/;"	m	struct:Eigen::internal::linspaced_op_impl
m_stl_content	srLib/SceneGraph/ModelSTL.h	/^    srSTL::STLc m_stl_content;$/;"	m	class:ModelSTL
m_storage	Eigen/src/Core/PlainObjectBase.h	/^    DenseStorage<Scalar, Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime, Base::ColsAtCompileTime, Options> m_storage;$/;"	m	class:Eigen::PlainObjectBase
m_stride	Eigen/src/Core/Map.h	/^    StrideType m_stride;$/;"	m	class:Eigen::Map
m_stride	Eigen/src/Core/Ref.h	/^  StrideBase m_stride;$/;"	m	class:Eigen::RefBase
m_stride	Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::blas_data_mapper
m_stride	Eigen/src/Core/util/BlasUtil.h	/^    Index m_stride;$/;"	m	class:Eigen::internal::const_blas_data_mapper
m_structureIsUptodate	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    bool m_structureIsUptodate;$/;"	m	class:Eigen::PastixLU
m_subdiag	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    typename TridiagonalizationType::SubDiagonalType m_subdiag;$/;"	m	class:Eigen::SelfAdjointEigenSolver
m_subs	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrix
m_subs	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Subs>   m_subs;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_supPolyBoundary	srLib/srExt/srExt_System.h	/^		Eigen::VectorXd	m_supPolyBoundary;$/;"	m	class:srExt::srExtSystem
m_sup_to_col	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* m_sup_to_col; \/\/sup_to_col[s] points to the starting column of the s-th supernode$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix
m_supers	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrix
m_supers	Eigen/src/Core/BandMatrix.h	/^    internal::variable_if_dynamic<Index, _Supers> m_supers;$/;"	m	class:Eigen::internal::BandMatrixWrapper
m_supno	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index m_supno;                    \/\/ Current SuperNode number$/;"	m	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
m_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    void* m_symbolic;$/;"	m	class:Eigen::UmfPackLU
m_symmetricmode	Eigen/src/SparseLU/SparseLU.h	/^    bool m_symmetricmode;$/;"	m	class:Eigen::SparseLU
m_temp	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    VectorType m_temp;$/;"	m	class:Eigen::HessenbergDecomposition
m_temp	Eigen/src/QR/ColPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::ColPivHouseholderQR
m_temp	Eigen/src/QR/FullPivHouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::FullPivHouseholderQR
m_temp	Eigen/src/QR/HouseholderQR.h	/^    RowVectorType m_temp;$/;"	m	class:Eigen::HouseholderQR
m_temporary	Eigen/src/Cholesky/LDLT.h	/^    TmpMatrixType m_temporary;$/;"	m	class:Eigen::LDLT
m_then	Eigen/src/Core/Select.h	/^    typename ThenMatrixType::Nested m_then;$/;"	m	class:Eigen::Select
m_threshold	Eigen/src/SparseQR/SparseQR.h	/^    RealScalar m_threshold;         \/\/ Threshold to determine null Householder reflections$/;"	m	class:Eigen::SparseQR
m_tmp	Eigen/src/Eigenvalues/EigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::EigenSolver
m_tmp	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    ColumnVectorType m_tmp;$/;"	m	class:Eigen::GeneralizedEigenSolver
m_tolerance	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar m_tolerance;$/;"	m	class:Eigen::IterativeSolverBase
m_tolerance	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    RealScalar m_tolerance; \/\/ treat columns with 2-norm below this tolerance as zero$/;"	m	class:Eigen::SPQR
m_tolerance	Eigen/src/SparseCore/SparseProduct.h	/^    RealScalar m_tolerance;$/;"	m	class:Eigen::SparseSparseProduct
m_trans	Eigen/src/Householder/HouseholderSequence.h	/^    bool m_trans;$/;"	m	class:Eigen::HouseholderSequence
m_transpose	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  bool m_transpose; $/;"	m	struct:Eigen::SPQR_QProduct
m_transpose	Eigen/src/SparseQR/SparseQR.h	/^  bool m_transpose;$/;"	m	struct:Eigen::SparseQR_QProduct
m_transpositions	Eigen/src/Cholesky/LDLT.h	/^    TranspositionType m_transpositions;$/;"	m	class:Eigen::LDLT
m_transpositions	Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	class:Eigen::Transpose
m_transpositions	Eigen/src/Core/Transpositions.h	/^    const TranspositionType& m_transpositions;$/;"	m	struct:Eigen::internal::transposition_matrix_product_retval
m_triangularMatrix	Eigen/src/Core/SolveTriangular.h	/^    const TriangularType& m_triangularMatrix;$/;"	m	struct:Eigen::internal::triangular_solve_retval
m_type	Eigen/src/PardisoSupport/PardisoSupport.h	/^    Index m_type, m_msglvl;$/;"	m	class:Eigen::PardisoImpl
m_u	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::SuperLUBase
m_u	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    mutable LUMatrixType m_u;$/;"	m	class:Eigen::UmfPackLU
m_useDefaultThreshold	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SPQR
m_useDefaultThreshold	Eigen/src/SparseQR/SparseQR.h	/^    bool m_useDefaultThreshold;     \/\/ Use default threshold$/;"	m	class:Eigen::SparseQR
m_usePrescribedThreshold	Eigen/src/LU/FullPivLU.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivLU
m_usePrescribedThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::ColPivHouseholderQR
m_usePrescribedThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    bool m_isInitialized, m_usePrescribedThreshold;$/;"	m	class:Eigen::FullPivHouseholderQR
m_usePrescribedThreshold	Eigen/src/SVD/JacobiSVD.h	/^    bool m_isInitialized, m_isAllocated, m_usePrescribedThreshold;$/;"	m	class:Eigen::JacobiSVD
m_vCenter	srLib/srg/srgCamera.h	/^	Vec3				m_vCenter;$/;"	m	class:srgCamera
m_vEye	srLib/srg/srgCamera.h	/^	Vec3				m_vEye;$/;"	m	class:srgCamera
m_vUp	srLib/srg/srgCamera.h	/^	Vec3				m_vUp;$/;"	m	class:srgCamera
m_value	Eigen/src/SparseCore/SparseBlock.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
m_value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    Scalar m_value;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_value	Eigen/src/SparseCore/SparseMatrix.h	/^        Index m_value;$/;"	m	class:Eigen::SparseMatrix::SingletonVector
m_value	Eigen/src/SparseCore/SparseUtil.h	/^  Scalar m_value;$/;"	m	class:Eigen::Triplet
m_valuePtr	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    const Scalar* m_valuePtr;$/;"	m	class:Eigen::UmfPackLU
m_values	Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* m_values;$/;"	m	class:Eigen::internal::CompressedStorage
m_values	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    Scalar* m_values;$/;"	m	class:Eigen::MappedSparseMatrix
m_values	Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::InnerIterator
m_values	Eigen/src/SparseCore/SparseMatrix.h	/^    const Scalar* m_values;$/;"	m	class:Eigen::SparseMatrix::ReverseInnerIterator
m_vector	Eigen/src/SparseCore/AmbiVector.h	/^    const AmbiVector& m_vector; \/\/ the target vector$/;"	m	class:Eigen::internal::AmbiVector::Iterator
m_vectors	Eigen/src/Householder/HouseholderSequence.h	/^    typename VectorsType::Nested m_vectors;$/;"	m	class:Eigen::HouseholderSequence
m_view	Eigen/src/SparseCore/SparseView.h	/^  const SparseView& m_view;$/;"	m	class:Eigen::SparseView::InnerIterator
m_workMatrix	Eigen/src/SVD/JacobiSVD.h	/^    WorkMatrixType m_workMatrix;$/;"	m	class:Eigen::JacobiSVD
m_workspace	Eigen/src/Eigenvalues/RealQZ.h	/^      Matrix<Scalar,Dynamic,1> m_workspace;$/;"	m	class:Eigen::RealQZ
m_workspace	Eigen/src/SVD/JacobiSVD.h	/^  WorkspaceType m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_col_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspace	Eigen/src/SVD/JacobiSVD.h	/^  typename internal::plain_row_type<MatrixType>::type m_workspace;$/;"	m	class:Eigen::internal::qr_preconditioner_impl
m_workspaceVector	Eigen/src/Eigenvalues/RealSchur.h	/^    ColumnVectorType m_workspaceVector;$/;"	m	class:Eigen::RealSchur
m_xeProjectionMode	srLib/srg/srgCamera.h	/^	ProjectionType	m_xeProjectionMode;$/;"	m	class:srgCamera
m_xeViewDirection	srLib/srg/srgCamera.h	/^	ViewDirection	m_xeViewDirection;$/;"	m	class:srgCamera
m_xpr	Eigen/src/Core/Block.h	/^    const typename XprType::Nested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_xpr	Eigen/src/Core/Block.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::internal::BlockImpl_dense
m_xpr	Eigen/src/Core/CommaInitializer.h	/^  XprType& m_xpr;   \/\/ target expression$/;"	m	struct:Eigen::CommaInitializer
m_xpr	Eigen/src/Core/CwiseUnaryOp.h	/^    typename XprType::Nested m_xpr;$/;"	m	class:Eigen::CwiseUnaryOp
m_xpr	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    const CwiseBinaryXpr& m_xpr;$/;"	m	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
m_zero	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar m_zero;$/;"	m	class:Eigen::internal::AmbiVector
machine_epsilon	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T machine_epsilon () { return NumTraits<T>::epsilon(); }$/;"	f	namespace:Eigen
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, AccPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp) const$/;"	f	class:Eigen::internal::gebp_traits
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, DoublePacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd(const LhsPacket& a, const RhsPacket& b, ResPacket& c, RhsPacket& \/*tmp*\/) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsPacket& a, const RhsPacket& b, AccPacket& c, RhsPacket& tmp, const true_type&) const$/;"	f	class:Eigen::internal::gebp_traits
madd_impl	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void madd_impl(const LhsScalar& a, const RhsScalar& b, ResScalar& c, RhsScalar& \/*tmp*\/, const false_type&) const$/;"	f	class:Eigen::internal::gebp_traits
main	Example/DracoP1/simulation_draco.cpp	/^int main(int argc, char **argv) $/;"	f
main	Example/MobileRobots/MobileRobots.cpp	/^int main(int argc, char **argv)$/;"	f
main	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^int main(argc, argv) int argc; char *argv[];$/;"	f
main	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^void main() {}$/;"	f
main	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^int main(int argc, char* argv[])$/;"	f
main	build/CMakeFiles/feature_tests.c	/^int main(int argc, char** argv) { (void)argv; return features[argc]; }$/;"	f
main	build/CMakeFiles/feature_tests.cxx	/^int main(int argc, char** argv) { (void)argv; return features[argc]; }$/;"	f
makeAffine	Eigen/src/Geometry/Transform.h	/^  void makeAffine()$/;"	f	class:Eigen::Transform
makeBoxObject	srLib/srExt/srExtension.cpp	/^srSystem * srExt::makeBoxObject(Eigen::VectorXd pos, Eigen::VectorXd dim, bool invisible, bool expand)$/;"	f	class:srExt
makeCompressed	Eigen/src/SparseCore/SparseMatrix.h	/^    void makeCompressed()$/;"	f	class:Eigen::SparseMatrix
makeGivens	Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::false_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* r, internal::true_type)$/;"	f	class:Eigen::JacobiRotation
makeGivens	Eigen/src/Jacobi/Jacobi.h	/^void JacobiRotation<Scalar>::makeGivens(const Scalar& p, const Scalar& q, Scalar* z)$/;"	f	class:Eigen::JacobiRotation
makeHouseholder	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholder($/;"	f	class:Eigen::MatrixBase
makeHouseholderInPlace	Eigen/src/Householder/Householder.h	/^void MatrixBase<Derived>::makeHouseholderInPlace(Scalar& tau, RealScalar& beta)$/;"	f	class:Eigen::MatrixBase
makeJacobi	Eigen/src/Jacobi/Jacobi.h	/^bool JacobiRotation<Scalar>::makeJacobi(const RealScalar& x, const Scalar& y, const RealScalar& z)$/;"	f	class:Eigen::JacobiRotation
makeJacobi	Eigen/src/Jacobi/Jacobi.h	/^inline bool JacobiRotation<Scalar>::makeJacobi(const MatrixBase<Derived>& m, typename Derived::Index p, typename Derived::Index q)$/;"	f	class:Eigen::JacobiRotation
makeTubeList	srLib/SceneGraph/Leaf.cpp	/^void Tube::makeTubeList()$/;"	f	class:Tube
make_block_householder_triangular_factor	Eigen/src/Householder/BlockHouseholder.h	/^void make_block_householder_triangular_factor(TriangularFactorType& triFactor, const VectorsType& vectors, const CoeffsType& hCoeffs)$/;"	f	namespace:Eigen::internal
manageErrorCode	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void manageErrorCode(Index error)$/;"	f	class:Eigen::PardisoImpl
manage_caching_sizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void manage_caching_sizes(Action action, std::ptrdiff_t* l1=0, std::ptrdiff_t* l2=0)$/;"	f	namespace:Eigen::internal
manage_caching_sizes_helper	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline std::ptrdiff_t manage_caching_sizes_helper(std::ptrdiff_t a, std::ptrdiff_t b)$/;"	f	namespace:Eigen::internal
manage_multi_threading	Eigen/src/Core/products/Parallelizer.h	/^inline void manage_multi_threading(Action action, int* v)$/;"	f	namespace:Eigen::internal
map_superlu	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> map_superlu(SluMatrix& sluMat)$/;"	f	namespace:Eigen::internal
mark	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index mark ;  \/* for computing set differences and marking dead rows*\/$/;"	m	union:internal::Colamd_Row::__anon354
markAsRValue	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& markAsRValue() { m_isRValue = true; return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
marked	Eigen/src/Eigen2Support/Lazy.h	/^MatrixBase<Derived>::marked() const$/;"	f	class:Eigen::MatrixBase
maskshno	srLib/SceneGraph/gl2ps.c	/^  int gsno, fontno, imno, shno, maskshno, trgroupno;$/;"	m	struct:__anon14	file:
maskshobjno	srLib/SceneGraph/gl2ps.c	/^  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;$/;"	m	struct:__anon14	file:
matPrefix	Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
matSuffix	Eigen/src/Core/IO.h	/^  std::string matPrefix, matSuffix;$/;"	m	struct:Eigen::IOFormat
match	Eigen/src/Core/Ref.h	/^  template<typename Derived> struct match {$/;"	s	struct:Eigen::internal::traits
matrix	Eigen/src/Core/ArrayBase.h	/^    MatrixWrapper<Derived> matrix() { return derived(); }$/;"	f	class:Eigen::ArrayBase
matrix	Eigen/src/Core/ArrayBase.h	/^    const MatrixWrapper<const Derived> matrix() const { return derived(); }$/;"	f	class:Eigen::ArrayBase
matrix	Eigen/src/Core/MatrixBase.h	/^    MatrixBase<Derived>& matrix() { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	Eigen/src/Core/MatrixBase.h	/^    const MatrixBase<Derived>& matrix() const { return *this; }$/;"	f	class:Eigen::MatrixBase
matrix	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType matrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
matrix	Eigen/src/Geometry/Transform.h	/^  inline MatrixType& matrix() { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	Eigen/src/Geometry/Transform.h	/^  inline const MatrixType& matrix() const { return m_matrix; }$/;"	f	class:Eigen::Transform
matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    _MatrixTypeNested& matrix() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    const _MatrixTypeNested& matrix() const { return m_matrix; }$/;"	f	class:Eigen::SparseSelfAdjointView
matrix	srMath/SE3.cpp	/^	const Matrix4 SE3::matrix() const$/;"	f	class:srMath::SE3
matrix	srMath/SO3.cpp	/^	const Matrix3& SO3::matrix() const$/;"	f	class:srMath::SO3
matrixH	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    MatrixHReturnType matrixH() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixL	Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LDLT
matrixL	Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixL matrixL() const$/;"	f	class:Eigen::LLT
matrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixL	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixL matrixL() const {$/;"	f	class:Eigen::SimplicialLLT
matrixL	Eigen/src/SparseLU/SparseLU.h	/^    SparseLUMatrixLReturnType<SCMatrix> matrixL() const$/;"	f	class:Eigen::SparseLU
matrixL	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const LMatrixType& matrixL() const$/;"	f	class:Eigen::SuperLU
matrixL	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixL() const$/;"	f	class:Eigen::UmfPackLU
matrixLDLT	Eigen/src/Cholesky/LDLT.h	/^    inline const MatrixType& matrixLDLT() const$/;"	f	class:Eigen::LDLT
matrixLLT	Eigen/src/Cholesky/LLT.h	/^    inline const MatrixType& matrixLLT() const$/;"	f	class:Eigen::LLT
matrixLU	Eigen/src/LU/FullPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::FullPivLU
matrixLU	Eigen/src/LU/PartialPivLU.h	/^    inline const MatrixType& matrixLU() const$/;"	f	class:Eigen::PartialPivLU
matrixQ	Eigen/src/Eigen2Support/QR.h	/^    MatrixType matrixQ(void) const {$/;"	f	class:Eigen::QR
matrixQ	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::HessenbergDecomposition
matrixQ	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixQ() const {$/;"	f	class:Eigen::RealQZ
matrixQ	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    HouseholderSequenceType matrixQ() const$/;"	f	class:Eigen::Tridiagonalization
matrixQ	Eigen/src/QR/ColPivHouseholderQR.h	/^    HouseholderSequenceType matrixQ(void) const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQ	Eigen/src/QR/FullPivHouseholderQR.h	/^inline typename FullPivHouseholderQR<MatrixType>::MatrixQReturnType FullPivHouseholderQR<MatrixType>::matrixQ() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQ	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    SPQRMatrixQReturnType<SPQR> matrixQ() const$/;"	f	class:Eigen::SPQR
matrixQ	Eigen/src/SparseQR/SparseQR.h	/^    SparseQRMatrixQReturnType<SparseQR> matrixQ() const $/;"	f	class:Eigen::SparseQR
matrixQR	Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixQR	Eigen/src/QR/FullPivHouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::FullPivHouseholderQR
matrixQR	Eigen/src/QR/HouseholderQR.h	/^    const MatrixType& matrixQR() const$/;"	f	class:Eigen::HouseholderQR
matrixR	Eigen/src/Eigen2Support/QR.h	/^    matrixR(void) const$/;"	f	class:Eigen::QR
matrixR	Eigen/src/QR/ColPivHouseholderQR.h	/^    const MatrixType& matrixR() const$/;"	f	class:Eigen::ColPivHouseholderQR
matrixR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    const MatrixType matrixR() const$/;"	f	class:Eigen::SPQR
matrixR	Eigen/src/SparseQR/SparseQR.h	/^    const QRMatrixType& matrixR() const { return m_R; }$/;"	f	class:Eigen::SparseQR
matrixS	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixS() const {$/;"	f	class:Eigen::RealQZ
matrixT	Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixT() const$/;"	f	class:Eigen::ComplexSchur
matrixT	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixT() const {$/;"	f	class:Eigen::RealQZ
matrixT	Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixT() const$/;"	f	class:Eigen::RealSchur
matrixT	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    MatrixTReturnType matrixT() const$/;"	f	class:Eigen::Tridiagonalization
matrixU	Eigen/src/Cholesky/LDLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LDLT
matrixU	Eigen/src/Cholesky/LLT.h	/^    inline typename Traits::MatrixU matrixU() const$/;"	f	class:Eigen::LLT
matrixU	Eigen/src/Eigen2Support/SVD.h	/^    const MatrixUType& matrixU() const { return m_matU; }$/;"	f	class:Eigen::SVD
matrixU	Eigen/src/Eigenvalues/ComplexSchur.h	/^    const ComplexMatrixType& matrixU() const$/;"	f	class:Eigen::ComplexSchur
matrixU	Eigen/src/Eigenvalues/RealSchur.h	/^    const MatrixType& matrixU() const$/;"	f	class:Eigen::RealSchur
matrixU	Eigen/src/SVD/JacobiSVD.h	/^    const MatrixUType& matrixU() const$/;"	f	class:Eigen::JacobiSVD
matrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLDLT
matrixU	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const MatrixU matrixU() const {$/;"	f	class:Eigen::SimplicialLLT
matrixU	Eigen/src/SparseLU/SparseLU.h	/^    SparseLUMatrixUReturnType<SCMatrix,MappedSparseMatrix<Scalar,ColMajor,Index> > matrixU() const$/;"	f	class:Eigen::SparseLU
matrixU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const UMatrixType& matrixU() const$/;"	f	class:Eigen::SuperLU
matrixU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const LUMatrixType& matrixU() const$/;"	f	class:Eigen::UmfPackLU
matrixV	Eigen/src/Eigen2Support/SVD.h	/^    const MatrixVType& matrixV() const { return m_matV; }$/;"	f	class:Eigen::SVD
matrixV	Eigen/src/SVD/JacobiSVD.h	/^    const MatrixVType& matrixV() const$/;"	f	class:Eigen::JacobiSVD
matrixZ	Eigen/src/Eigenvalues/RealQZ.h	/^      const MatrixType& matrixZ() const {$/;"	f	class:Eigen::RealQZ
matrix_swap_impl	Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl$/;"	s	namespace:Eigen::internal
matrix_swap_impl	Eigen/src/Core/PlainObjectBase.h	/^struct matrix_swap_impl<MatrixTypeA, MatrixTypeB, true>$/;"	s	namespace:Eigen::internal
matrix_type_times_scalar_type	Eigen/src/Householder/HouseholderSequence.h	/^template<typename OtherScalarType, typename MatrixType> struct matrix_type_times_scalar_type$/;"	s	namespace:Eigen::internal
max	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (max)() { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (max)() const { return m_max; }$/;"	f	class:Eigen::AlignedBox
max	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^max$/;"	f
max	srLib/SceneGraph/Model3DS.h	/^	Vector	max, min;			\/\/ max\/min vertex.$/;"	m	class:Model3DS
maxCoeff	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::maxCoeff() const$/;"	f	class:Eigen::DenseBase
maxCoeff	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_maxCoeff>::Type maxCoeff() const$/;"	f	class:Eigen::VectorwiseOp
maxCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
maxCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::maxCoeff(IndexType* rowPtr, IndexType* colPtr) const$/;"	f	class:Eigen::DenseBase
maxIterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  int maxIterations() const$/;"	f	class:Eigen::IterativeSolverBase
maxPivot	Eigen/src/LU/FullPivLU.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivLU
maxPivot	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::ColPivHouseholderQR
maxPivot	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar maxPivot() const { return m_maxpivot; }$/;"	f	class:Eigen::FullPivHouseholderQR
max_coeff_visitor	Eigen/src/Core/Visitor.h	/^struct max_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
maxbestroot	srLib/SceneGraph/gl2ps.c	/^  GLint maxbestroot;$/;"	m	struct:__anon15	file:
maximum_bouncing_velocity	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL ContactConstraint::maximum_bouncing_velocity = 30;$/;"	m	class:ContactConstraint	file:
maximum_bouncing_velocity	srLib/srDyn/srContactConstraint.h	/^	static SR_REAL maximum_bouncing_velocity;$/;"	m	class:ContactConstraint
maximum_bouncing_velocity	srLib/srDyn/srJointConstraint.cpp	/^SR_REAL JointConstraint::maximum_bouncing_velocity = 20;$/;"	m	class:JointConstraint	file:
maximum_bouncing_velocity	srLib/srDyn/srJointConstraint.h	/^	static SR_REAL maximum_bouncing_velocity;$/;"	m	class:JointConstraint
maximum_erp_velocity	srLib/srDyn/srClosedLoopConstraint.cpp	/^SR_REAL ClosedLoop::maximum_erp_velocity = 10;$/;"	m	class:ClosedLoop	file:
maximum_erp_velocity	srLib/srDyn/srClosedLoopConstraint.h	/^	static SR_REAL maximum_erp_velocity;$/;"	m	class:ClosedLoop
maximum_erp_velocity	srLib/srDyn/srContactConstraint.cpp	/^SR_REAL ContactConstraint::maximum_erp_velocity = 10;$/;"	m	class:ContactConstraint	file:
maximum_erp_velocity	srLib/srDyn/srContactConstraint.h	/^	static SR_REAL maximum_erp_velocity;$/;"	m	class:ContactConstraint
maximum_erp_velocity	srLib/srDyn/srJointConstraint.cpp	/^SR_REAL JointConstraint::maximum_erp_velocity = 10;$/;"	m	class:JointConstraint	file:
maximum_erp_velocity	srLib/srDyn/srJointConstraint.h	/^	static SR_REAL maximum_erp_velocity;$/;"	m	class:JointConstraint
maxsuper	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index maxsuper; \/\/ The maximum size for a supernode in complete LU$/;"	m	struct:Eigen::internal::perfvalues
mc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex mc() const { return m_mc; }$/;"	f	class:Eigen::internal::level3_blocking
mean	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::mean() const$/;"	f	class:Eigen::DenseBase
mean	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_mean>::Type mean() const$/;"	f	class:Eigen::VectorwiseOp
memInit	Eigen/src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,Index>::memInit(Index m, Index n, Index annz, Index lwork, Index fillratio, Index panel_size,  GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
memXpand	Eigen/src/SparseLU/SparseLU_Memory.h	/^Index SparseLUImpl<Scalar,Index>::memXpand(VectorType& vec, Index& maxlen, Index nbElts, MemType memtype, Index& num_expansions)$/;"	f	class:Eigen::internal::SparseLUImpl
mem_expand	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  void mem_expand(IndexVector& lsub, Index& nextl, Index chmark)$/;"	f	struct:Eigen::internal::column_dfs_traits
mem_expand	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  void mem_expand(IndexVector& \/*glu.lsub*\/, Index \/*nextl*\/, Index \/*chmark*\/) {}$/;"	f	struct:Eigen::internal::panel_dfs_traits
mem_size	srLib/LieGroup/_array.h	/^	int		 mem_size;$/;"	m	class:_array
member_redux	Eigen/src/Core/VectorwiseOp.h	/^  member_redux(const BinaryOp func) : m_functor(func) {}$/;"	f	struct:Eigen::internal::member_redux
member_redux	Eigen/src/Core/VectorwiseOp.h	/^struct member_redux {$/;"	s	namespace:Eigen::internal
merged	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox merged(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
meta_sqrt	Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	c	namespace:Eigen
middle	Eigen/src/Core/MathFunctions.h	/^  enum { middle = (lower + upper) \/ 2,$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon207
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr middleCols(Index startCol, Index numCols)$/;"	f
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr middleCols(Index startCol, Index numCols) const$/;"	f
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N) const$/;"	f
middleCols	Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type middleCols(Index startCol, Index n = N)$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr middleRows(Index startRow, Index n) const$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr middleRows(Index startRow, Index n)$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N) const$/;"	f
middleRows	Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type middleRows(Index startRow, Index n = N)$/;"	f
min	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType& (min)() { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	Eigen/src/Geometry/AlignedBox.h	/^  inline const VectorType& (min)() const { return m_min; }$/;"	f	class:Eigen::AlignedBox
min	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^min$/;"	f
min	srLib/SceneGraph/Model3DS.h	/^	Vector	max, min;			\/\/ max\/min vertex.$/;"	m	class:Model3DS
minCoeff	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::minCoeff() const$/;"	f	class:Eigen::DenseBase
minCoeff	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_minCoeff>::Type minCoeff() const$/;"	f	class:Eigen::VectorwiseOp
minCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* index) const$/;"	f	class:Eigen::DenseBase
minCoeff	Eigen/src/Core/Visitor.h	/^DenseBase<Derived>::minCoeff(IndexType* rowId, IndexType* colId) const$/;"	f	class:Eigen::DenseBase
min_coeff_visitor	Eigen/src/Core/Visitor.h	/^struct min_coeff_visitor : coeff_visitor<Derived>$/;"	s	namespace:Eigen::internal
minimum_degree_ordering	Eigen/src/OrderingMethods/Amd.h	/^void minimum_degree_ordering(SparseMatrix<Scalar,ColMajor,Index>& C, PermutationMatrix<Dynamic,Dynamic,Index>& perm)$/;"	f	namespace:Eigen::internal
minor	Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col) const$/;"	f	class:Eigen::MatrixBase
minor	Eigen/src/Eigen2Support/Minor.h	/^MatrixBase<Derived>::minor(Index row, Index col)$/;"	f	class:Eigen::MatrixBase
mode	srLib/SceneGraph/Camera.h	/^	CAMERAMODE		mode;$/;"	m	class:Camera
mode_type	srLib/SceneGraph/Font.h	/^	} mode_type;$/;"	t	class:srgString	typeref:enum:srgString::__anon4
mode_type	srLib/srg/srgFont.h	/^	} mode_type;$/;"	t	class:srgString	typeref:enum:srgString::__anon2
modelDL	srLib/SceneGraph/Model3DS.h	/^	GLuint	modelDL;$/;"	m	class:Model3DS
modelname	srLib/SceneGraph/Model3DS.h	/^	char	modelname[PATH_LENGTH];$/;"	m	class:Model3DS
motionFunc	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::motionFunc(GLint X, GLint Y)$/;"	f	class:SceneGraphRenderer
motionFunc2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::motionFunc2(GLint X, GLint Y)$/;"	f	class:SceneGraphRenderer
mouse2Camera	srLib/SceneGraph/Camera.cpp	/^void Camera::mouse2Camera( GLint Button, GLint State, GLint X, GLint Y )$/;"	f	class:Camera
mouseFunc	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::mouseFunc( GLint Button, GLint State, GLint X, GLint Y )$/;"	f	class:SceneGraphRenderer
mouseFunc2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::mouseFunc2( GLint Button, GLint State, GLint X, GLint Y )$/;"	f	class:SceneGraphRenderer
mp_matrix	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const MatrixType* mp_matrix;$/;"	m	class:Eigen::IterativeSolverBase
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * LhsPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2 * ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
mr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    mr = 2*ResPacketSize,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
mshader_stack	srLib/SceneGraph/gl2ps.c	/^  int mshader_stack; \/* mask shader object numbers *\/$/;"	m	struct:__anon15	file:
multTransformation	srLib/SceneGraph/Transformation.cpp	/^void Transformation::multTransformation( SE3 trans )$/;"	f	class:Transformation
n	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   n; \/\/ Number of columns in the matrix  $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
n	srLib/SceneGraph/gl2ps.c	/^  GLint nmax, size, incr, n;$/;"	m	struct:__anon6	file:
nBlink_Constraints	srLib/srDyn/srDYN.h	/^	int									nBlink_Constraints;$/;"	m	class:srDYN
nContactPts	srLib/srDyn/srContactConstraint.h	/^	int				nContactPts;$/;"	m	class:ContactConstraint
nPossible_All_Constraints	srLib/srDyn/srDYN.h	/^	int									nPossible_All_Constraints;$/;"	m	class:srDYN
nPossible_Blink_Constraints	srLib/srDyn/srDYN.h	/^	int									nPossible_Blink_Constraints;$/;"	m	class:srDYN
nSolid_Constraints	srLib/srDyn/srDYN.h	/^	int									nSolid_Constraints;$/;"	m	class:srDYN
name	srLib/SceneGraph/Model3DS.h	/^		char	name[PATH_LENGTH];	\/\/ The material's name$/;"	m	struct:Model3DS::Material
name	srLib/SceneGraph/Model3DS.h	/^		char	name[PATH_LENGTH];	\/\/ The object name$/;"	m	struct:Model3DS::Object
nbThreads	Eigen/src/Core/products/Parallelizer.h	/^inline int nbThreads()$/;"	f	namespace:Eigen
nc	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    inline DenseIndex nc() const { return m_nc; }$/;"	f	class:Eigen::internal::level3_blocking
nd	srLib/srDyn/srConstraint.h	/^	int		nd;		\/\/ number of constraint dimension$/;"	m	class:Constraint
neighborSE3	srLib/SceneGraph/Leaf.h	/^	SE3			neighborSE3;$/;"	m	class:Line
nestByValue	Eigen/src/Core/NestByValue.h	/^DenseBase<Derived>::nestByValue() const$/;"	f	class:Eigen::DenseBase
nested	Eigen/src/Core/ProductBase.h	/^struct nested<GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:internal
nested	Eigen/src/Core/ProductBase.h	/^struct nested<const GeneralProduct<Lhs,Rhs,Mode>, N, PlainObject>$/;"	s	namespace:internal
nested	Eigen/src/Core/ReturnByValue.h	/^struct nested<ReturnByValue<Derived>, n, PlainObject>$/;"	s	namespace:Eigen::internal
nested	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct nested<CoeffBasedProduct<Lhs,Rhs,EvalBeforeNestingBit|EvalBeforeAssigningBit>, N, PlainObject>$/;"	s	namespace:Eigen::internal
nestedExpression	Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::ArrayWrapper
nestedExpression	Eigen/src/Core/ArrayWrapper.h	/^    nestedExpression() const $/;"	f	class:Eigen::MatrixWrapper
nestedExpression	Eigen/src/Core/Block.h	/^    const typename internal::remove_all<typename XprType::Nested>::type& nestedExpression() const $/;"	f	class:Eigen::internal::BlockImpl_dense
nestedExpression	Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() const { return m_xpr; }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	Eigen/src/Core/CwiseUnaryOp.h	/^    nestedExpression() { return m_xpr.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryOp
nestedExpression	Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	Eigen/src/Core/CwiseUnaryView.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::CwiseUnaryView
nestedExpression	Eigen/src/Core/Diagonal.h	/^    nestedExpression() const $/;"	f	class:Eigen::Diagonal
nestedExpression	Eigen/src/Core/Replicate.h	/^    const _MatrixTypeNested& nestedExpression() const$/;"	f	class:Eigen::Replicate
nestedExpression	Eigen/src/Core/Reverse.h	/^    nestedExpression() const $/;"	f	class:Eigen::Reverse
nestedExpression	Eigen/src/Core/SelfAdjointView.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	Eigen/src/Core/SelfAdjointView.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SelfAdjointView
nestedExpression	Eigen/src/Core/Transpose.h	/^    nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::Transpose
nestedExpression	Eigen/src/Core/Transpose.h	/^    nestedExpression() { return m_matrix.const_cast_derived(); }$/;"	f	class:Eigen::Transpose
nestedExpression	Eigen/src/Core/TriangularMatrix.h	/^    MatrixTypeNestedCleaned& nestedExpression() { return *const_cast<MatrixTypeNestedCleaned*>(&m_matrix); }$/;"	f	class:Eigen::TriangularView
nestedExpression	Eigen/src/Core/TriangularMatrix.h	/^    const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::TriangularView
nestedExpression	Eigen/src/SparseCore/SparseBlock.h	/^    inline const _MatrixTypeNested& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::BlockImpl
nestedExpression	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline const MatrixTypeNestedCleaned& nestedExpression() const { return m_matrix; }$/;"	f	class:Eigen::SparseTriangularView
nestedPermutation	Eigen/src/Core/PermutationMatrix.h	/^    const PermutationType& nestedPermutation() const { return m_permutation; }$/;"	f	class:Eigen::Transpose
next	Eigen/src/SparseCore/AmbiVector.h	/^      Index next;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
next	srLib/SceneGraph/gl2ps.c	/^  GL2PSimagemap *next;$/;"	m	struct:_GL2PSimagemap	file:
next	tinyxml2/tinyxml2.h	/^        Item*   next;$/;"	m	union:tinyxml2::MemPoolT::Item
nmax	srLib/SceneGraph/gl2ps.c	/^  GLint nmax, size, incr, n;$/;"	m	struct:__anon6	file:
nnz	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    union {int nnz;int lda;};$/;"	m	union:Eigen::SluMatrix::__anon458::__anon459
no_assignment_operator	Eigen/src/Core/util/XprHelper.h	/^class no_assignment_operator$/;"	c	namespace:Eigen::internal
noalias	Eigen/src/Core/NoAlias.h	/^NoAlias<Derived,MatrixBase> MatrixBase<Derived>::noalias()$/;"	f	class:Eigen::MatrixBase
nonZeros	Eigen/src/Core/DenseBase.h	/^    inline Index nonZeros() const { return size(); }$/;"	f	class:Eigen::DenseBase
nonZeros	Eigen/src/SparseCore/AmbiVector.h	/^_Index AmbiVector<_Scalar,_Index>::nonZeros() const$/;"	f	class:Eigen::internal::AmbiVector
nonZeros	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index nonZeros() const  { return m_nnz; }$/;"	f	class:Eigen::MappedSparseMatrix
nonZeros	Eigen/src/SparseCore/SparseBlock.h	/^    Index nonZeros() const$/;"	f	class:Eigen::BlockImpl
nonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index nonZeros() const$/;"	f	class:Eigen::SparseMatrix
nonZeros	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index nonZeros() const { return derived().nonZeros(); }$/;"	f	class:Eigen::SparseMatrixBase
nonZeros	Eigen/src/SparseCore/SparseTranspose.h	/^    inline Index nonZeros() const { return derived().nestedExpression().nonZeros(); }$/;"	f	class:Eigen::TransposeImpl
nonZeros	Eigen/src/SparseCore/SparseVector.h	/^    inline Index nonZeros() const  { return static_cast<Index>(m_data.size()); }$/;"	f	class:Eigen::SparseVector
noncopyable	Eigen/src/Core/util/Meta.h	/^  noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
noncopyable	Eigen/src/Core/util/Meta.h	/^class noncopyable$/;"	c	namespace:Eigen::internal
nonzeroPivots	Eigen/src/LU/FullPivLU.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivLU
nonzeroPivots	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::ColPivHouseholderQR
nonzeroPivots	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index nonzeroPivots() const$/;"	f	class:Eigen::FullPivHouseholderQR
nonzeroSingularValues	Eigen/src/SVD/JacobiSVD.h	/^    Index nonzeroSingularValues() const$/;"	f	class:Eigen::JacobiSVD
norm	Eigen/src/Core/Dot.h	/^inline typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::norm() const$/;"	f	class:Eigen::MatrixBase
norm	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_norm,RealScalar>::Type norm() const$/;"	f	class:Eigen::VectorwiseOp
norm	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar norm() const { return m_coeffs.norm(); }$/;"	f	class:Eigen::Quaternion
norm	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar norm() const { return coeffs().norm(); }$/;"	f	class:Eigen::QuaternionBase
norm	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::norm() const$/;"	f	class:Eigen::SparseMatrixBase
norm1	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(norm1, Scalar) norm1(const Scalar& x)$/;"	f	namespace:Eigen::numext
norm1_default_impl	Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl$/;"	s	namespace:Eigen::internal
norm1_default_impl	Eigen/src/Core/MathFunctions.h	/^struct norm1_default_impl<Scalar, false>$/;"	s	namespace:Eigen::internal
norm1_impl	Eigen/src/Core/MathFunctions.h	/^struct norm1_impl : norm1_default_impl<Scalar, NumTraits<Scalar>::IsComplex> {};$/;"	s	namespace:Eigen::internal
norm1_retval	Eigen/src/Core/MathFunctions.h	/^struct norm1_retval$/;"	s	namespace:Eigen::internal
normal	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const NormalReturnType normal() const { return NormalReturnType(*const_cast<Coefficients*>(&m_coeffs),0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	Eigen/src/Geometry/Hyperplane.h	/^  inline ConstNormalReturnType normal() const { return ConstNormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	Eigen/src/Geometry/Hyperplane.h	/^  inline NormalReturnType normal() { return NormalReturnType(m_coeffs,0,0,dim(),1); }$/;"	f	class:Eigen::Hyperplane
normal	srLib/common/srSTL.h	/^		Eigen::Vector3d normal;$/;"	m	class:srSTL::facet
normalize	Eigen/src/Core/Dot.h	/^inline void MatrixBase<Derived>::normalize()$/;"	f	class:Eigen::MatrixBase
normalize	Eigen/src/Core/VectorwiseOp.h	/^    void normalize() {$/;"	f	class:Eigen::VectorwiseOp
normalize	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane
normalize	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline void normalize() { m_coeffs.normalize(); }$/;"	f	class:Eigen::Quaternion
normalize	Eigen/src/Geometry/Hyperplane.h	/^  void normalize(void)$/;"	f	class:Eigen::Hyperplane
normalize	Eigen/src/Geometry/Quaternion.h	/^  inline void normalize() { coeffs().normalize(); }$/;"	f	class:Eigen::QuaternionBase
normalize	srLib/LieGroup/LieGroup.cpp	/^Quaternion& Quaternion::normalize()$/;"	f	class:Quaternion
normalized	Eigen/src/Core/Dot.h	/^MatrixBase<Derived>::normalized() const$/;"	f	class:Eigen::MatrixBase
normalized	Eigen/src/Core/VectorwiseOp.h	/^    normalized() const { return m_matrix.cwiseQuotient(extendedToOpposite(this->norm())); }$/;"	f	class:Eigen::VectorwiseOp
normalized	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion normalized() const { return Quaternion(m_coeffs.normalized()); }$/;"	f	class:Eigen::Quaternion
normalized	Eigen/src/Geometry/Quaternion.h	/^  inline Quaternion<Scalar> normalized() const { return Quaternion<Scalar>(coeffs().normalized()); }$/;"	f	class:Eigen::QuaternionBase
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 2,$/;"	e	enum:Eigen::internal::gebp_traits::__anon112
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = 4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon113
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon110
nr	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    nr = NumberOfRegisters\/4,$/;"	e	enum:Eigen::internal::gebp_traits::__anon111
nr_etdfs	Eigen/src/SparseCore/SparseColEtree.h	/^void nr_etdfs (Index n, IndexVector& parent, IndexVector& first_kid, IndexVector& next_kid, IndexVector& post, Index postnum)$/;"	f	namespace:Eigen::internal
nsuper	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index nsuper() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
numFaces	srLib/SceneGraph/Model3DS.h	/^		int		numFaces;			\/\/ The number of faces$/;"	m	struct:Model3DS::Object
numMatFaces	srLib/SceneGraph/Model3DS.h	/^		int		numMatFaces;		\/\/ The number of differnet material faces$/;"	m	struct:Model3DS::Object
numMaterials	srLib/SceneGraph/Model3DS.h	/^	int		numMaterials;		\/\/ Total number of materials in the model$/;"	m	class:Model3DS
numObjects	srLib/SceneGraph/Model3DS.h	/^	int		numObjects;			\/\/ Total number of objects in the model$/;"	m	class:Model3DS
numOfLight	srLib/SceneGraph/Light.cpp	/^unsigned int Light::numOfLight = 0;$/;"	m	class:Light	file:
numOfLight	srLib/SceneGraph/Light.h	/^	static unsigned int		numOfLight;$/;"	m	class:Light
numSubFaces	srLib/SceneGraph/Model3DS.h	/^		int numSubFaces;			\/\/ The number of faces$/;"	m	struct:Model3DS::MaterialFaces
numTexCoords	srLib/SceneGraph/Model3DS.h	/^		int		numTexCoords;		\/\/ The number of vertexes$/;"	m	struct:Model3DS::Object
numVerts	srLib/SceneGraph/Model3DS.h	/^		int		numVerts;			\/\/ The number of vertexes$/;"	m	struct:Model3DS::Object
num_act_joint_	Example/DracoP1/draco.h	/^	int num_act_joint_;$/;"	m	class:srDraco
num_expansions	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   num_expansions; $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
num_fixed_joint_	Example/DracoP1/draco.h	/^  int num_fixed_joint_;$/;"	m	class:srDraco
num_p_joint_	Example/DracoP1/draco.h	/^  int num_p_joint_;$/;"	m	class:srDraco
num_r_joint_	Example/DracoP1/draco.h	/^  int num_r_joint_;$/;"	m	class:srDraco
numext	Eigen/src/Core/MathFunctions.h	/^namespace numext {$/;"	n	namespace:Eigen
numverts	srLib/SceneGraph/gl2ps.c	/^  GLshort type, numverts;$/;"	m	struct:__anon11	file:
nzlmax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzlmax; \/\/ Current max size of lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
nzlumax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzlumax; \/\/ Current max size of lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
nzumax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index   nzumax; \/\/ Current max size of ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
objects_stack	srLib/SceneGraph/gl2ps.c	/^  int objects_stack; \/* available objects *\/$/;"	m	struct:__anon15	file:
offset	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar& offset() { return m_coeffs(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	Eigen/src/Geometry/Hyperplane.h	/^  inline const Scalar& offset() const { return m_coeffs.coeff(dim()); }$/;"	f	class:Eigen::Hyperplane
offset	srLib/SceneGraph/gl2ps.c	/^  GLfloat *feedback, offset[2], lastlinewidth;$/;"	m	struct:__anon15	file:
offset	srLib/SceneGraph/gl2ps.c	/^  char boundary, offset, culled;$/;"	m	struct:__anon11	file:
operator !=	Eigen/src/Core/MatrixBase.h	/^    inline bool operator!=(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator !=	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(Scalar s) const$/;"	f	class:Eigen::Cwise
operator !=	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator!=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator !=	srLib/LieGroup/LieGroup.cpp	/^bool operator != (const Quaternion& p, const Quaternion& q)$/;"	f
operator &&	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator&&(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/DenseCoeffsBase.h	/^    operator()(Index row, Index col)$/;"	f	class:Eigen::DenseCoeffsBase
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE Scalar operator() (const Scalar& a) const { return a \/ m_other; }$/;"	f	struct:Eigen::internal::scalar_quotient1_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a && b; }$/;"	f	struct:Eigen::internal::scalar_boolean_and_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator() (const bool& a, const bool& b) const { return a || b; }$/;"	f	struct:Eigen::internal::scalar_boolean_or_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return !(a<=b || b<=a);}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a!=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a<=b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a<b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE bool operator()(const Scalar& a, const Scalar& b) const {return a==b;}$/;"	f	struct:Eigen::internal::scalar_cmp_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const NewType operator() (const Scalar& a) const { return cast<Scalar, NewType>(a); }$/;"	f	struct:Eigen::internal::scalar_cast_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const $/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return impl(i); }$/;"	f	struct:Eigen::internal::linspaced_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index i) const { return m_low+i*m_step; }$/;"	f	struct:Eigen::internal::linspaced_op_impl
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const $/;"	f	struct:Eigen::internal::linspaced_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index row, Index col) const { return row==col ? Scalar(1) : Scalar(0); }$/;"	f	struct:Eigen::internal::scalar_identity_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (Index, Index = 0) const { return m_other; }$/;"	f	struct:Eigen::internal::scalar_constant_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& _x, const Scalar& _y) const$/;"	f	struct:Eigen::internal::scalar_hypot_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { return -a; }$/;"	f	struct:Eigen::internal::scalar_opposite_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a) const { using numext::conj; return conj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a + b; }$/;"	f	struct:Eigen::internal::scalar_sum_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { return a - b; }$/;"	f	struct:Eigen::internal::scalar_difference_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::max; return (max)(a, b); }$/;"	f	struct:Eigen::internal::scalar_max_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar operator() (const Scalar& a, const Scalar& b) const { using std::min; return (min)(a, b); }$/;"	f	struct:Eigen::internal::scalar_min_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a * b; }$/;"	f	struct:Eigen::internal::scalar_product_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const { return a \/ b; }$/;"	f	struct:Eigen::internal::scalar_quotient_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const LhsScalar& a, const RhsScalar& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { return numext::abs2(a); }$/;"	f	struct:Eigen::internal::scalar_abs2_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type operator() (const Scalar& a) const { using std::abs; return abs(a); }$/;"	f	struct:Eigen::internal::scalar_abs_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::imag(a); }$/;"	f	struct:Eigen::internal::scalar_imag_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar& a) const { return numext::real(a); }$/;"	f	struct:Eigen::internal::scalar_real_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type operator() (const Scalar1& a) const { return a * m_other; }$/;"	f	struct:Eigen::internal::scalar_multiple2_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::imag_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_imag_ref_op
operator ()	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE result_type& operator() (const Scalar& a) const { return numext::real_ref(*const_cast<Scalar*>(&a)); }$/;"	f	struct:Eigen::internal::scalar_real_ref_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return Scalar(1)\/a; }$/;"	f	struct:Eigen::internal::scalar_inverse_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a + m_other; }$/;"	f	struct:Eigen::internal::scalar_add_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a*a; }$/;"	f	struct:Eigen::internal::scalar_cube_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return a*a; }$/;"	f	struct:Eigen::internal::scalar_square_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return m_other \/ a; }$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { return numext::pow(a, m_exponent); }$/;"	f	struct:Eigen::internal::scalar_pow_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a) const { using std::cos; return cos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
operator ()	Eigen/src/Core/Functors.h	/^  inline Scalar operator() (const Scalar& a, const OtherScalar& b) const { return numext::pow(a, b); }$/;"	f	struct:Eigen::internal::scalar_binary_pow_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::acos; return acos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::asin; return asin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::exp; return exp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::log; return log(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::sin; return sin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::sqrt; return sqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
operator ()	Eigen/src/Core/Functors.h	/^  inline const Scalar operator() (const Scalar& a) const { using std::tan; return tan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
operator ()	Eigen/src/Core/GeneralProduct.h	/^      template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const {$/;"	f	struct:Eigen::GeneralProduct::adds
operator ()	Eigen/src/Core/GeneralProduct.h	/^    struct add  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() += src; } };$/;"	f	struct:Eigen::GeneralProduct::add
operator ()	Eigen/src/Core/GeneralProduct.h	/^    struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	f	struct:Eigen::GeneralProduct::set
operator ()	Eigen/src/Core/GeneralProduct.h	/^    struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	f	struct:Eigen::GeneralProduct::sub
operator ()	Eigen/src/Core/Random.h	/^  inline const Scalar operator() (Index, Index = 0) const { return random<Scalar>(); }$/;"	f	struct:Eigen::internal::scalar_random_op
operator ()	Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType operator()(Index index) const$/;"	f	class:Eigen::Reverse
operator ()	Eigen/src/Core/Reverse.h	/^    inline CoeffReturnType operator()(Index row, Index col) const$/;"	f	class:Eigen::Reverse
operator ()	Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index index)$/;"	f	class:Eigen::Reverse
operator ()	Eigen/src/Core/Reverse.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::Reverse
operator ()	Eigen/src/Core/Transpositions.h	/^    inline Index& operator()(Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	Eigen/src/Core/Transpositions.h	/^    inline const Index& operator()(Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator ()	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar operator()(Index row, Index col) const$/;"	f	class:Eigen::TriangularBase
operator ()	Eigen/src/Core/TriangularMatrix.h	/^    inline Scalar& operator()(Index row, Index col)$/;"	f	class:Eigen::TriangularBase
operator ()	Eigen/src/Core/VectorwiseOp.h	/^  inline result_type operator()(const DenseBase<Derived>& mat) const$/;"	f	struct:Eigen::internal::member_redux
operator ()	Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::max_coeff_visitor
operator ()	Eigen/src/Core/Visitor.h	/^  void operator() (const Scalar& value, Index i, Index j)$/;"	f	struct:Eigen::internal::min_coeff_visitor
operator ()	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index rows, Index depth, Index cols, ResScalar alpha,$/;"	f	class:Eigen::internal::gebp_kernel
operator ()	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockA, const Scalar* EIGEN_RESTRICT _lhs, Index lhsStride, Index depth, Index rows, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_lhs
operator ()	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  ::operator()(Scalar* blockB, const Scalar* rhs, Index rhsStride, Index depth, Index cols, Index stride, Index offset)$/;"	f	class:Eigen::internal::gemm_pack_rhs
operator ()	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  void operator() (Index row, Index rows, Index col=0, Index cols=-1, GemmParallelInfo<Index>* info=0) const$/;"	f	struct:Eigen::internal::gemm_functor
operator ()	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  void operator()(ResScalar* res, Index resStride, const LhsScalar* blockA, const RhsScalar* blockB, Index size, Index depth, const ResScalar& alpha, RhsScalar* workspace)$/;"	f	struct:Eigen::internal::tribb_kernel
operator ()	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockA, const Scalar* _lhs, Index lhsStride, Index cols, Index rows)$/;"	f	struct:Eigen::internal::symm_pack_lhs
operator ()	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void operator()(Scalar* blockB, const Scalar* _rhs, Index rhsStride, Index rows, Index cols, Index k2)$/;"	f	struct:Eigen::internal::symm_pack_rhs
operator ()	Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE Scalar& operator()(Index i, Index j)$/;"	f	class:Eigen::internal::blas_data_mapper
operator ()	Eigen/src/Core/util/BlasUtil.h	/^    EIGEN_STRONG_INLINE const Scalar& operator()(Index i, Index j) const$/;"	f	class:Eigen::internal::const_blas_data_mapper
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  inline T operator()(const T& x) const { return numext::conj(x); }$/;"	f	struct:Eigen::internal::conj_if
operator ()	Eigen/src/Core/util/BlasUtil.h	/^  inline const T& operator()(const T& x) const { return x; }$/;"	f	struct:Eigen::internal::conj_if
operator ()	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar operator() (int row, int col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Scalar& operator() (int row, int col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	Eigen/src/Geometry/Transform.h	/^  inline Scalar operator() (Index row, Index col) const { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	Eigen/src/Geometry/Transform.h	/^  inline Scalar& operator() (Index row, Index col) { return m_matrix(row,col); }$/;"	f	class:Eigen::Transform
operator ()	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::IncompleteLUT::keep_diag
operator ()	Eigen/src/MetisSupport/MetisSupport.h	/^  void operator() (const MatrixType& A, PermutationType& matperm)$/;"	f	class:Eigen::MetisOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator() (const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::COLAMDOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& \/*mat*\/, PermutationType& perm)$/;"	f	class:Eigen::NaturalOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const MatrixType& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering
operator ()	Eigen/src/OrderingMethods/Ordering.h	/^    void operator()(const SparseSelfAdjointView<SrcType, SrcUpLo>& mat, PermutationType& perm)$/;"	f	class:Eigen::AMDOrdering
operator ()	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^      inline bool operator() (const Index& row, const Index& col, const Scalar&) const$/;"	f	struct:Eigen::SimplicialCholeskyBase::keep_diag
operator ()	Eigen/src/SparseCore/SparseMatrix.h	/^    inline bool operator() (const Index&, const Index&, const Scalar& value) const$/;"	f	struct:Eigen::SparseMatrix::default_prunning_func
operator ()	srMath/Function.h	/^		VectorX operator()(const VectorX& x) const$/;"	f	class:srMath::EmptyFunction
operator ()	srMath/Function.h	/^		VectorX operator()(const VectorX& x) const$/;"	f	class:srMath::Function
operator ()	srMath/Function.h	/^		VectorX operator()(const VectorX& x) const$/;"	f	class:srMath::MultiplyConstFunction
operator ()	srMath/Interpolation.h	/^	Eigen::Matrix<Real, Dimension, -1> BSpline<CoefficientN, OrderK, Dimension>::operator()(const VectorX& x)$/;"	f	class:srMath::BSpline
operator ()	srMath/Interpolation.h	/^	Eigen::Matrix<Real, Dimension, 1> BSpline<CoefficientN, OrderK, Dimension>::operator()(const Real& x)$/;"	f	class:srMath::BSpline
operator *	Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const MatrixBase<MatrixDerived> &matrix) const$/;"	f	class:Eigen::DiagonalBase
operator *	Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar) const$/;"	f	class:Eigen::DiagonalBase
operator *	Eigen/src/Core/DiagonalMatrix.h	/^    operator*(const Scalar& scalar, const DiagonalBase& other)$/;"	f	class:Eigen::DiagonalBase
operator *	Eigen/src/Core/DiagonalProduct.h	/^MatrixBase<Derived>::operator*(const DiagonalBase<DiagonalDerived> &a_diagonal) const$/;"	f	class:Eigen::MatrixBase
operator *	Eigen/src/Core/GeneralProduct.h	/^MatrixBase<Derived>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::MatrixBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const PermutationBase<Other>& other) const$/;"	f	class:Eigen::PermutationBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other) const$/;"	f	class:Eigen::PermutationBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    inline PlainPermutationType operator*(const Transpose<PermutationBase<Other> >& other, const PermutationBase& perm)$/;"	f	class:Eigen::PermutationBase
operator *	Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix) const$/;"	f	class:Eigen::Transpose
operator *	Eigen/src/Core/PermutationMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& matrix, const Transpose& trPerm)$/;"	f	class:Eigen::Transpose
operator *	Eigen/src/Core/PermutationMatrix.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/PermutationMatrix.h	/^operator*(const PermutationBase<PermutationDerived> &permutation,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, const typename Derived::RealScalar& x)$/;"	f
operator *	Eigen/src/Core/ProductBase.h	/^operator*(const ProductBase<Derived,Lhs,Rhs>& prod, const typename Derived::Scalar& x)$/;"	f
operator *	Eigen/src/Core/ProductBase.h	/^operator*(const typename Derived::RealScalar& x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f
operator *	Eigen/src/Core/ProductBase.h	/^operator*(const typename Derived::Scalar& x,const ProductBase<Derived,Lhs,Rhs>& prod)$/;"	f
operator *	Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SelfAdjointView& rhs)$/;"	f	class:Eigen::SelfAdjointView
operator *	Eigen/src/Core/SelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SelfAdjointView
operator *	Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix) const$/;"	f	class:Eigen::Transpose
operator *	Eigen/src/Core/Transpositions.h	/^    operator*(const MatrixBase<Derived>& matrix, const Transpose& trt)$/;"	f	class:Eigen::Transpose
operator *	Eigen/src/Core/Transpositions.h	/^operator*(const MatrixBase<Derived>& matrix,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/Transpositions.h	/^operator*(const TranspositionsBase<TranspositionDerived> &transpositions,$/;"	f	namespace:Eigen
operator *	Eigen/src/Core/TriangularMatrix.h	/^    operator*(const EigenBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView
operator *	Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const TriangularView& rhs)$/;"	f	class:Eigen::TriangularView
operator *	Eigen/src/Core/TriangularMatrix.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::TriangularView
operator *	Eigen/src/Core/VectorwiseOp.h	/^    operator*(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator *	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator *	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Matrix3 operator* (const Matrix3& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline Vector3 operator* (const Vector3& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^  inline friend Matrix3 operator* (const Matrix3& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::operator* (const MatrixBase<Derived>& v) const$/;"	f	class:Eigen::Quaternion
operator *	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar> Quaternion<Scalar>::operator* (const Quaternion& other) const$/;"	f	class:Eigen::Quaternion
operator *	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D
operator *	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
operator *	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const Scaling<Scalar,Dim>& s) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Transform<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  friend inline LinearMatrixType operator* (const LinearMatrixType& other, const Scaling& s)$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator* (const LinearMatrixType& other) const$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline LinearMatrixType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling operator* (const Scaling& other) const$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^Scaling<Scalar,Dim>::operator* (const TranslationType& t) const$/;"	f	class:Eigen::Scaling
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  friend inline Transform operator*(const LinearMatrixType& mat, const Transform& t)$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  operator * (const Transform& other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const ScalingType& s) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim> Transform<Scalar,Dim>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  friend inline TransformType operator* (const LinearMatrixType& linear, const Translation& t)$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline TransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  inline VectorType operator* (const VectorType& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const LinearMatrixType& linear) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const ScalingType& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Eigen2Support/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const TransformType& t) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/AngleAxis.h	/^  friend inline QuaternionType operator* (const QuaternionType& a, const AngleAxis& b)$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const AngleAxis& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Geometry/AngleAxis.h	/^  inline QuaternionType operator* (const QuaternionType& other) const$/;"	f	class:Eigen::AngleAxis
operator *	Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Lhs>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	Eigen/src/Geometry/Homogeneous.h	/^    operator* (const MatrixBase<Rhs>& rhs) const$/;"	f	class:Eigen::Homogeneous
operator *	Eigen/src/Geometry/Homogeneous.h	/^    operator* (const Transform<Scalar,Dim,Mode,Options>& lhs, const Homogeneous& rhs)$/;"	f	class:Eigen::Homogeneous
operator *	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::operator* (const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
operator *	Eigen/src/Geometry/Rotation2D.h	/^  Vector2 operator* (const Vector2& vec) const$/;"	f	class:Eigen::Rotation2D
operator *	Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D operator*(const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
operator *	Eigen/src/Geometry/RotationBase.h	/^    friend inline Transform<Scalar,Dim,Affine> operator*(const DiagonalMatrix<Scalar,Dim>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const EigenBase<OtherDerived>& l, const Derived& r)$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Isometry> operator*(const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    inline Transform<Scalar,Dim,Mode> operator*(const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/RotationBase.h	/^    operator*(const EigenBase<OtherDerived>& e) const$/;"	f	class:Eigen::RotationBase
operator *	Eigen/src/Geometry/Scaling.h	/^  inline Matrix<Scalar,Dim,Dim> operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?Affine:Mode)> operator* (const Transform<Scalar,Dim, Mode, Options>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^  inline UniformScaling operator* (const UniformScaling& other) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^  inline typename internal::plain_matrix_type<Derived>::type operator* (const MatrixBase<Derived>& other) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Scaling.h	/^MatrixBase<Derived>::operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::MatrixBase
operator *	Eigen/src/Geometry/Scaling.h	/^UniformScaling<Scalar>::operator* (const Translation<Scalar,Dim>& t) const$/;"	f	class:Eigen::UniformScaling
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const DiagonalBase<DiagonalDerived> &b) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const EigenBase<OtherDerived> &a, const Transform &b)$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^    operator * (const Transform<Scalar,Dim,OtherMode,OtherOptions>& other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^  inline Transform<Scalar,Dim,(int(Mode)==int(Isometry)?int(Affine):int(Mode))> operator*(const UniformScaling<Scalar>& s) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^  inline const Transform operator * (const Transform& other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^  operator * (const EigenBase<OtherDerived> &other) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options> Transform<Scalar,Dim,Mode,Options>::operator*(const TranslationType& t) const$/;"	f	class:Eigen::Transform
operator *	Eigen/src/Geometry/Translation.h	/^  inline AffineTransformType operator*(const EigenBase<OtherDerived>& linear, const Translation& t)$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  inline IsometryTransformType operator*(const RotationBase<Derived,Dim>& r) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  inline Transform<Scalar,Dim,Mode> operator* (const Transform<Scalar,Dim,Mode,Options>& t) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  inline Translation operator* (const Translation& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^  operator* (const MatrixBase<Derived>& vec) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const EigenBase<OtherDerived>& linear) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Geometry/Translation.h	/^Translation<Scalar,Dim>::operator* (const UniformScaling<Scalar>& other) const$/;"	f	class:Eigen::Translation
operator *	Eigen/src/Householder/HouseholderSequence.h	/^    typename internal::matrix_type_times_scalar_type<Scalar, OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::HouseholderSequence
operator *	Eigen/src/Householder/HouseholderSequence.h	/^typename internal::matrix_type_times_scalar_type<typename VectorsType::Scalar,OtherDerived>::Type operator*(const MatrixBase<OtherDerived>& other, const HouseholderSequence<VectorsType,CoeffsType,Side>& h)$/;"	f	namespace:Eigen
operator *	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation operator*(const JacobiRotation& other)$/;"	f	class:Eigen::JacobiRotation
operator *	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQReturnType
operator *	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQR_QProduct<SPQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SPQRMatrixQTransposeReturnType
operator *	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^SparseMatrixBase<Derived>::operator*(const DiagonalBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const DiagonalBase<OtherDerived> &lhs, const SparseMatrixBase& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseMatrixBase.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const Derived& rhs)$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*( const PermutationBase<PermDerived>& perm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const PermutationBase<PermDerived>& perm)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const SparseMatrixBase<SparseDerived>& matrix, const Transpose<PermutationBase<PermDerived> >& tperm)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparsePermutation.h	/^operator*(const Transpose<PermutationBase<PermDerived> >& tperm, const SparseMatrixBase<SparseDerived>& matrix)$/;"	f	namespace:Eigen
operator *	Eigen/src/SparseCore/SparseProduct.h	/^SparseMatrixBase<Derived>::operator*(const SparseMatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::SparseMatrixBase
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const MatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& lhs, const SparseSelfAdjointView& rhs)$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    operator*(const SparseMatrixBase<OtherDerived>& rhs) const$/;"	f	class:Eigen::SparseSelfAdjointView
operator *	Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType, Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
operator *	Eigen/src/SparseQR/SparseQR.h	/^  SparseQR_QProduct<SparseQRType,Derived> operator*(const MatrixBase<Derived>& other)$/;"	f	struct:Eigen::SparseQRMatrixQTransposeReturnType
operator *	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator*(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator *	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar) const$/;"	f
operator *	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const Scalar& scalar, const StorageBaseType& matrix)$/;"	f
operator *	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar) const$/;"	f
operator *	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator*(const std::complex<Scalar>& scalar, const StorageBaseType& matrix)$/;"	f
operator *	srLib/LieGroup/LieGroup.cpp	/^Quaternion operator * (SR_REAL k, const Quaternion& q)$/;"	f
operator *	srLib/LieGroup/LieGroup.cpp	/^Quaternion operator * (const Quaternion& p, const Quaternion& q)$/;"	f
operator *	srLib/srExt/srExt_LieGroup.h	/^	Eigen::MatrixXd		operator * (const MatrixType& _M, const SE3& _T)$/;"	f	namespace:srExt
operator *	srLib/srExt/srExt_LieGroup.h	/^	Eigen::MatrixXd		operator * (const MatrixType& _M, const SO3& _R)$/;"	f	namespace:srExt
operator *	srLib/srExt/srExt_LieGroup.h	/^	Eigen::MatrixXd		operator * (const MatrixType& _M, const Vec3& _v)$/;"	f	namespace:srExt
operator *	srLib/srExt/srExt_LieGroup.h	/^	Eigen::MatrixXd		operator * (const SE3& _T, const MatrixType& _M)$/;"	f	namespace:srExt
operator *	srLib/srExt/srExt_LieGroup.h	/^	Eigen::MatrixXd		operator * (const SO3& _R, const MatrixType& _M)$/;"	f	namespace:srExt
operator *	srLib/srg/srgColor.cpp	/^srgColor srgColor::operator * (const float f)$/;"	f	class:srgColor
operator *	srMath/Inertia.cpp	/^	Inertia Inertia::operator * (const Real& constant) const$/;"	f	class:srMath::Inertia
operator *	srMath/SE3.cpp	/^	SE3 SE3::operator * (const SE3& operand) const$/;"	f	class:srMath::SE3
operator *	srMath/SO3.cpp	/^	SO3 SO3::operator * (const SO3& operand) const$/;"	f	class:srMath::SO3
operator *=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator*=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator *=	Eigen/src/Core/MatrixBase.h	/^MatrixBase<Derived>::operator*=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator *=	Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator *=	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator*=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix * other; }$/;"	f	class:Eigen::TriangularView
operator *=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator*=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator *=	Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator*=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise
operator *=	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator*= (const Quaternion& other)$/;"	f	class:Eigen::Quaternion
operator *=	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D
operator *=	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const ScalingType& s) { return scale(s.coeffs()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator*= (const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator *=	Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D& operator*=(const Rotation2D& other)$/;"	f	class:Eigen::Rotation2D
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const DiagonalMatrix<Scalar,Dim>& s) { linearExt() *= s; return *this; }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const EigenBase<OtherDerived>& other) { return *this = *this * other; }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const RotationBase<Derived,Dim>& r) { return rotate(r.toRotationMatrix()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const TranslationType& t) { return translate(t.vector()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator*=(const UniformScaling<Scalar>& s) { return scale(s.factor()); }$/;"	f	class:Eigen::Transform
operator *=	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator*=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator *=	srLib/LieGroup/LieGroup.cpp	/^Quaternion& Quaternion::operator *= (const Quaternion q)$/;"	f	class:Quaternion
operator *=	srLib/LieGroup/LieGroup.h	/^	Quaternion& operator *= (SR_REAL k)                      \/\/ Q *= k$/;"	f	union:Quaternion
operator *=	srMath/Inertia.cpp	/^	Inertia& Inertia::operator *= (const Real& constant)$/;"	f	class:srMath::Inertia
operator *=	srMath/SE3.cpp	/^	SE3& SE3::operator *= (const SE3& operand)$/;"	f	class:srMath::SE3
operator *=	srMath/SO3.cpp	/^	SO3& SO3::operator *= (const SO3& operand)$/;"	f	class:srMath::SO3
operator +	Eigen/src/Core/VectorwiseOp.h	/^    operator+(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator +	Eigen/src/Eigen2Support/Cwise.h	/^    operator+(const Scalar& scalar, const Cwise& mat)$/;"	f	class:Eigen::Cwise
operator +	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator+(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise
operator +	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar) const$/;"	f
operator +	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator+(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f
operator +	srLib/LieGroup/LieGroup.cpp	/^Quaternion operator + (const Quaternion& p, const Quaternion& q)$/;"	f
operator +	srLib/srg/srgColor.cpp	/^srgColor srgColor::operator + (const srgColor &rhs)$/;"	f	class:srgColor
operator +	srMath/Inertia.cpp	/^	Inertia Inertia::operator + (const Inertia& I) const$/;"	f	class:srMath::Inertia
operator ++	Eigen/src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++() { m_inner++; return *this; }$/;"	f	class:Eigen::DenseBase::InnerIterator
operator ++	Eigen/src/SparseCore/AmbiVector.h	/^    Iterator& operator++()$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator ++	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
operator ++	Eigen/src/SparseCore/SparseBlock.h	/^    inline GenericSparseBlockInnerIteratorImpl& operator++()$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
operator ++	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Derived& operator++()$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator ++	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator
operator ++	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
operator ++	Eigen/src/SparseCore/SparseMatrix.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
operator ++	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
operator ++	Eigen/src/SparseCore/SparseVector.h	/^    inline InnerIterator& operator++() { m_id++; return *this; }$/;"	f	class:Eigen::SparseVector::InnerIterator
operator ++	Eigen/src/SparseCore/SparseView.h	/^  EIGEN_STRONG_INLINE InnerIterator& operator++()$/;"	f	class:Eigen::SparseView::InnerIterator
operator ++	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline InnerIterator& operator++()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
operator +=	Eigen/src/Core/ArrayBase.h	/^    Derived& operator+=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase
operator +=	Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator+=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator +=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator+=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator +=	Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator+=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator +=	Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator+=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator +=	Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator+=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator +=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias
operator +=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias
operator +=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator+=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator +=	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView
operator +=	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator+=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView
operator +=	Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator+=(const DenseBase<Other>& other) { return *this = m_matrix + other.derived(); }$/;"	f	class:Eigen::TriangularView
operator +=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator+=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator +=	Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator+=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise
operator +=	Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator+=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase
operator +=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator+=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator +=	srLib/LieGroup/LieGroup.h	/^	Quaternion& operator += (const Quaternion& q)           \/\/ Q += Q$/;"	f	union:Quaternion
operator +=	srMath/Inertia.cpp	/^	Inertia& Inertia::operator += (const Inertia& I)$/;"	f	class:srMath::Inertia
operator ,	Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::CommaInitializer
operator ,	Eigen/src/Core/CommaInitializer.h	/^  CommaInitializer& operator,(const Scalar& s)$/;"	f	struct:Eigen::CommaInitializer
operator -	Eigen/src/Core/VectorwiseOp.h	/^    operator-(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator -	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator-(const Scalar& scalar) const$/;"	f	class:Eigen::Cwise
operator -	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar) const$/;"	f
operator -	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator-(const Scalar& scalar,const EIGEN_CURRENT_STORAGE_BASE_CLASS<Derived>& other)$/;"	f
operator -	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator-() const { return derived(); }$/;"	f
operator -	srLib/LieGroup/LieGroup.cpp	/^Quaternion operator - (const Quaternion& p, const Quaternion& q)$/;"	f
operator -	srLib/LieGroup/LieGroup.cpp	/^Quaternion operator - (const Quaternion& q)$/;"	f
operator -	srLib/srg/srgColor.cpp	/^srgColor srgColor::operator - (const srgColor &rhs)$/;"	f	class:srgColor
operator -	srMath/Inertia.cpp	/^	Inertia Inertia::operator - (const Inertia& I) const$/;"	f	class:srMath::Inertia
operator --	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
operator --	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
operator --	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
operator --	Eigen/src/SparseCore/SparseMatrix.h	/^    inline ReverseInnerIterator& operator--() { --m_id; return *this; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
operator --	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE ReverseInnerIterator& operator--()$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
operator --	Eigen/src/SparseCore/SparseVector.h	/^    inline ReverseInnerIterator& operator--() { m_id--; return *this; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
operator -=	Eigen/src/Core/ArrayBase.h	/^    Derived& operator-=(const Scalar& scalar)$/;"	f	class:Eigen::ArrayBase
operator -=	Eigen/src/Core/ArrayBase.h	/^    template<typename OtherDerived> Derived& operator-=(const MatrixBase<OtherDerived>& )$/;"	f	class:Eigen::ArrayBase
operator -=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator-=(const ArrayBase<OtherDerived> &other)$/;"	f	class:Eigen::ArrayBase
operator -=	Eigen/src/Core/CwiseBinaryOp.h	/^MatrixBase<Derived>::operator-=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::MatrixBase
operator -=	Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator-=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator -=	Eigen/src/Core/MatrixBase.h	/^    template<typename OtherDerived> Derived& operator-=(const ArrayBase<OtherDerived>& )$/;"	f	class:Eigen::MatrixBase
operator -=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const CoeffBasedProduct<Lhs,Rhs,NestingFlags>& other)$/;"	f	class:Eigen::NoAlias
operator -=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::NoAlias
operator -=	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator-=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator -=	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView
operator -=	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator-=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView
operator -=	Eigen/src/Core/TriangularMatrix.h	/^    template<typename Other> TriangularView&  operator-=(const DenseBase<Other>& other) { return *this = m_matrix - other.derived(); }$/;"	f	class:Eigen::TriangularView
operator -=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator-=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator -=	Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator-=(const Scalar& scalar)$/;"	f	class:Eigen::Cwise
operator -=	Eigen/src/Eigen2Support/Lazy.h	/^Derived& MatrixBase<Derived>::operator-=(const Flagged<ProductBase<ProductDerived, Lhs,Rhs>, 0,$/;"	f	class:Eigen::MatrixBase
operator -=	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^SparseMatrixBase<Derived>::operator-=(const SparseMatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator -=	srLib/LieGroup/LieGroup.h	/^	Quaternion& operator -= (const Quaternion& q)           \/\/ Q -= Q$/;"	f	union:Quaternion
operator -=	srMath/Inertia.cpp	/^	Inertia& Inertia::operator -= (const Inertia& I)$/;"	f	class:srMath::Inertia
operator /	Eigen/src/Core/GlobalFunctions.h	/^    operator\/(const typename Derived::Scalar& s, const Eigen::ArrayBase<Derived>& a)$/;"	f	namespace:Eigen
operator /	Eigen/src/Core/VectorwiseOp.h	/^    operator\/(const DenseBase<OtherDerived>& other) const$/;"	f	class:Eigen::VectorwiseOp
operator /	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator\/(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator /	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator\/(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operator /	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^operator\/(const Scalar& scalar) const$/;"	f
operator /	srMath/Inertia.cpp	/^	Inertia Inertia::operator \/ (const Real& constant) const$/;"	f	class:srMath::Inertia
operator /=	Eigen/src/Core/ArrayBase.h	/^ArrayBase<Derived>::operator\/=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::ArrayBase
operator /=	Eigen/src/Core/SelfCwiseBinaryOp.h	/^inline Derived& DenseBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::DenseBase
operator /=	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView&  operator\/=(const typename internal::traits<MatrixType>::Scalar& other) { return *this = m_matrix \/ other; }$/;"	f	class:Eigen::TriangularView
operator /=	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator\/=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator /=	Eigen/src/Eigen2Support/CwiseOperators.h	/^inline ExpressionType& Cwise<ExpressionType>::operator\/=(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Cwise
operator /=	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^SparseMatrixBase<Derived>::operator\/=(const Scalar& other)$/;"	f	class:Eigen::SparseMatrixBase
operator /=	srMath/Inertia.cpp	/^	Inertia& Inertia::operator \/= (const Real& constant)$/;"	f	class:srMath::Inertia
operator <	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(Scalar s) const$/;"	f	class:Eigen::Cwise
operator <	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator <<	Eigen/src/Core/CommaInitializer.h	/^DenseBase<Derived>::operator<<(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator <<	Eigen/src/Core/CommaInitializer.h	/^inline CommaInitializer<Derived> DenseBase<Derived>::operator<< (const Scalar& s)$/;"	f	class:Eigen::DenseBase
operator <<	Eigen/src/Core/IO.h	/^    friend std::ostream & operator << (std::ostream & s, const WithFormat& wf)$/;"	f	class:Eigen::WithFormat
operator <<	Eigen/src/Core/IO.h	/^std::ostream & operator <<$/;"	f	namespace:Eigen
operator <<	Eigen/src/SparseCore/SparseMatrix.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrix& m)$/;"	f	class:Eigen::SparseMatrix
operator <<	Eigen/src/SparseCore/SparseMatrixBase.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseMatrixBase& m)$/;"	f	class:Eigen::SparseMatrixBase
operator <<	Eigen/src/SparseCore/SparseVector.h	/^    friend std::ostream & operator << (std::ostream & s, const SparseVector& m)$/;"	f	class:Eigen::SparseVector
operator <<	srLib/LieGroup/LieGroup.cpp	/^ostream &operator << (ostream &os, const Axis &v)$/;"	f
operator <<	srLib/LieGroup/LieGroup.cpp	/^ostream &operator << (ostream &os, const SE3 &T)$/;"	f
operator <<	srLib/LieGroup/LieGroup.cpp	/^ostream &operator << (ostream &os, const Vec3 &v)$/;"	f
operator <<	srLib/LieGroup/LieGroup.cpp	/^ostream &operator << (ostream &os, const dse3 &t)$/;"	f
operator <<	srLib/LieGroup/LieGroup.cpp	/^ostream &operator << (ostream &os, const se3 &s)$/;"	f
operator <<	srLib/LieGroup/LieGroup.cpp	/^std::ostream& operator << (std::ostream& os, const Quaternion& q)$/;"	f
operator <<	srMath/SE3.cpp	/^	ostream& operator << (ostream& out, const SE3& T)$/;"	f	namespace:srMath
operator <<	srMath/SO3.cpp	/^	ostream& operator << (ostream& out, const SO3& R)$/;"	f	namespace:srMath
operator <=	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(Scalar s) const$/;"	f	class:Eigen::Cwise
operator <=	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator<=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator =	Eigen/src/Core/Array.h	/^    Array& operator=(Array&& other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const Array& other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const ArrayBase<OtherDerived>& other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/Array.h	/^    EIGEN_STRONG_INLINE Array& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Array
operator =	Eigen/src/Core/ArrayBase.h	/^    Derived& operator=(const ArrayBase& other)$/;"	f	class:Eigen::ArrayBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase& other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const MatrixBase& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/Assign.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::MatrixBase
operator =	Eigen/src/Core/DenseStorage.h	/^    DenseStorage& operator=(DenseStorage&& other)$/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DenseStorage.h	/^    DenseStorage& operator=(const DenseStorage&) { return *this; }$/;"	f	class:Eigen::DenseStorage
operator =	Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalBase<OtherDerived>& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	Eigen/src/Core/DiagonalMatrix.h	/^    DiagonalMatrix& operator=(const DiagonalMatrix& other)$/;"	f	class:Eigen::DiagonalMatrix
operator =	Eigen/src/Core/EigenBase.h	/^Derived& DenseBase<Derived>::operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/MapBase.h	/^    Derived& operator=(const MapBase& other)$/;"	f	class:Eigen::MapBase
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const Matrix& other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    EIGEN_STRONG_INLINE Matrix& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/Matrix.h	/^    Matrix& operator=(Matrix&& other)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Core/NoAlias.h	/^    EIGEN_STRONG_INLINE ExpressionType& operator=(const StorageBase<OtherDerived>& other)$/;"	f	class:Eigen::NoAlias
operator =	Eigen/src/Core/NoAlias.h	/^    ExpressionType& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::NoAlias
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase& other)$/;"	f	class:Eigen::PermutationBase
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const PermutationBase<OtherDerived>& other)$/;"	f	class:Eigen::PermutationBase
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& tr)$/;"	f	class:Eigen::PermutationBase
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/PermutationMatrix.h	/^    Map& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationBase<Other>& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const PermutationMatrix& other)$/;"	f	class:Eigen::PermutationMatrix
operator =	Eigen/src/Core/PermutationMatrix.h	/^    PermutationMatrix& operator=(const TranspositionsBase<Other>& tr)$/;"	f	class:Eigen::PermutationMatrix
operator =	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const PlainObjectBase& other)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Derived& operator=(const ReturnByValue<OtherDerived>& func)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/PlainObjectBase.h	/^    PlainObjectBase& operator=(PlainObjectBase&& other)$/;"	f	class:Eigen::PlainObjectBase
operator =	Eigen/src/Core/ReturnByValue.h	/^      Unusable& operator=(const Unusable&) {return *this;}$/;"	f	class:Eigen::ReturnByValue::Unusable
operator =	Eigen/src/Core/ReturnByValue.h	/^Derived& DenseBase<Derived>::operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
operator =	Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SelfAdjointView
operator =	Eigen/src/Core/SelfAdjointView.h	/^    SelfAdjointView& operator=(const TriangularView<OtherMatrixType, OtherMode>& other)$/;"	f	class:Eigen::SelfAdjointView
operator =	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    SelfCwiseBinaryOp& operator=(const Rhs& _rhs)$/;"	f	class:Eigen::SelfCwiseBinaryOp
operator =	Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	Eigen/src/Core/Transpositions.h	/^    Derived& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsBase
operator =	Eigen/src/Core/Transpositions.h	/^    Map& operator=(const Map& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/Transpositions.h	/^    Map& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Map
operator =	Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const Transpositions& other)$/;"	f	class:Eigen::Transpositions
operator =	Eigen/src/Core/Transpositions.h	/^    Transpositions& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::Transpositions
operator =	Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsBase<OtherDerived>& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	Eigen/src/Core/Transpositions.h	/^    TranspositionsWrapper& operator=(const TranspositionsWrapper& other)$/;"	f	class:Eigen::TranspositionsWrapper
operator =	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ProductBase<ProductDerived, Lhs,Rhs>& other)$/;"	f	class:Eigen::TriangularView
operator =	Eigen/src/Core/TriangularMatrix.h	/^    EIGEN_STRONG_INLINE TriangularView& operator=(const ScaledProduct<ProductDerived>& other)$/;"	f	class:Eigen::TriangularView
operator =	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& operator=(const TriangularView& other)$/;"	f	class:Eigen::TriangularView
operator =	Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
operator =	Eigen/src/Core/TriangularMatrix.h	/^TriangularView<MatrixType, Mode>::operator=(const TriangularBase<OtherDerived>& other)$/;"	f	class:Eigen::TriangularView
operator =	Eigen/src/Core/VectorwiseOp.h	/^    ExpressionType& operator=(const DenseBase<OtherDerived>& other)$/;"	f	class:Eigen::VectorwiseOp
operator =	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
operator =	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionType& q)$/;"	f	class:Eigen::AngleAxis
operator =	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::Quaternion
operator =	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const MatrixBase<Derived>& xpr)$/;"	f	class:Eigen::Quaternion
operator =	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::operator=(const Quaternion& other)$/;"	f	class:Eigen::Quaternion
operator =	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Eigen2Support/Geometry/Scaling.h	/^  inline Scaling& operator=(const Scaling& other)$/;"	f	class:Eigen::Scaling
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const MatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const ScalingType& s)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation
operator =	Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const MatrixBase<Derived>& mat)$/;"	f	class:Eigen::AngleAxis
operator =	Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>& AngleAxis<Scalar>::operator=(const QuaternionBase<QuatDerived>& q)$/;"	f	class:Eigen::AngleAxis
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const AngleAxisType& aa)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE Derived& QuaternionBase<Derived>::operator=(const QuaternionBase<OtherDerived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Quaternion.h	/^EIGEN_STRONG_INLINE QuaternionBase<Derived>& QuaternionBase<Derived>::operator=(const QuaternionBase<Derived>& other)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::operator=(const MatrixBase<MatrixDerived>& xpr)$/;"	f	class:Eigen::QuaternionBase
operator =	Eigen/src/Geometry/RotationBase.h	/^::operator=(const RotationBase<OtherDerived,ColsAtCompileTime>& r)$/;"	f	class:Eigen::Matrix
operator =	Eigen/src/Geometry/Transform.h	/^  Transform& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^  inline Transform& operator=(const Transform& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QMatrix& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const QTransform& other)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const RotationBase<Derived,Dim>& r)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const TranslationType& t)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::operator=(const UniformScaling<Scalar>& s)$/;"	f	class:Eigen::Transform
operator =	Eigen/src/Geometry/Translation.h	/^  Translation& operator=(const Translation& other)$/;"	f	class:Eigen::Translation
operator =	Eigen/src/SparseCore/CompressedStorage.h	/^    CompressedStorage& operator=(const CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
operator =	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const BlockType& other)$/;"	f	class:Eigen::BlockImpl
operator =	Eigen/src/SparseCore/SparseBlock.h	/^    inline BlockType& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::BlockImpl
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const EigenBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^    inline SparseMatrix& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrix.h	/^EIGEN_DONT_INLINE SparseMatrix<Scalar,_Options,_Index>& SparseMatrix<Scalar,_Options,_Index>::operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrix
operator =	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const EigenBase<OtherDerived> &other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Derived& operator=(const ReturnByValue<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const Derived& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Derived& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseProduct.h	/^inline Derived& SparseMatrixBase<Derived>::operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseMatrixBase
operator =	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSelfAdjointView<SrcMatrixType,SrcUpLo>& src)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSelfAdjointView& operator=(const SparseSymmetricPermutationProduct<SrcMatrixType,SrcUpLo>& permutedMatrix)$/;"	f	class:Eigen::SparseSelfAdjointView
operator =	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseMatrixBase<OtherDerived>& other)$/;"	f	class:Eigen::SparseVector
operator =	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseSparseProduct<Lhs,Rhs>& product)$/;"	f	class:Eigen::SparseVector
operator =	Eigen/src/SparseCore/SparseVector.h	/^    inline SparseVector& operator=(const SparseVector& other)$/;"	f	class:Eigen::SparseVector
operator =	Eigen/src/StlSupport/details.h	/^    inline T& operator=(const OtherT& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support& operator=(const workaround_msvc_stl_support& other)$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator =	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  SluMatrix& operator=(const SluMatrix& other)$/;"	f	struct:Eigen::SluMatrix
operator =	srLib/LieGroup/_array.h	/^	_array<TYPE> &operator = (const _array<TYPE> &ary)$/;"	f	class:_array
operator =	srLib/srDyn/srState.cpp	/^const srBallState& srBallState::operator = (const srBallState &_rv)$/;"	f	class:srBallState
operator =	srLib/srDyn/srState.cpp	/^const srRevoluteState & srRevoluteState::operator = (const srRevoluteState &_rv)$/;"	f	class:srRevoluteState
operator =	srLib/srDyn/srState.cpp	/^const srUniversalState& srUniversalState::operator = (const srUniversalState &_rv)$/;"	f	class:srUniversalState
operator =	srLib/srDyn/srState.h	/^	const srWeldState & operator = (const srWeldState& ) { return *this; };$/;"	f	class:srWeldState
operator =	srLib/srg/srgColor.cpp	/^srgColor& srgColor::operator = (const srgColor &rhs)$/;"	f	class:srgColor
operator =	srLib/srg/srgColor.cpp	/^srgMaterialColor& srgMaterialColor::operator = (const srgMaterialColor &rhs)$/;"	f	class:srgMaterialColor
operator =	srMath/Inertia.cpp	/^	Inertia& Inertia::operator = (const Inertia& I)$/;"	f	class:srMath::Inertia
operator =	srMath/SE3.cpp	/^	SE3& SE3::operator = (const Matrix4& operand)$/;"	f	class:srMath::SE3
operator =	srMath/SE3.cpp	/^	SE3& SE3::operator = (const SE3& operand)$/;"	f	class:srMath::SE3
operator =	srMath/SO3.cpp	/^	SO3& SO3::operator = (const Matrix3& operand)$/;"	f	class:srMath::SO3
operator =	srMath/SO3.cpp	/^	SO3& SO3::operator = (const SO3& operand)$/;"	f	class:srMath::SO3
operator =	tinyxml2/tinyxml2.h	/^    XMLConstHandle& operator=( const XMLConstHandle& ref )							{$/;"	f	class:tinyxml2::XMLConstHandle
operator =	tinyxml2/tinyxml2.h	/^    XMLHandle& operator=( const XMLHandle& ref )							{$/;"	f	class:tinyxml2::XMLHandle
operator ==	Eigen/src/Core/MatrixBase.h	/^    inline bool operator==(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::MatrixBase
operator ==	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(Scalar s) const$/;"	f	class:Eigen::Cwise
operator ==	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator==(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator ==	srLib/LieGroup/LieGroup.cpp	/^bool operator == (const Quaternion& p, const Quaternion& q)$/;"	f
operator ==	srLib/srg/srgColor.cpp	/^bool srgColor::operator == (const srgColor &rhs)$/;"	f	class:srgColor
operator ==	srLib/srg/srgColor.cpp	/^bool srgMaterialColor::operator == (const srgMaterialColor &rhs)$/;"	f	class:srgMaterialColor
operator >	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(Scalar s) const$/;"	f	class:Eigen::Cwise
operator >	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator >=	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(Scalar s) const$/;"	f	class:Eigen::Cwise
operator >=	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::operator>=(const MatrixBase<OtherDerived> &other) const$/;"	f	class:Eigen::Cwise
operator Matrix6	srMath/Inertia.cpp	/^	Inertia::operator Matrix6()$/;"	f	class:srMath::Inertia
operator T&	Eigen/src/StlSupport/details.h	/^    inline operator T& () { return *static_cast<T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator []	Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
operator []	Eigen/src/Core/DenseCoeffsBase.h	/^    operator[](Index index)$/;"	f	class:Eigen::DenseCoeffsBase
operator []	Eigen/src/Core/Transpositions.h	/^    inline Index& operator[](Index i) { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	Eigen/src/Core/Transpositions.h	/^    inline const Index& operator[](Index i) const { return indices()(i); }$/;"	f	class:Eigen::TranspositionsBase
operator []	Eigen/src/SparseCore/SparseMatrix.h	/^        Index operator[](Index i) const { return i==m_index ? m_value : 0; }$/;"	f	class:Eigen::SparseMatrix::SingletonVector
operator []	srLib/LieGroup/_array.h	/^	TYPE &operator [] (int i)$/;"	f	class:_array
operator []	srLib/LieGroup/_array.h	/^	const TYPE &operator [] (int i) const$/;"	f	class:_array
operator []	tinyxml2/tinyxml2.h	/^    T& operator[](int i)				{$/;"	f	class:tinyxml2::DynArray
operator []	tinyxml2/tinyxml2.h	/^    const T& operator[](int i) const	{$/;"	f	class:tinyxml2::DynArray
operator bool	Eigen/src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_inner < m_end && m_inner>=0; }$/;"	f	class:Eigen::DenseBase::InnerIterator
operator bool	Eigen/src/SparseCore/AmbiVector.h	/^    operator bool() const { return m_cachedIndex>=0; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
operator bool	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end) && (m_id>=m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
operator bool	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline operator bool() const { return (m_id <= m_end) && (m_id>m_start); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
operator bool	Eigen/src/SparseCore/SparseBlock.h	/^      inline operator bool() const { return Base::operator bool() && Base::index() >= m_begin; }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
operator bool	Eigen/src/SparseCore/SparseBlock.h	/^    inline operator bool() const { return Base::operator bool() && Base::index() < m_end; }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
operator bool	Eigen/src/SparseCore/SparseBlock.h	/^    inline operator bool() const { return m_outerPos < m_end; }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return (m_lhsIter && m_rhsIter); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_id>=0; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_lhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE operator bool() const { return m_rhsIter; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
operator bool	Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
operator bool	Eigen/src/SparseCore/SparseMatrix.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
operator bool	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
operator bool	Eigen/src/SparseCore/SparseTriangularView.h	/^    EIGEN_STRONG_INLINE operator bool() const$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
operator bool	Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id < m_end); }$/;"	f	class:Eigen::SparseVector::InnerIterator
operator bool	Eigen/src/SparseCore/SparseVector.h	/^    inline operator bool() const { return (m_id > m_start); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
operator bool	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline operator bool() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
operator const ExpressionType&	Eigen/src/Core/ForceAlignedAccess.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::ForceAlignedAccess
operator const ExpressionType&	Eigen/src/Core/NestByValue.h	/^    operator const ExpressionType&() const { return m_expression; }$/;"	f	class:Eigen::NestByValue
operator const PlainObject&	Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE operator const PlainObject& () const$/;"	f	class:Eigen::CoeffBasedProduct
operator const T&	Eigen/src/StlSupport/details.h	/^    inline operator const T& () const { return *static_cast<const T*>(this); }$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
operator const typename Base::Scalar	Eigen/src/Core/GeneralProduct.h	/^    operator const typename Base::Scalar() const {$/;"	f	class:Eigen::GeneralProduct
operator ||	Eigen/src/plugins/ArrayCwiseBinaryOps.h	/^operator||(const EIGEN_CURRENT_STORAGE_BASE_CLASS<OtherDerived> &other) const$/;"	f
operatorInverseSqrt	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorInverseSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
operatorNorm	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^MatrixBase<Derived>::operatorNorm() const$/;"	f	class:Eigen::MatrixBase
operatorNorm	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^SelfAdjointView<MatrixType, UpLo>::operatorNorm() const$/;"	f	class:Eigen::SelfAdjointView
operatorSqrt	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^    MatrixType operatorSqrt() const$/;"	f	class:Eigen::SelfAdjointEigenSolver
options	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline superlu_options_t& options() { return m_sluOptions; }$/;"	f	class:Eigen::SuperLUBase
options	srLib/SceneGraph/gl2ps.c	/^  GLint format, sort, options, colorsize, colormode, buffersize;$/;"	m	struct:__anon15	file:
order	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index order ; \/* pivot ordering of this column, if col is dead *\/$/;"	m	union:internal::colamd_col::__anon350
order_children	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^static inline  void order_children$/;"	f	namespace:internal
ordering	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^void SimplicialCholeskyBase<Derived>::ordering(const MatrixType& a, CholMatrixType& ap)$/;"	f	class:Eigen::SimplicialCholeskyBase
ordering_helper_at_plus_a	Eigen/src/OrderingMethods/Ordering.h	/^void ordering_helper_at_plus_a(const MatrixType& mat, MatrixType& symmat)$/;"	f	namespace:Eigen::internal
ori_mtx	Example/DracoP1/Draco_Dyn_environment.h	/^    double ori_mtx[9];$/;"	m	struct:state
ori_mtx_	Example/DracoP1/Draco_Dyn_environment.h	/^        double ori_mtx_[9];$/;"	m	class:Draco_Dyn_environment
origin	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType& origin() { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
origin	Eigen/src/Geometry/ParametrizedLine.h	/^  const VectorType& origin() const { return m_origin; }$/;"	f	class:Eigen::ParametrizedLine
originalMatrix	Eigen/src/misc/Image.h	/^  inline const MatrixType& originalMatrix() const { return m_originalMatrix; }$/;"	f	struct:Eigen::internal::image_retval_base
ortho	srLib/SceneGraph/Camera.h	/^    double          ortho[6];$/;"	m	class:Camera
other	Eigen/src/Core/util/Memory.h	/^    typedef aligned_allocator<U> other;$/;"	t	struct:Eigen::aligned_allocator::rebind
other	Eigen/src/StlSupport/details.h	/^      typedef aligned_allocator_indirection<U> other;$/;"	t	struct:Eigen::aligned_allocator_indirection::rebind
outer	Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling::__anon29
outer	Eigen/src/Core/Assign.h	/^    outer = Index \/ Derived1::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::assign_innervec_CompleteUnrolling::__anon30
outer	Eigen/src/Core/Redux.h	/^    outer = Start \/ Derived::InnerSizeAtCompileTime,$/;"	e	enum:Eigen::internal::redux_novec_unroller::__anon333
outer	Eigen/src/Core/Redux.h	/^    outer = index \/ int(Derived::InnerSizeAtCompileTime),$/;"	e	enum:Eigen::internal::redux_vec_unroller::__anon335
outer	Eigen/src/Core/Stride.h	/^    inline Index outer() const { return m_outer.value(); }$/;"	f	class:Eigen::Stride
outer	Eigen/src/SparseCore/SparseBlock.h	/^      inline Index outer()  const { return Base::outer() - (IsRowMajor ? m_block.m_startRow.value() : m_block.m_startCol.value()); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
outer	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index outer()  const { return 0; }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
outer	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index outer()  const { return Base::outer() - (IsRowMajor ? m_block.m_startRow.value() : m_block.m_startCol.value()); }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
outer	Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
outer	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
outer	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
outer	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outer() const { return m_outer; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
outerInd	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    int *outerInd;$/;"	m	struct:Eigen::SluMatrix::__anon458
outerIndexPtr	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix
outerIndexPtr	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::MappedSparseMatrix
outerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index* outerIndexPtr()$/;"	f	class:Eigen::BlockImpl
outerIndexPtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Index* outerIndexPtr() const$/;"	f	class:Eigen::BlockImpl
outerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index* outerIndexPtr() { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerIndexPtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Index* outerIndexPtr() const { return m_outerIndex; }$/;"	f	class:Eigen::SparseMatrix
outerSize	Eigen/src/Core/DenseBase.h	/^    Index outerSize() const$/;"	f	class:Eigen::DenseBase
outerSize	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
outerSize	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index outerSize() const { return m_outerSize; }$/;"	f	class:Eigen::SparseMatrix
outerSize	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Index outerSize() const { return (int(Flags)&RowMajorBit) ? this->rows() : this->cols(); }$/;"	f	class:Eigen::SparseMatrixBase
outerSize	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index outerSize() const { return 1; }$/;"	f	class:Eigen::SparseVector
outerSize	Eigen/src/SparseCore/SparseView.h	/^  inline Index outerSize() const { return m_matrix.outerSize(); }$/;"	f	class:Eigen::SparseView
outerStride	Eigen/src/Core/Array.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Array
outerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ArrayWrapper
outerStride	Eigen/src/Core/ArrayWrapper.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::MatrixWrapper
outerStride	Eigen/src/Core/Block.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::internal::BlockImpl_dense
outerStride	Eigen/src/Core/CwiseUnaryView.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::CwiseUnaryViewImpl
outerStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::DenseCoeffsBase
outerStride	Eigen/src/Core/Diagonal.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Diagonal
outerStride	Eigen/src/Core/Flagged.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::Flagged
outerStride	Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::ForceAlignedAccess
outerStride	Eigen/src/Core/Map.h	/^    inline Index outerStride() const$/;"	f	class:Eigen::Map
outerStride	Eigen/src/Core/Matrix.h	/^    inline Index outerStride() const { return this->innerSize(); }$/;"	f	class:Eigen::Matrix
outerStride	Eigen/src/Core/NestByValue.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::NestByValue
outerStride	Eigen/src/Core/Ref.h	/^  inline Index outerStride() const$/;"	f	class:Eigen::RefBase
outerStride	Eigen/src/Core/SelfAdjointView.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfAdjointView
outerStride	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
outerStride	Eigen/src/Core/Swap.h	/^    inline Index outerStride() const { return m_expression.outerStride(); }$/;"	f	class:Eigen::SwapWrapper
outerStride	Eigen/src/Core/Transpose.h	/^    inline Index outerStride() const { return derived().nestedExpression().outerStride(); }$/;"	f	class:Eigen::TransposeImpl
outerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return derived().outerStride(); }$/;"	f	class:Eigen::TriangularBase
outerStride	Eigen/src/Core/TriangularMatrix.h	/^    inline Index outerStride() const { return m_matrix.outerStride(); }$/;"	f	class:Eigen::TriangularView
outerTube_pointsList	srLib/SceneGraph/Leaf.h	/^	vector<vector<Vec3>>		outerTube_pointsList;$/;"	m	class:Tube
outer_product_selector_run	Eigen/src/Core/GeneralProduct.h	/^EIGEN_DONT_INLINE void outer_product_selector_run(const ProductType& prod, Dest& dest, const Func& func, const false_type&)$/;"	f	namespace:Eigen::internal
outer_product_selector_run	Eigen/src/Core/GeneralProduct.h	/^EIGEN_DONT_INLINE void outer_product_selector_run(const ProductType& prod, Dest& dest, const Func& func, const true_type&) {$/;"	f	namespace:Eigen::internal
outer_radius	srLib/SceneGraph/Leaf.h	/^	double						outer_radius;$/;"	m	class:Tube
outer_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time$/;"	s	namespace:Eigen::internal
outer_stride_at_compile_time	Eigen/src/Core/DenseCoeffsBase.h	/^struct outer_stride_at_compile_time<Derived, false>$/;"	s	namespace:Eigen::internal
p	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index p ;   \/* used as a row pointer in init_rows_cols () *\/$/;"	m	union:internal::Colamd_Row::__anon353
p16uc_COMPLEX_IM	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_IM   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 1), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 3), 8);\/\/{ 4,5,6,7, 4,5,6,7, 12,13,14,15, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_RE	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_RE   = vec_sld((Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet16uc) vec_splat((Packet4ui)p16uc_FORWARD, 2), 8);\/\/{ 0,1,2,3, 0,1,2,3, 8,9,10,11, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV  = vec_sld(p16uc_REVERSE, p16uc_REVERSE, 8);\/\/{ 4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11 };$/;"	m	namespace:Eigen::internal
p16uc_COMPLEX_REV2	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_COMPLEX_REV2 = vec_sld(p16uc_FORWARD, p16uc_FORWARD, 8);\/\/{ 8,9,10,11, 12,13,14,15, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_DUPLICATE	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_DUPLICATE = {0,1,2,3, 0,1,2,3, 4,5,6,7, 4,5,6,7};$/;"	m	namespace:Eigen::internal
p16uc_FORWARD	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_FORWARD = vec_lvsl(0, (float*)0);$/;"	m	namespace:Eigen::internal
p16uc_PSET_HI	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_HI = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 0), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 1));\/\/{ 0,1,2,3, 4,5,6,7, 0,1,2,3, 4,5,6,7 };$/;"	m	namespace:Eigen::internal
p16uc_PSET_LO	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet16uc p16uc_PSET_LO = (Packet16uc) vec_mergeh((Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 2), (Packet4ui) vec_splat((Packet4ui)p16uc_FORWARD, 3));\/\/{ 8,9,10,11, 12,13,14,15, 8,9,10,11, 12,13,14,15 };$/;"	m	namespace:Eigen::internal
p16uc_REVERSE	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet16uc p16uc_REVERSE = {12,13,14,15, 8,9,10,11, 4,5,6,7, 0,1,2,3};$/;"	m	namespace:Eigen::internal
p2ui_CONJ_XOR	Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x2_t p2ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET2(0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
p4f_COUNTDOWN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_COUNTDOWN = { 3.0, 2.0, 1.0, 0.0 };$/;"	m	namespace:Eigen::internal
p4f_ONE	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ONE = vec_ctf(p4i_ONE, 0);$/;"	m	namespace:Eigen::internal
p4f_ZERO_	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4f p4f_ZERO_ = (Packet4f) vec_sl((Packet4ui)p4i_MINUS1, (Packet4ui)p4i_MINUS1);$/;"	m	namespace:Eigen::internal
p4i_COUNTDOWN	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^static Packet4i p4i_COUNTDOWN = { 3, 2, 1, 0 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	Eigen/src/Core/arch/AltiVec/Complex.h	/^static Packet4ui  p4ui_CONJ_XOR = vec_mergeh((Packet4ui)p4i_ZERO, (Packet4ui)p4f_ZERO_);\/\/{ 0x00000000, 0x80000000, 0x00000000, 0x80000000 };$/;"	m	namespace:Eigen::internal
p4ui_CONJ_XOR	Eigen/src/Core/arch/NEON/Complex.h	/^static uint32x4_t p4ui_CONJ_XOR = EIGEN_INIT_NEON_PACKET4(0x00000000, 0x80000000, 0x00000000, 0x80000000);$/;"	m	namespace:Eigen::internal
pContactConstraint	srLib/srDyn/srContactConstraint.h	/^	ContactConstraint *pContactConstraint;$/;"	m	class:CollisionPair
pContactPts	srLib/srDyn/srContactConstraint.h	/^	ContactPtr		pContactPts[MAX_NUM_OF_CONTACTPOINT_PER_MASSPAIR];$/;"	m	class:ContactConstraint
pForce	srLib/SceneGraph/Leaf.h	/^	dse3*		pForce;$/;"	m	class:ForceVector
pInv	srLib/srExt/srExt_Eigen.h	/^	MatrixXd pInv(const MatrixBase<Derived>& A)$/;"	f	namespace:Eigen
pInv	srMath/Common.h	/^	static MatrixX pInv(const MatrixX& matrix \/\/\/< Matrix for inversion$/;"	f	namespace:srMath
pJoint	srLib/srDyn/srJointConstraint.h	/^	srJoint *	pJoint;$/;"	m	class:JointConstraint
pLSystem	srLib/srDyn/srContactConstraint.h	/^	srSystem			*pLSystem;$/;"	m	class:ContactConstraint
pLeftCol	srLib/srDyn/srContactConstraint.h	/^	srCollision		*pLeftCol;$/;"	m	class:CollisionPair
pLeftMass	srLib/srDyn/srClosedLoopConstraint.h	/^	srLink	* pLeftMass;$/;"	m	class:ClosedLoop
pLeftMass	srLib/srDyn/srContactConstraint.h	/^	srLink			*pLeftMass;$/;"	m	class:ContactConstraint
pLeftMass	srLib/srDyn/srContactConstraint.h	/^	srLink			*pLeftMass;$/;"	m	struct:MassPair
pRSystem	srLib/srDyn/srContactConstraint.h	/^	srSystem			*pRSystem;$/;"	m	class:ContactConstraint
pRightCol	srLib/srDyn/srContactConstraint.h	/^	srCollision		*pRightCol;$/;"	m	class:CollisionPair
pRightMass	srLib/srDyn/srClosedLoopConstraint.h	/^	srLink	* pRightMass;$/;"	m	class:ClosedLoop
pRightMass	srLib/srDyn/srContactConstraint.h	/^	srLink			*pRightMass;$/;"	m	class:ContactConstraint
pRightMass	srLib/srDyn/srContactConstraint.h	/^	srLink			*pRightMass;$/;"	m	struct:MassPair
pSystem	srLib/srDyn/srClosedLoopConstraint.h	/^	srSystem	* pSystem;$/;"	m	class:ClosedLoop
pSystem	srLib/srDyn/srJointConstraint.h	/^	srSystem *	pSystem;$/;"	m	class:JointConstraint
pTargetSE3	srLib/SceneGraph/Transformation.h	/^	SE3*	pTargetSE3;$/;"	m	class:Transformation
p_joint_	Example/DracoP1/draco.h	/^  std::vector<srPrismaticJoint*> p_joint_;$/;"	m	class:srDraco
p_joint_idx_map_	Example/DracoP1/draco.h	/^  std::map<std::string, int> p_joint_idx_map_;$/;"	m	class:srDraco
pabs	Eigen/src/Core/GenericPacketMath.h	/^pabs(const Packet& a) { using std::abs; return abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vec_abs(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a) { return vabsq_f32(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a) { return vabsq_s32(a); }$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pabs(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pabs(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pabs	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pabs(const Packet4i& a)$/;"	f	namespace:Eigen::internal
pack	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  void pack(Scalar* blockA, const const_blas_data_mapper<Scalar,Index,StorageOrder>& lhs, Index cols, Index i, Index& count)$/;"	f	struct:Eigen::internal::symm_pack_lhs
packedMatrix	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    const MatrixType& packedMatrix() const$/;"	f	class:Eigen::HessenbergDecomposition
packedMatrix	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    inline const MatrixType& packedMatrix() const$/;"	f	class:Eigen::Tridiagonalization
packet	Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ArrayWrapper
packet	Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::MatrixWrapper
packet	Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::ArrayWrapper
packet	Eigen/src/Core/ArrayWrapper.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MatrixWrapper
packet	Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::internal::BlockImpl_dense
packet	Eigen/src/Core/Block.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::internal::BlockImpl_dense
packet	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
packet	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseBinaryOpImpl
packet	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseNullaryOp
packet	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseNullaryOp
packet	Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
packet	Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::CwiseUnaryOpImpl
packet	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index index) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packet(Index row, Index col) const$/;"	f	class:Eigen::DenseCoeffsBase
packet	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index idx) const$/;"	f	class:Eigen::DiagonalProduct
packet	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::DiagonalProduct
packet	Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Flagged
packet	Eigen/src/Core/Flagged.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Flagged
packet	Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	Eigen/src/Core/ForceAlignedAccess.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::ForceAlignedAccess
packet	Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index index) const$/;"	f	class:Eigen::MapBase
packet	Eigen/src/Core/MapBase.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::MapBase
packet	Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::NestByValue
packet	Eigen/src/Core/NestByValue.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::NestByValue
packet	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index index) const$/;"	f	class:Eigen::PlainObjectBase
packet	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::PlainObjectBase
packet	Eigen/src/Core/Replicate.h	/^    inline PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::Replicate
packet	Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::Reverse
packet	Eigen/src/Core/Reverse.h	/^    inline const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::Reverse
packet	Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index index) const$/;"	f	class:Eigen::TransposeImpl
packet	Eigen/src/Core/Transpose.h	/^    inline const PacketScalar packet(Index rowId, Index colId) const$/;"	f	class:Eigen::TransposeImpl
packet	Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE const PacketScalar packet(Index row, Index col) const$/;"	f	class:Eigen::CoeffBasedProduct
packetByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE PacketReturnType packetByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const { return impl.packetOp(i); }$/;"	f	struct:Eigen::internal::linspaced_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index i) const$/;"	f	struct:Eigen::internal::linspaced_op_impl
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index row, Index col) const$/;"	f	struct:Eigen::internal::linspaced_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index) const { return m_base = padd(m_base,m_packetStep); }$/;"	f	struct:Eigen::internal::linspaced_op_impl
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(Index, Index = 0) const { return internal::pset1<Packet>(m_other); }$/;"	f	struct:Eigen::internal::scalar_constant_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const { return internal::pconj(a); }$/;"	f	struct:Eigen::internal::scalar_conjugate_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs2_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_abs_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_multiple_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_opposite_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_quotient1_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_conj_product_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_difference_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_max_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_min_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_product_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_quotient_op
packetOp	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Packet packetOp(const Packet& a, const Packet& b) const$/;"	f	struct:Eigen::internal::scalar_sum_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pacos(a); }$/;"	f	struct:Eigen::internal::scalar_acos_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pasin(a); }$/;"	f	struct:Eigen::internal::scalar_asin_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pcos(a); }$/;"	f	struct:Eigen::internal::scalar_cos_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::pexp(a); }$/;"	f	struct:Eigen::internal::scalar_exp_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::plog(a); }$/;"	f	struct:Eigen::internal::scalar_log_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psin(a); }$/;"	f	struct:Eigen::internal::scalar_sin_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::psqrt(a); }$/;"	f	struct:Eigen::internal::scalar_sqrt_op
packetOp	Eigen/src/Core/Functors.h	/^  inline Packet packetOp(const Packet& a) const { return internal::ptan(a); }$/;"	f	struct:Eigen::internal::scalar_tan_op
packetOp	Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_add_op
packetOp	Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_cube_op
packetOp	Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op
packetOp	Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_inverse_op
packetOp	Eigen/src/Core/Functors.h	/^  inline const Packet packetOp(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_square_op
packet_impl	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::false_type) const$/;"	f	class:Eigen::DiagonalProduct
packet_impl	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE PacketScalar packet_impl(Index row, Index col, Index id, internal::true_type) const$/;"	f	class:Eigen::DiagonalProduct
packet_traits	Eigen/src/Core/GenericPacketMath.h	/^template<typename T> struct packet_traits : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<double> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct packet_traits<std::complex<float> >  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<double> : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<float>  : default_packet_traits$/;"	s	namespace:Eigen::internal
packet_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct packet_traits<int>    : default_packet_traits$/;"	s	namespace:Eigen::internal
pacos	Eigen/src/Core/GenericPacketMath.h	/^Packet pacos(const Packet& a) { using std::acos; return acos(a); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/GenericPacketMath.h	/^padd(const Packet& a,$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_add(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_add(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(padd<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return vaddq_f32(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return vaddq_s32(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd padd<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_add_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf padd<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_add_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d padd<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_add_pd(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f padd<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_add_ps(a,b); }$/;"	f	namespace:Eigen::internal
padd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i padd<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_add_epi32(a,b); }$/;"	f	namespace:Eigen::internal
palign	Eigen/src/Core/GenericPacketMath.h	/^inline void palign(PacketType& first, const PacketType& second)$/;"	f	namespace:Eigen::internal
palign_impl	Eigen/src/Core/GenericPacketMath.h	/^struct palign_impl$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/NEON/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet1cd>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/Complex.h	/^struct palign_impl<Offset,Packet2cf>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet2d>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4f>$/;"	s	namespace:Eigen::internal
palign_impl	Eigen/src/Core/arch/SSE/PacketMath.h	/^struct palign_impl<Offset,Packet4i>$/;"	s	namespace:Eigen::internal
pand	Eigen/src/Core/GenericPacketMath.h	/^pand(const Packet& a, const Packet& b) { return a & b; }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return vandq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pand   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_and_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pand   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_and_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pand<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_and_pd(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pand<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_and_ps(a,b); }$/;"	f	namespace:Eigen::internal
pand	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pand<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_and_si128(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/GenericPacketMath.h	/^pandnot(const Packet& a, const Packet& b) { return a & (!b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_and(a.v, vec_nor(b.v,b.v))); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_and(a, vec_nor(b, b)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return vbicq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pandnot<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_andnot_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pandnot<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_andnot_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pandnot<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_andnot_pd(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pandnot<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_andnot_ps(a,b); }$/;"	f	namespace:Eigen::internal
pandnot	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pandnot<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_andnot_si128(a,b); }$/;"	f	namespace:Eigen::internal
panel_bmod	Eigen/src/SparseLU/SparseLU_panel_bmod.h	/^void SparseLUImpl<Scalar,Index>::panel_bmod(const Index m, const Index w, const Index jcol, $/;"	f	class:Eigen::internal::SparseLUImpl
panel_dfs	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^void SparseLUImpl<Scalar,Index>::panel_dfs(const Index m, const Index w, const Index jcol, MatrixType& A, IndexVector& perm_r, Index& nseg, ScalarVector& dense, IndexVector& panel_lsub, IndexVector& segrep, IndexVector& repfnz, IndexVector& xprune, IndexVector& marker, IndexVector& parent, IndexVector& xplore, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
panel_dfs_traits	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  panel_dfs_traits(Index jcol, Index* marker)$/;"	f	struct:Eigen::internal::panel_dfs_traits
panel_dfs_traits	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^struct panel_dfs_traits$/;"	s	namespace:Eigen::internal
panel_size	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index panel_size; \/\/ a panel consists of at most <panel_size> consecutive columns$/;"	m	struct:Eigen::internal::perfvalues
parallelize_gemm	Eigen/src/Core/products/Parallelizer.h	/^void parallelize_gemm(const Functor& func, Index rows, Index cols, bool transpose)$/;"	f	namespace:Eigen::internal
pardisoInit	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoInit(int type)$/;"	f	class:Eigen::PardisoImpl
pardisoParameterArray	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ParameterType& pardisoParameterArray()$/;"	f	class:Eigen::PardisoImpl
pardisoRelease	Eigen/src/PardisoSupport/PardisoSupport.h	/^    void pardisoRelease()$/;"	f	class:Eigen::PardisoImpl
pardiso_run_selector	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector$/;"	s	namespace:Eigen::internal
pardiso_run_selector	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_run_selector<long long int>$/;"	s	namespace:Eigen::internal
pardiso_traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLDLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLLT<_MatrixType, Options> >$/;"	s	namespace:Eigen::internal
pardiso_traits	Eigen/src/PardisoSupport/PardisoSupport.h	/^  struct pardiso_traits< PardisoLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
parent	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index parent ;  \/* parent in parent tree super-column structure, if *\/$/;"	m	union:internal::colamd_col::__anon349
parse_options	Example/DracoP1/simulation_draco.cpp	/^void parse_options(int argc, char ** argv){$/;"	f
parsing	srLib/SceneGraph/srSpaceRenderer.h	/^	void parsing(Group* nodeGroup, Group* coordiGroup)$/;"	f	class:srSpaceRenderer
part	Eigen/src/Core/MatrixBase.h	/^    const DiagonalWrapper<ConstDiagonalReturnType> part() const$/;"	f	class:Eigen::MatrixBase
part	Eigen/src/Core/TriangularMatrix.h	/^const typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part() const$/;"	f	class:Eigen::MatrixBase
part	Eigen/src/Core/TriangularMatrix.h	/^typename internal::eigen2_part_return_type<Derived, Mode>::type MatrixBase<Derived>::part()$/;"	f	class:Eigen::MatrixBase
partialPivLu	Eigen/src/LU/PartialPivLU.h	/^MatrixBase<Derived>::partialPivLu() const$/;"	f	class:Eigen::MatrixBase
partial_lu_impl	Eigen/src/LU/PartialPivLU.h	/^struct partial_lu_impl$/;"	s	namespace:Eigen::internal
partial_lu_inplace	Eigen/src/LU/PartialPivLU.h	/^void partial_lu_inplace(MatrixType& lu, TranspositionType& row_transpositions, typename TranspositionType::Index& nb_transpositions)$/;"	f	namespace:Eigen::internal
pasin	Eigen/src/Core/GenericPacketMath.h	/^Packet pasin(const Packet& a) { using std::asin; return asin(a); }$/;"	f	namespace:Eigen::internal
pastix_traits	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLDLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLLT<_MatrixType,Options> >$/;"	s	namespace:Eigen::internal
pastix_traits	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^  struct pastix_traits< PastixLU<_MatrixType> >$/;"	s	namespace:Eigen::internal
path	srLib/SceneGraph/Model3DS.h	/^	char	path[PATH_LENGTH];$/;"	m	class:Model3DS
pattern	srLib/SceneGraph/gl2ps.c	/^  GLushort pattern;$/;"	m	struct:__anon11	file:
pattern	tinyxml2/tinyxml2.cpp	/^    const char* pattern;$/;"	m	struct:tinyxml2::Entity	file:
pconj	Eigen/src/Core/GenericPacketMath.h	/^pconj(const Packet& a) { return numext::conj(a); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a) { return Packet2cf((Packet4f)vec_xor((Packet4ui)a.v, p4ui_CONJ_XOR)); }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pconj(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pconj(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pconj(const Packet2d& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pconj(const Packet4f& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pconj(const Packet4i& a) { return a; }$/;"	f	namespace:Eigen::internal
pconj	Eigen/src/Core/util/BlasUtil.h	/^  inline T pconj(const T& x) const { return internal::pconj(x); }$/;"	f	struct:Eigen::internal::conj_if
pconj	Eigen/src/Core/util/BlasUtil.h	/^  inline const T& pconj(const T& x) const { return x; }$/;"	f	struct:Eigen::internal::conj_if
pcos	Eigen/src/Core/GenericPacketMath.h	/^Packet pcos(const Packet& a) { using std::cos; return cos(a); }$/;"	f	namespace:Eigen::internal
pcos	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pcos<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet pcplxflip(const Packet& a)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pcplxflip<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet1cd pcplxflip\/*<Packet1cd>*\/(const Packet1cd& x)$/;"	f	namespace:Eigen::internal
pcplxflip	Eigen/src/Core/arch/SSE/Complex.h	/^EIGEN_STRONG_INLINE Packet2cf pcplxflip\/*<Packet2cf>*\/(const Packet2cf& x)$/;"	f	namespace:Eigen::internal
pdfgrouplist	srLib/SceneGraph/gl2ps.c	/^  GL2PSlist *pdfprimlist, *pdfgrouplist;$/;"	m	struct:__anon15	file:
pdfprimlist	srLib/SceneGraph/gl2ps.c	/^  GL2PSlist *pdfprimlist, *pdfgrouplist;$/;"	m	struct:__anon15	file:
pdiv	Eigen/src/Core/GenericPacketMath.h	/^pdiv(const Packet& a,$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pdiv<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pdiv<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pdiv<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_div_pd(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pdiv<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_div_ps(a,b); }$/;"	f	namespace:Eigen::internal
pdiv	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pdiv<Packet4i>(const Packet4i& \/*a*\/, const Packet4i& \/*b*\/)$/;"	f	namespace:Eigen::internal
performFrancisQRStep	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::performFrancisQRStep(Index il, Index im, Index iu, bool computeU, const Vector3s& firstHouseholderVector, Scalar* workspace)$/;"	f	class:Eigen::RealSchur
perfvalues	Eigen/src/SparseLU/SparseLU_Structs.h	/^struct perfvalues {$/;"	s	namespace:Eigen::internal
permut_matrix_product_retval	Eigen/src/Core/PermutationMatrix.h	/^    permut_matrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
permut_matrix_product_retval	Eigen/src/Core/PermutationMatrix.h	/^struct permut_matrix_product_retval$/;"	s	namespace:Eigen::internal
permut_sparsematrix_product_retval	Eigen/src/SparseCore/SparsePermutation.h	/^    permut_sparsematrix_product_retval(const PermutationType& perm, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
permut_sparsematrix_product_retval	Eigen/src/SparseCore/SparsePermutation.h	/^struct permut_sparsematrix_product_retval$/;"	s	namespace:Eigen::internal
permutationP	Eigen/src/LU/FullPivLU.h	/^    inline const PermutationPType& permutationP() const$/;"	f	class:Eigen::FullPivLU
permutationP	Eigen/src/LU/PartialPivLU.h	/^    inline const PermutationType& permutationP() const$/;"	f	class:Eigen::PartialPivLU
permutationP	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationP() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationP	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::SuperLU
permutationP	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntColVectorType& permutationP() const$/;"	f	class:Eigen::UmfPackLU
permutationPinv	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    const PermutationMatrix<Dynamic,Dynamic,Index>& permutationPinv() const$/;"	f	class:Eigen::SimplicialCholeskyBase
permutationQ	Eigen/src/LU/FullPivLU.h	/^    inline const PermutationQType& permutationQ() const$/;"	f	class:Eigen::FullPivLU
permutationQ	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::SuperLU
permutationQ	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const IntRowVectorType& permutationQ() const$/;"	f	class:Eigen::UmfPackLU
permute_symm_to_fullsymm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_fullsymm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DestOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal
permute_symm_to_symm	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^void permute_symm_to_symm(const MatrixType& mat, SparseMatrix<typename MatrixType::Scalar,DstOrder,typename MatrixType::Index>& _dest, const typename MatrixType::Index* perm)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/GenericPacketMath.h	/^Packet pexp(const Packet& a) { using std::exp; return exp(a); }$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet2d pexp<Packet2d>(const Packet2d& _x)$/;"	f	namespace:Eigen::internal
pexp	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f pexp<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type pfirst(const Packet& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vec_st(a, 0, x); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float EIGEN_ALIGN16 x[4]; vst1q_f32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int   EIGEN_ALIGN16 x[4]; vst1q_s32(x, a); return x[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double>  pfirst<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float>  pfirst<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { double x = _mm_cvtsd_f64(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return _mm_cvtsd_f64(a); }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double pfirst<Packet2d>(const Packet2d& a) { return a.m128d_f64[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { float x = _mm_cvtss_f32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return _mm_cvtss_f32(a); }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float  pfirst<Packet4f>(const Packet4f& a) { return a.m128_f32[0]; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { int x = _mm_cvtsi128_si32(a); return x; }$/;"	f	namespace:Eigen::internal
pfirst	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int    pfirst<Packet4i>(const Packet4i& a) { return _mm_cvtsi128_si32(a); }$/;"	f	namespace:Eigen::internal
phi	srLib/SceneGraph/Camera.h	/^	double			phi;$/;"	m	class:Camera
pivotL	Eigen/src/SparseLU/SparseLU_pivotL.h	/^Index SparseLUImpl<Scalar,Index>::pivotL(const Index jcol, const RealScalar& diagpivotthresh, IndexVector& perm_r, IndexVector& iperm_c, Index& pivrow, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
pixels	srLib/SceneGraph/gl2ps.c	/^  GLfloat *pixels;$/;"	m	struct:__anon10	file:
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array() $/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array() {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) $/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^  plain_array(constructor_without_unaligned_array_assert) {}$/;"	f	struct:Eigen::internal::plain_array
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, 0, MatrixOrArrayOptions, Alignment>$/;"	s	namespace:Eigen::internal
plain_array	Eigen/src/Core/DenseStorage.h	/^struct plain_array<T, Size, MatrixOrArrayOptions, 16>$/;"	s	namespace:Eigen::internal
plain_matrix_type	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct plain_matrix_type<T,Sparse>$/;"	s	namespace:Eigen::internal
plane	srLib/SceneGraph/gl2ps.c	/^  GL2PSplane plane;$/;"	m	struct:_GL2PSbsptree	file:
plane	srLib/SceneGraph/gl2ps.c	/^  GL2PSplane plane;$/;"	m	struct:_GL2PSbsptree2d	file:
pload	Eigen/src/Core/GenericPacketMath.h	/^pload(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return vec_ld(0, from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float* from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*   from) { EIGEN_DEBUG_ALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pload <Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pload <Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_ALIGNED_LOAD return Packet2cf(pload<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pload<Packet2d>(const double*  from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_pd(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pload<Packet4f>(const float*   from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_ps(from); }$/;"	f	namespace:Eigen::internal
pload	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pload<Packet4i>(const int*     from) { EIGEN_DEBUG_ALIGNED_LOAD return _mm_load_si128(reinterpret_cast<const Packet4i*>(from)); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/GenericPacketMath.h	/^ploaddup(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>*     from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploaddup<Packet1cd>(const std::complex<double>* from) { return pset1<Packet1cd>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploaddup<Packet2cf>(const std::complex<float>* from) { return pset1<Packet2cf>(*from); }$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploaddup<Packet2d>(const double*  from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploaddup<Packet4f>(const float*   from)$/;"	f	namespace:Eigen::internal
ploaddup	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploaddup<Packet4i>(const int*     from)$/;"	f	namespace:Eigen::internal
ploadt	Eigen/src/Core/GenericPacketMath.h	/^inline Packet ploadt(const typename unpacket_traits<Packet>::type* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/GenericPacketMath.h	/^ploadu(const typename unpacket_traits<Packet>::type* from) { return *from; }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>((const float*)from)); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from) { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_f32(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)   { EIGEN_DEBUG_UNALIGNED_LOAD return vld1q_s32(from); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd ploadu<Packet1cd>(const std::complex<double>* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf ploadu<Packet2cf>(const std::complex<float>* from) { EIGEN_DEBUG_UNALIGNED_LOAD return Packet2cf(ploadu<Packet4f>(&numext::real_ref(*from))); }$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^  template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float*  from) {$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d ploadu<Packet2d>(const double* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f ploadu<Packet4f>(const float* from)$/;"	f	namespace:Eigen::internal
ploadu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i ploadu<Packet4i>(const int* from)$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/GenericPacketMath.h	/^Packet plog(const Packet& a) { using std::log; return log(a); }$/;"	f	namespace:Eigen::internal
plog	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f plog<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/GenericPacketMath.h	/^plset(const Scalar& a) { return a; }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return vec_add(pset1<Packet4f>(a), p4f_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)     { return vec_add(pset1<Packet4i>(a), p4i_COUNTDOWN); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a)$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a)$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d plset<double>(const double& a) { return _mm_add_pd(pset1<Packet2d>(a),_mm_set_pd(1,0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f plset<float>(const float& a) { return _mm_add_ps(pset1<Packet4f>(a), _mm_set_ps(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
plset	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i plset<int>(const int& a) { return _mm_add_epi32(pset1<Packet4i>(a),_mm_set_epi32(3,2,1,0)); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/GenericPacketMath.h	/^pmadd(const Packet&  a,$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vec_madd(a, b, c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmadd(const Packet4f& a, const Packet4f& b, const Packet4f& c) { return vmlaq_f32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return vmlaq_s32(c,a,b); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet1cd& x, const Packet2d& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmadd(const Packet2d& x, const Packet1cd& y, const Packet1cd& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet2cf& x, const Packet4f& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmadd(const Packet4f& x, const Packet2cf& y, const Packet2cf& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmadd(const Packet4i& a, const Packet4i& b, const Packet4i& c) { return padd(pmul(a,b), c); }$/;"	f	namespace:Eigen::internal
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const LhsScalar& x, const RhsScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const RealScalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const RealScalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const { return internal::pmadd(x,y,c); }$/;"	f	struct:Eigen::internal::conj_helper
pmadd	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmadd(const Scalar& x, const Scalar& y, const Scalar& c) const$/;"	f	struct:Eigen::internal::conj_helper
pmax	Eigen/src/Core/GenericPacketMath.h	/^pmax(const Packet& a,$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_max(a, b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmaxq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmaxq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmax<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_max_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmax<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_max_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmax	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmax<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/GenericPacketMath.h	/^pmin(const Packet& a,$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_min(a, b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return vminq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b) { return vminq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmin<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_min_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmin<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_min_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmin	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmin<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/GenericPacketMath.h	/^pmul(const Packet& a,$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<double> pmul(const std::complex<double>& a, const std::complex<double>& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/GenericPacketMath.h	/^template<> inline std::complex<float> pmul(const std::complex<float>& a, const std::complex<float>& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_madd(a,b,p4f_ZERO); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return vmulq_f32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b) { return vmulq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& a, const Packet1cd& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet1cd& x, const Packet2d& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet1cd pmul(const Packet2d& x, const Packet1cd& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& a, const Packet2cf& b) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet2cf& x, const Packet4f& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^  EIGEN_STRONG_INLINE Packet2cf pmul(const Packet4f& x, const Packet2cf& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pmul<Packet1cd>(const Packet1cd& a, const Packet1cd& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pmul<Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pmul<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_mul_pd(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pmul<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_mul_ps(a,b); }$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pmul<Packet4i>(const Packet4i& a, const Packet4i& b)$/;"	f	namespace:Eigen::internal
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const LhsScalar& x, const RhsScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const RealScalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const RealScalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const { return internal::pmul(x,y); }$/;"	f	struct:Eigen::internal::conj_helper
pmul	Eigen/src/Core/util/BlasUtil.h	/^  EIGEN_STRONG_INLINE Scalar pmul(const Scalar& x, const Scalar& y) const$/;"	f	struct:Eigen::internal::conj_helper
pnegate	Eigen/src/Core/GenericPacketMath.h	/^pnegate(const Packet& a) { return -a; }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return psub<Packet4f>(p4f_ZERO, a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return psub<Packet4i>(p4i_ZERO, a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a) { return Packet2cf(pnegate<Packet4f>(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a) { return vnegq_f32(a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a) { return vnegq_s32(a); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pnegate(const Packet1cd& a) { return Packet1cd(pnegate(a.v)); }$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pnegate(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pnegate(const Packet2d& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pnegate(const Packet4f& a)$/;"	f	namespace:Eigen::internal
pnegate	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pnegate(const Packet4i& a)$/;"	f	namespace:Eigen::internal
png_jmpbuf	srLib/SceneGraph/gl2ps.c	/^#  define png_jmpbuf(/;"	d	file:
pointAt	Eigen/src/Geometry/ParametrizedLine.h	/^ParametrizedLine<_Scalar, _AmbientDim,_Options>::pointAt(const _Scalar& t) const$/;"	f	class:Eigen::ParametrizedLine
pointer	Eigen/src/Core/util/Memory.h	/^  typedef T*              pointer;$/;"	t	class:Eigen::aligned_allocator
pointer	Eigen/src/StlSupport/details.h	/^    typedef T*        pointer;$/;"	t	class:Eigen::aligned_allocator_indirection
points	srLib/SceneGraph/Leaf.h	/^	list<Vec3>	points;$/;"	m	class:ColorPointGroup
points	srLib/SceneGraph/Leaf.h	/^	vector<Vec3>		points;$/;"	m	class:Polygon
pop	srLib/LieGroup/_array.h	/^	void pop(int idx)$/;"	f	class:_array
por	Eigen/src/Core/GenericPacketMath.h	/^por(const Packet& a, const Packet& b) { return a | b; }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_or(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_or(a, b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return vorrq_s32(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd por    <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_or_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf por    <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_or_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d por<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_or_pd(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f por<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_or_ps(a,b); }$/;"	f	namespace:Eigen::internal
por	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i por<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_or_si128(a,b); }$/;"	f	namespace:Eigen::internal
pos	srLib/SceneGraph/Leaf.h	/^		Vec3        pos;$/;"	m	struct:Lines::PTY
pos	srLib/SceneGraph/Model3DS.h	/^		Vector	pos;				\/\/ The position to move the object to$/;"	m	struct:Model3DS::Object
pos	srLib/SceneGraph/Model3DS.h	/^	Vector	pos;				\/\/ The position to move the model to$/;"	m	class:Model3DS
pos	srLib/srDyn/srCollisionPair.cpp	/^	dVector3 pos;$/;"	m	struct:dContactGeom	file:
position	srLib/SceneGraph/Light.h	/^	float			position[4];$/;"	m	class:Light
pow	Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const Eigen::ArrayBase<Derived>& exponents) $/;"	f	namespace:Eigen
pow	Eigen/src/Core/GlobalFunctions.h	/^  pow(const Eigen::ArrayBase<Derived>& x, const typename Derived::Scalar& exponent) {$/;"	f	namespace:Eigen
pow	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(pow, Scalar) pow(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::numext
pow	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::pow(const Scalar& exponent) const$/;"	f	class:Eigen::Cwise
pow	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^pow(const Scalar& exponent) const$/;"	f
pow_default_impl	Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl$/;"	s	namespace:Eigen::internal
pow_default_impl	Eigen/src/Core/MathFunctions.h	/^struct pow_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
pow_impl	Eigen/src/Core/MathFunctions.h	/^struct pow_impl : pow_default_impl<Scalar, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
pow_retval	Eigen/src/Core/MathFunctions.h	/^struct pow_retval$/;"	s	namespace:Eigen::internal
precision	Eigen/src/Core/IO.h	/^  int precision;$/;"	m	struct:Eigen::IOFormat
precision	Eigen/src/Eigen2Support/MathFunctions.h	/^template<typename T> inline T precision () { return NumTraits<T>::dummy_precision(); }$/;"	f	namespace:Eigen
preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Preconditioner& preconditioner() { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
preconditioner	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  const Preconditioner& preconditioner() const { return m_preconditioner; }$/;"	f	class:Eigen::IterativeSolverBase
predux	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_max_op
predux	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_min_op
predux	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const Scalar predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_sum_op
predux	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE const result_type predux(const Packet& a) const$/;"	f	struct:Eigen::internal::scalar_product_op
predux	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux(const Packet& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a) { return pfirst(_mm_hadd_pd(a, a)); }$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_max(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_max<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_max<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_max	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_max<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_min(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_min<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_min<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_min	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_min<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline typename unpacket_traits<Packet>::type predux_mul(const Packet& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<double> predux_mul<Packet1cd>(const Packet1cd& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE std::complex<float> predux_mul<Packet2cf>(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE double predux_mul<Packet2d>(const Packet2d& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE float predux_mul<Packet4f>(const Packet4f& a)$/;"	f	namespace:Eigen::internal
predux_mul	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE int predux_mul<Packet4i>(const Packet4i& a)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/GenericPacketMath.h	/^preduxp(const Packet* vecs) { return vecs[0]; }$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preduxp<Packet1cd>(const Packet1cd* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preduxp<Packet2cf>(const Packet2cf* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preduxp<Packet2d>(const Packet2d* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preduxp<Packet4f>(const Packet4f* vecs)$/;"	f	namespace:Eigen::internal
preduxp	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preduxp<Packet4i>(const Packet4i* vecs)$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar> inline void prefetch(const Scalar* addr)$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { vec_dstt((float *)addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { vec_dstt(addr, DST_CTRL(2,2,32), DST_CHAN); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { EIGEN_ARM_PREFETCH((float *)addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float* addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*     addr) { EIGEN_ARM_PREFETCH(addr); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<double> >(const std::complex<double> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void prefetch<std::complex<float> >(const std::complex<float> *   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<double>(const double* addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<float>(const float*   addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prefetch	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void prefetch<int>(const int*       addr) { _mm_prefetch((const char*)(addr), _MM_HINT_T0); }$/;"	f	namespace:Eigen::internal
prerotate	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
prerotate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prerotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
prescale	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prescale	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::prescale(Scalar s)$/;"	f	class:Eigen::Transform
prescale	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::prescale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prescale	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::prescale(const Scalar& s)$/;"	f	class:Eigen::Transform
preshear	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::preshear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform
preshear	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::preshear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform
pretranslate	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
pretranslate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::pretranslate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
prev	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index prev ;  \/* previous column in degree list, if col is in a *\/$/;"	m	union:internal::colamd_col::__anon351
preverse	Eigen/src/Core/GenericPacketMath.h	/^template<typename Packet> inline Packet preverse(const Packet& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) { return (Packet4f)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) { return (Packet4i)vec_perm((Packet16uc)a,(Packet16uc)a, p16uc_REVERSE); }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a) {$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a) {$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd preverse(const Packet1cd& a) { return a; }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf preverse(const Packet2cf& a) { return Packet2cf(_mm_castpd_ps(preverse(_mm_castps_pd(a.v)))); }$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d preverse(const Packet2d& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f preverse(const Packet4f& a)$/;"	f	namespace:Eigen::internal
preverse	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i preverse(const Packet4i& a)$/;"	f	namespace:Eigen::internal
primitives	srLib/SceneGraph/gl2ps.c	/^  GL2PSlist *primitives, *auxprimitives;$/;"	m	struct:__anon15	file:
primitives	srLib/SceneGraph/gl2ps.c	/^  GL2PSlist *primitives;$/;"	m	struct:_GL2PSbsptree	file:
primitivetoadd	srLib/SceneGraph/gl2ps.c	/^  GL2PSprimitive *primitivetoadd;$/;"	m	struct:__anon15	file:
printFinalPrimitive	srLib/SceneGraph/gl2ps.c	/^  void  (*printFinalPrimitive)(void);$/;"	m	struct:__anon16	file:
printFooter	srLib/SceneGraph/gl2ps.c	/^  void  (*printFooter)(void);$/;"	m	struct:__anon16	file:
printHeader	srLib/SceneGraph/gl2ps.c	/^  void  (*printHeader)(void);$/;"	m	struct:__anon16	file:
printPrimitive	srLib/SceneGraph/gl2ps.c	/^  void  (*printPrimitive)(void *data);$/;"	m	struct:__anon16	file:
print_matrix	Eigen/src/Core/IO.h	/^std::ostream & print_matrix(std::ostream & s, const Derived& _m, const IOFormat& fmt)$/;"	f	namespace:Eigen::internal
priority	srLib/SceneGraph/node.h	/^	unsigned int			priority;$/;"	m	class:Node
prod	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::prod() const$/;"	f	class:Eigen::DenseBase
prod	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_prod>::Type prod() const$/;"	f	class:Eigen::VectorwiseOp
producer	srLib/SceneGraph/gl2ps.c	/^  char *title, *producer, *filename;$/;"	m	struct:__anon15	file:
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, 1, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<DefaultTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, 0, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, Dynamic, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_impl<InnerVectorizedTraversal, UnrollingIndex, Lhs, Rhs, RetScalar>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,1,RhsCols>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_dyn_selector	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_dyn_selector<Lhs,Rhs,LhsRows,1>$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller$/;"	s	namespace:Eigen::internal
product_coeff_vectorized_unroller	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_coeff_vectorized_unroller<0, Lhs, Rhs, Packet>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<ColMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 0, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, 1, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, Dynamic, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_packet_impl	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct product_packet_impl<RowMajor, UnrollingIndex, Lhs, Rhs, Packet, LoadMode>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,LhsSelfAdjoint,ConjugateLhs, RhsStorageOrder,RhsSelfAdjoint,ConjugateRhs,RowMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_selfadjoint_matrix	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>$/;"	s	namespace:Eigen::internal
product_size_category	Eigen/src/Core/GeneralProduct.h	/^template<int Size, int MaxSize> struct product_size_category$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,LhsIsTriangular,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,false,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct product_triangular_matrix_matrix<Scalar,Index,Mode,true,$/;"	s	namespace:Eigen::internal
product_triangular_matrix_matrix_trmm	Eigen/src/Core/products/TriangularMatrixMatrix_MKL.h	/^struct product_triangular_matrix_matrix_trmm :$/;"	s	namespace:Eigen::internal
product_type	Eigen/src/Core/GeneralProduct.h	/^template<typename Lhs, typename Rhs> struct product_type$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	s	namespace:Eigen::internal
product_type_selector	Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	s	namespace:Eigen::internal
projection	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane
projection	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
projection	Eigen/src/Geometry/Hyperplane.h	/^  inline VectorType projection(const VectorType& p) const { return p - signedDistance(p) * normal(); }$/;"	f	class:Eigen::Hyperplane
projection	Eigen/src/Geometry/ParametrizedLine.h	/^  VectorType projection(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
projective_transform_inverse	Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse$/;"	s	namespace:Eigen::internal
projective_transform_inverse	Eigen/src/Geometry/Transform.h	/^struct projective_transform_inverse<TransformType, Projective>$/;"	s	namespace:Eigen::internal
promote_index_type	Eigen/src/Core/util/XprHelper.h	/^struct promote_index_type$/;"	s	namespace:Eigen::internal
promote_storage_type	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Dense,Sparse>$/;"	s	namespace:Eigen::internal
promote_storage_type	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^template<> struct promote_storage_type<Sparse,Dense>$/;"	s	namespace:Eigen::internal
prop	srLib/SceneGraph/gl2ps.c	/^  int prop;$/;"	m	struct:__anon8	file:
prune	Eigen/src/SparseCore/CompressedStorage.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::internal::CompressedStorage
prune	Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const KeepFunc& keep = KeepFunc())$/;"	f	class:Eigen::SparseMatrix
prune	Eigen/src/SparseCore/SparseMatrix.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseMatrix
prune	Eigen/src/SparseCore/SparseVector.h	/^    void prune(const Scalar& reference, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision())$/;"	f	class:Eigen::SparseVector
pruneL	Eigen/src/SparseLU/SparseLU_pruneL.h	/^void SparseLUImpl<Scalar,Index>::pruneL(const Index jcol, const IndexVector& perm_r, const Index pivrow, const Index nseg, const IndexVector& segrep, BlockIndexVector repfnz, IndexVector& xprune, GlobalLU_t& glu)$/;"	f	class:Eigen::internal::SparseLUImpl
pruned	Eigen/src/SparseCore/SparseProduct.h	/^    SparseSparseProduct pruned(const Scalar& reference = 0, const RealScalar& epsilon = NumTraits<RealScalar>::dummy_precision()) const$/;"	f	class:Eigen::SparseSparseProduct
pset1	Eigen/src/Core/GenericPacketMath.h	/^pset1(const typename unpacket_traits<Packet>::type& a) { return a; }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   {$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return vdupq_n_f32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from)   { return vdupq_n_s32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pset1<Packet1cd>(const std::complex<double>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pset1<Packet2cf>(const std::complex<float>&  from)$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set1_pd(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pset1<Packet2d>(const double& from) { return _mm_set_pd(from,from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set1_ps(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pset1<Packet4f>(const float&  from) { return _mm_set_ps(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set1_epi32(from); }$/;"	f	namespace:Eigen::internal
pset1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pset1<Packet4i>(const int&    from) { return _mm_set_epi32(from,from,from,from); }$/;"	f	namespace:Eigen::internal
pseudoEigenvalueMatrix	Eigen/src/Eigenvalues/EigenSolver.h	/^MatrixType EigenSolver<MatrixType>::pseudoEigenvalueMatrix() const$/;"	f	class:Eigen::EigenSolver
pseudoEigenvectors	Eigen/src/Eigenvalues/EigenSolver.h	/^    const MatrixType& pseudoEigenvectors() const$/;"	f	class:Eigen::EigenSolver
psin	Eigen/src/Core/GenericPacketMath.h	/^Packet psin(const Packet& a) { using std::sin; return sin(a); }$/;"	f	namespace:Eigen::internal
psin	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psin<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/GenericPacketMath.h	/^Packet psqrt(const Packet& a) { using std::sqrt; return sqrt(a); }$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^Packet4f psqrt<Packet4f>(const Packet4f& _x)$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^template<> EIGEN_STRONG_INLINE Packet2d psqrt<Packet2d>(const Packet2d& x) { return _mm_sqrt_pd(x); }$/;"	f	namespace:Eigen::internal
psqrt	Eigen/src/Core/arch/SSE/MathFunctions.h	/^template<> EIGEN_STRONG_INLINE Packet4f psqrt<Packet4f>(const Packet4f& x) { return _mm_sqrt_ps(x); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstore(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vec_st(from, 0, to); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_ALIGNED_STORE pstore((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstore <std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_ALIGNED_STORE pstore(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<double>(double* to, const Packet2d& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_pd(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<float>(float*   to, const Packet4f& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_ps(to, from); }$/;"	f	namespace:Eigen::internal
pstore	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore<int>(int*       to, const Packet4i& from) { EIGEN_DEBUG_ALIGNED_STORE _mm_store_si128(reinterpret_cast<Packet4i*>(to), from); }$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/GenericPacketMath.h	/^inline void pstore1(typename unpacket_traits<Packet>::type* to, const typename unpacket_traits<Packet>::type& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet2d>(double* to, const double& a)$/;"	f	namespace:Eigen::internal
pstore1	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstore1<Packet4f>(float* to, const float& a)$/;"	f	namespace:Eigen::internal
pstoret	Eigen/src/Core/GenericPacketMath.h	/^inline void pstoret(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/GenericPacketMath.h	/^template<typename Scalar, typename Packet> inline void pstoreu(Scalar* to, const Packet& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from)$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((float*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_f32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE vst1q_s32(to, from); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<double> >(std::complex<double> *   to, const Packet1cd& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu((double*)to, from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<std::complex<float> >(std::complex<float> *   to, const Packet2cf& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(&numext::real_ref(*to), from.v); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<double>(double* to, const Packet2d& from) {$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<float>(float*  to, const Packet4f& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castps_pd(from)); }$/;"	f	namespace:Eigen::internal
pstoreu	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE void pstoreu<int>(int*      to, const Packet4i& from) { EIGEN_DEBUG_UNALIGNED_STORE pstoreu(reinterpret_cast<double*>(to), _mm_castsi128_pd(from)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/GenericPacketMath.h	/^psub(const Packet& a,$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_sub(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_sub(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(psub<Packet4f>(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return vsubq_f32(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return vsubq_s32(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd psub<Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_sub_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf psub<Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_sub_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d psub<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_sub_pd(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f psub<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_sub_ps(a,b); }$/;"	f	namespace:Eigen::internal
psub	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i psub<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_sub_epi32(a,b); }$/;"	f	namespace:Eigen::internal
ptan	Eigen/src/Core/GenericPacketMath.h	/^Packet ptan(const Packet& a) { using std::tan; return tan(a); }$/;"	f	namespace:Eigen::internal
ptrlist	srLib/SceneGraph/gl2ps.c	/^  GL2PSlist* ptrlist;$/;"	m	struct:__anon14	file:
punpackp	Eigen/src/Core/arch/SSE/PacketMath.h	/^EIGEN_STRONG_INLINE void punpackp(Packet4f* vecs)$/;"	f	namespace:Eigen::internal
pushDownZero	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::pushDownZero(Index z, Index f, Index l)$/;"	f	class:Eigen::RealQZ
push_back	Eigen/src/StlSupport/StdDeque.h	/^  void push_back(const value_type& x)$/;"	f	class:std::deque
push_back	Eigen/src/StlSupport/StdList.h	/^    void push_back(const value_type& x)$/;"	f	class:std::list
push_back	Eigen/src/StlSupport/StdVector.h	/^  void push_back(const value_type& x)$/;"	f	class:std::vector
push_front	Eigen/src/StlSupport/StdDeque.h	/^  void push_front(const value_type& x)$/;"	f	class:std::deque
px	srLib/SceneGraph/Camera.h	/^	GLint			px;$/;"	m	class:Camera
pxor	Eigen/src/Core/GenericPacketMath.h	/^pxor(const Packet& a, const Packet& b) { return a ^ b; }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(vec_xor(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return vec_xor(a, b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b)$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return veorq_s32(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet1cd pxor   <Packet1cd>(const Packet1cd& a, const Packet1cd& b) { return Packet1cd(_mm_xor_pd(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/Complex.h	/^template<> EIGEN_STRONG_INLINE Packet2cf pxor   <Packet2cf>(const Packet2cf& a, const Packet2cf& b) { return Packet2cf(_mm_xor_ps(a.v,b.v)); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet2d pxor<Packet2d>(const Packet2d& a, const Packet2d& b) { return _mm_xor_pd(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4f pxor<Packet4f>(const Packet4f& a, const Packet4f& b) { return _mm_xor_ps(a,b); }$/;"	f	namespace:Eigen::internal
pxor	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> EIGEN_STRONG_INLINE Packet4i pxor<Packet4i>(const Packet4i& a, const Packet4i& b) { return _mm_xor_si128(a,b); }$/;"	f	namespace:Eigen::internal
py	srLib/SceneGraph/Camera.h	/^	GLint			py;$/;"	m	class:Camera
qnxnto	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^char const* qnxnto = "INFO" ":" "qnxnto[]";$/;"	v
qnxnto	build/CMakeFiles/3.6.2/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* qnxnto = "INFO" ":" "qnxnto[]";$/;"	v
qr	Eigen/src/Eigen2Support/QR.h	/^MatrixBase<Derived>::qr() const$/;"	f	class:Eigen::MatrixBase
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^> struct qr_preconditioner_impl {};$/;"	s	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, ColPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, FullPivHouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreColsThanRows, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, HouseholderQRPreconditioner, PreconditionIfMoreRowsThanCols, true>$/;"	c	namespace:Eigen::internal
qr_preconditioner_impl	Eigen/src/SVD/JacobiSVD.h	/^class qr_preconditioner_impl<MatrixType, QRPreconditioner, Case, false>$/;"	c	namespace:Eigen::internal
qr_preconditioner_should_do_anything	Eigen/src/SVD/JacobiSVD.h	/^struct qr_preconditioner_should_do_anything$/;"	s	namespace:Eigen::internal
quat_product	Eigen/src/Geometry/Quaternion.h	/^template<int Arch, class Derived1, class Derived2, typename Scalar, int _Options> struct quat_product$/;"	s	namespace:Eigen::internal
quat_product	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, double, Aligned>$/;"	s	namespace:Eigen::internal
quat_product	Eigen/src/Geometry/arch/Geometry_SSE.h	/^struct quat_product<Architecture::SSE, Derived, OtherDerived, float, Aligned>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,3,3>$/;"	s	namespace:Eigen::internal
quaternionbase_assign_impl	Eigen/src/Geometry/Quaternion.h	/^struct quaternionbase_assign_impl<Other,4,1>$/;"	s	namespace:Eigen::internal
queryCacheSizes	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_amd	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_amd(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel(int& l1, int& l2, int& l3, int max_std_funcs)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_codes	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_codes(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryCacheSizes_intel_direct	Eigen/src/Core/util/Memory.h	/^inline void queryCacheSizes_intel_direct(int& l1, int& l2, int& l3)$/;"	f	namespace:Eigen::internal
queryL1CacheSize	Eigen/src/Core/util/Memory.h	/^inline int queryL1CacheSize()$/;"	f	namespace:Eigen::internal
queryTopLevelCacheSize	Eigen/src/Core/util/Memory.h	/^inline int queryTopLevelCacheSize()$/;"	f	namespace:Eigen::internal
r	srLib/SceneGraph/Camera.h	/^	double		   r;$/;"	m	class:Camera
r	srLib/SceneGraph/Leaf.h	/^	double				r, g, b, alpha;$/;"	m	class:Polygon
r	srLib/SceneGraph/Leaf.h	/^	double r;$/;"	m	class:ColorPoint
r	srLib/SceneGraph/Leaf.h	/^	double r;$/;"	m	class:ColorPointGroup
r	srLib/SceneGraph/Model3DS.h	/^		unsigned char r;$/;"	m	struct:Model3DS::Color4i
rFriction_coeff	srLib/srDyn/srContactConstraint.h	/^	SR_REAL			rFriction_coeff;$/;"	m	class:ContactConstraint
rRestitution_coeff	srLib/srDyn/srContactConstraint.h	/^	SR_REAL			rRestitution_coeff;$/;"	m	class:ContactConstraint
r_joint_	Example/DracoP1/draco.h	/^  std::vector<srRevoluteJoint*> r_joint_;$/;"	m	class:srDraco
r_joint_idx_map_	Example/DracoP1/draco.h	/^  std::map<std::string, int> r_joint_idx_map_;$/;"	m	class:srDraco
radius	srLib/SceneGraph/Leaf.h	/^	double	radius;$/;"	m	class:Sphere
radius	srLib/SceneGraph/Leaf.h	/^	double radius;$/;"	m	class:Cylinder
radius	srLib/SceneGraph/Leaf.h	/^	double radius;$/;"	m	class:DomeBase
random	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random()$/;"	f	namespace:Eigen::internal
random	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(random, Scalar) random(const Scalar& x, const Scalar& y)$/;"	f	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl {};$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
random_default_impl	Eigen/src/Core/MathFunctions.h	/^struct random_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
random_impl	Eigen/src/Core/MathFunctions.h	/^struct random_impl : random_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
random_impl	Eigen/src/Core/MathFunctions.h	/^template<> struct random_impl<bool>$/;"	s	namespace:Eigen::internal
random_retval	Eigen/src/Core/MathFunctions.h	/^struct random_retval$/;"	s	namespace:Eigen::internal
rank	Eigen/src/LU/FullPivLU.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivLU
rank	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::ColPivHouseholderQR
rank	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rank() const$/;"	f	class:Eigen::FullPivHouseholderQR
rank	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    Index rank() const$/;"	f	class:Eigen::SPQR
rank	Eigen/src/SVD/JacobiSVD.h	/^    inline Index rank() const$/;"	f	class:Eigen::JacobiSVD
rank	Eigen/src/SparseQR/SparseQR.h	/^    Index rank() const $/;"	f	class:Eigen::SparseQR
rank	Eigen/src/misc/Image.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::image_retval_base
rank	Eigen/src/misc/Kernel.h	/^  inline Index rank() const { return m_rank; }$/;"	f	struct:Eigen::internal::kernel_retval_base
rankUpdate	Eigen/src/Cholesky/LDLT.h	/^LDLT<MatrixType,_UpLo>& LDLT<MatrixType,_UpLo>::rankUpdate(const MatrixBase<Derived>& w, const typename LDLT<MatrixType,_UpLo>::RealScalar& sigma)$/;"	f	class:Eigen::LDLT
rankUpdate	Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index rankUpdate(MatrixType& mat, const VectorType& vec, const RealScalar& sigma)$/;"	f	struct:Eigen::internal::llt_inplace
rankUpdate	Eigen/src/Cholesky/LLT.h	/^LLT<_MatrixType,_UpLo> LLT<_MatrixType,_UpLo>::rankUpdate(const VectorType& v, const RealScalar& sigma)$/;"	f	class:Eigen::LLT
rankUpdate	Eigen/src/Core/products/SelfadjointProduct.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	Eigen/src/Core/products/SelfadjointRank2Update.h	/^::rankUpdate(const MatrixBase<DerivedU>& u, const MatrixBase<DerivedV>& v, const Scalar& alpha)$/;"	f	class:Eigen::SelfAdjointView
rankUpdate	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<MatrixType,UpLo>::rankUpdate(const SparseMatrixBase<DerivedU>& u, const Scalar& alpha)$/;"	f	class:Eigen::SparseSelfAdjointView
rawMatrix	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const CholMatrixType rawMatrix() const {$/;"	f	class:Eigen::SimplicialCholesky
readBinaryFloat	srLib/common/srSTL.h	/^	static double readBinaryFloat(FILE* in)$/;"	f	namespace:srSTL
readFromFile	srLib/srExt/srExt_Eigen.cpp	/^Eigen::MatrixXd Eigen::readFromFile(const std::string & fileName)$/;"	f	class:Eigen
readSTLfile	srLib/common/srSTL.h	/^	static STLc readSTLfile(string stl_filename, STLc & stl_list)$/;"	f	namespace:srSTL
real	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real, Scalar) real(const Scalar& x)$/;"	f	namespace:Eigen::numext
real	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() const { return derived(); }$/;"	f
real	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^real() { return derived(); }$/;"	f
real	Example/MobileRobots/MobileRobots.h	/^#define real /;"	d
real_2x2_jacobi_svd	Eigen/src/SVD/JacobiSVD.h	/^void real_2x2_jacobi_svd(const MatrixType& matrix, Index p, Index q,$/;"	f	namespace:Eigen::internal
real_default_impl	Eigen/src/Core/MathFunctions.h	/^struct real_default_impl$/;"	s	namespace:Eigen::internal
real_default_impl	Eigen/src/Core/MathFunctions.h	/^struct real_default_impl<Scalar,true>$/;"	s	namespace:Eigen::internal
real_impl	Eigen/src/Core/MathFunctions.h	/^template<typename Scalar> struct real_impl : real_default_impl<Scalar> {};$/;"	s	namespace:Eigen::internal
real_ref	Eigen/src/Core/MathFunctions.h	/^inline EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) real_ref(Scalar& x)$/;"	f	namespace:Eigen::numext
real_ref	Eigen/src/Core/MathFunctions.h	/^inline typename internal::add_const_on_value_type< EIGEN_MATHFUNC_RETVAL(real_ref, Scalar) >::type real_ref(const Scalar& x)$/;"	f	namespace:Eigen::numext
real_ref_impl	Eigen/src/Core/MathFunctions.h	/^struct real_ref_impl$/;"	s	namespace:Eigen::internal
real_ref_retval	Eigen/src/Core/MathFunctions.h	/^struct real_ref_retval$/;"	s	namespace:Eigen::internal
real_retval	Eigen/src/Core/MathFunctions.h	/^struct real_retval$/;"	s	namespace:Eigen::internal
reallocate	Eigen/src/SparseCore/AmbiVector.h	/^    void reallocate(Index size)$/;"	f	class:Eigen::internal::AmbiVector
reallocate	Eigen/src/SparseCore/CompressedStorage.h	/^    inline void reallocate(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
reallocateSparse	Eigen/src/SparseCore/AmbiVector.h	/^    void reallocateSparse()$/;"	f	class:Eigen::internal::AmbiVector
rebind	Eigen/src/Core/util/Memory.h	/^  struct rebind$/;"	s	class:Eigen::aligned_allocator
rebind	Eigen/src/StlSupport/details.h	/^    struct rebind$/;"	s	class:Eigen::aligned_allocator_indirection
recip_timestep	srLib/srDyn/srConstraint.h	/^	SR_REAL recip_timestep;$/;"	m	struct:ConstraintInfo
reconstructedMatrix	Eigen/src/Cholesky/LDLT.h	/^MatrixType LDLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LDLT
reconstructedMatrix	Eigen/src/Cholesky/LLT.h	/^MatrixType LLT<MatrixType,_UpLo>::reconstructedMatrix() const$/;"	f	class:Eigen::LLT
reconstructedMatrix	Eigen/src/LU/FullPivLU.h	/^MatrixType FullPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::FullPivLU
reconstructedMatrix	Eigen/src/LU/PartialPivLU.h	/^MatrixType PartialPivLU<MatrixType>::reconstructedMatrix() const$/;"	f	class:Eigen::PartialPivLU
reduceToTriangularForm	Eigen/src/Eigenvalues/ComplexSchur.h	/^void ComplexSchur<MatrixType>::reduceToTriangularForm(bool computeU)$/;"	f	class:Eigen::ComplexSchur
redux	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::redux(const Func& func) const$/;"	f	class:Eigen::DenseBase
redux	Eigen/src/Core/VectorwiseOp.h	/^    redux(const BinaryOp& func = BinaryOp()) const$/;"	f	class:Eigen::VectorwiseOp
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, DefaultTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, LinearVectorizedTraversal, NoUnrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func, Derived, SliceVectorizedTraversal, Unrolling>$/;"	s	namespace:Eigen::internal
redux_impl	Eigen/src/Core/Redux.h	/^struct redux_impl<Func,Derived, DefaultTraversal, CompleteUnrolling>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	Eigen/src/Core/Redux.h	/^struct redux_novec_unroller$/;"	s	namespace:Eigen::internal
redux_novec_unroller	Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 0>$/;"	s	namespace:Eigen::internal
redux_novec_unroller	Eigen/src/Core/Redux.h	/^struct redux_novec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
redux_traits	Eigen/src/Core/Redux.h	/^struct redux_traits$/;"	s	namespace:Eigen::internal
redux_vec_unroller	Eigen/src/Core/Redux.h	/^struct redux_vec_unroller$/;"	s	namespace:Eigen::internal
redux_vec_unroller	Eigen/src/Core/Redux.h	/^struct redux_vec_unroller<Func, Derived, Start, 1>$/;"	s	namespace:Eigen::internal
reference	Eigen/src/Core/util/Memory.h	/^  typedef T&              reference;$/;"	t	class:Eigen::aligned_allocator
reference	Eigen/src/SparseCore/SparseMatrix.h	/^    Scalar reference;$/;"	m	struct:Eigen::SparseMatrix::default_prunning_func
reference	Eigen/src/StlSupport/details.h	/^    typedef T&        reference;$/;"	t	class:Eigen::aligned_allocator_indirection
registerClearColor	srLib/SceneGraph/Camera.cpp	/^void Camera::registerClearColor()$/;"	f	class:Camera
relax	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index relax; \/\/ To control degree of relaxing supernodes. If the number of nodes (columns) $/;"	m	struct:Eigen::internal::perfvalues
relax_snode	Eigen/src/SparseLU/SparseLU_relax_snode.h	/^void SparseLUImpl<Scalar,Index>::relax_snode (const Index n, IndexVector& et, const Index relax_columns, IndexVector& descendants, IndexVector& relax_end)$/;"	f	class:Eigen::internal::SparseLUImpl
remove	srLib/LieGroup/_array.h	/^	void remove(const TYPE &value)$/;"	f	class:_array
removeNode	srLib/SceneGraph/Node.cpp	/^void Node::removeNode( Node* node )$/;"	f	class:Node
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_all	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_const	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	s	namespace:Eigen::internal
remove_pointer	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_pointer	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	s	namespace:Eigen::internal
remove_reference	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	s	namespace:Eigen::internal
render	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::render()$/;"	f	class:SceneGraphRenderer
render2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::render2()$/;"	f	class:SceneGraphRenderer
replicate	Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate() const$/;"	f	class:Eigen::DenseBase
replicate	Eigen/src/Core/Replicate.h	/^DenseBase<Derived>::replicate(Index rowFactor,Index colFactor) const$/;"	f	class:Eigen::DenseBase
replicate	Eigen/src/Core/Replicate.h	/^VectorwiseOp<ExpressionType,Direction>::replicate(Index factor) const$/;"	f	class:Eigen::VectorwiseOp
replicate	Eigen/src/Core/VectorwiseOp.h	/^    replicate(Index factor = Factor) const$/;"	f	class:Eigen::VectorwiseOp
res	Eigen/src/Core/Visitor.h	/^  Scalar res;$/;"	m	struct:Eigen::internal::coeff_visitor
reserve	Eigen/src/SparseCore/CompressedStorage.h	/^    void reserve(size_t size)$/;"	f	class:Eigen::internal::CompressedStorage
reserve	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(Index reserveSize)$/;"	f	class:Eigen::SparseMatrix
reserve	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::Scalar& enableif =$/;"	f	class:Eigen::SparseMatrix
reserve	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserve(const SizesType& reserveSizes, const typename SizesType::value_type& enableif = typename SizesType::value_type())$/;"	f	class:Eigen::SparseMatrix
reserve	Eigen/src/SparseCore/SparseVector.h	/^    inline void reserve(Index reserveSize) { m_data.reserve(reserveSize); }$/;"	f	class:Eigen::SparseVector
reserveInnerVectors	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void reserveInnerVectors(const SizesType& reserveSizes)$/;"	f	class:Eigen::SparseMatrix
reshape	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::reshape(int w, int h)$/;"	f	class:SceneGraphRenderer
reshape2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::reshape2( int w, int h )$/;"	f	class:SceneGraphRenderer
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::ArrayWrapper
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index nbRows, Index nbCols) { m_expression.const_cast_derived().resize(nbRows,nbCols); }$/;"	f	class:Eigen::MatrixWrapper
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::ArrayWrapper
resize	Eigen/src/Core/ArrayWrapper.h	/^    void resize(Index newSize) { m_expression.const_cast_derived().resize(newSize); }$/;"	f	class:Eigen::MatrixWrapper
resize	Eigen/src/Core/DenseBase.h	/^    void resize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::DenseBase
resize	Eigen/src/Core/DenseBase.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::DenseBase
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex nbRows, DenseIndex)$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    EIGEN_STRONG_INLINE void resize(DenseIndex size, DenseIndex, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex size, DenseIndex nbRows, DenseIndex nbCols)$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex nbRows, DenseIndex nbCols) { m_rows = nbRows; m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex nbRows, DenseIndex) { m_rows = nbRows; }$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex, DenseIndex, DenseIndex nbCols) { m_cols = nbCols; }$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DenseStorage.h	/^    void resize(DenseIndex,DenseIndex,DenseIndex) {}$/;"	f	class:Eigen::DenseStorage
resize	Eigen/src/Core/DiagonalMatrix.h	/^    inline void resize(Index size) { m_diagonal.resize(size); }$/;"	f	class:Eigen::DiagonalMatrix
resize	Eigen/src/Core/PermutationMatrix.h	/^    inline void resize(Index newSize)$/;"	f	class:Eigen::PermutationBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resize(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index nbRows, NoChange_t)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(Index size)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/PlainObjectBase.h	/^    inline void resize(NoChange_t, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
resize	Eigen/src/Core/Transpositions.h	/^    inline void resize(int newSize)$/;"	f	class:Eigen::TranspositionsBase
resize	Eigen/src/SparseCore/AmbiVector.h	/^    void resize(Index size)$/;"	f	class:Eigen::internal::AmbiVector
resize	Eigen/src/SparseCore/CompressedStorage.h	/^    void resize(size_t size, double reserveSizeFactor = 0)$/;"	f	class:Eigen::internal::CompressedStorage
resize	Eigen/src/SparseCore/SparseMatrix.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseMatrix
resize	Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index newSize)$/;"	f	class:Eigen::SparseVector
resize	Eigen/src/SparseCore/SparseVector.h	/^    void resize(Index rows, Index cols)$/;"	f	class:Eigen::SparseVector
resize	Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size)$/;"	f	class:std::deque
resize	Eigen/src/StlSupport/StdDeque.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::deque
resize	Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size)$/;"	f	class:std::list
resize	Eigen/src/StlSupport/StdList.h	/^    void resize(size_type new_size, const value_type& x)$/;"	f	class:std::list
resize	Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size)$/;"	f	class:std::vector
resize	Eigen/src/StlSupport/StdVector.h	/^  void resize(size_type new_size, const value_type& x)$/;"	f	class:std::vector
resizeLike	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void resizeLike(const EigenBase<OtherDerived>& _other)$/;"	f	class:Eigen::PlainObjectBase
resizeNonZeros	Eigen/src/SparseCore/SparseMatrix.h	/^    void resizeNonZeros(Index size)$/;"	f	class:Eigen::SparseMatrix
resizeNonZeros	Eigen/src/SparseCore/SparseVector.h	/^    void resizeNonZeros(Index size) { m_data.resize(size); }$/;"	f	class:Eigen::SparseVector
restart	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::restart()$/;"	f	class:Eigen::internal::AmbiVector
result	Eigen/src/Core/ProductBase.h	/^      Matrix<Scalar,1,1> result = *this;$/;"	m	class:Eigen::ProductBase
result_of	Eigen/src/Core/Functors.h	/^struct result_of<scalar_cmp_op<Scalar, Cmp>(Scalar,Scalar)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^struct result_of<Func(ArgType0,ArgType1)> {$/;"	s	namespace:Eigen::internal
result_of	Eigen/src/Core/util/Meta.h	/^template<typename T> struct result_of {};$/;"	s	namespace:Eigen::internal
result_type	Eigen/src/Core/Functors.h	/^  typedef NewType result_type;$/;"	t	struct:Eigen::internal::scalar_cast_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs2_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_abs_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_imag_ref_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename NumTraits<Scalar>::Real result_type;$/;"	t	struct:Eigen::internal::scalar_real_ref_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_conj_product_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_product_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<LhsScalar,RhsScalar>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_quotient_op
result_type	Eigen/src/Core/Functors.h	/^  typedef typename scalar_product_traits<Scalar1,Scalar2>::ReturnType result_type;$/;"	t	struct:Eigen::internal::scalar_multiple2_op
result_type	Eigen/src/Core/VectorwiseOp.h	/^                   >::type  result_type;$/;"	t	struct:Eigen::internal::member_redux
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon235
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = 0 };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon237
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::InnerStrideAtCompileTime };$/;"	e	enum:Eigen::internal::inner_stride_at_compile_time::__anon234
ret	Eigen/src/Core/DenseCoeffsBase.h	/^  enum { ret = traits<Derived>::OuterStrideAtCompileTime };$/;"	e	enum:Eigen::internal::outer_stride_at_compile_time::__anon236
ret	Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_has_linear_access { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon67
ret	Eigen/src/Core/Functors.h	/^template<typename Functor> struct functor_is_product_like { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon69
ret	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_conj_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon71
ret	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_product_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon70
ret	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct functor_is_product_like<scalar_quotient_op<LhsScalar,RhsScalar> > { enum { ret = 1 }; };$/;"	e	enum:Eigen::internal::functor_is_product_like::__anon72
ret	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct functor_has_linear_access<scalar_identity_op<Scalar> > { enum { ret = 0 }; };$/;"	e	enum:Eigen::internal::functor_has_linear_access::__anon68
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    1,    1>      { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon288
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon296
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Large,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon295
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon297
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<1,    Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon290
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon294
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Large>  { enum { ret = GemvProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon299
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon298
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon304
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon307
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon302
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Large,Small,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon305
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Large, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon293
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small, Small, 1>    { enum { ret = LazyCoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon292
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Large>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon300
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,1,    Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon289
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon303
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Large,Small>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon306
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Large>  { enum { ret = GemmProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon301
ret	Eigen/src/Core/GeneralProduct.h	/^template<>              struct product_type_selector<Small,Small,Small>  { enum { ret = CoeffBasedProductMode }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon291
ret	Eigen/src/Core/GeneralProduct.h	/^template<int Depth>     struct product_type_selector<1,    1,    Depth>  { enum { ret = InnerProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon287
ret	Eigen/src/Core/GeneralProduct.h	/^template<int M, int N>  struct product_type_selector<M,N,1>              { enum { ret = OuterProduct }; };$/;"	e	enum:Eigen::internal::product_type_selector::__anon286
ret	Eigen/src/Core/Transpose.h	/^  enum { ret =    bool(blas_traits<DerivedA>::IsTransposed) != DestIsTransposed$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon326
ret	Eigen/src/Core/Transpose.h	/^  enum { ret = bool(blas_traits<OtherDerived>::IsTransposed) != DestIsTransposed };$/;"	e	enum:Eigen::internal::check_transpose_aliasing_compile_time_selector::__anon325
ret	Eigen/src/Core/util/ForwardDeclarations.h	/^  enum { ret = (traits<Derived>::Flags & DirectAccessBit) ? 1 : 0 };$/;"	e	enum:Eigen::internal::has_direct_access::__anon145
ret	Eigen/src/Core/util/Meta.h	/^    enum { ret = meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::internal::__anon191
ret	Eigen/src/Core/util/Meta.h	/^class meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:Eigen::meta_sqrt::__anon192
ret	Eigen/src/Core/util/Meta.h	/^{ enum { ret = false }; };$/;"	e	enum:Eigen::is_diagonal::__anon197
ret	Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon198
ret	Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon199
ret	Eigen/src/Core/util/Meta.h	/^{ enum { ret = true }; };$/;"	e	enum:Eigen::is_diagonal::__anon200
ret	Eigen/src/Eigen2Support/Meta.h	/^    enum { ret = ei_meta_sqrt<Y,NewInf,NewSup>::ret };$/;"	e	enum:Eigen::__anon415
ret	Eigen/src/Eigen2Support/Meta.h	/^class ei_meta_sqrt<Y, InfX, SupX, true> { public:  enum { ret = (SupX*SupX <= Y) ? SupX : InfX }; };$/;"	e	enum:ei_meta_sqrt::__anon416
ret	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_false { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_meta_false::__anon412
ret	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if <false, Then, Else> { typedef Else ret; };$/;"	t	struct:Eigen::ei_meta_if
ret	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_if { typedef Then ret; };$/;"	t	struct:Eigen::ei_meta_if
ret	Eigen/src/Eigen2Support/Meta.h	/^struct ei_meta_true {  enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_meta_true::__anon411
ret	Eigen/src/Eigen2Support/Meta.h	/^template<typename T, typename U> struct ei_is_same_type { enum { ret = 0 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon413
ret	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_is_same_type<T,T> { enum { ret = 1 }; };$/;"	e	enum:Eigen::ei_is_same_type::__anon414
ret	Eigen/src/Householder/Householder.h	/^    ret = n==Dynamic ? n : n-1$/;"	e	enum:Eigen::internal::decrement_size::__anon357
ret	Eigen/src/SVD/JacobiSVD.h	/^         ret = !( (QRPreconditioner == NoQRPreconditioner) ||$/;"	e	enum:Eigen::internal::qr_preconditioner_should_do_anything::__anon418
ret	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^{ typedef Sparse ret; };$/;"	t	struct:Eigen::internal::promote_storage_type
retval	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::atanh2_default_impl
retval	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar retval;$/;"	t	struct:Eigen::internal::pow_default_impl
reverse	Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse() const$/;"	f	class:Eigen::DenseBase
reverse	Eigen/src/Core/Reverse.h	/^DenseBase<Derived>::reverse()$/;"	f	class:Eigen::DenseBase
reverse	Eigen/src/Core/VectorwiseOp.h	/^    const Reverse<ExpressionType, Direction> reverse() const$/;"	f	class:Eigen::VectorwiseOp
reverseInPlace	Eigen/src/Core/Reverse.h	/^inline void DenseBase<Derived>::reverseInPlace()$/;"	f	class:Eigen::DenseBase
reverse_packet	Eigen/src/Core/Reverse.h	/^    typedef internal::reverse_packet_cond<PacketScalar,ReversePacket> reverse_packet;$/;"	t	class:Eigen::Reverse
reverse_packet_cond	Eigen/src/Core/Reverse.h	/^template<typename PacketScalar, bool ReversePacket> struct reverse_packet_cond$/;"	s	namespace:Eigen::internal
reverse_packet_cond	Eigen/src/Core/Reverse.h	/^template<typename PacketScalar> struct reverse_packet_cond<PacketScalar,false>$/;"	s	namespace:Eigen::internal
rgba	srLib/SceneGraph/gl2ps.c	/^  GL2PSrgba rgba;$/;"	m	struct:__anon7	file:
rhs	Eigen/src/Core/CwiseBinaryOp.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CwiseBinaryOp
rhs	Eigen/src/Core/products/CoeffBasedProduct.h	/^    const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::CoeffBasedProduct
rhs	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDenseOuterProduct
rhs	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseDiagonalProduct
rhs	Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE const _RhsNested& rhs() const { return m_rhs; }$/;"	f	class:Eigen::SparseSparseProduct
rhs	Eigen/src/misc/Solve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::solve_retval_base
rhs	Eigen/src/misc/SparseSolve.h	/^  inline const RhsNestedCleaned& rhs() const { return m_rhs; }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
rhs_length	Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_length;$/;"	m	struct:Eigen::internal::GemmParallelInfo
rhs_start	Eigen/src/Core/products/Parallelizer.h	/^  Index rhs_start;$/;"	m	struct:Eigen::internal::GemmParallelInfo
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline ColsBlockXpr rightCols(Index n)$/;"	f
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline ConstColsBlockXpr rightCols(Index n) const$/;"	f
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNColsBlockXpr<N>::Type rightCols(Index n = N) const$/;"	f
rightCols	Eigen/src/plugins/BlockMethods.h	/^inline typename NColsBlockXpr<N>::Type rightCols(Index n = N)$/;"	f
rightHouseholderSequence	Eigen/src/Householder/HouseholderSequence.h	/^HouseholderSequence<VectorsType,CoeffsType,OnTheRight> rightHouseholderSequence(const VectorsType& v, const CoeffsType& h)$/;"	f	namespace:Eigen
rightPos	srLib/SceneGraph/Leaf.h	/^		Vec3        rightPos;$/;"	m	struct:Strip::PTY
robot1	Example/MobileRobots/MobileRobots.cpp	/^MobileRobot	robot1;$/;"	v
robot2	Example/MobileRobots/MobileRobots.cpp	/^MobileRobot	robot2;$/;"	v
robot_	Example/DracoP1/Draco_Dyn_environment.h	/^        srDraco* robot_;$/;"	m	class:Draco_Dyn_environment
rot	srLib/SceneGraph/Model3DS.h	/^		Vector	rot;				\/\/ The angles to rotate the object$/;"	m	struct:Model3DS::Object
rot	srLib/SceneGraph/Model3DS.h	/^	Vector	rot;				\/\/ The angles to rotate the model$/;"	m	class:Model3DS
rotate	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
rotate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotate(const RotationType& rotation)$/;"	f	class:Eigen::Transform
rotation	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::rotation() const$/;"	f	class:Eigen::Transform
rotation	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::rotation() const$/;"	f	class:Eigen::Transform
rotation_base_generic_product_selector	Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector< RotationDerived, DiagonalMatrix<Scalar,Dim,MaxDim>, false >$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,MatrixType,false>$/;"	s	namespace:Eigen::internal
rotation_base_generic_product_selector	Eigen/src/Geometry/RotationBase.h	/^struct rotation_base_generic_product_selector<RotationDerived,OtherVectorType,true>$/;"	s	namespace:Eigen::internal
row	Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::all_unroller::__anon320
row	Eigen/src/Core/BooleanRedux.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::any_unroller::__anon321
row	Eigen/src/Core/CoreIterators.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::DenseBase::InnerIterator
row	Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon279
row	Eigen/src/Core/SelfAdjointView.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon280
row	Eigen/src/Core/TriangularMatrix.h	/^    row = (UnrollCount-1) % Derived1::RowsAtCompileTime$/;"	e	enum:Eigen::internal::triangular_assignment_selector::__anon241
row	Eigen/src/Core/Visitor.h	/^    row = (UnrollCount-1) % Derived::RowsAtCompileTime$/;"	e	enum:Eigen::internal::visitor_impl::__anon229
row	Eigen/src/Core/Visitor.h	/^  Index row, col;$/;"	m	struct:Eigen::internal::coeff_visitor
row	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
row	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::BlockImpl::InnerIterator
row	Eigen/src/SparseCore/SparseBlock.h	/^        inline Index row() const { return IsRowMajor ? m_outer : this->index(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseBlock.h	/^      inline Index row()    const { return Base::row()   - m_block.m_startRow.value(); }$/;"	f	class:Eigen::BlockImpl::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index row()    const { return Base::row()   - m_block.m_startRow.value(); }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
row	Eigen/src/SparseCore/SparseBlock.h	/^    inline Index row()    const { return IsRowMajor ? 0 : index(); }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return Lhs::IsRowMajor ? m_lhsIter.row() : index(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_lhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
row	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index row() const { return m_rhsIter.row(); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
row	Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Index row() const { return Transpose ? m_outer : Base::index(); }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
row	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline Index row() const { return m_outer; }$/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
row	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
row	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index row() const { return IsRowMajor ? m_outer : index(); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::InnerIterator
row	Eigen/src/SparseCore/SparseTranspose.h	/^    typename TransposeImpl<MatrixType,Sparse>::Index row() const { return Base::col(); }$/;"	f	class:Eigen::TransposeImpl::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return (MatrixType::Flags&RowMajorBit ? Base::outer() : this->index()); }$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
row	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index row() const { return Base::row(); }$/;"	f	class:Eigen::SparseTriangularView::ReverseInnerIterator
row	Eigen/src/SparseCore/SparseUtil.h	/^  const Index& row() const { return m_row; }$/;"	f	class:Eigen::Triplet
row	Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::InnerIterator
row	Eigen/src/SparseCore/SparseVector.h	/^    inline Index row() const { return IsColVector ? index() : 0; }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
row	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index row() const { return index(); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
row	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowXpr row(Index i) const$/;"	f
row	Eigen/src/plugins/BlockMethods.h	/^inline RowXpr row(Index i)$/;"	f
rowIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* rowIndex()  { return m_rowind; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* rowIndex() const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndexByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE Index rowIndexByOuterInner(Index outer, Index inner) const$/;"	f	class:Eigen::DenseCoeffsBase
rowIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* rowIndexPtr() { return m_rowind_colptr; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowIndexPtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* rowIndexPtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rowOffset	Eigen/src/Core/Diagonal.h	/^    EIGEN_STRONG_INLINE Index rowOffset() const { return m_index.value()>0 ? 0 : -m_index.value(); }$/;"	f	class:Eigen::Diagonal
rowPrefix	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSeparator	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowSpacer	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowStride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index rowStride() const$/;"	f	class:Eigen::DenseCoeffsBase
rowSuffix	Eigen/src/Core/IO.h	/^  std::string rowPrefix, rowSuffix, rowSeparator, rowSpacer;$/;"	m	struct:Eigen::IOFormat
rowblk	Eigen/src/SparseLU/SparseLU_Structs.h	/^  Index rowblk; \/\/ The minimum row dimension for 2-D blocking to be used;$/;"	m	struct:Eigen::internal::perfvalues
rows	Eigen/src/Cholesky/LDLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LDLT
rows	Eigen/src/Cholesky/LLT.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::LLT
rows	Eigen/src/CholmodSupport/CholmodSupport.h	/^    inline Index rows() const { return m_cholmodFactor->n; }$/;"	f	class:Eigen::CholmodBase
rows	Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ArrayWrapper
rows	Eigen/src/Core/ArrayWrapper.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::MatrixWrapper
rows	Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrix
rows	Eigen/src/Core/BandMatrix.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
rows	Eigen/src/Core/Block.h	/^    inline Index rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::internal::BlockImpl_dense
rows	Eigen/src/Core/CwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const {$/;"	f	class:Eigen::CwiseBinaryOp
rows	Eigen/src/Core/CwiseNullaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::CwiseNullaryOp
rows	Eigen/src/Core/CwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_xpr.rows(); }$/;"	f	class:Eigen::CwiseUnaryOp
rows	Eigen/src/Core/CwiseUnaryView.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::CwiseUnaryView
rows	Eigen/src/Core/DenseStorage.h	/^    DenseIndex rows() const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/DenseStorage.h	/^    DenseIndex rows(void) const {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/DenseStorage.h	/^    DenseIndex rows(void) const {return m_rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/DenseStorage.h	/^    static DenseIndex rows(void) {return _Rows;}$/;"	f	class:Eigen::DenseStorage
rows	Eigen/src/Core/Diagonal.h	/^    inline Index rows() const$/;"	f	class:Eigen::Diagonal
rows	Eigen/src/Core/DiagonalMatrix.h	/^    inline Index rows() const { return diagonal().size(); }$/;"	f	class:Eigen::DiagonalBase
rows	Eigen/src/Core/DiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::DiagonalProduct
rows	Eigen/src/Core/EigenBase.h	/^  inline Index rows() const { return derived().rows(); }$/;"	f	struct:Eigen::EigenBase
rows	Eigen/src/Core/Flagged.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Flagged
rows	Eigen/src/Core/ForceAlignedAccess.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::ForceAlignedAccess
rows	Eigen/src/Core/MapBase.h	/^    inline Index rows() const { return m_rows.value(); }$/;"	f	class:Eigen::MapBase
rows	Eigen/src/Core/NestByValue.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::NestByValue
rows	Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
rows	Eigen/src/Core/PermutationMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_matrix_product_retval
rows	Eigen/src/Core/PermutationMatrix.h	/^    inline int rows() const { return m_permutation.rows(); }$/;"	f	class:Eigen::Transpose
rows	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_storage.rows(); }$/;"	f	class:Eigen::PlainObjectBase
rows	Eigen/src/Core/Replicate.h	/^    inline Index rows() const { return m_matrix.rows() * m_rowFactor.value(); }$/;"	f	class:Eigen::Replicate
rows	Eigen/src/Core/ReturnByValue.h	/^    inline Index rows() const { return static_cast<const Derived*>(this)->rows(); }$/;"	f	class:Eigen::ReturnByValue
rows	Eigen/src/Core/Reverse.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::Reverse
rows	Eigen/src/Core/Select.h	/^    Index rows() const { return m_condition.rows(); }$/;"	f	class:Eigen::Select
rows	Eigen/src/Core/SelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfAdjointView
rows	Eigen/src/Core/SelfCwiseBinaryOp.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SelfCwiseBinaryOp
rows	Eigen/src/Core/SolveTriangular.h	/^  inline Index rows() const { return m_rhs.rows(); }$/;"	f	struct:Eigen::internal::triangular_solve_retval
rows	Eigen/src/Core/Swap.h	/^    inline Index rows() const { return m_expression.rows(); }$/;"	f	class:Eigen::SwapWrapper
rows	Eigen/src/Core/Transpose.h	/^    inline Index rows() const { return m_matrix.cols(); }$/;"	f	class:Eigen::Transpose
rows	Eigen/src/Core/Transpositions.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
rows	Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::TriangularBase
rows	Eigen/src/Core/TriangularMatrix.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::TriangularView
rows	Eigen/src/Core/VectorwiseOp.h	/^    Index rows() const { return (Direction==Vertical   ? 1 : m_matrix.rows()); }$/;"	f	class:Eigen::PartialReduxExpr
rows	Eigen/src/Core/products/CoeffBasedProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::CoeffBasedProduct
rows	Eigen/src/Eigen2Support/Minor.h	/^    inline Index rows() const { return m_matrix.rows() - 1; }$/;"	f	class:Eigen::Minor
rows	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^    Index rows() const { return m_hess.packedMatrix().rows(); }$/;"	f	struct:Eigen::internal::HessenbergDecompositionMatrixHReturnType
rows	Eigen/src/Eigenvalues/Tridiagonalization.h	/^    Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::TridiagonalizationMatrixTReturnType
rows	Eigen/src/Geometry/Homogeneous.h	/^    inline Index rows() const { return m_matrix.rows() + (int(Direction)==Vertical   ? 1 : 0); }$/;"	f	class:Eigen::Homogeneous
rows	Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_left_product_impl
rows	Eigen/src/Geometry/Homogeneous.h	/^  inline Index rows() const { return m_lhs.rows(); }$/;"	f	struct:Eigen::internal::homogeneous_right_product_impl
rows	Eigen/src/Householder/HouseholderSequence.h	/^    Index rows() const { return Side==OnTheLeft ? m_vectors.rows() : m_vectors.cols(); }$/;"	f	class:Eigen::HouseholderSequence
rows	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    Index rows() const { return m_invdiag.size(); }$/;"	f	class:Eigen::DiagonalPreconditioner
rows	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^    Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::IncompleteLUT
rows	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Index rows() const { return mp_matrix ? mp_matrix->rows() : 0; }$/;"	f	class:Eigen::IterativeSolverBase
rows	Eigen/src/LU/FullPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::FullPivLU
rows	Eigen/src/LU/Inverse.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::inverse_impl
rows	Eigen/src/LU/PartialPivLU.h	/^    inline Index rows() const { return m_lu.rows(); }$/;"	f	class:Eigen::PartialPivLU
rows	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PastixBase
rows	Eigen/src/PardisoSupport/PardisoSupport.h	/^    inline Index rows() const { return m_size; }$/;"	f	class:Eigen::PardisoImpl
rows	Eigen/src/QR/ColPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::ColPivHouseholderQR
rows	Eigen/src/QR/FullPivHouseholderQR.h	/^    Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::internal::FullPivHouseholderQRMatrixQReturnType
rows	Eigen/src/QR/FullPivHouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::FullPivHouseholderQR
rows	Eigen/src/QR/HouseholderQR.h	/^    inline Index rows() const { return m_qr.rows(); }$/;"	f	class:Eigen::HouseholderQR
rows	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline Index rows() const {return m_cR->nrow; }$/;"	f	class:Eigen::SPQR
rows	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  inline Index rows() const { return m_transpose ? m_spqr.rows() : m_spqr.cols(); }$/;"	f	struct:Eigen::SPQR_QProduct
rows	Eigen/src/SVD/JacobiSVD.h	/^    inline Index rows() const { return m_rows; }$/;"	f	class:Eigen::JacobiSVD
rows	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SimplicialCholeskyBase
rows	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::MappedSparseMatrix
rows	Eigen/src/SparseCore/SparseBlock.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsRowMajor ? m_outerSize.value() : m_matrix.rows(); }$/;"	f	class:Eigen::BlockImpl
rows	Eigen/src/SparseCore/SparseBlock.h	/^    inline int rows() const { return m_blockRows.value(); }$/;"	f	class:Eigen::BlockImpl
rows	Eigen/src/SparseCore/SparseDenseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return Tr ? m_rhs.rows() : m_lhs.rows(); }$/;"	f	class:Eigen::SparseDenseOuterProduct
rows	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseDiagonalProduct
rows	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Index rows() const { return IsRowMajor ? m_outerSize : m_innerSize; }$/;"	f	class:Eigen::SparseMatrix
rows	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index rows() const { return derived().rows(); }$/;"	f	class:Eigen::SparseMatrixBase
rows	Eigen/src/SparseCore/SparsePermutation.h	/^    inline int rows() const { return m_matrix.rows(); }$/;"	f	struct:Eigen::internal::permut_sparsematrix_product_retval
rows	Eigen/src/SparseCore/SparseProduct.h	/^    EIGEN_STRONG_INLINE Index rows() const { return m_lhs.rows(); }$/;"	f	class:Eigen::SparseSparseProduct
rows	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSelfAdjointView
rows	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseSymmetricPermutationProduct
rows	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseTriangularView
rows	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Index rows() const { return IsColVector ? m_size : 1; }$/;"	f	class:Eigen::SparseVector
rows	Eigen/src/SparseCore/SparseView.h	/^  inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SparseView
rows	Eigen/src/SparseLU/SparseLU.h	/^    inline Index rows() const { return m_mat.rows(); }$/;"	f	class:Eigen::SparseLU
rows	Eigen/src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
rows	Eigen/src/SparseLU/SparseLU.h	/^  Index rows() { return m_mapL.rows(); }$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
rows	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index rows() { return m_row; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
rows	Eigen/src/SparseQR/SparseQR.h	/^    inline Index rows() const { return m_pmat.rows(); }$/;"	f	class:Eigen::SparseQR
rows	Eigen/src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_qr.rows(); }$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
rows	Eigen/src/SparseQR/SparseQR.h	/^  inline Index rows() const { return m_transpose ? m_qr.rows() : m_qr.cols(); }$/;"	f	struct:Eigen::SparseQR_QProduct
rows	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline Index rows() const { return m_matrix.rows(); }$/;"	f	class:Eigen::SuperLUBase
rows	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline Index rows() const { return m_copyMatrix.rows(); }$/;"	f	class:Eigen::UmfPackLU
rows	Eigen/src/misc/Image.h	/^  inline Index rows() const { return m_dec.rows(); }$/;"	f	struct:Eigen::internal::image_retval_base
rows	Eigen/src/misc/Kernel.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::kernel_retval_base
rows	Eigen/src/misc/Solve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_base
rows	Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::solve_retval_with_guess
rows	Eigen/src/misc/SparseSolve.h	/^  inline Index rows() const { return m_dec.cols(); }$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
rowsPermutation	Eigen/src/SparseLU/SparseLU.h	/^    inline const PermutationType& rowsPermutation() const$/;"	f	class:Eigen::SparseLU
rowsTranspositions	Eigen/src/QR/FullPivHouseholderQR.h	/^    const IntDiagSizeVectorType& rowsTranspositions() const$/;"	f	class:Eigen::FullPivHouseholderQR
rows_select	Eigen/src/Core/GeneralProduct.h	/^    rows_select = product_size_category<Rows,MaxRows>::value,$/;"	e	enum:Eigen::internal::product_type::__anon284
rowwise	Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise() const$/;"	f	class:Eigen::DenseBase
rowwise	Eigen/src/Core/VectorwiseOp.h	/^DenseBase<Derived>::rowwise()$/;"	f	class:Eigen::DenseBase
run	Eigen/src/Core/Assign.h	/^  static EIGEN_DONT_INLINE void run(const Derived& src, OtherDerived& dst, typename Derived::Index start, typename Derived::Index end)$/;"	f	struct:Eigen::internal::unaligned_assign_impl
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.derived()); }$/;"	f	struct:Eigen::internal::assign_selector
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.eval()); }$/;"	f	struct:Eigen::internal::assign_selector
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose()); }$/;"	f	struct:Eigen::internal::assign_selector
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& dst, const OtherDerived& other) { return dst.lazyAssign(other.transpose().eval()); }$/;"	f	struct:Eigen::internal::assign_selector
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, typename Derived1::Index) {}$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &, const Derived2 &, typename Derived1::Index) {}$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_CompleteUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_LinearTraversal_CompleteUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_innervec_CompleteUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)$/;"	f	struct:Eigen::internal::assign_DefaultTraversal_InnerUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(Derived1 &dst, const Derived2 &src, typename Derived1::Index outer)$/;"	f	struct:Eigen::internal::assign_innervec_InnerUnrolling
run	Eigen/src/Core/Assign.h	/^  static EIGEN_STRONG_INLINE void run(const Derived&, OtherDerived&, typename Derived::Index, typename Derived::Index) {}$/;"	f	struct:Eigen::internal::unaligned_assign_impl
run	Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &, const Derived2 &) { }$/;"	f	struct:Eigen::internal::assign_impl
run	Eigen/src/Core/Assign.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::assign_impl
run	Eigen/src/Core/Assign_MKL.h	/^  static inline void run(Derived1& dst, const CwiseUnaryOp<UnaryOp, Derived2>& src)$/;"	f	struct:Eigen::internal::vml_assign_impl
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived & \/*mat*\/) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::all_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &) { return false; }$/;"	f	struct:Eigen::internal::any_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &\/*mat*\/) { return true; }$/;"	f	struct:Eigen::internal::all_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::all_unroller
run	Eigen/src/Core/BooleanRedux.h	/^  static inline bool run(const Derived &mat)$/;"	f	struct:Eigen::internal::any_unroller
run	Eigen/src/Core/CwiseNullaryOp.h	/^  static EIGEN_STRONG_INLINE Derived& run(Derived& m)$/;"	f	struct:Eigen::internal::setIdentity_impl
run	Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived& m)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	Eigen/src/Core/DenseCoeffsBase.h	/^  static inline typename Derived::Index run(const Derived&)$/;"	f	struct:Eigen::internal::first_aligned_impl
run	Eigen/src/Core/Dot.h	/^  static inline RealScalar run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	Eigen/src/Core/Dot.h	/^  static inline ResScalar run(const MatrixBase<T>& a, const MatrixBase<U>& b)$/;"	f	struct:Eigen::internal::dot_nocheck
run	Eigen/src/Core/Dot.h	/^  static inline typename NumTraits<typename traits<Derived>::Scalar>::Real run(const MatrixBase<Derived>& m)$/;"	f	struct:Eigen::internal::lpNorm_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isApprox_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived& y, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isApprox_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const OtherDerived&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_object_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar& y, const typename Derived::RealScalar& prec)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	Eigen/src/Core/Fuzzy.h	/^  static bool run(const Derived& x, const typename Derived::RealScalar&, const typename Derived::RealScalar&)$/;"	f	struct:Eigen::internal::isMuchSmallerThan_scalar_selector
run	Eigen/src/Core/GeneralProduct.h	/^  static inline void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_selector
run	Eigen/src/Core/GeneralProduct.h	/^  static void run(const ProductType& prod, Dest& dest, const typename ProductType::Scalar& alpha)$/;"	f	struct:Eigen::internal::gemv_selector
run	Eigen/src/Core/GenericPacketMath.h	/^  static inline void run(PacketType&, const PacketType&) {}$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/IO.h	/^  static inline int run()$/;"	f	struct:Eigen::internal::significant_decimals_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline NewType run(const OldType& x)$/;"	f	struct:Eigen::internal::cast_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::abs2_impl_default
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::hypot_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline RealScalar& run(Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run()$/;"	f	struct:Eigen::internal::random_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar x, Scalar y)$/;"	f	struct:Eigen::internal::pow_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::conj_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x)$/;"	f	struct:Eigen::internal::norm1_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::atanh2_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::pow_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar& x, const Scalar& y)$/;"	f	struct:Eigen::internal::random_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline Scalar run(const Scalar&, const Scalar&)$/;"	f	struct:Eigen::internal::atanh2_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline bool run()$/;"	f	struct:Eigen::internal::random_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline const RealScalar& run(const Scalar& x)$/;"	f	struct:Eigen::internal::real_ref_impl
run	Eigen/src/Core/MathFunctions.h	/^  static inline const Scalar run(const Scalar&)$/;"	f	struct:Eigen::internal::imag_ref_default_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index rows, Index cols)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow
run	Eigen/src/Core/PlainObjectBase.h	/^  static EIGEN_ALWAYS_INLINE void run(Index, Index)$/;"	f	struct:Eigen::internal::check_rows_cols_for_overflow
run	Eigen/src/Core/PlainObjectBase.h	/^  static inline void run(MatrixTypeA& a, MatrixTypeB& b)$/;"	f	struct:Eigen::internal::matrix_swap_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index rows, Index cols)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, Index size)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	Eigen/src/Core/PlainObjectBase.h	/^  static void run(DenseBase<Derived>& _this, const DenseBase<OtherDerived>& other)$/;"	f	struct:Eigen::internal::conservative_resize_like_impl
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE PacketScalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_vec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived &mat, const Func&)$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	Eigen/src/Core/Redux.h	/^  static EIGEN_STRONG_INLINE Scalar run(const Derived&, const Func&) { return Scalar(); }$/;"	f	struct:Eigen::internal::redux_novec_unroller
run	Eigen/src/Core/Redux.h	/^  static Scalar run(const Derived& mat, const Func& func)$/;"	f	struct:Eigen::internal::redux_impl
run	Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return preverse(x); }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	Eigen/src/Core/Reverse.h	/^  static inline PacketScalar run(const PacketScalar& x) { return x; }$/;"	f	struct:Eigen::internal::reverse_packet_cond
run	Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	Eigen/src/Core/SelfAdjointView.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_selector
run	Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs& lhs, Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	Eigen/src/Core/SolveTriangular.h	/^  static void run(const Lhs&, Rhs&) {}$/;"	f	struct:Eigen::internal::triangular_solver_unroller
run	Eigen/src/Core/Transpose.h	/^    static void run(const Derived& dst, const OtherDerived& other)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	Eigen/src/Core/Transpose.h	/^    static void run(const Derived&, const OtherDerived&)$/;"	f	struct:Eigen::internal::checkTransposeAliasing_impl
run	Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const CwiseBinaryOp<BinOp,DerivedA,DerivedB>& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	Eigen/src/Core/Transpose.h	/^  static bool run(const Scalar* dest, const OtherDerived& src)$/;"	f	struct:Eigen::internal::check_transpose_aliasing_run_time_selector
run	Eigen/src/Core/Transpose.h	/^  static void run(MatrixType& m) {$/;"	f	struct:Eigen::internal::inplace_transpose_selector
run	Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &, const Derived2 &) {}$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	Eigen/src/Core/TriangularMatrix.h	/^  static inline void run(Derived1 &dst, const Derived2 &src)$/;"	f	struct:Eigen::internal::triangular_assignment_selector
run	Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived &mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	Eigen/src/Core/Visitor.h	/^  static inline void run(const Derived& mat, Visitor& visitor)$/;"	f	struct:Eigen::internal::visitor_impl
run	Eigen/src/Core/arch/AltiVec/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/NEON/Complex.h	/^  EIGEN_STRONG_INLINE static void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet1cd& \/*first*\/, const Packet1cd& \/*second*\/)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/Complex.h	/^  static EIGEN_STRONG_INLINE void run(Packet2cf& first, const Packet2cf& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet2d& first, const Packet2d& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4f& first, const Packet4f& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/arch/SSE/PacketMath.h	/^  static EIGEN_STRONG_INLINE void run(Packet4i& first, const Packet4i& second)$/;"	f	struct:Eigen::internal::palign_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& \/*lhs*\/, const Rhs& \/*rhs*\/, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index \/*row*\/, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index \/*col*\/, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet &res)$/;"	f	struct:Eigen::internal::product_packet_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, Packet& res)$/;"	f	struct:Eigen::internal::product_packet_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, RetScalar& res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::PacketScalar &pres)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_unroller
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_impl
run	Eigen/src/Core/products/CoeffBasedProduct.h	/^  static EIGEN_STRONG_INLINE void run(Index row, Index col, const Lhs& lhs, const Rhs& rhs, typename Lhs::Scalar &res)$/;"	f	struct:Eigen::internal::product_coeff_vectorized_dyn_selector
run	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, A& a, B& b, C& c, T& \/*t*\/)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    EIGEN_ALWAYS_INLINE static void run(const CJ& cj, T& a, T& b, T& c, T& t)$/;"	f	struct:Eigen::internal::gebp_madd_selector
run	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^static void run(Index rows, Index cols, Index depth,$/;"	f	struct:Eigen::internal::general_matrix_matrix_product
run	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* _lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static EIGEN_STRONG_INLINE void run(Index size, Index depth,const LhsScalar* lhs, Index lhsStride,$/;"	f	struct:Eigen::internal::general_matrix_matrix_triangular_product
run	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^  static void run(MatrixType& mat, const ProductType& prod, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::general_product_to_triangular_selector
run	Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,ColMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product
run	Eigen/src/Core/products/GeneralMatrixVector.h	/^EIGEN_DONT_INLINE void general_matrix_vector_product<Index,LhsScalar,RowMajor,ConjugateLhs,RhsScalar,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::general_matrix_vector_product
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_selfadjoint_matrix
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,false,ConjugateLhs, RhsStorageOrder,true,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix
run	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^EIGEN_DONT_INLINE void product_selfadjoint_matrix<Scalar,Index,LhsStorageOrder,true,ConjugateLhs, RhsStorageOrder,false,ConjugateRhs,ColMajor>::run($/;"	f	class:Eigen::internal::product_selfadjoint_matrix
run	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^EIGEN_DONT_INLINE void selfadjoint_matrix_vector_product<Scalar,Index,StorageOrder,UpLo,ConjugateLhs,ConjugateRhs,Version>::run($/;"	f	class:Eigen::internal::selfadjoint_matrix_vector_product
run	Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(Index size, Scalar* mat, Index stride, const Scalar* vecX, const Scalar* vecY, const Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_rank1_update
run	Eigen/src/Core/products/SelfadjointProduct.h	/^  static void run(MatrixType& mat, const OtherType& other, const typename MatrixType::Scalar& alpha)$/;"	f	struct:Eigen::selfadjoint_product_selector
run	Eigen/src/Core/products/SelfadjointRank2Update.h	/^  static void run(Scalar* mat, Index stride, const UType& u, const VType& v, const Scalar& alpha)$/;"	f	struct:Eigen::internal::selfadjoint_rank2_update_selector
run	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^                                                        RhsStorageOrder,ConjugateRhs,ColMajor,Version>::run($/;"	f	class:Eigen::internal::product_triangular_matrix_matrix
run	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  static EIGEN_STRONG_INLINE void run($/;"	f	struct:Eigen::internal::product_triangular_matrix_matrix
run	Eigen/src/Core/products/TriangularMatrixVector.h	/^  ::run(Index _rows, Index _cols, const LhsScalar* _lhs, Index lhsStride,$/;"	f	class:Eigen::internal::triangular_matrix_vector_product
run	Eigen/src/Core/products/TriangularMatrixVector.h	/^  static void run(const TriangularProduct<Mode,true,Lhs,false,Rhs,true>& prod, Dest& dest, const typename TriangularProduct<Mode,true,Lhs,false,Rhs,true>::Scalar& alpha)$/;"	f	struct:Eigen::internal::trmv_selector
run	Eigen/src/Core/products/TriangularSolverMatrix.h	/^  static void run($/;"	f	struct:Eigen::internal::triangular_solve_matrix
run	Eigen/src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix
run	Eigen/src/Core/products/TriangularSolverMatrix.h	/^EIGEN_DONT_INLINE void triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>::run($/;"	f	class:Eigen::internal::triangular_solve_matrix
run	Eigen/src/Core/products/TriangularSolverVector.h	/^  static void run(Index size, const LhsScalar* _lhs, Index lhsStride, RhsScalar* rhs)$/;"	f	struct:Eigen::internal::triangular_solve_vector
run	Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE To run(const From& x) { return x; }$/;"	f	struct:Eigen::internal::get_factor
run	Eigen/src/Core/util/BlasUtil.h	/^  static EIGEN_STRONG_INLINE typename NumTraits<Scalar>::Real run(const Scalar& x) { return numext::real(x); }$/;"	f	struct:Eigen::internal::get_factor
run	Eigen/src/Core/util/BlasUtil.h	/^  static const typename T::Scalar* run(const T& m)$/;"	f	struct:Eigen::internal::extract_data_selector
run	Eigen/src/Core/util/BlasUtil.h	/^  static typename T::Scalar* run(const T&) { return 0; }$/;"	f	struct:Eigen::internal::extract_data_selector
run	Eigen/src/Core/util/Memory.h	/^  static inline void run(const T* start, const T* end, T* target)$/;"	f	struct:Eigen::internal::smart_copy_helper
run	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& mat)$/;"	f	struct:Eigen::ei_quaternion_assign_impl
run	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  static inline void run(Quaternion<Scalar>& q, const Other& vec)$/;"	f	struct:Eigen::ei_quaternion_assign_impl
run	Eigen/src/Eigen2Support/Geometry/Transform.h	/^    static inline void run(Transform *transform, const MatrixBase<OtherDerived>& other)$/;"	f	struct:Eigen::Transform::construct_from_matrix
run	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  static ResultType run(const TransformType& tr, const Other& other)$/;"	f	struct:Eigen::ei_transform_product_impl
run	Eigen/src/Eigenvalues/ComplexSchur.h	/^  static void run(ComplexSchur<MatrixType>& _this, const MatrixType& matrix, bool computeU)$/;"	f	struct:Eigen::internal::complex_schur_reduce_to_hessenberg
run	Eigen/src/Eigenvalues/MatrixBaseEigenvalues.h	/^  run(const MatrixBase<Derived>& m)$/;"	f	class:Eigen::internal::eigenvalues_selector::MatrixBase
run	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& eig, const typename SolverType::MatrixType& A, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^  static inline void run(SolverType& solver, const MatrixType& mat, int options)$/;"	f	struct:Eigen::internal::direct_selfadjoint_eigenvalues
run	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	Eigen/src/Eigenvalues/Tridiagonalization.h	/^  static void run(MatrixType& mat, DiagonalType& diag, SubDiagonalType&, bool extractQ)$/;"	f	struct:Eigen::internal::tridiagonalization_inplace_selector
run	Eigen/src/Geometry/Homogeneous.h	/^  static const type& run (const TransformType& x) { return x.matrix(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	Eigen/src/Geometry/Homogeneous.h	/^  static const type& run(const type &x) { return x; }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	Eigen/src/Geometry/Homogeneous.h	/^  static type run (const TransformType& x) { return x.affine(); }$/;"	f	struct:Eigen::internal::take_matrix_for_product
run	Eigen/src/Geometry/OrthoMethods.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	Eigen/src/Geometry/OrthoMethods.h	/^  static inline VectorType run(const Derived& src)$/;"	f	struct:Eigen::internal::unitOrthogonal_selector
run	Eigen/src/Geometry/Quaternion.h	/^  static EIGEN_STRONG_INLINE Quaternion<Scalar> run(const QuaternionBase<Derived1>& a, const QuaternionBase<Derived2>& b){$/;"	f	struct:Eigen::internal::quat_product
run	Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& mat)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	Eigen/src/Geometry/Quaternion.h	/^  template<class Derived> static inline void run(QuaternionBase<Derived>& q, const Other& vec)$/;"	f	struct:Eigen::internal::quaternionbase_assign_impl
run	Eigen/src/Geometry/RotationBase.h	/^  static EIGEN_STRONG_INLINE ReturnType run(const RotationDerived& r, const OtherVectorType& v)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const DiagonalMatrix<Scalar,Dim,MaxDim>& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	Eigen/src/Geometry/RotationBase.h	/^  static inline ReturnType run(const RotationDerived& r, const MatrixType& m)$/;"	f	struct:Eigen::internal::rotation_base_generic_product_selector
run	Eigen/src/Geometry/Transform.h	/^  static EIGEN_STRONG_INLINE ResultType run(const TransformType& T, const MatrixType& other)$/;"	f	struct:Eigen::internal::transform_right_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Lhs& lhs, const Rhs& rhs)$/;"	f	struct:Eigen::internal::transform_transform_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other, const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static ResultType run(const Other& other,const TransformType& tr)$/;"	f	struct:Eigen::internal::transform_left_product_impl
run	Eigen/src/Geometry/Transform.h	/^  static inline AffinePart run(MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline ConstAffinePart run(const MatrixType& m)$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline MatrixType& run(MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline const MatrixType& run(const MatrixType& m) { return m; }$/;"	f	struct:Eigen::internal::transform_take_affine_part
run	Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,AffineCompact,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	Eigen/src/Geometry/Transform.h	/^  static inline void run(Transform<typename Other::Scalar,Dim,Mode,Options> *transform, const Other& other)$/;"	f	struct:Eigen::internal::transform_construct_from_matrix
run	Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType& m, TransformType& res)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	Eigen/src/Geometry/Transform.h	/^  static inline void run(const TransformType&, TransformType&)$/;"	f	struct:Eigen::internal::projective_transform_inverse
run	Eigen/src/Geometry/Transform.h	/^  static void run(MatrixType &mat)$/;"	f	struct:Eigen::internal::transform_make_affine
run	Eigen/src/Geometry/Transform.h	/^  template<typename MatrixType> static void run(MatrixType &) { }$/;"	f	struct:Eigen::internal::transform_make_affine
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  run(const VectorLhs& lhs, const VectorRhs& rhs)$/;"	f	struct:Eigen::internal::cross3_impl
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<double> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	Eigen/src/Geometry/arch/Geometry_SSE.h	/^  static inline Quaternion<float> run(const QuaternionBase<Derived>& _a, const QuaternionBase<OtherDerived>& _b)$/;"	f	struct:Eigen::internal::quat_product
run	Eigen/src/LU/Determinant.h	/^  static inline typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	Eigen/src/LU/Determinant.h	/^  static typename traits<Derived>::Scalar run(const Derived& m)$/;"	f	struct:Eigen::internal::determinant_impl
run	Eigen/src/LU/Inverse.h	/^  static inline void run($/;"	f	struct:Eigen::internal::compute_inverse_and_det_with_check
run	Eigen/src/LU/Inverse.h	/^  static inline void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse
run	Eigen/src/LU/Inverse.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	Eigen/src/LU/arch/Inverse_SSE.h	/^  static void run(const MatrixType& matrix, ResultType& result)$/;"	f	struct:Eigen::internal::compute_inverse_size4
run	Eigen/src/PardisoSupport/PardisoSupport.h	/^    static Index run( _MKL_DSS_HANDLE_t pt, Index maxfct, Index mnum, Index type, Index phase, Index n, void *a,$/;"	f	struct:Eigen::internal::pardiso_run_selector
run	Eigen/src/QR/HouseholderQR.h	/^  static void run(MatrixQR& mat, HCoeffs& hCoeffs,$/;"	f	struct:Eigen::internal::householder_qr_inplace_blocked
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, ColPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, FullPivHouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, HouseholderQRPreconditioner>& svd, const MatrixType& matrix)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  bool run(JacobiSVD<MatrixType, QRPreconditioner>&, const MatrixType&)$/;"	f	class:Eigen::internal::qr_preconditioner_impl
run	Eigen/src/SVD/JacobiSVD.h	/^  static bool run(typename SVD::WorkMatrixType& work_matrix, SVD& svd, Index p, Index q, RealScalar& maxDiagEntry)$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	Eigen/src/SVD/JacobiSVD.h	/^  static bool run(typename SVD::WorkMatrixType&, SVD&, Index, Index, RealScalar&) { return true; }$/;"	f	struct:Eigen::internal::svd_precondition_2x2_block_to_be_real
run	Eigen/src/SparseCore/ConservativeSparseSparseProduct.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res)$/;"	f	struct:Eigen::internal::conservative_sparse_sparse_product_selector
run	Eigen/src/SparseCore/SparseDenseProduct.h	/^  static void run(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const typename Res::Scalar& alpha)$/;"	f	struct:Eigen::internal::sparse_time_dense_product_impl
run	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^  static void run(const Lhs& lhs, const Rhs& rhs, ResultType& res, const RealScalar& tolerance)$/;"	f	struct:Eigen::internal::sparse_sparse_product_with_pruning_selector
run	Eigen/src/SparseCore/SparseVector.h	/^  static void run(Dest& dst, const Src& src) {$/;"	f	struct:Eigen::internal::sparse_vector_assign_selector
run	Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_selector
run	Eigen/src/SparseCore/TriangularSolver.h	/^  static void run(const Lhs& lhs, Rhs& other)$/;"	f	struct:Eigen::internal::sparse_solve_triangular_sparse_selector
run	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<1>::run(const int \/*segsize*\/, BlockScalarVector& dense, ScalarVector& \/*tempv*\/, ScalarVector& lusup, Index& luptr,$/;"	f	class:Eigen::internal::LU_kernel_bmod
run	Eigen/src/SparseLU/SparseLU_kernel_bmod.h	/^EIGEN_DONT_INLINE void LU_kernel_bmod<SegSizeAtCompileTime>::run(const int segsize, BlockScalarVector& dense, ScalarVector& tempv, ScalarVector& lusup, Index& luptr, const Index lda,$/;"	f	class:Eigen::internal::LU_kernel_bmod
run	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  static void run(MatrixType& mat, SluMatrix& res)$/;"	f	struct:Eigen::SluMatrixMapHelper
runTransformation	srLib/SceneGraph/Transformation.cpp	/^void Transformation::runTransformation()$/;"	f	class:Transformation
s	Eigen/src/Jacobi/Jacobi.h	/^    Scalar s() const { return m_s; }$/;"	f	class:Eigen::JacobiRotation
s	Eigen/src/Jacobi/Jacobi.h	/^    Scalar& s() { return m_s; }$/;"	f	class:Eigen::JacobiRotation
sMaterialColor	srLib/srg/srgColor.h	/^	struct sMaterialColor$/;"	s	class:srgMaterialColor
sRGBA	srLib/srg/srgColor.h	/^	union { SRGBA sRGBA; float m_RGBA[4]; };$/;"	m	union:srgColor::__anon3
s_CountCreation	srLib/srDyn/srObject.cpp	/^unsigned int srObject::s_CountCreation = 0;$/;"	m	class:srObject	file:
s_CountCreation	srLib/srDyn/srObject.h	/^	static unsigned int s_CountCreation;$/;"	m	class:srObject
s_CountNumObj	srLib/srDyn/srObject.cpp	/^unsigned int srObject::s_CountNumObj = 0;$/;"	m	class:srObject	file:
s_CountNumObj	srLib/srDyn/srObject.h	/^	static unsigned int s_CountNumObj;$/;"	m	class:srObject
s_Objects	srLib/srDyn/srObject.cpp	/^_array<srObject*> srObject::s_Objects;$/;"	m	class:srObject	file:
s_Objects	srLib/srDyn/srObject.h	/^	static _array<srObject*> s_Objects;$/;"	m	class:srObject
sacleFactor	srLib/SceneGraph/Leaf.h	/^	GLdouble	sacleFactor;$/;"	m	class:Coordinate
sample	Eigen/src/Geometry/AlignedBox.h	/^  inline VectorType sample() const$/;"	f	class:Eigen::AlignedBox
scalar_abs2_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs2_op {$/;"	s	namespace:Eigen::internal
scalar_abs_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_abs_op {$/;"	s	namespace:Eigen::internal
scalar_acos_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_acos_op {$/;"	s	namespace:Eigen::internal
scalar_add_op	Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_add_op
scalar_add_op	Eigen/src/Core/Functors.h	/^  inline scalar_add_op(const scalar_add_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_add_op
scalar_add_op	Eigen/src/Core/Functors.h	/^struct scalar_add_op {$/;"	s	namespace:Eigen::internal
scalar_asin_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_asin_op {$/;"	s	namespace:Eigen::internal
scalar_binary_pow_op	Eigen/src/Core/Functors.h	/^template<typename Scalar, typename OtherScalar> struct scalar_binary_pow_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_and_op	Eigen/src/Core/Functors.h	/^struct scalar_boolean_and_op {$/;"	s	namespace:Eigen::internal
scalar_boolean_or_op	Eigen/src/Core/Functors.h	/^struct scalar_boolean_or_op {$/;"	s	namespace:Eigen::internal
scalar_cast_op	Eigen/src/Core/Functors.h	/^struct scalar_cast_op {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_EQ> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_LE> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_LT> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_NEQ> {$/;"	s	namespace:Eigen::internal
scalar_cmp_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cmp_op<Scalar, cmp_UNORD> {$/;"	s	namespace:Eigen::internal
scalar_conj_product_op	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_conj_product_op {$/;"	s	namespace:Eigen::internal
scalar_conjugate_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_conjugate_op {$/;"	s	namespace:Eigen::internal
scalar_constant_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_constant_op(const scalar_constant_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_constant_op
scalar_constant_op	Eigen/src/Core/Functors.h	/^struct scalar_constant_op {$/;"	s	namespace:Eigen::internal
scalar_cos_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_cos_op {$/;"	s	namespace:Eigen::internal
scalar_cube_op	Eigen/src/Core/Functors.h	/^struct scalar_cube_op {$/;"	s	namespace:Eigen::internal
scalar_difference_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_difference_op {$/;"	s	namespace:Eigen::internal
scalar_exp_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_exp_op {$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, false, true>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_default_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_default_impl<Scalar, true, false>$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	Eigen/src/Core/MathFunctions.h	/^struct scalar_fuzzy_impl : scalar_fuzzy_default_impl<Scalar, NumTraits<Scalar>::IsComplex, NumTraits<Scalar>::IsInteger> {};$/;"	s	namespace:Eigen::internal
scalar_fuzzy_impl	Eigen/src/Core/MathFunctions.h	/^template<> struct scalar_fuzzy_impl<bool>$/;"	s	namespace:Eigen::internal
scalar_hypot_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_hypot_op {$/;"	s	namespace:Eigen::internal
scalar_identity_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_identity_op {$/;"	s	namespace:Eigen::internal
scalar_imag_op	Eigen/src/Core/Functors.h	/^struct scalar_imag_op {$/;"	s	namespace:Eigen::internal
scalar_imag_ref_op	Eigen/src/Core/Functors.h	/^struct scalar_imag_ref_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_mult_op	Eigen/src/Core/Functors.h	/^  scalar_inverse_mult_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_inverse_mult_op
scalar_inverse_mult_op	Eigen/src/Core/Functors.h	/^struct scalar_inverse_mult_op {$/;"	s	namespace:Eigen::internal
scalar_inverse_op	Eigen/src/Core/Functors.h	/^struct scalar_inverse_op {$/;"	s	namespace:Eigen::internal
scalar_log_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_log_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_max_op {$/;"	s	namespace:Eigen::internal
scalar_max_op	Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_max_op)$/;"	f	class:Eigen::Cwise
scalar_min_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_min_op {$/;"	s	namespace:Eigen::internal
scalar_min_op	Eigen/src/Eigen2Support/Cwise.h	/^    const EIGEN_CWISE_BINOP_RETURN_TYPE(internal::scalar_min_op)$/;"	f	class:Eigen::Cwise
scalar_multiple2_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const Scalar2& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op
scalar_multiple2_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple2_op(const scalar_multiple2_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple2_op
scalar_multiple2_op	Eigen/src/Core/Functors.h	/^struct scalar_multiple2_op {$/;"	s	namespace:Eigen::internal
scalar_multiple_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const Scalar& other) : m_other(other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op
scalar_multiple_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_multiple_op(const scalar_multiple_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_multiple_op
scalar_multiple_op	Eigen/src/Core/Functors.h	/^struct scalar_multiple_op {$/;"	s	namespace:Eigen::internal
scalar_opposite_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_opposite_op {$/;"	s	namespace:Eigen::internal
scalar_pow_op	Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const Scalar& exponent) : m_exponent(exponent) {}$/;"	f	struct:Eigen::internal::scalar_pow_op
scalar_pow_op	Eigen/src/Core/Functors.h	/^  inline scalar_pow_op(const scalar_pow_op& other) : m_exponent(other.m_exponent) { }$/;"	f	struct:Eigen::internal::scalar_pow_op
scalar_pow_op	Eigen/src/Core/Functors.h	/^struct scalar_pow_op {$/;"	s	namespace:Eigen::internal
scalar_product_op	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_product_op {$/;"	s	namespace:Eigen::internal
scalar_product_traits	Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct scalar_product_traits$/;"	s	namespace:Eigen
scalar_product_traits	Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,T>$/;"	s	namespace:Eigen
scalar_product_traits	Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<T,std::complex<T> >$/;"	s	namespace:Eigen
scalar_product_traits	Eigen/src/Core/util/Meta.h	/^template<typename T> struct scalar_product_traits<std::complex<T>, T>$/;"	s	namespace:Eigen
scalar_quotient1_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const Scalar& other) : m_other(other) {}$/;"	f	struct:Eigen::internal::scalar_quotient1_op
scalar_quotient1_op	Eigen/src/Core/Functors.h	/^  EIGEN_STRONG_INLINE scalar_quotient1_op(const scalar_quotient1_op& other) : m_other(other.m_other) { }$/;"	f	struct:Eigen::internal::scalar_quotient1_op
scalar_quotient1_op	Eigen/src/Core/Functors.h	/^struct scalar_quotient1_op {$/;"	s	namespace:Eigen::internal
scalar_quotient_op	Eigen/src/Core/Functors.h	/^template<typename LhsScalar,typename RhsScalar> struct scalar_quotient_op {$/;"	s	namespace:Eigen::internal
scalar_random_op	Eigen/src/Core/Random.h	/^template<typename Scalar> struct scalar_random_op {$/;"	s	namespace:Eigen::internal
scalar_real_op	Eigen/src/Core/Functors.h	/^struct scalar_real_op {$/;"	s	namespace:Eigen::internal
scalar_real_ref_op	Eigen/src/Core/Functors.h	/^struct scalar_real_ref_op {$/;"	s	namespace:Eigen::internal
scalar_sin_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sin_op {$/;"	s	namespace:Eigen::internal
scalar_sqrt_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sqrt_op {$/;"	s	namespace:Eigen::internal
scalar_square_op	Eigen/src/Core/Functors.h	/^struct scalar_square_op {$/;"	s	namespace:Eigen::internal
scalar_sum_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_sum_op {$/;"	s	namespace:Eigen::internal
scalar_tan_op	Eigen/src/Core/Functors.h	/^template<typename Scalar> struct scalar_tan_op {$/;"	s	namespace:Eigen::internal
scale	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
scale	Eigen/src/Eigen2Support/Geometry/Transform.h	/^inline Transform<Scalar,Dim>& Transform<Scalar,Dim>::scale(Scalar s)$/;"	f	class:Eigen::Transform
scale	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::scale(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
scale	Eigen/src/Geometry/Transform.h	/^inline Transform<Scalar,Dim,Mode,Options>& Transform<Scalar,Dim,Mode,Options>::scale(const Scalar& s)$/;"	f	class:Eigen::Transform
scale	srLib/SceneGraph/Leaf.h	/^	double		scale;$/;"	m	class:ForceVector
scale	srLib/SceneGraph/Model3DS.h	/^	float	scale;				\/\/ The size you want the model scaled to$/;"	m	class:Model3DS
scaleAndAddTo	Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct
scaleAndAddTo	Eigen/src/Core/GeneralProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct
scaleAndAddTo	Eigen/src/Core/ProductBase.h	/^    inline void scaleAndAddTo(Dest& dst, const Scalar& a_alpha) const { m_prod.derived().scaleAndAddTo(dst,a_alpha * m_alpha); }$/;"	f	class:ScaledProduct
scaleAndAddTo	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	class:Eigen::GeneralProduct
scaleAndAddTo	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix
scaleAndAddTo	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	struct:Eigen::SelfadjointProductMatrix
scaleAndAddTo	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::TriangularProduct
scaleAndAddTo	Eigen/src/Core/products/TriangularMatrixVector.h	/^  template<typename Dest> void scaleAndAddTo(Dest& dst, const Scalar& alpha) const$/;"	f	struct:Eigen::TriangularProduct
scaleAndAddTo	Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::DenseTimeSparseProduct
scaleAndAddTo	Eigen/src/SparseCore/SparseDenseProduct.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::SparseTimeDenseProduct
scaleAndAddTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& \/*dest*\/, const Scalar& \/*alpha*\/) const$/;"	f	class:Eigen::DenseTimeSparseSelfAdjointProduct
scaleAndAddTo	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    template<typename Dest> void scaleAndAddTo(Dest& dest, const Scalar& alpha) const$/;"	f	class:Eigen::SparseSelfAdjointTimeDenseProduct
scaleFactor	srLib/SceneGraph/Transformation.h	/^	double	scaleFactor;$/;"	m	class:Transformation
scomplex	Eigen/src/Core/util/MKL_support.h	/^typedef std::complex<float>  scomplex;$/;"	t	namespace:Eigen
score	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index score ; \/* the score used to maintain heap, if col is alive *\/$/;"	m	union:internal::colamd_col::__anon350
screenShotNum	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int     SceneGraphRenderer::screenShotNum = 0;$/;"	m	class:SceneGraphRenderer	file:
screenShotNum	srLib/SceneGraph/SceneGraphRenderer.h	/^	static  int		screenShotNum;$/;"	m	class:SceneGraphRenderer
sdf2srSystem	srLib/common/srSDF.cpp	/^void srSDF::sdf2srSystem(srSystem * _system, string _stlPath, string _sdfPath)$/;"	f	class:srSDF
se3	srLib/LieGroup/LieGroup.h	/^class se3$/;"	c
se3	srMath/SE3.h	/^	typedef Vector6 se3;$/;"	t	namespace:srMath
se3_bracket	srLib/srExt/srExt_LieGroup.cpp	/^Eigen::Matrix4d srExt::se3_bracket(const se3 & _s)$/;"	f	class:srExt
searchLowerIndex	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
searchLowerIndex	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Index searchLowerIndex(size_t start, size_t end, Index key) const$/;"	f	class:Eigen::internal::CompressedStorage
second	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^    RealPacket second;$/;"	m	struct:Eigen::internal::gebp_traits::DoublePacket
seed	srLib/srDyn/srISLAND.cpp	/^static unsigned long seed = 0;$/;"	v	file:
segment	Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType segment(Index start, Index n) const$/;"	f
segment	Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType segment(Index start, Index n)$/;"	f
segment	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type segment(Index start, Index n = N) const$/;"	f
segment	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type segment(Index start, Index n = N)$/;"	f
select	Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const DenseBase<ThenDerived>& thenMatrix,$/;"	f	class:Eigen::DenseBase
select	Eigen/src/Core/Select.h	/^DenseBase<Derived>::select(const typename ElseDerived::Scalar& thenScalar,$/;"	f	class:Eigen::DenseBase
selector	Eigen/src/Core/GeneralProduct.h	/^  typedef product_type_selector<rows_select, cols_select, depth_select> selector;$/;"	t	struct:Eigen::internal::product_type
selfadjointView	Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::MatrixBase
selfadjointView	Eigen/src/Core/SelfAdjointView.h	/^MatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::MatrixBase
selfadjointView	Eigen/src/Core/TriangularMatrix.h	/^    SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView()$/;"	f	class:Eigen::TriangularView
selfadjointView	Eigen/src/Core/TriangularMatrix.h	/^    const SelfAdjointView<MatrixTypeNestedNonRef,Mode> selfadjointView() const$/;"	f	class:Eigen::TriangularView
selfadjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView()$/;"	f	class:Eigen::SparseMatrixBase
selfadjointView	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^const SparseSelfAdjointView<Derived, UpLo> SparseMatrixBase<Derived>::selfadjointView() const$/;"	f	class:Eigen::SparseMatrixBase
selfadjoint_matrix_vector_product	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct selfadjoint_matrix_vector_product$/;"	s	namespace:Eigen::internal
selfadjoint_matrix_vector_product_symv	Eigen/src/Core/products/SelfadjointMatrixVector_MKL.h	/^struct selfadjoint_matrix_vector_product_symv :$/;"	s	namespace:Eigen::internal
selfadjoint_product_selector	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,false>$/;"	s	namespace:Eigen
selfadjoint_product_selector	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_product_selector<MatrixType,OtherType,UpLo,true>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,ColMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank1_update	Eigen/src/Core/products/SelfadjointProduct.h	/^struct selfadjoint_rank1_update<Scalar,Index,RowMajor,UpLo,ConjLhs,ConjRhs>$/;"	s	namespace:Eigen
selfadjoint_rank2_update_selector	Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Lower>$/;"	s	namespace:Eigen::internal
selfadjoint_rank2_update_selector	Eigen/src/Core/products/SelfadjointRank2Update.h	/^struct selfadjoint_rank2_update_selector<Scalar,Index,UType,VType,Upper>$/;"	s	namespace:Eigen::internal
set	Eigen/src/Core/GeneralProduct.h	/^    struct set  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived()  = src; } };$/;"	s	class:Eigen::GeneralProduct
setA	srMath/Function.h	/^		void setA(const MatrixX& A) { _A = A; }$/;"	f	class:srMath::AffineFunction
setA	srMath/Function.h	/^		void setA(const MatrixX& A) { _A = A; }$/;"	f	class:srMath::QuadraticFunction
setAmbient	srLib/SceneGraph/Light.cpp	/^void Light::setAmbient( float r, float g, float b, float alpha )$/;"	f	class:Light
setAmbient	srLib/SceneGraph/Shader.cpp	/^void Shader::setAmbient( float r, float g, float b, float alpha )$/;"	f	class:Shader
setArrowSize	srLib/SceneGraph/Leaf.cpp	/^void Coordinate::setArrowSize(double arrowSize)$/;"	f	class:Coordinate
setArrowVector	srLib/SceneGraph/Leaf.cpp	/^void Arrow::setArrowVector(Vec3 _arrow)$/;"	f	class:Arrow
setBaseFunction	srMath/Function.cpp	/^	void MultiplyConstFunction::setBaseFunction(const std::shared_ptr<const Function>& baseFunction)$/;"	f	class:srMath::MultiplyConstFunction
setBounds	Eigen/src/SparseCore/AmbiVector.h	/^    void setBounds(Index start, Index end) { m_start = start; m_end = end; }$/;"	f	class:Eigen::internal::AmbiVector
setClearColor	srLib/SceneGraph/Camera.cpp	/^void Camera::setClearColor( double r, double g, double b, double alpha )$/;"	f	class:Camera
setCollision	srLib/common/srRobot.cpp	/^srCollision * srrobot::srRobot::setCollision(string collisionname)$/;"	f	class:srrobot::srRobot
setColor	srLib/SceneGraph/Leaf.cpp	/^void ColorPoint::setColor(double r, double g, double b)$/;"	f	class:ColorPoint
setColor	srLib/SceneGraph/Leaf.cpp	/^void ColorPointGroup::setColor(double r, double g, double b)$/;"	f	class:ColorPointGroup
setColor	srLib/SceneGraph/Leaf.cpp	/^void Lines::setColor(float r, float g, float b, float alpha)$/;"	f	class:Lines
setColor	srLib/SceneGraph/Leaf.cpp	/^void Polygon::setColor(double r, double g, double b, double alpha)$/;"	f	class:Polygon
setColor	srLib/SceneGraph/Leaf.cpp	/^void Strip::setColor(float r, float g, float b, float alpha)$/;"	f	class:Strip
setColor	srLib/SceneGraph/Shader.cpp	/^void Shader::setColor( float r, float g, float b, float alpha \/*= 1.0f*\/ )$/;"	f	class:Shader
setConstant	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setConstant(const Scalar& val)$/;"	f	class:Eigen::DenseBase
setConstant	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index nbRows, Index nbCols, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase
setConstant	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setConstant(Index size, const Scalar& val)$/;"	f	class:Eigen::PlainObjectBase
setConstant	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setConstant(const Scalar& value)$/;"	f	class:Eigen::TriangularView
setCpuCacheSizes	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^inline void setCpuCacheSizes(std::ptrdiff_t l1, std::ptrdiff_t l2)$/;"	f	namespace:Eigen
setDiffuse	srLib/SceneGraph/Light.cpp	/^void Light::setDiffuse( float r, float g, float b, float alpha )$/;"	f	class:Light
setDiffuse	srLib/SceneGraph/Shader.cpp	/^void Shader::setDiffuse( float r, float g, float b, float alpha )$/;"	f	class:Shader
setDroptol	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setDroptol(const RealScalar& droptol)$/;"	f	class:Eigen::IncompleteLUT
setEdgePointList	srLib/SceneGraph/Leaf.cpp	/^void varianceStrap::setEdgePointList(const vector<vector<Vec3>>& list)$/;"	f	class:varianceStrap
setEmpty	Eigen/src/Geometry/AlignedBox.h	/^  inline void setEmpty()$/;"	f	class:Eigen::AlignedBox
setFillfactor	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^void IncompleteLUT<Scalar>::setFillfactor(int fillfactor)$/;"	f	class:Eigen::IncompleteLUT
setForce	srLib/SceneGraph/Leaf.cpp	/^void ForceVector::setForce(dse3 force)$/;"	f	class:ForceVector
setForce	srLib/SceneGraph/Leaf.cpp	/^void ForceVector::setForce(dse3* pForce)$/;"	f	class:ForceVector
setFromTriplets	Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::setFromTriplets(const InputIterators& begin, const InputIterators& end)$/;"	f	class:Eigen::SparseMatrix
setFromTwoVectors	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^inline Quaternion<Scalar>& Quaternion<Scalar>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::Quaternion
setFromTwoVectors	Eigen/src/Geometry/Quaternion.h	/^inline Derived& QuaternionBase<Derived>::setFromTwoVectors(const MatrixBase<Derived1>& a, const MatrixBase<Derived2>& b)$/;"	f	class:Eigen::QuaternionBase
setIdentity	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity()$/;"	f	class:Eigen::MatrixBase
setIdentity	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& MatrixBase<Derived>::setIdentity(Index nbRows, Index nbCols)$/;"	f	class:Eigen::MatrixBase
setIdentity	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity() { m_diagonal.setOnes(); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setIdentity(Index size) { m_diagonal.setOnes(size); }$/;"	f	class:Eigen::DiagonalMatrix
setIdentity	Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity()$/;"	f	class:Eigen::PermutationBase
setIdentity	Eigen/src/Core/PermutationMatrix.h	/^    void setIdentity(Index newSize)$/;"	f	class:Eigen::PermutationBase
setIdentity	Eigen/src/Core/Transpositions.h	/^    void setIdentity()$/;"	f	class:Eigen::TranspositionsBase
setIdentity	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Quaternion& setIdentity() { m_coeffs << 0, 0, 0, 1; return *this; }$/;"	f	class:Eigen::Quaternion
setIdentity	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform
setIdentity	Eigen/src/Geometry/Quaternion.h	/^  inline QuaternionBase& setIdentity() { coeffs() << Scalar(0), Scalar(0), Scalar(0), Scalar(1); return *this; }$/;"	f	class:Eigen::QuaternionBase
setIdentity	Eigen/src/Geometry/Transform.h	/^  void setIdentity() { m_matrix.setIdentity(); }$/;"	f	class:Eigen::Transform
setIdentity	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setIdentity()$/;"	f	class:Eigen::SparseMatrix
setIdentity_impl	Eigen/src/Core/CwiseNullaryOp.h	/^struct setIdentity_impl<Derived, true>$/;"	s	namespace:Eigen::internal
setInfos	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    void setInfos(Index m, Index n, ScalarVector& nzval, IndexVector& nzval_colptr, IndexVector& rowind, $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
setJoint	srLib/common/srRobot.cpp	/^srJoint * srrobot::srRobot::setJoint(string jointname, srJoint::JOINTTYPE jointType)$/;"	f	class:srrobot::srRobot
setJointValue	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::setJointValue(srLink * const _endEffector, const Eigen::VectorXd & _q)$/;"	f	class:srExt::srExtSystem
setJointValue	srLib/srExt/srExtension.cpp	/^void srExt::setJointValue(srLink * const _endEffector, const VectorXd & _q)$/;"	f	class:srExt
setLength	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setLength(Index length)$/;"	f	class:Eigen::HouseholderSequence
setLinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(Index newSize, const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setLinSpaced	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setLinSpaced(const Scalar& low, const Scalar& high)$/;"	f	class:Eigen::DenseBase
setLineWidth	srLib/SceneGraph/Leaf.cpp	/^void Coordinate::setLineWidth(double lineWidth)$/;"	f	class:Coordinate
setLineWidth	srLib/SceneGraph/Leaf.cpp	/^void Lines::setLineWidth(double width)$/;"	f	class:Lines
setLink	srLib/common/srRobot.cpp	/^srLink * srrobot::srRobot::setLink(string linkname)$/;"	f	class:srrobot::srRobot
setLocalFrame	srLib/SceneGraph/Transformation.cpp	/^void Transformation::setLocalFrame( SE3 localFrame )$/;"	f	class:Transformation
setMaxIterations	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^    ComplexEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexEigenSolver
setMaxIterations	Eigen/src/Eigenvalues/ComplexSchur.h	/^    ComplexSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::ComplexSchur
setMaxIterations	Eigen/src/Eigenvalues/EigenSolver.h	/^    EigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::EigenSolver
setMaxIterations	Eigen/src/Eigenvalues/GeneralizedEigenSolver.h	/^    GeneralizedEigenSolver& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::GeneralizedEigenSolver
setMaxIterations	Eigen/src/Eigenvalues/RealQZ.h	/^      RealQZ& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealQZ
setMaxIterations	Eigen/src/Eigenvalues/RealSchur.h	/^    RealSchur& setMaxIterations(Index maxIters)$/;"	f	class:Eigen::RealSchur
setMaxIterations	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setMaxIterations(int maxIters)$/;"	f	class:Eigen::IterativeSolverBase
setMode	Eigen/src/CholmodSupport/CholmodSupport.h	/^    void setMode(CholmodMode mode)$/;"	f	class:Eigen::CholmodDecomposition
setMode	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    SimplicialCholesky& setMode(SimplicialCholeskyMode mode)$/;"	f	class:Eigen::SimplicialCholesky
setNbThreads	Eigen/src/Core/products/Parallelizer.h	/^inline void setNbThreads(int v)$/;"	f	namespace:Eigen
setNull	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline void setNull()$/;"	f	class:Eigen::AlignedBox
setNull	Eigen/src/Geometry/AlignedBox.h	/^  inline void setNull() { setEmpty(); }$/;"	f	class:Eigen::AlignedBox
setOnes	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setOnes()$/;"	f	class:Eigen::DenseBase
setOnes	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
setOnes	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setOnes(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setOnes	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setOnes() { return setConstant(Scalar(1)); }$/;"	f	class:Eigen::TriangularView
setOrtho	srLib/SceneGraph/Camera.cpp	/^void Camera::setOrtho( double x1,double x2,double y1,double y2, double z1, double z2 )$/;"	f	class:Camera
setPivotThreshold	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setPivotThreshold(const RealScalar& tol)$/;"	f	class:Eigen::SPQR
setPivotThreshold	Eigen/src/SparseLU/SparseLU.h	/^    void setPivotThreshold(const RealScalar& thresh)$/;"	f	class:Eigen::SparseLU
setPivotThreshold	Eigen/src/SparseQR/SparseQR.h	/^    void setPivotThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::SparseQR
setPointSize	srLib/SceneGraph/Leaf.cpp	/^void ColorPoint::setPointSize(double size)$/;"	f	class:ColorPoint
setPointSize	srLib/SceneGraph/Leaf.cpp	/^void ColorPointGroup::setPointSize(double size)$/;"	f	class:ColorPointGroup
setPointSize	srLib/SceneGraph/Leaf.cpp	/^void Polygon::setPointSize(double size)$/;"	f	class:Polygon
setPosition	srLib/SceneGraph/Light.cpp	/^void Light::setPosition( float x, float y, float z, float w )$/;"	f	class:Light
setPosition	srMath/SE3.cpp	/^	void SE3::setPosition(const Vector3& p)$/;"	f	class:srMath::SE3
setRandom	Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
setRandom	Eigen/src/Core/Random.h	/^PlainObjectBase<Derived>::setRandom(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setRandom	Eigen/src/Core/Random.h	/^inline Derived& DenseBase<Derived>::setRandom()$/;"	f	class:Eigen::DenseBase
setRange	srLib/SceneGraph/Leaf.cpp	/^void Grid::setRange(double range)$/;"	f	class:Grid
setRotation	srMath/SE3.cpp	/^	void SE3::setRotation(const Matrix3& M)$/;"	f	class:srMath::SE3
setRotation	srMath/SE3.cpp	/^	void SE3::setRotation(const SO3& R)$/;"	f	class:srMath::SE3
setSPQROrdering	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    void setSPQROrdering(int ord) { m_ordering = ord;}$/;"	f	class:Eigen::SPQR
setScalarType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setScalarType()$/;"	f	struct:Eigen::SluMatrix
setScale	srLib/SceneGraph/Leaf.cpp	/^void ForceVector::setScale(double scale)$/;"	f	class:ForceVector
setScaleFactor	srLib/SceneGraph/Leaf.cpp	/^void Coordinate::setScaleFactor(double sacleFactor)$/;"	f	class:Coordinate
setScaleFactor	srLib/SceneGraph/Transformation.cpp	/^void Transformation::setScaleFactor(double scale)$/;"	f	class:Transformation
setScreenShot	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void SceneGraphRenderer::setScreenShot( bool bScreenShot )$/;"	f	class:SceneGraphRenderer
setShift	Eigen/src/CholmodSupport/CholmodSupport.h	/^    Derived& setShift(const RealScalar& offset)$/;"	f	class:Eigen::CholmodBase
setShift	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setShift(Index shift)$/;"	f	class:Eigen::HouseholderSequence
setShift	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    Derived& setShift(const RealScalar& offset, const RealScalar& scale = 1)$/;"	f	class:Eigen::SimplicialCholeskyBase
setShininess	srLib/SceneGraph/Shader.cpp	/^void Shader::setShininess( float s )$/;"	f	class:Shader
setSingleJoint	srLib/common/srSDF.cpp	/^void srSDF::setSingleJoint(srSystem * _system, tinyxml2::XMLElement * _pjoint)$/;"	f	class:srSDF
setSingleLink	srLib/common/srSDF.cpp	/^void srSDF::setSingleLink(srSystem * _system, tinyxml2::XMLElement * _plink, std::string _stlPath)$/;"	f	class:srSDF
setSlice	srLib/SceneGraph/Leaf.cpp	/^void Sphere::setSlice(double _slice)$/;"	f	class:Sphere
setSpecular	srLib/SceneGraph/Light.cpp	/^void Light::setSpecular( float r, float g, float b, float alpha )$/;"	f	class:Light
setSpecular	srLib/SceneGraph/Shader.cpp	/^void Shader::setSpecular( float r, float g, float b, float alpha )$/;"	f	class:Shader
setStepSize	srLib/SceneGraph/Leaf.cpp	/^void Grid::setStepSize(double step)$/;"	f	class:Grid
setStorageType	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  void setStorageType(Stype_t t)$/;"	f	struct:Eigen::SluMatrix
setString	srLib/SceneGraph/Leaf.cpp	/^void Font::setString(const string& str)$/;"	f	class:Font
setSupportPolygon	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::setSupportPolygon(Eigen::VectorXd _supPolyBoundary)$/;"	f	class:srExt::srExtSystem
setTargetSE3Pointer	srLib/SceneGraph/Transformation.cpp	/^void Transformation::setTargetSE3Pointer( SE3* pSE3 )$/;"	f	class:Transformation
setThreshold	Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivLU
setThreshold	Eigen/src/LU/FullPivLU.h	/^    FullPivLU& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivLU
setThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    ColPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::ColPivHouseholderQR
setThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(Default_t)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    FullPivHouseholderQR& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::FullPivHouseholderQR
setThreshold	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& setThreshold(Default_t)$/;"	f	class:Eigen::JacobiSVD
setThreshold	Eigen/src/SVD/JacobiSVD.h	/^    JacobiSVD& setThreshold(const RealScalar& threshold)$/;"	f	class:Eigen::JacobiSVD
setTolerance	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  Derived& setTolerance(const RealScalar& tolerance)$/;"	f	class:Eigen::IterativeSolverBase
setTrans	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence& setTrans(bool trans)$/;"	f	class:Eigen::HouseholderSequence
setTransformation	srLib/SceneGraph/Transformation.cpp	/^void Transformation::setTransformation(SE3 trans)$/;"	f	class:Transformation
setUpdateFunc	srLib/SceneGraph/srSpaceRenderer.h	/^	void setUpdateFunc(void(*func)(void)) {$/;"	f	class:srSpaceRenderer
setWeight	srMath/Function.cpp	/^	void MultiplyConstFunction::setWeight(const Real w)$/;"	f	class:srMath::MultiplyConstFunction
setZero	Eigen/src/Cholesky/LDLT.h	/^    void setZero()$/;"	f	class:Eigen::LDLT
setZero	Eigen/src/Core/CwiseNullaryOp.h	/^EIGEN_STRONG_INLINE Derived& DenseBase<Derived>::setZero()$/;"	f	class:Eigen::DenseBase
setZero	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index nbRows, Index nbCols)$/;"	f	class:Eigen::PlainObjectBase
setZero	Eigen/src/Core/CwiseNullaryOp.h	/^PlainObjectBase<Derived>::setZero(Index newSize)$/;"	f	class:Eigen::PlainObjectBase
setZero	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero() { m_diagonal.setZero(); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	Eigen/src/Core/DiagonalMatrix.h	/^    inline void setZero(Index size) { m_diagonal.setZero(size); }$/;"	f	class:Eigen::DiagonalMatrix
setZero	Eigen/src/Core/TriangularMatrix.h	/^    TriangularView& setZero() { return setConstant(Scalar(0)); }$/;"	f	class:Eigen::TriangularView
setZero	Eigen/src/SparseCore/AmbiVector.h	/^void AmbiVector<_Scalar,_Index>::setZero()$/;"	f	class:Eigen::internal::AmbiVector
setZero	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void setZero()$/;"	f	class:Eigen::SparseMatrix
setZero	Eigen/src/SparseCore/SparseVector.h	/^    inline void setZero() { m_data.clear(); }$/;"	f	class:Eigen::SparseVector
set_from_triplets	Eigen/src/SparseCore/SparseMatrix.h	/^void set_from_triplets(const InputIterator& begin, const InputIterator& end, SparseMatrixType& mat, int Options = 0)$/;"	f	namespace:Eigen::internal
set_is_malloc_allowed	Eigen/src/Core/util/Memory.h	/^inline bool set_is_malloc_allowed(bool new_value) { return is_malloc_allowed_impl(true, new_value); }$/;"	f	namespace:Eigen::internal
set_size	srLib/LieGroup/_array.h	/^	void set_size(int n, bool keep_value = false)$/;"	f	class:_array
setb	srMath/Function.h	/^		void setb(const VectorX& b) { _b = b; }$/;"	f	class:srMath::AffineFunction
setb	srMath/Function.h	/^		void setb(const VectorX& b) { _b = b; }$/;"	f	class:srMath::QuadraticFunction
setc	srMath/Function.h	/^		void setc(const Real c) { _c(0) = c; }$/;"	f	class:srMath::QuadraticFunction
shader_stack	srLib/SceneGraph/gl2ps.c	/^  int shader_stack; \/* shader object numbers *\/$/;"	m	struct:__anon15	file:
shared1	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon353
shared1	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared1 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon349
shared2	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::Colamd_Row	typeref:union:internal::Colamd_Row::__anon354
shared2	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared2 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon350
shared3	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared3 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon351
shared4	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  } shared4 ;$/;"	m	struct:internal::colamd_col	typeref:union:internal::colamd_col::__anon352
shear	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::shear(Scalar sx, Scalar sy)$/;"	f	class:Eigen::Transform
shear	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::shear(const Scalar& sx, const Scalar& sy)$/;"	f	class:Eigen::Transform
shift	Eigen/src/Householder/HouseholderSequence.h	/^    Index shift() const { return m_shift; }    \/**< \\brief Returns the shift of the Householder sequence. *\/$/;"	f	class:Eigen::HouseholderSequence
shininess	srLib/SceneGraph/Shader.h	/^	float			shininess;$/;"	m	class:Shader
shno	srLib/SceneGraph/gl2ps.c	/^  int gsno, fontno, imno, shno, maskshno, trgroupno;$/;"	m	struct:__anon14	file:
shobjno	srLib/SceneGraph/gl2ps.c	/^  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;$/;"	m	struct:__anon14	file:
shownormals	srLib/SceneGraph/Model3DS.h	/^	bool	shownormals;		\/\/ True: show the normals$/;"	m	class:Model3DS
signDeterminant	Eigen/src/SparseLU/SparseLU.h	/^    Scalar signDeterminant()$/;"	f	class:Eigen::SparseLU
signedDistance	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return p.eigen2_dot(normal()) + offset(); }$/;"	f	class:Eigen::Hyperplane
signedDistance	Eigen/src/Geometry/Hyperplane.h	/^  inline Scalar signedDistance(const VectorType& p) const { return normal().dot(p) + offset(); }$/;"	f	class:Eigen::Hyperplane
significant_decimals_default_impl	Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl$/;"	s	namespace:Eigen::internal
significant_decimals_default_impl	Eigen/src/Core/IO.h	/^struct significant_decimals_default_impl<Scalar, true>$/;"	s	namespace:Eigen::internal
significant_decimals_impl	Eigen/src/Core/IO.h	/^struct significant_decimals_impl$/;"	s	namespace:Eigen::internal
sin	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sin() const$/;"	f	class:Eigen::Cwise
sin	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sin() const$/;"	f
singularValues	Eigen/src/Eigen2Support/SVD.h	/^    const SingularValuesType& singularValues() const { return m_sigma; }$/;"	f	class:Eigen::SVD
singularValues	Eigen/src/SVD/JacobiSVD.h	/^    const SingularValuesType& singularValues() const$/;"	f	class:Eigen::JacobiSVD
size	Eigen/src/Core/EigenBase.h	/^  inline Index size() const { return rows() * cols(); }$/;"	f	struct:Eigen::EigenBase
size	Eigen/src/Core/GenericPacketMath.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon225
size	Eigen/src/Core/PermutationMatrix.h	/^    inline Index size() const { return Index(indices().size()); }$/;"	f	class:Eigen::PermutationBase
size	Eigen/src/Core/Transpositions.h	/^    inline Index size() const { return indices().size(); }$/;"	f	class:Eigen::TranspositionsBase
size	Eigen/src/Core/Transpositions.h	/^    inline int size() const { return m_transpositions.size(); }$/;"	f	class:Eigen::Transpose
size	Eigen/src/Core/arch/AltiVec/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon267
size	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon268
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon264
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon263
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon265
size	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon266
size	Eigen/src/Core/arch/NEON/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon261
size	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon262
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^    size = 4,$/;"	e	enum:Eigen::internal::packet_traits::__anon257
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon258
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon259
size	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon260
size	Eigen/src/Core/arch/SSE/Complex.h	/^    size = 1,$/;"	e	enum:Eigen::internal::packet_traits::__anon255
size	Eigen/src/Core/arch/SSE/Complex.h	/^    size = 2,$/;"	e	enum:Eigen::internal::packet_traits::__anon253
size	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon256
size	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon254
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=2,$/;"	e	enum:Eigen::internal::packet_traits::__anon248
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4$/;"	e	enum:Eigen::internal::packet_traits::__anon249
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^    size=4,$/;"	e	enum:Eigen::internal::packet_traits::__anon247
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon251
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon250
size	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	e	enum:Eigen::internal::unpacket_traits::__anon252
size	Eigen/src/SparseCore/AmbiVector.h	/^    Index size() const { return m_size; }$/;"	f	class:Eigen::internal::AmbiVector
size	Eigen/src/SparseCore/CompressedStorage.h	/^    inline size_t size() const { return m_size; }$/;"	f	class:Eigen::internal::CompressedStorage
size	Eigen/src/SparseCore/SparseMatrixBase.h	/^    inline Index size() const { return rows() * cols(); }$/;"	f	class:Eigen::SparseMatrixBase
size	srLib/LieGroup/_array.h	/^	int		 size;$/;"	m	class:_array
size	srLib/SceneGraph/Leaf.h	/^	double				size;$/;"	m	class:Polygon
size	srLib/SceneGraph/Leaf.h	/^	double size;$/;"	m	class:Arrow
size	srLib/SceneGraph/Leaf.h	/^	double size;$/;"	m	class:ColorPoint
size	srLib/SceneGraph/Leaf.h	/^	double size;$/;"	m	class:ColorPointGroup
size	srLib/SceneGraph/gl2ps.c	/^  GLint nmax, size, incr, n;$/;"	m	struct:__anon6	file:
size_type	Eigen/src/Core/util/Memory.h	/^  typedef size_t          size_type;$/;"	t	class:Eigen::aligned_allocator
size_type	Eigen/src/StlSupport/details.h	/^    typedef size_t    size_type;$/;"	t	class:Eigen::aligned_allocator_indirection
sizes	Eigen/src/Geometry/AlignedBox.h	/^  inline const CwiseBinaryOp< internal::scalar_difference_op<Scalar>, const VectorType, const VectorType> sizes() const$/;"	f	class:Eigen::AlignedBox
skewSymm	srLib/srExt/srExt_Eigen.cpp	/^Matrix3d Eigen::skewSymm(double _v0, double _v1, double _v2)$/;"	f	class:Eigen
skewSymm	srLib/srExt/srExt_Eigen.h	/^	Matrix3d skewSymm(const vectorClass& _v)$/;"	f	namespace:Eigen
slerp	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar> Quaternion<Scalar>::slerp(Scalar t, const Quaternion& other) const$/;"	f	class:Eigen::Quaternion
slerp	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(Scalar t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
slerp	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::slerp(const Scalar& t, const QuaternionBase<OtherDerived>& other) const$/;"	f	class:Eigen::QuaternionBase
slerp	Eigen/src/Geometry/Rotation2D.h	/^  inline Rotation2D slerp(const Scalar& t, const Rotation2D& other) const$/;"	f	class:Eigen::Rotation2D
slerp	srLib/LieGroup/LieGroup.cpp	/^Quaternion slerp(const Quaternion& p, const Quaternion& q, SR_REAL t)$/;"	f
slice	srLib/SceneGraph/Leaf.h	/^	double slice;$/;"	m	class:Sphere
slice	srLib/SceneGraph/Leaf.h	/^	int		slice;$/;"	m	class:Cylinder
slice	srLib/SceneGraph/Leaf.h	/^	int		slice;$/;"	m	class:DomeBase
smart_copy	Eigen/src/Core/util/Memory.h	/^template<typename T> void smart_copy(const T* start, const T* end, T* target)$/;"	f	namespace:Eigen::internal
smart_copy_helper	Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,false> {$/;"	s	namespace:Eigen::internal
smart_copy_helper	Eigen/src/Core/util/Memory.h	/^template<typename T> struct smart_copy_helper<T,true> {$/;"	s	namespace:Eigen::internal
so3	srMath/SO3.h	/^	typedef Vector3 so3;$/;"	t	namespace:srMath
solve	Eigen/src/Cholesky/LDLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LDLT
solve	Eigen/src/Cholesky/LDLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LDLT
solve	Eigen/src/Cholesky/LLT.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LLT
solve	Eigen/src/Cholesky/LLT.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::LLT
solve	Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase
solve	Eigen/src/CholmodSupport/CholmodSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::CholmodBase
solve	Eigen/src/Core/SolveTriangular.h	/^TriangularView<Derived,Mode>::solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView
solve	Eigen/src/Core/TriangularMatrix.h	/^    solve(const MatrixBase<Other>& other) const$/;"	f	class:Eigen::TriangularView
solve	Eigen/src/Eigen2Support/LU.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::LU
solve	Eigen/src/Eigen2Support/QR.h	/^    bool solve(const MatrixBase<OtherDerived>& b, ResultType *result) const$/;"	f	class:Eigen::QR
solve	Eigen/src/Eigen2Support/SVD.h	/^bool SVD<MatrixType>::solve(const MatrixBase<OtherDerived> &b, ResultType* result) const$/;"	f	class:Eigen::SVD
solve	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    inline const Rhs& solve(const Rhs& b) const { return b; }$/;"	f	class:Eigen::IdentityPreconditioner
solve	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::DiagonalPreconditioner
solve	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^     solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IncompleteLUT
solve	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase
solve	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::IterativeSolverBase
solve	Eigen/src/LU/FullPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivLU
solve	Eigen/src/LU/PartialPivLU.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PartialPivLU
solve	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase
solve	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PastixBase
solve	Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl
solve	Eigen/src/PardisoSupport/PardisoSupport.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::PardisoImpl
solve	Eigen/src/QR/ColPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::ColPivHouseholderQR
solve	Eigen/src/QR/FullPivHouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::FullPivHouseholderQR
solve	Eigen/src/QR/HouseholderQR.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::HouseholderQR
solve	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    inline const internal::solve_retval<SPQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SPQR
solve	Eigen/src/SVD/JacobiSVD.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::JacobiSVD
solve	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase
solve	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SimplicialCholeskyBase
solve	Eigen/src/SparseCore/TriangularSolver.h	/^SparseTriangularView<ExpressionType,Mode>::solve(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView
solve	Eigen/src/SparseLU/SparseLU.h	/^    inline const internal::solve_retval<SparseLU, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseLU
solve	Eigen/src/SparseLU/SparseLU.h	/^    inline const internal::sparse_solve_retval<SparseLU, Rhs> solve(const SparseMatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseLU
solve	Eigen/src/SparseQR/SparseQR.h	/^    inline const internal::solve_retval<SparseQR, Rhs> solve(const MatrixBase<Rhs>& B) const $/;"	f	class:Eigen::SparseQR
solve	Eigen/src/SparseQR/SparseQR.h	/^    inline const internal::sparse_solve_retval<SparseQR, Rhs> solve(const SparseMatrixBase<Rhs>& B) const$/;"	f	class:Eigen::SparseQR
solve	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::solve_retval<SuperLUBase, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase
solve	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    inline const internal::sparse_solve_retval<SuperLUBase, Rhs> solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::SuperLUBase
solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::solve_retval<UmfPackLU, Rhs> solve(const MatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU
solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    inline const internal::sparse_solve_retval<UmfPackLU, Rhs> solve(const SparseMatrixBase<Rhs>& b) const$/;"	f	class:Eigen::UmfPackLU
solveInPlace	Eigen/src/Cholesky/LDLT.h	/^bool LDLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LDLT
solveInPlace	Eigen/src/Cholesky/LLT.h	/^void LLT<MatrixType,_UpLo>::solveInPlace(MatrixBase<Derived> &bAndX) const$/;"	f	class:Eigen::LLT
solveInPlace	Eigen/src/Core/SolveTriangular.h	/^void TriangularView<MatrixType,Mode>::solveInPlace(const MatrixBase<OtherDerived>& _other) const$/;"	f	class:Eigen::TriangularView
solveInPlace	Eigen/src/Core/TriangularMatrix.h	/^    void solveInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::TriangularView
solveInPlace	Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView
solveInPlace	Eigen/src/SparseCore/TriangularSolver.h	/^void SparseTriangularView<ExpressionType,Mode>::solveInPlace(SparseMatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseTriangularView
solveInPlace	Eigen/src/SparseLU/SparseLU.h	/^  template<typename Dest>   void solveInPlace(MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixUReturnType
solveInPlace	Eigen/src/SparseLU/SparseLU.h	/^  void solveInPlace( MatrixBase<Dest> &X) const$/;"	f	struct:Eigen::SparseLUMatrixLReturnType
solveInPlace	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^void MappedSuperNodalMatrix<Scalar,Index>::solveInPlace( MatrixBase<Dest>&X) const$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
solveTriangular	Eigen/src/Eigen2Support/TriangularSolver.h	/^Flagged<ExpressionType,Added,Removed>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged
solveTriangular	Eigen/src/SparseCore/TriangularSolver.h	/^SparseMatrixBase<Derived>::solveTriangular(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
solveTriangularInPlace	Eigen/src/Eigen2Support/TriangularSolver.h	/^void Flagged<ExpressionType,Added,Removed>::solveTriangularInPlace(const MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::Flagged
solveTriangularInPlace	Eigen/src/SparseCore/TriangularSolver.h	/^void SparseMatrixBase<Derived>::solveTriangularInPlace(MatrixBase<OtherDerived>& other) const$/;"	f	class:Eigen::SparseMatrixBase
solveWithGuess	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::BiCGSTAB
solveWithGuess	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  solveWithGuess(const MatrixBase<Rhs>& b, const Guess& x0) const$/;"	f	class:Eigen::ConjugateGradient
solve_retval	Eigen/src/Cholesky/LDLT.h	/^struct solve_retval<LDLT<_MatrixType,_UpLo>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/Cholesky/LLT.h	/^struct solve_retval<LLT<_MatrixType, UpLo>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/CholmodSupport/CholmodSupport.h	/^struct solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/IterativeLinearSolvers/BasicPreconditioners.h	/^struct solve_retval<DiagonalPreconditioner<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct solve_retval<BiCGSTAB<_MatrixType, _Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct solve_retval<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/IterativeLinearSolvers/IncompleteLUT.h	/^struct solve_retval<IncompleteLUT<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/LU/FullPivLU.h	/^struct solve_retval<FullPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/LU/PartialPivLU.h	/^struct solve_retval<PartialPivLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/PardisoSupport/PardisoSupport.h	/^struct solve_retval<PardisoImpl<_Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/QR/ColPivHouseholderQR.h	/^struct solve_retval<ColPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/QR/FullPivHouseholderQR.h	/^struct solve_retval<FullPivHouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/QR/HouseholderQR.h	/^struct solve_retval<HouseholderQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^struct solve_retval<SPQR<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/SVD/JacobiSVD.h	/^struct solve_retval<JacobiSVD<_MatrixType, QRPreconditioner>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/SparseLU/SparseLU.h	/^struct solve_retval<SparseLU<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/SparseQR/SparseQR.h	/^struct solve_retval<SparseQR<_MatrixType,OrderingType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
solve_retval_base	Eigen/src/misc/Solve.h	/^  solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::solve_retval_base
solve_retval_base	Eigen/src/misc/Solve.h	/^template<typename _DecompositionType, typename Rhs> struct solve_retval_base$/;"	s	namespace:Eigen::internal
solve_retval_with_guess	Eigen/src/misc/SparseSolve.h	/^  solve_retval_with_guess(const DecompositionType& dec, const Rhs& rhs, const Guess& guess)$/;"	f	struct:Eigen::internal::solve_retval_with_guess
solve_retval_with_guess	Eigen/src/misc/SparseSolve.h	/^template<typename DecompositionType, typename Rhs, typename Guess> struct solve_retval_with_guess$/;"	s	namespace:Eigen::internal
sor_w	srLib/srDyn/srISLAND.h	/^	SR_REAL sor_w;$/;"	m	struct:PGSOption
sort	Eigen/src/Eigen2Support/SVD.h	/^SVD<MatrixType>& SVD<MatrixType>::sort()$/;"	f	class:Eigen::SVD
sort	srLib/SceneGraph/gl2ps.c	/^  GLint format, sort, options, colorsize, colormode, buffersize;$/;"	m	struct:__anon15	file:
sortEigenvalues	Eigen/src/Eigenvalues/ComplexEigenSolver.h	/^void ComplexEigenSolver<MatrixType>::sortEigenvalues(bool computeEigenvectors)$/;"	f	class:Eigen::ComplexEigenSolver
sort_matrix_Q	Eigen/src/SparseQR/SparseQR.h	/^    inline void sort_matrix_Q()$/;"	f	class:Eigen::SparseQR
sparseView	Eigen/src/SparseCore/SparseView.h	/^const SparseView<Derived> MatrixBase<Derived>::sparseView(const Scalar& m_reference,$/;"	f	class:Eigen::MatrixBase
sparse_cwise_binary_op_inner_iterator_selector	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE sparse_cwise_binary_op_inner_iterator_selector(const CwiseBinaryXpr& xpr, Index outer)$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
sparse_cwise_binary_op_inner_iterator_selector	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<BinaryOp, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Dense, Sparse>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Dense>$/;"	c	namespace:Eigen::internal
sparse_cwise_binary_op_inner_iterator_selector	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^class sparse_cwise_binary_op_inner_iterator_selector<scalar_product_op<T>, Lhs, Rhs, Derived, Sparse, Sparse>$/;"	c	namespace:Eigen::internal
sparse_diagonal_product_inner_iterator_selector	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^    inline sparse_diagonal_product_inner_iterator_selector($/;"	f	class:Eigen::internal::sparse_diagonal_product_inner_iterator_selector
sparse_diagonal_product_inner_iterator_selector	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^class sparse_diagonal_product_inner_iterator_selector$/;"	c	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Cols> struct sparse_eval<T,1,Cols> {$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows,int Cols> struct sparse_eval {$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T,int Rows> struct sparse_eval<T,Rows,1> {$/;"	s	namespace:Eigen::internal
sparse_eval	Eigen/src/SparseCore/SparseUtil.h	/^template<typename T> struct sparse_eval<T,1,1> {$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/CholmodSupport/CholmodSupport.h	/^struct sparse_solve_retval<CholmodBase<_MatrixType,_UpLo,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^struct sparse_solve_retval<IterativeSolverBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^struct sparse_solve_retval<PastixBase<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/PardisoSupport/PardisoSupport.h	/^struct sparse_solve_retval<PardisoImpl<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^struct sparse_solve_retval<SimplicialCholeskyBase<Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/SparseLU/SparseLU.h	/^struct sparse_solve_retval<SparseLU<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/SparseQR/SparseQR.h	/^struct sparse_solve_retval<SparseQR<_MatrixType, OrderingType>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^struct sparse_solve_retval<SuperLUBase<_MatrixType,Derived>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^struct sparse_solve_retval<UmfPackLU<_MatrixType>, Rhs>$/;"	s	namespace:Eigen::internal
sparse_solve_retval_base	Eigen/src/misc/SparseSolve.h	/^  sparse_solve_retval_base(const DecompositionType& dec, const Rhs& rhs)$/;"	f	struct:Eigen::internal::sparse_solve_retval_base
sparse_solve_retval_base	Eigen/src/misc/SparseSolve.h	/^template<typename _DecompositionType, typename Rhs> struct sparse_solve_retval_base$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Lower,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_selector<Lhs,Rhs,Mode,Upper,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_solve_triangular_sparse_selector	Eigen/src/SparseCore/TriangularSolver.h	/^struct sparse_solve_triangular_sparse_selector<Lhs,Rhs,Mode,UpLo,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_impl	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^static void sparse_sparse_product_with_pruning_impl(const Lhs& lhs, const Rhs& rhs, ResultType& res, const typename ResultType::RealScalar& tolerance)$/;"	f	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,ColMajor,ColMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,ColMajor>$/;"	s	namespace:Eigen::internal
sparse_sparse_product_with_pruning_selector	Eigen/src/SparseCore/SparseSparseProductWithPruning.h	/^struct sparse_sparse_product_with_pruning_selector<Lhs,Rhs,ResultType,RowMajor,RowMajor,RowMajor>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product	Eigen/src/SparseCore/SparseDenseProduct.h	/^inline void sparse_time_dense_product(const SparseLhsType& lhs, const DenseRhsType& rhs, DenseResType& res, const AlphaType& alpha)$/;"	f	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, ColMajor, true>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, false>$/;"	s	namespace:Eigen::internal
sparse_time_dense_product_impl	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct sparse_time_dense_product_impl<SparseLhsType,DenseRhsType,DenseResType, RowMajor, true>$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Inner> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_Outer> {$/;"	s	namespace:Eigen::internal
sparse_vector_assign_selector	Eigen/src/SparseCore/SparseVector.h	/^struct sparse_vector_assign_selector<Dest,Src,SVA_RuntimeSwitch> {$/;"	s	namespace:Eigen::internal
sparselu_gemm	Eigen/src/SparseLU/SparseLU_gemm_kernel.h	/^void sparselu_gemm(Index m, Index n, Index d, const Scalar* A, Index lda, const Scalar* B, Index ldb, Scalar* C, Index ldc)$/;"	f	namespace:Eigen::internal
specular	srLib/SceneGraph/Light.h	/^	float			specular[4];$/;"	m	class:Light
specular	srLib/SceneGraph/Shader.h	/^	float			specular[4];$/;"	m	class:Shader
splitOffTwoRows	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::splitOffTwoRows(Index i)$/;"	f	class:Eigen::RealQZ
splitOffTwoRows	Eigen/src/Eigenvalues/RealSchur.h	/^inline void RealSchur<MatrixType>::splitOffTwoRows(Index iu, bool computeU, const Scalar& exshift)$/;"	f	class:Eigen::RealSchur
sqrt	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::sqrt() const$/;"	f	class:Eigen::Cwise
sqrt	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^sqrt() const$/;"	f
square	Eigen/src/Eigen2Support/CwiseOperators.h	/^Cwise<ExpressionType>::square() const$/;"	f	class:Eigen::Cwise
square	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^square() const$/;"	f
squaredDistance	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
squaredDistance	Eigen/src/Geometry/ParametrizedLine.h	/^  RealScalar squaredDistance(const VectorType& p) const$/;"	f	class:Eigen::ParametrizedLine
squaredExteriorDistance	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbiantDim>::squaredExteriorDistance(const VectorType& p) const$/;"	f	class:Eigen::AlignedBox
squaredExteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const AlignedBox& b) const$/;"	f	class:Eigen::AlignedBox
squaredExteriorDistance	Eigen/src/Geometry/AlignedBox.h	/^inline Scalar AlignedBox<Scalar,AmbientDim>::squaredExteriorDistance(const MatrixBase<Derived>& a_p) const$/;"	f	class:Eigen::AlignedBox
squaredNorm	Eigen/src/Core/Dot.h	/^EIGEN_STRONG_INLINE typename NumTraits<typename internal::traits<Derived>::Scalar>::Real MatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::MatrixBase
squaredNorm	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_squaredNorm,RealScalar>::Type squaredNorm() const$/;"	f	class:Eigen::VectorwiseOp
squaredNorm	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return m_coeffs.squaredNorm(); }$/;"	f	class:Eigen::Quaternion
squaredNorm	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar squaredNorm() const { return coeffs().squaredNorm(); }$/;"	f	class:Eigen::QuaternionBase
squaredNorm	Eigen/src/SparseCore/SparseDot.h	/^SparseMatrixBase<Derived>::squaredNorm() const$/;"	f	class:Eigen::SparseMatrixBase
squeeze	Eigen/src/SparseCore/CompressedStorage.h	/^    void squeeze()$/;"	f	class:Eigen::internal::CompressedStorage
srBallJoint	srLib/srDyn/srBallJoint.cpp	/^srBallJoint::srBallJoint()$/;"	f	class:srBallJoint
srBallJoint	srLib/srDyn/srBallJoint.h	/^class srBallJoint : public srJoint$/;"	c
srBallState	srLib/srDyn/srState.cpp	/^srBallState::srBallState()$/;"	f	class:srBallState
srBallState	srLib/srDyn/srState.cpp	/^srBallState::srBallState(srBallState& s)$/;"	f	class:srBallState
srBallState	srLib/srDyn/srState.h	/^class srBallState : public srState$/;"	c
srCollision	srLib/srDyn/srCollision.cpp	/^srCollision::srCollision()$/;"	f	class:srCollision
srCollision	srLib/srDyn/srCollision.h	/^class srCollision : public srEntity$/;"	c
srDYN	srLib/srDyn/srDYN.cpp	/^srDYN::srDYN()$/;"	f	class:srDYN
srDYN	srLib/srDyn/srDYN.h	/^class srDYN$/;"	c
srDraco	Example/DracoP1/draco.cpp	/^srDraco::srDraco(Vec3 location)$/;"	f	class:srDraco
srDraco	Example/DracoP1/draco.h	/^class srDraco: public srSystem{$/;"	c
srEntity	srLib/srDyn/srEntity.cpp	/^srEntity::srEntity()$/;"	f	class:srEntity
srEntity	srLib/srDyn/srEntity.h	/^class srEntity : public srObject$/;"	c
srExt	srLib/srExt/srExt_LieGroup.h	/^namespace srExt$/;"	n
srExt	srLib/srExt/srExt_System.h	/^namespace srExt$/;"	n
srExt	srLib/srExt/srExtension.h	/^namespace srExt$/;"	n
srExtRevoluteJoint	srLib/srExt/srExt_RevoluteJoint.h	/^	srExtRevoluteJoint()$/;"	f	class:srExtRevoluteJoint
srExtRevoluteJoint	srLib/srExt/srExt_RevoluteJoint.h	/^class srExtRevoluteJoint : public srRevoluteJoint$/;"	c
srExtSystem	srLib/srExt/srExt_System.cpp	/^srExt::srExtSystem::srExtSystem()$/;"	f	class:srExt::srExtSystem
srExtSystem	srLib/srExt/srExt_System.cpp	/^srExt::srExtSystem::srExtSystem(const std::string & _fileName, const std::string & _meshDir)$/;"	f	class:srExt::srExtSystem
srExtSystem	srLib/srExt/srExt_System.cpp	/^srExt::srExtSystem::srExtSystem(srSystem * _system)$/;"	f	class:srExt::srExtSystem
srExtSystem	srLib/srExt/srExt_System.h	/^	class srExtSystem : public srSystem$/;"	c	namespace:srExt
srGeometryInfo	srLib/srDyn/srGeometryInfo.cpp	/^srGeometryInfo::srGeometryInfo()$/;"	f	class:srGeometryInfo
srGeometryInfo	srLib/srDyn/srGeometryInfo.h	/^class srGeometryInfo$/;"	c
srIRSensor	srLib/srDyn/srIRSensor.cpp	/^srIRSensor::srIRSensor()$/;"	f	class:srIRSensor
srIRSensor	srLib/srDyn/srIRSensor.h	/^class srIRSensor : public srSensor$/;"	c
srJoint	srLib/srDyn/srJoint.cpp	/^srJoint::srJoint()$/;"	f	class:srJoint
srJoint	srLib/srDyn/srJoint.h	/^class srJoint : public srEntity$/;"	c
srLOG	srLib/common/srSTL.h	/^#define srLOG /;"	d
srLinearSpring	srLib/srDyn/srLinearSpring.cpp	/^srLinearSpring::srLinearSpring()$/;"	f	class:srLinearSpring
srLinearSpring	srLib/srDyn/srLinearSpring.h	/^class srLinearSpring : public srSpring$/;"	c
srLink	srLib/srDyn/srLink.cpp	/^srLink::srLink()$/;"	f	class:srLink
srLink	srLib/srDyn/srLink.h	/^class srLink : public srEntity$/;"	c
srMath	srMath/Common.h	/^namespace srMath$/;"	n
srMath	srMath/Constant.h	/^namespace srMath$/;"	n
srMath	srMath/EulerIntegrator.h	/^namespace srMath$/;"	n
srMath	srMath/Function.cpp	/^namespace srMath$/;"	n	file:
srMath	srMath/Function.h	/^namespace srMath$/;"	n
srMath	srMath/GaussianQuadrature.cpp	/^namespace srMath$/;"	n	file:
srMath	srMath/GaussianQuadrature.h	/^namespace srMath$/;"	n
srMath	srMath/Inertia.cpp	/^namespace srMath$/;"	n	file:
srMath	srMath/Inertia.h	/^namespace srMath$/;"	n
srMath	srMath/Interpolation.cpp	/^namespace srMath$/;"	n	file:
srMath	srMath/Interpolation.h	/^namespace srMath$/;"	n
srMath	srMath/LinearIntegrator.h	/^namespace srMath$/;"	n
srMath	srMath/SE3.cpp	/^namespace srMath$/;"	n	file:
srMath	srMath/SE3.h	/^namespace srMath$/;"	n
srMath	srMath/SO3.cpp	/^namespace srMath$/;"	n	file:
srMath	srMath/SO3.h	/^namespace srMath$/;"	n
srObject	srLib/srDyn/srObject.cpp	/^srObject::srObject()$/;"	f	class:srObject
srObject	srLib/srDyn/srObject.h	/^class srObject$/;"	c
srPrismaticJoint	srLib/srDyn/srPrismaticJoint.cpp	/^srPrismaticJoint::srPrismaticJoint()$/;"	f	class:srPrismaticJoint
srPrismaticJoint	srLib/srDyn/srPrismaticJoint.h	/^class srPrismaticJoint : public srJoint$/;"	c
srPrismaticState	srLib/srDyn/srState.h	/^typedef srRevoluteState srPrismaticState;$/;"	t
srRangeFinder	srLib/srDyn/srRangeFinder.cpp	/^srRangeFinder::srRangeFinder()$/;"	f	class:srRangeFinder
srRangeFinder	srLib/srDyn/srRangeFinder.h	/^class srRangeFinder : public srSensor$/;"	c
srRevoluteJoint	srLib/srDyn/srRevoluteJoint.cpp	/^srRevoluteJoint::srRevoluteJoint()$/;"	f	class:srRevoluteJoint
srRevoluteJoint	srLib/srDyn/srRevoluteJoint.h	/^class srRevoluteJoint : public srJoint$/;"	c
srRevoluteState	srLib/srDyn/srState.cpp	/^srRevoluteState::srRevoluteState()$/;"	f	class:srRevoluteState
srRevoluteState	srLib/srDyn/srState.cpp	/^srRevoluteState::srRevoluteState(srRevoluteState& s)$/;"	f	class:srRevoluteState
srRevoluteState	srLib/srDyn/srState.h	/^class srRevoluteState : public srState$/;"	c
srRobot	srLib/common/srRobot.cpp	/^srRobot::srRobot()$/;"	f	class:srRobot
srRobot	srLib/common/srRobot.h	/^	class srRobot : public srSystem$/;"	c	namespace:srrobot
srSDF	srLib/common/srSDF.h	/^namespace srSDF$/;"	n
srSTL	srLib/common/srSTL.h	/^namespace srSTL$/;"	n
srSensor	srLib/srDyn/srSensor.cpp	/^srSensor::srSensor()$/;"	f	class:srSensor
srSensor	srLib/srDyn/srSensor.h	/^class srSensor : public srEntity$/;"	c
srSpace	srLib/srDyn/srSpace.cpp	/^srSpace::srSpace()$/;"	f	class:srSpace
srSpace	srLib/srDyn/srSpace.h	/^class srSpace : public srObject$/;"	c
srSpaceRenderer	srLib/SceneGraph/srSpaceRenderer.h	/^class srSpaceRenderer : public SceneGraphRenderer$/;"	c
srSpring	srLib/srDyn/srSpring.cpp	/^srSpring::srSpring()$/;"	f	class:srSpring
srSpring	srLib/srDyn/srSpring.h	/^class srSpring : public srEntity$/;"	c
srState	srLib/srDyn/srState.cpp	/^srState::srState()$/;"	f	class:srState
srState	srLib/srDyn/srState.h	/^class srState$/;"	c
srSystem	srLib/srDyn/srSystem.cpp	/^srSystem::srSystem()$/;"	f	class:srSystem
srSystem	srLib/srDyn/srSystem.h	/^class srSystem : public srObject$/;"	c
srTouchSensor	srLib/srDyn/srTouchSensor.cpp	/^srTouchSensor::srTouchSensor()$/;"	f	class:srTouchSensor
srTouchSensor	srLib/srDyn/srTouchSensor.h	/^class srTouchSensor : public srSensor$/;"	c
srURDF	srLib/common/srURDF.h	/^namespace srURDF$/;"	n
srUniversalJoint	srLib/srDyn/srUniversalJoint.cpp	/^srUniversalJoint::srUniversalJoint()$/;"	f	class:srUniversalJoint
srUniversalJoint	srLib/srDyn/srUniversalJoint.h	/^class srUniversalJoint : public srJoint$/;"	c
srUniversalState	srLib/srDyn/srState.cpp	/^srUniversalState::srUniversalState()$/;"	f	class:srUniversalState
srUniversalState	srLib/srDyn/srState.cpp	/^srUniversalState::srUniversalState(srUniversalState& s)$/;"	f	class:srUniversalState
srUniversalState	srLib/srDyn/srState.h	/^class srUniversalState : public srState$/;"	c
srWeldJoint	srLib/srDyn/srWeldJoint.cpp	/^srWeldJoint::srWeldJoint()$/;"	f	class:srWeldJoint
srWeldJoint	srLib/srDyn/srWeldJoint.h	/^class srWeldJoint : public srJoint$/;"	c
srWeldState	srLib/srDyn/srState.h	/^	srWeldState() {};$/;"	f	class:srWeldState
srWeldState	srLib/srDyn/srState.h	/^class srWeldState : public srState$/;"	c
src	srLib/SceneGraph/gl2ps.c	/^  Bytef *dest, *src, *start;$/;"	m	struct:__anon13	file:
srcLen	srLib/SceneGraph/gl2ps.c	/^  uLongf destLen, srcLen;$/;"	m	struct:__anon13	file:
srgBitmap	srLib/SceneGraph/Bitmap.h	/^typedef	_Bitmap	srgBitmap;$/;"	t
srgBitmap	srLib/srg/srgBitmap.h	/^typedef	_Bitmap	srgBitmap;$/;"	t
srgCamera	srLib/srg/srgCamera.cpp	/^srgCamera::srgCamera():$/;"	f	class:srgCamera
srgCamera	srLib/srg/srgCamera.cpp	/^srgCamera::srgCamera(const Vec3& _eye, const Vec3& _center, const Vec3& _up):$/;"	f	class:srgCamera
srgCamera	srLib/srg/srgCamera.h	/^class srgCamera$/;"	c
srgColor	srLib/srg/srgColor.cpp	/^srgColor::srgColor()$/;"	f	class:srgColor
srgColor	srLib/srg/srgColor.cpp	/^srgColor::srgColor(const srgColor& rhs)$/;"	f	class:srgColor
srgColor	srLib/srg/srgColor.cpp	/^srgColor::srgColor(float Red, float Green, float Blue, float Alpha)$/;"	f	class:srgColor
srgColor	srLib/srg/srgColor.h	/^class srgColor$/;"	c
srgDraw2DSphere	srLib/srg/srgGeometryDraw.cpp	/^void srgDraw2DSphere(float Radius, int Slices, int Stacks)$/;"	f
srgDrawArrow1	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawArrow1(float Length)$/;"	f
srgDrawBox	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawBox(DWORD dwFlags,$/;"	f
srgDrawBox	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawBox(QuadricState eQuadricState,$/;"	f
srgDrawBox	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawBox(double HalfWidth, double HalfHeight, double HalfDepth)$/;"	f
srgDrawBox_FeatureLine	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawBox_FeatureLine(double HalfWidth, double HalfHeight, double HalfDepth)$/;"	f
srgDrawBox_NV	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawBox_NV(double HalfWidth, double HalfHeight, double HalfDepth)$/;"	f
srgDrawBox_NV_TEX	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawBox_NV_TEX(double HalfWidth, double HalfHeight, double HalfDepth)$/;"	f
srgDrawCameraFocus	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCameraFocus( void )$/;"	f
srgDrawCameraLoop	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCameraLoop(float Radius, int Slice, int LineWidth)$/;"	f
srgDrawCapsule	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCapsule(DWORD dwFlags,$/;"	f
srgDrawCapsule	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCapsule(QuadricState	eQuadricState,$/;"	f
srgDrawCircle	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCircle(float Radius, int Slices)$/;"	f
srgDrawCoordinateLoop	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCoordinateLoop(float Radius, int Slice, int LineWidth)$/;"	f
srgDrawCoordinate_axis_basic	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCoordinate_axis_basic(float size)$/;"	f
srgDrawCoordinate_axis_basic	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCoordinate_axis_basic(void)$/;"	f
srgDrawCylinder	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCylinder(DWORD dwFlags,$/;"	f
srgDrawCylinder	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawCylinder(QuadricState	eQuadricState,$/;"	f
srgDrawDisk	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawDisk(QuadricState	eQuadricState,$/;"	f
srgDrawDisk	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawDisk(double InnerRadius, double OuterRadius, int Slices, int Loops, DWORD dwFlag)$/;"	f
srgDrawDome	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawDome(DWORD dwFlags,$/;"	f
srgDrawDome	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawDome(QuadricState	eQuadricState,$/;"	f
srgDrawGrid	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawGrid( void )$/;"	f
srgDrawGrid_Flexible	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawGrid_Flexible( int ViewportHeight, float SightHeight )$/;"	f
srgDrawLine	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawLine(float fX1, float fY1, float fZ1, float fX2, float fY2, float fZ2)$/;"	f
srgDrawLoop	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawLoop(float Radius, int Slices)$/;"	f
srgDrawOpenCylinder	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenCylinder(DWORD dwFlags,$/;"	f
srgDrawOpenCylinder	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenCylinder(QuadricState	eQuadricState,$/;"	f
srgDrawOpenCylinder_FeatureLine	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenCylinder_FeatureLine(double BaseRadius, double TopRadius, double Height, int FeatureSlices, int Slices)$/;"	f
srgDrawOpenDome	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenDome(DWORD dwFlags,$/;"	f
srgDrawOpenDome	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenDome(QuadricState	eQuadricState,$/;"	f
srgDrawOpenDome	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenDome(double Radius, int Slices, int Stacks)$/;"	f
srgDrawOpenDome_FeatureLine	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenDome_FeatureLine(double Radius, int FeatureSlices, int FeatureStacks, int Slices, int Stacks)$/;"	f
srgDrawOpenDome_NV	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenDome_NV(double Radius, int Slices, int Stacks)$/;"	f
srgDrawOpenDome_NV_TEX	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawOpenDome_NV_TEX(double Radius, int Slices, int Stacks)$/;"	f
srgDrawPartialDisk	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawPartialDisk(QuadricState eQuadricState, double InnerRadius, double OuterRadius, int Slices, int \/* Loops *\/, double startAngle, double SweepAngle)$/;"	f
srgDrawPrismaticJoint	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawPrismaticJoint(DWORD dwFlags, double Radius, int Slices, int Stacks)$/;"	f
srgDrawRevoluteJoint	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawRevoluteJoint(DWORD dwFlags, double Radius, int Slices, int Stacks)$/;"	f
srgDrawSphere	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawSphere(DWORD dwFlags,$/;"	f
srgDrawSphere	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawSphere(QuadricState	eQuadricState,$/;"	f
srgDrawSphere_FeatureLine	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawSphere_FeatureLine(double Radius, int FeatureSlices, int FeatureStacks, int Slices, int Stacks)$/;"	f
srgDrawStyle	srLib/srg/srgGeometryDraw.h	/^enum srgDrawStyle$/;"	g
srgDrawTorus	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawTorus(GLfloat majorRadius, GLfloat minorRadius, GLint numMajor, GLint numMinor)$/;"	f
srgDrawUniAxisX	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawUniAxisX(float fAxisRadius, float fAxisHeight, float fArrowRadius, float fArrowHeight)$/;"	f
srgDrawUniAxisX2	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawUniAxisX2(float fAxisRadius, float fAxisHeight, float fArrowRadius, float fArrowHeight)$/;"	f
srgDrawUniAxisY	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawUniAxisY(float fAxisRadius, float fAxisHeight, float fArrowRadius, float fArrowHeight)$/;"	f
srgDrawUniAxisZ	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawUniAxisZ(float fAxisRadius, float fAxisHeight, float fArrowRadius, float fArrowHeight)$/;"	f
srgDrawUnitAxes	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawUnitAxes(void)$/;"	f
srgDrawUniversalJoint	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawUniversalJoint(DWORD dwFlags, double Radius, int Slices, int Stacks)$/;"	f
srgDrawWeldJoint	srLib/srg/srgGeometryDraw.cpp	/^void srgDrawWeldJoint(DWORD dwFlags, double Radius, int Slices, int Stacks)$/;"	f
srgMaterialColor	srLib/srg/srgColor.cpp	/^srgMaterialColor::srgMaterialColor():$/;"	f	class:srgMaterialColor
srgMaterialColor	srLib/srg/srgColor.cpp	/^srgMaterialColor::srgMaterialColor(float Red, float Green, float Blue, float Alpha):$/;"	f	class:srgMaterialColor
srgMaterialColor	srLib/srg/srgColor.cpp	/^srgMaterialColor::srgMaterialColor(float Red, float Green, float Blue,$/;"	f	class:srgMaterialColor
srgMaterialColor	srLib/srg/srgColor.h	/^class srgMaterialColor$/;"	c
srgPartialDrawDisk	srLib/srg/srgGeometryDraw.cpp	/^void srgPartialDrawDisk(QuadricState	eQuadricState,$/;"	f
srgString	srLib/SceneGraph/Font.cpp	/^srgString::srgString()$/;"	f	class:srgString
srgString	srLib/SceneGraph/Font.h	/^class srgString$/;"	c
srgString	srLib/srg/srgFont.cpp	/^srgString::srgString()$/;"	f	class:srgString
srgString	srLib/srg/srgFont.h	/^class srgString$/;"	c
srrobot	srLib/common/srRobot.h	/^namespace srrobot$/;"	n
sse3RotateX	srLib/srg/srgCamera.h	/^	static const se3 sse3RotateX;$/;"	m	class:srgCamera
sse3RotateY	srLib/srg/srgCamera.h	/^	static const se3 sse3RotateY;$/;"	m	class:srgCamera
sse3RotateZ	srLib/srg/srgCamera.h	/^	static const se3 sse3RotateZ;$/;"	m	class:srgCamera
sse3TranslateX	srLib/srg/srgCamera.h	/^	static const se3 sse3TranslateX;$/;"	m	class:srgCamera
sse3TranslateY	srLib/srg/srgCamera.h	/^	static const se3 sse3TranslateY;$/;"	m	class:srgCamera
sse3TranslateZ	srLib/srg/srgCamera.h	/^	static const se3 sse3TranslateZ;$/;"	m	class:srgCamera
stableNorm	Eigen/src/Core/StableNorm.h	/^MatrixBase<Derived>::stableNorm() const$/;"	f	class:Eigen::MatrixBase
stableNorm	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_stableNorm,RealScalar>::Type stableNorm() const$/;"	f	class:Eigen::VectorwiseOp
stable_norm_kernel	Eigen/src/Core/StableNorm.h	/^inline void stable_norm_kernel(const ExpressionType& bl, Scalar& ssq, Scalar& scale, Scalar& invScale)$/;"	f	namespace:Eigen::internal
stack	srLib/SceneGraph/Leaf.h	/^	int		stack;$/;"	m	class:DomeBase
start	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start() const$/;"	f	class:Eigen::MatrixBase
start	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start()$/;"	f	class:Eigen::MatrixBase
start	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size) const$/;"	f	class:Eigen::MatrixBase
start	Eigen/src/Eigen2Support/VectorBlock.h	/^MatrixBase<Derived>::start(Index size)$/;"	f	class:Eigen::MatrixBase
start	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  Index start ;   \/* index for A of first col in this row *\/$/;"	m	struct:internal::Colamd_Row
start	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^  Index start ;   \/* index for A of first row in this column, or DEAD *\/$/;"	m	struct:internal::colamd_col
start	srLib/SceneGraph/gl2ps.c	/^  Bytef *dest, *src, *start;$/;"	m	struct:__anon13	file:
startCol	Eigen/src/Core/Block.h	/^    Index startCol() const $/;"	f	class:Eigen::internal::BlockImpl_dense
startFill	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_DEPRECATED void startFill(Index reserve)$/;"	f	class:Eigen::SparseVector
startRow	Eigen/src/Core/Block.h	/^    Index startRow() const $/;"	f	class:Eigen::internal::BlockImpl_dense
startVec	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseMatrix
startVec	Eigen/src/SparseCore/SparseVector.h	/^    inline void startVec(Index outer)$/;"	f	class:Eigen::SparseVector
state	Example/DracoP1/Draco_Dyn_environment.h	/^struct state$/;"	s
static_assertion	Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion {};$/;"	s	namespace:Eigen::internal
static_assertion	Eigen/src/Core/util/StaticAssert.h	/^    struct static_assertion<true>$/;"	s	namespace:Eigen::internal
std	Eigen/src/StlSupport/StdDeque.h	/^namespace std {$/;"	n
std	Eigen/src/StlSupport/StdList.h	/^namespace std$/;"	n
std	Eigen/src/StlSupport/StdVector.h	/^namespace std {$/;"	n
stem_function	Eigen/src/Core/util/ForwardDeclarations.h	/^struct stem_function$/;"	s	namespace:Eigen::internal
step	Eigen/src/Eigenvalues/RealQZ.h	/^    inline void RealQZ<MatrixType>::step(Index f, Index l, Index iter)$/;"	f	class:Eigen::RealQZ
storage	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^  } storage;$/;"	m	struct:Eigen::SluMatrix	typeref:struct:Eigen::SluMatrix::__anon458
str	srLib/SceneGraph/Leaf.h	/^	string			str;$/;"	m	class:Font
str	srLib/SceneGraph/gl2ps.c	/^  char *str, *fontname;$/;"	m	struct:__anon9	file:
stream	srLib/SceneGraph/gl2ps.c	/^  FILE *stream;$/;"	m	struct:__anon15	file:
streamlength	srLib/SceneGraph/gl2ps.c	/^  int streamlength;$/;"	m	struct:__anon15	file:
stride	Eigen/src/Core/DenseCoeffsBase.h	/^    inline Index stride() const$/;"	f	class:Eigen::DenseCoeffsBase
string2vec	srLib/common/srSDF.cpp	/^Eigen::VectorXd srSDF::string2vec(std::string _string, int _dim)$/;"	f	class:srSDF
stroke_font_names	srLib/SceneGraph/Font.h	/^	void* stroke_font_names[2];$/;"	m	class:srgString
stroke_font_names	srLib/srg/srgFont.h	/^	void* stroke_font_names[2];$/;"	m	class:srgString
stroke_fonts	srLib/SceneGraph/Font.h	/^	void* stroke_fonts[2];$/;"	m	class:srgString
stroke_fonts	srLib/srg/srgFont.h	/^	void* stroke_fonts[2];$/;"	m	class:srgString
sub	Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<-1>::Type sub() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<-1>::Type sub()$/;"	f	class:Eigen::internal::TridiagonalMatrix
sub	Eigen/src/Core/GeneralProduct.h	/^    struct sub  { template<typename Dst, typename Src> void operator()(const Dst& dst, const Src& src) const { dst.const_cast_derived() -= src; } };$/;"	s	class:Eigen::GeneralProduct
subDiagonal	Eigen/src/Eigenvalues/Tridiagonalization.h	/^Tridiagonalization<MatrixType>::subDiagonal() const$/;"	f	class:Eigen::Tridiagonalization
subFaces	srLib/SceneGraph/Model3DS.h	/^		unsigned short *subFaces;	\/\/ Index to our vertex array of all the faces that use this material$/;"	m	struct:Model3DS::MaterialFaces
subTo	Eigen/src/Core/DiagonalMatrix.h	/^    inline void subTo(MatrixBase<DenseDerived> &other) const$/;"	f	class:Eigen::DiagonalBase
subTo	Eigen/src/Core/EigenBase.h	/^  template<typename Dest> inline void subTo(Dest& dst) const$/;"	f	struct:Eigen::EigenBase
subTo	Eigen/src/Core/GeneralProduct.h	/^    inline void subTo(Dest& dest) const {$/;"	f	class:Eigen::GeneralProduct
subTo	Eigen/src/Core/ProductBase.h	/^    inline void subTo(Dest& dst) const { scaleAndAddTo(dst, Scalar(-1)); }$/;"	f	class:ScaledProduct
subVector	Eigen/src/Core/VectorwiseOp.h	/^    SubVector subVector(Index i)$/;"	f	class:Eigen::VectorwiseOp
subVectors	Eigen/src/Core/VectorwiseOp.h	/^    Index subVectors() const$/;"	f	class:Eigen::VectorwiseOp
subdiagonalEntryIsNeglegible	Eigen/src/Eigenvalues/ComplexSchur.h	/^inline bool ComplexSchur<MatrixType>::subdiagonalEntryIsNeglegible(Index i)$/;"	f	class:Eigen::ComplexSchur
subs	Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return derived().subs(); }$/;"	f	class:Eigen::internal::BandMatrixBase
subs	Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrix
subs	Eigen/src/Core/BandMatrix.h	/^    inline Index subs() const { return m_subs.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
sum	Eigen/src/Core/Redux.h	/^DenseBase<Derived>::sum() const$/;"	f	class:Eigen::DenseBase
sum	Eigen/src/Core/VectorwiseOp.h	/^    const typename ReturnType<internal::member_sum>::Type sum() const$/;"	f	class:Eigen::VectorwiseOp
sum	Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrix<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseMatrix
sum	Eigen/src/SparseCore/SparseRedux.h	/^SparseMatrixBase<Derived>::sum() const$/;"	f	class:Eigen::SparseMatrixBase
sum	Eigen/src/SparseCore/SparseRedux.h	/^SparseVector<_Scalar,_Options,_Index>::sum() const$/;"	f	class:Eigen::SparseVector
sumupDuplicates	Eigen/src/SparseCore/SparseMatrix.h	/^void SparseMatrix<Scalar,_Options,_Index>::sumupDuplicates()$/;"	f	class:Eigen::SparseMatrix
supIndex	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Index supIndex() const { return m_supno; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
supToCol	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Index* supToCol() { return m_sup_to_col; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
supToCol	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Index* supToCol() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
super	Eigen/src/Core/BandMatrix.h	/^    inline const typename Base::template DiagonalIntReturnType<1>::Type super() const$/;"	f	class:Eigen::internal::TridiagonalMatrix
super	Eigen/src/Core/BandMatrix.h	/^    inline typename Base::template DiagonalIntReturnType<1>::Type super()$/;"	f	class:Eigen::internal::TridiagonalMatrix
supers	Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return derived().supers(); }$/;"	f	class:Eigen::internal::BandMatrixBase
supers	Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrix
supers	Eigen/src/Core/BandMatrix.h	/^    inline Index supers() const { return m_supers.value(); }$/;"	f	class:Eigen::internal::BandMatrixWrapper
supno	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector supno; \/\/ Supernode number corresponding to this column (column to supernode mapping)$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
svd	Eigen/src/Eigen2Support/SVD.h	/^MatrixBase<Derived>::svd() const$/;"	f	class:Eigen::MatrixBase
svd_precondition_2x2_block_to_be_real	Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real {};$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, false>$/;"	s	namespace:Eigen::internal
svd_precondition_2x2_block_to_be_real	Eigen/src/SVD/JacobiSVD.h	/^struct svd_precondition_2x2_block_to_be_real<MatrixType, QRPreconditioner, true>$/;"	s	namespace:Eigen::internal
swap	Eigen/src/Core/Array.h	/^    void swap(ArrayBase<OtherDerived> const & other)$/;"	f	class:Eigen::Array
swap	Eigen/src/Core/DenseBase.h	/^    void swap(PlainObjectBase<OtherDerived>& other)$/;"	f	class:Eigen::DenseBase
swap	Eigen/src/Core/DenseBase.h	/^    void swap(const DenseBase<OtherDerived>& other,$/;"	f	class:Eigen::DenseBase
swap	Eigen/src/Core/DenseStorage.h	/^    void swap(DenseStorage& ) {}$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_cols,other.m_cols); }$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); std::swap(m_rows,other.m_rows); }$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    void swap(DenseStorage& other) { std::swap(m_data,other.m_data); }$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/DenseStorage.h	/^    void swap(DenseStorage& other)$/;"	f	class:Eigen::DenseStorage
swap	Eigen/src/Core/Matrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::Matrix
swap	Eigen/src/Core/TriangularMatrix.h	/^    void swap(MatrixBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView
swap	Eigen/src/Core/TriangularMatrix.h	/^    void swap(TriangularBase<OtherDerived> const & other)$/;"	f	class:Eigen::TriangularView
swap	Eigen/src/SparseCore/CompressedStorage.h	/^    void swap(CompressedStorage& other)$/;"	f	class:Eigen::internal::CompressedStorage
swap	Eigen/src/SparseCore/SparseMatrix.h	/^    inline void swap(SparseMatrix& other)$/;"	f	class:Eigen::SparseMatrix
swap	Eigen/src/SparseCore/SparseVector.h	/^    inline void swap(SparseVector& other)$/;"	f	class:Eigen::SparseVector
switchBDrawFocus	srLib/SceneGraph/Camera.cpp	/^void Camera::switchBDrawFocus()$/;"	f	class:Camera
symm_pack_lhs	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_lhs$/;"	s	namespace:Eigen::internal
symm_pack_rhs	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct symm_pack_rhs$/;"	s	namespace:Eigen::internal
sync	Eigen/src/Core/products/Parallelizer.h	/^  int volatile sync;$/;"	m	struct:Eigen::internal::GemmParallelInfo
tail	Eigen/src/plugins/BlockMethods.h	/^inline ConstSegmentReturnType tail(Index n) const$/;"	f
tail	Eigen/src/plugins/BlockMethods.h	/^inline SegmentReturnType tail(Index n)$/;"	f
tail	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstFixedSegmentReturnType<N>::Type tail(Index n = N) const$/;"	f
tail	Eigen/src/plugins/BlockMethods.h	/^inline typename FixedSegmentReturnType<N>::Type tail(Index n = N)$/;"	f
take_affine_part	Eigen/src/Geometry/Transform.h	/^  typedef internal::transform_take_affine_part<Transform> take_affine_part;$/;"	t	class:Eigen::Transform
take_matrix_for_product	Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product$/;"	s	namespace:Eigen::internal
take_matrix_for_product	Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Mode, Options> >$/;"	s	namespace:Eigen::internal
take_matrix_for_product	Eigen/src/Geometry/Homogeneous.h	/^struct take_matrix_for_product<Transform<Scalar, Dim, Projective, Options> >$/;"	s	namespace:Eigen::internal
tan	Eigen/src/plugins/ArrayCwiseUnaryOps.h	/^tan() const$/;"	f
targetCheck	srLib/SceneGraph/Transformation.cpp	/^void Transformation::targetCheck()$/;"	f	class:Transformation
targetSpace	srLib/SceneGraph/srSpaceRenderer.h	/^	srSpace* targetSpace;$/;"	m	class:srSpaceRenderer
tex	srLib/SceneGraph/Model3DS.h	/^		Texture3DS	tex;				\/\/ The texture (this is the only outside reference in this class)$/;"	m	struct:Model3DS::Material
text	srLib/SceneGraph/gl2ps.c	/^    GL2PSstring *text;$/;"	m	union:__anon11::__anon12	file:
texture	srLib/SceneGraph/Texture3DS.h	/^	unsigned int texture[1];	\/\/ OpenGL's number for the texture$/;"	m	class:Texture3DS
textured	srLib/SceneGraph/Model3DS.h	/^		bool	textured;			\/\/ True: the object has textures$/;"	m	struct:Model3DS::Object
textured	srLib/SceneGraph/Model3DS.h	/^		bool	textured;			\/\/ whether or not it is textured$/;"	m	struct:Model3DS::Material
thenMatrix	Eigen/src/Core/Select.h	/^    const ThenMatrixType& thenMatrix() const$/;"	f	class:Eigen::Select
theta	srLib/SceneGraph/Camera.h	/^	double			theta;$/;"	m	class:Camera
thickness	Eigen/src/OrderingMethods/Eigen_Colamd.h	/^    Index thickness ; \/* number of original columns represented by this *\/$/;"	m	union:internal::colamd_col::__anon349
threshold	Eigen/src/LU/FullPivLU.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivLU
threshold	Eigen/src/QR/ColPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::ColPivHouseholderQR
threshold	Eigen/src/QR/FullPivHouseholderQR.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::FullPivHouseholderQR
threshold	Eigen/src/SVD/JacobiSVD.h	/^    RealScalar threshold() const$/;"	f	class:Eigen::JacobiSVD
threshold	srLib/SceneGraph/gl2ps.c	/^  GL2PSrgba *colormap, lastrgba, threshold, bgcolor;$/;"	m	struct:__anon15	file:
throw_std_bad_alloc	Eigen/src/Core/util/Memory.h	/^inline void throw_std_bad_alloc()$/;"	f	namespace:Eigen::internal
tinyxml2	tinyxml2/tinyxml2.cpp	/^namespace tinyxml2$/;"	n	file:
tinyxml2	tinyxml2/tinyxml2.h	/^namespace tinyxml2$/;"	n
title	srLib/SceneGraph/gl2ps.c	/^  char *title, *producer, *filename;$/;"	m	struct:__anon15	file:
toDense	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Matrix<Scalar,RowsAtCompileTime,ColsAtCompileTime> toDense() const$/;"	f	class:Eigen::SparseMatrixBase
toDenseMatrix	Eigen/src/Core/BandMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::internal::BandMatrixBase
toDenseMatrix	Eigen/src/Core/DiagonalMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return derived(); }$/;"	f	class:Eigen::DiagonalBase
toDenseMatrix	Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const { return *this; }$/;"	f	class:Eigen::Transpose
toDenseMatrix	Eigen/src/Core/PermutationMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::PermutationBase
toDenseMatrix	Eigen/src/Core/TriangularMatrix.h	/^    DenseMatrixType toDenseMatrix() const$/;"	f	class:Eigen::TriangularBase
toEigenMat	srLib/srExt/srExt_LieGroup.h	/^	Eigen::MatrixXd toEigenMat(const SRtype& _mat, int _rows, int _cols)$/;"	f	namespace:srExt
toEigenVec	srLib/srExt/srExt_LieGroup.h	/^	Eigen::VectorXd toEigenVec(const SRtype& _vec, int _numel, int _offset = 0)$/;"	f	namespace:srExt
toQMatrix	Eigen/src/Eigen2Support/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim>::toQMatrix(void) const$/;"	f	class:Eigen::Transform
toQMatrix	Eigen/src/Geometry/Transform.h	/^QMatrix Transform<Scalar,Dim,Mode,Options>::toQMatrix(void) const$/;"	f	class:Eigen::Transform
toQTransform	Eigen/src/Eigen2Support/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim>::toQTransform(void) const$/;"	f	class:Eigen::Transform
toQTransform	Eigen/src/Geometry/Transform.h	/^QTransform Transform<Scalar,Dim,Mode,Options>::toQTransform(void) const$/;"	f	class:Eigen::Transform
toRotationMatrix	Eigen/src/Eigen2Support/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis
toRotationMatrix	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^Quaternion<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Quaternion
toRotationMatrix	Eigen/src/Eigen2Support/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D
toRotationMatrix	Eigen/src/Eigen2Support/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
toRotationMatrix	Eigen/src/Geometry/AngleAxis.h	/^AngleAxis<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::AngleAxis
toRotationMatrix	Eigen/src/Geometry/Quaternion.h	/^QuaternionBase<Derived>::toRotationMatrix(void) const$/;"	f	class:Eigen::QuaternionBase
toRotationMatrix	Eigen/src/Geometry/Rotation2D.h	/^Rotation2D<Scalar>::toRotationMatrix(void) const$/;"	f	class:Eigen::Rotation2D
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^    inline RotationMatrixType toRotationMatrix() const { return derived().toRotationMatrix(); }$/;"	f	class:Eigen::RotationBase
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,2,2> toRotationMatrix(const Scalar& s)$/;"	f	namespace:Eigen::internal
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^static inline Matrix<Scalar,Dim,Dim> toRotationMatrix(const RotationBase<OtherDerived,Dim>& r)$/;"	f	namespace:Eigen::internal
toRotationMatrix	Eigen/src/Geometry/RotationBase.h	/^static inline const MatrixBase<OtherDerived>& toRotationMatrix(const MatrixBase<OtherDerived>& mat)$/;"	f	namespace:Eigen::internal
tolerance	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  RealScalar tolerance() const { return m_tolerance; }$/;"	f	class:Eigen::IterativeSolverBase
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topLeftCorner()$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topLeftCorner(Index cRows, Index cCols)$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> topLeftCorner(Index cRows, Index cCols)$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topLeftCorner() const$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topLeftCorner(Index cRows, Index cCols) const$/;"	f
topLeftCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> topLeftCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topRightCorner()$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived, CRows, CCols> topRightCorner(Index cRows, Index cCols)$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline Block<Derived> topRightCorner(Index cRows, Index cCols)$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topRightCorner() const$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived, CRows, CCols> topRightCorner(Index cRows, Index cCols) const$/;"	f
topRightCorner	Eigen/src/plugins/BlockMethods.h	/^inline const Block<const Derived> topRightCorner(Index cRows, Index cCols) const$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline ConstRowsBlockXpr topRows(Index n) const$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline RowsBlockXpr topRows(Index n)$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline typename ConstNRowsBlockXpr<N>::Type topRows(Index n = N) const$/;"	f
topRows	Eigen/src/plugins/BlockMethods.h	/^inline typename NRowsBlockXpr<N>::Type topRows(Index n = N)$/;"	f
torque	Example/DracoP1/Draco_Dyn_environment.h	/^    std::vector<double> torque   ;$/;"	m	struct:state
torque_	Example/DracoP1/Draco_Dyn_environment.h	/^        std::vector<double> torque_   ;$/;"	m	class:Draco_Dyn_environment
totalFaces	srLib/SceneGraph/Model3DS.h	/^	int		totalFaces;			\/\/ Total number of faces in the model$/;"	m	class:Model3DS
totalVerts	srLib/SceneGraph/Model3DS.h	/^	int		totalVerts;			\/\/ Total number of vertexes in the model$/;"	m	class:Model3DS
trace	Eigen/src/Core/Redux.h	/^MatrixBase<Derived>::trace() const$/;"	f	class:Eigen::MatrixBase
trace1	Example/MobileRobots/MobileRobots.cpp	/^_array<Vec3>	trace1;$/;"	v
trace2	Example/MobileRobots/MobileRobots.cpp	/^_array<Vec3>	trace2;$/;"	v
traits	Eigen/src/Core/Array.h	/^struct traits<Array<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> > : traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ArrayWrapper.h	/^struct traits<ArrayWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ArrayWrapper.h	/^struct traits<MatrixWrapper<ExpressionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrix<_Scalar,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/BandMatrix.h	/^struct traits<BandMatrixWrapper<_CoefficientsType,_Rows,_Cols,_Supers,_Subs,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Block.h	/^struct traits<Block<XprType, BlockRows, BlockCols, InnerPanel> > : traits<XprType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseBinaryOp.h	/^struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseNullaryOp.h	/^struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType> > : traits<PlainObjectType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseUnaryOp.h	/^struct traits<CwiseUnaryOp<UnaryOp, XprType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/CwiseUnaryView.h	/^struct traits<CwiseUnaryView<ViewOp, MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Diagonal.h	/^struct traits<Diagonal<MatrixType,DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalMatrix<_Scalar,SizeAtCompileTime,MaxSizeAtCompileTime> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/DiagonalMatrix.h	/^struct traits<DiagonalWrapper<_DiagonalVectorType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/DiagonalProduct.h	/^struct traits<DiagonalProduct<MatrixType, DiagonalType, ProductOrder> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Flagged.h	/^struct traits<Flagged<ExpressionType, Added, Removed> > : traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ForceAlignedAccess.h	/^struct traits<ForceAlignedAccess<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemvProduct> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,InnerProduct> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/GeneralProduct.h	/^struct traits<GeneralProduct<Lhs,Rhs,OuterProduct> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Map.h	/^struct traits<Map<PlainObjectType, MapOptions, StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Matrix.h	/^struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/NestByValue.h	/^struct traits<NestByValue<ExpressionType> > : public traits<ExpressionType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<Map<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationMatrix<SizeAtCompileTime, MaxSizeAtCompileTime, IndexType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<PermutationWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<Transpose<PermutationBase<Derived> > >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/PermutationMatrix.h	/^struct traits<permut_matrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ProductBase.h	/^struct traits<ProductBase<Derived,_Lhs,_Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ProductBase.h	/^struct traits<ScaledProduct<NestedProduct> >$/;"	s	namespace:internal
traits	Eigen/src/Core/Ref.h	/^struct traits<Ref<_PlainObjectType, _Options, _StrideType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Ref.h	/^struct traits<RefBase<Derived> > : public traits<Derived> {};$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Replicate.h	/^struct traits<Replicate<MatrixType,RowFactor,ColFactor> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/ReturnByValue.h	/^struct traits<ReturnByValue<Derived> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Reverse.h	/^struct traits<Reverse<MatrixType, Direction> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Select.h	/^struct traits<Select<ConditionMatrixType, ThenMatrixType, ElseMatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/SelfAdjointView.h	/^struct traits<SelfAdjointView<MatrixType, UpLo> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/SelfCwiseBinaryOp.h	/^struct traits<SelfCwiseBinaryOp<BinaryOp,Lhs,Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/SolveTriangular.h	/^struct traits<triangular_solve_retval<Side, TriangularType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Swap.h	/^struct traits<SwapWrapper<ExpressionType> > : traits<ExpressionType> {};$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpose.h	/^struct traits<Transpose<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<Map<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType>,_PacketAccess> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<Transpositions<SizeAtCompileTime,MaxSizeAtCompileTime,IndexType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<TranspositionsWrapper<_IndicesType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/Transpositions.h	/^struct traits<transposition_matrix_product_retval<TranspositionType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/TriangularMatrix.h	/^struct traits<TriangularView<MatrixType, _Mode> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/VectorBlock.h	/^struct traits<VectorBlock<VectorType, Size> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/VectorwiseOp.h	/^struct traits<PartialReduxExpr<MatrixType, MemberOp, Direction> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/CoeffBasedProduct.h	/^struct traits<CoeffBasedProduct<LhsNested,RhsNested,NestingFlags> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^struct traits<GeneralProduct<Lhs,Rhs,GemmProduct> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/SelfadjointMatrixMatrix.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,0,true,Rhs,RhsMode,false> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/SelfadjointMatrixVector.h	/^struct traits<SelfadjointProductMatrix<Lhs,LhsMode,false,Rhs,0,true> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/TriangularMatrixMatrix.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,false> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,false,Rhs,true> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct traits<TriangularProduct<Mode,LhsIsTriangular,Lhs,true,Rhs,false> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Core/util/ForwardDeclarations.h	/^template<typename T> struct traits<const T> : traits<T> {};$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Eigen2Support/Minor.h	/^struct traits<Minor<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Eigenvalues/HessenbergDecomposition.h	/^struct traits<HessenbergDecompositionMatrixHReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct traits<TridiagonalizationMatrixTReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/AngleAxis.h	/^template<typename _Scalar> struct traits<AngleAxis<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Homogeneous.h	/^struct traits<Homogeneous<MatrixType,Direction> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_left_product_impl<Homogeneous<MatrixType,Vertical>,Lhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Homogeneous.h	/^struct traits<homogeneous_right_product_impl<Homogeneous<MatrixType,Horizontal>,Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Quaternion.h	/^  struct traits<Map<const Quaternion<_Scalar>, _Options> > : traits<Quaternion<_Scalar, (int(_Options)&Aligned)==Aligned ? AutoAlign : DontAlign> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Quaternion.h	/^struct traits<Quaternion<_Scalar,_Options> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Geometry/Rotation2D.h	/^template<typename _Scalar> struct traits<Rotation2D<_Scalar> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/Householder/HouseholderSequence.h	/^struct traits<HouseholderSequence<VectorsType,CoeffsType,Side> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^struct traits<BiCGSTAB<_MatrixType,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^struct traits<ConjugateGradient<_MatrixType,_UpLo,_Preconditioner> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/LU/Inverse.h	/^struct traits<inverse_impl<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/QR/FullPivHouseholderQR.h	/^struct traits<FullPivHouseholderQRMatrixQReturnType<MatrixType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType, typename Derived> struct traits<SPQR_QProduct<SPQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    template <typename SPQRType> struct traits<SPQRMatrixQTransposeReturnType<SPQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialCholesky<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType, int _UpLo, typename _Ordering> struct traits<SimplicialLLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^template<typename _MatrixType,int _UpLo, typename _Ordering> struct traits<SimplicialLDLT<_MatrixType,_UpLo,_Ordering> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/MappedSparseMatrix.h	/^struct traits<MappedSparseMatrix<_Scalar, _Flags, _Index> > : traits<SparseMatrix<_Scalar, _Flags, _Index> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<DenseTimeSparseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseDenseOuterProduct<Lhs,Rhs,Tr> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseDenseProduct.h	/^struct traits<SparseTimeDenseProduct<Lhs,Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseDiagonalProduct.h	/^struct traits<SparseDiagonalProduct<Lhs, Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<Diagonal<const SparseMatrix<_Scalar, _Options, _Index>, DiagIndex> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseMatrix.h	/^struct traits<SparseMatrix<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparsePermutation.h	/^struct traits<permut_sparsematrix_product_retval<PermutationType, MatrixType, Side, Transposed> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseProduct.h	/^struct traits<SparseSparseProduct<LhsNested, RhsNested> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<DenseTimeSparseSelfAdjointProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointTimeDenseProduct<Lhs,Rhs,UpLo> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSelfAdjointView<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^struct traits<SparseSymmetricPermutationProduct<MatrixType,UpLo> > : traits<MatrixType> {$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseTriangularView.h	/^struct traits<SparseTriangularView<MatrixType,Mode> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseVector.h	/^struct traits<SparseVector<_Scalar, _Options, _Index> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseCore/SparseView.h	/^struct traits<SparseView<MatrixType> > : traits<MatrixType>$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType, typename Derived> struct traits<SparseQR_QProduct<SparseQRType, Derived> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/SparseQR/SparseQR.h	/^  template <typename SparseQRType> struct traits<SparseQRMatrixQTransposeReturnType<SparseQRType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/Image.h	/^struct traits<image_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/Kernel.h	/^struct traits<kernel_retval_base<DecompositionType> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/Solve.h	/^struct traits<solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/SparseSolve.h	/^struct traits<solve_retval_with_guess<DecompositionType, Rhs, Guess> >$/;"	s	namespace:Eigen::internal
traits	Eigen/src/misc/SparseSolve.h	/^struct traits<sparse_solve_retval_base<DecompositionType, Rhs> >$/;"	s	namespace:Eigen::internal
trans	Eigen/src/Householder/HouseholderSequence.h	/^    bool trans() const { return m_trans; }     \/**< \\brief Returns the transpose flag. *\/$/;"	f	class:Eigen::HouseholderSequence
transform	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane
transform	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime>& t,$/;"	f	class:Eigen::Hyperplane
transform	Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const MatrixBase<XprType>& mat, TransformTraits traits = Affine)$/;"	f	class:Eigen::Hyperplane
transform	Eigen/src/Geometry/Hyperplane.h	/^  inline Hyperplane& transform(const Transform<Scalar,AmbientDimAtCompileTime,Affine,TrOptions>& t,$/;"	f	class:Eigen::Hyperplane
transformMatrix	srLib/SceneGraph/Transformation.h	/^	SE3		transformMatrix;$/;"	m	class:Transformation
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_construct_from_matrix	Eigen/src/Geometry/Transform.h	/^struct transform_construct_from_matrix<Other, Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,AffineCompact,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,Dim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, Dim,HDim>$/;"	s	namespace:Eigen::internal
transform_left_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_left_product_impl<Other,Mode,Options,Dim,HDim, HDim,HDim>$/;"	s	namespace:Eigen::internal
transform_make_affine	Eigen/src/Geometry/Transform.h	/^struct transform_make_affine$/;"	s	namespace:Eigen::internal
transform_make_affine	Eigen/src/Geometry/Transform.h	/^struct transform_make_affine<AffineCompact>$/;"	s	namespace:Eigen::internal
transform_product_result	Eigen/src/Geometry/Transform.h	/^struct transform_product_result$/;"	s	namespace:Eigen::internal
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 0 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 1 >$/;"	s	namespace:Eigen::internal
transform_right_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_right_product_impl< TransformType, MatrixType, 2 >$/;"	s	namespace:Eigen::internal
transform_take_affine_part	Eigen/src/Geometry/Transform.h	/^struct transform_take_affine_part<Transform<Scalar,Dim,AffineCompact, Options> > {$/;"	s	namespace:Eigen::internal
transform_take_affine_part	Eigen/src/Geometry/Transform.h	/^template<typename TransformType> struct transform_take_affine_part {$/;"	s	namespace:Eigen::internal
transform_traits	Eigen/src/Geometry/Transform.h	/^struct transform_traits$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,AffineCompact,LhsOptions>,Transform<Scalar,Dim,Projective,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,false >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,LhsMode,LhsOptions>,Transform<Scalar,Dim,RhsMode,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
transform_transform_product_impl	Eigen/src/Geometry/Transform.h	/^struct transform_transform_product_impl<Transform<Scalar,Dim,Projective,LhsOptions>,Transform<Scalar,Dim,AffineCompact,RhsOptions>,true >$/;"	s	namespace:Eigen::internal
translate	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const VectorType& t)$/;"	f	class:Eigen::AlignedBox
translate	Eigen/src/Eigen2Support/Geometry/Transform.h	/^Transform<Scalar,Dim>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
translate	Eigen/src/Geometry/AlignedBox.h	/^  inline AlignedBox& translate(const MatrixBase<Derived>& a_t)$/;"	f	class:Eigen::AlignedBox
translate	Eigen/src/Geometry/Transform.h	/^Transform<Scalar,Dim,Mode,Options>::translate(const MatrixBase<OtherDerived> &other)$/;"	f	class:Eigen::Transform
translation	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform
translation	Eigen/src/Eigen2Support/Geometry/Transform.h	/^  inline TranslationPart translation() { return m_matrix.template block<Dim,1>(0,Dim); }$/;"	f	class:Eigen::Transform
translation	Eigen/src/Geometry/Transform.h	/^  inline ConstTranslationPart translation() const { return ConstTranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	Eigen/src/Geometry/Transform.h	/^  inline TranslationPart translation() { return TranslationPart(m_matrix,0,Dim); }$/;"	f	class:Eigen::Transform
translation	Eigen/src/Geometry/Translation.h	/^  VectorType& translation() { return m_coeffs; }$/;"	f	class:Eigen::Translation
translation	Eigen/src/Geometry/Translation.h	/^  const VectorType& translation() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
translationExt	Eigen/src/Geometry/Transform.h	/^  inline Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt()$/;"	f	class:Eigen::Transform
translationExt	Eigen/src/Geometry/Transform.h	/^  inline const Block<MatrixType,int(Mode)==int(Projective)?HDim:Dim,1> translationExt() const$/;"	f	class:Eigen::Transform
transpose	Eigen/src/Core/PermutationMatrix.h	/^    inline Transpose<PermutationBase> transpose() const$/;"	f	class:Eigen::PermutationBase
transpose	Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose() const$/;"	f	class:Eigen::DenseBase
transpose	Eigen/src/Core/Transpose.h	/^DenseBase<Derived>::transpose()$/;"	f	class:Eigen::DenseBase
transpose	Eigen/src/Core/Transpositions.h	/^    inline Transpose<TranspositionsBase> transpose() const$/;"	f	class:Eigen::TranspositionsBase
transpose	Eigen/src/Core/TriangularMatrix.h	/^    inline TriangularView<Transpose<MatrixType>,TransposeMode> transpose()$/;"	f	class:Eigen::TriangularView
transpose	Eigen/src/Core/TriangularMatrix.h	/^    inline const TriangularView<Transpose<MatrixType>,TransposeMode> transpose() const$/;"	f	class:Eigen::TriangularView
transpose	Eigen/src/Householder/HouseholderSequence.h	/^    HouseholderSequence transpose() const$/;"	f	class:Eigen::HouseholderSequence
transpose	Eigen/src/Jacobi/Jacobi.h	/^    JacobiRotation transpose() const { using numext::conj; return JacobiRotation(m_c, -conj(m_s)); }$/;"	f	class:Eigen::JacobiRotation
transpose	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^  SPQRMatrixQTransposeReturnType<SPQRType> transpose() const$/;"	f	struct:Eigen::SPQRMatrixQReturnType
transpose	Eigen/src/SparseCore/SparseMatrixBase.h	/^    Transpose<Derived> transpose() { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	Eigen/src/SparseCore/SparseMatrixBase.h	/^    const Transpose<const Derived> transpose() const { return derived(); }$/;"	f	class:Eigen::SparseMatrixBase
transpose	Eigen/src/SparseQR/SparseQR.h	/^  SparseQRMatrixQTransposeReturnType<SparseQRType> transpose() const$/;"	f	struct:Eigen::SparseQRMatrixQReturnType
transposeInPlace	Eigen/src/Core/Transpose.h	/^inline void DenseBase<Derived>::transposeInPlace()$/;"	f	class:Eigen::DenseBase
transposition_matrix_product_retval	Eigen/src/Core/Transpositions.h	/^    transposition_matrix_product_retval(const TranspositionType& tr, const MatrixType& matrix)$/;"	f	struct:Eigen::internal::transposition_matrix_product_retval
transposition_matrix_product_retval	Eigen/src/Core/Transpositions.h	/^struct transposition_matrix_product_retval$/;"	s	namespace:Eigen::internal
transpositionsP	Eigen/src/Cholesky/LDLT.h	/^    inline const TranspositionType& transpositionsP() const$/;"	f	class:Eigen::LDLT
treePostorder	Eigen/src/SparseCore/SparseColEtree.h	/^void treePostorder(Index n, IndexVector& parent, IndexVector& post)$/;"	f	namespace:Eigen::internal
trgroupno	srLib/SceneGraph/gl2ps.c	/^  int gsno, fontno, imno, shno, maskshno, trgroupno;$/;"	m	struct:__anon14	file:
trgroupobjects_stack	srLib/SceneGraph/gl2ps.c	/^  int trgroupobjects_stack; \/* xobject numbers *\/$/;"	m	struct:__anon15	file:
trgroupobjno	srLib/SceneGraph/gl2ps.c	/^  int gsobjno, fontobjno, imobjno, shobjno, maskshobjno, trgroupobjno;$/;"	m	struct:__anon14	file:
triangularView	Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::MatrixBase
triangularView	Eigen/src/Core/TriangularMatrix.h	/^MatrixBase<Derived>::triangularView()$/;"	f	class:Eigen::MatrixBase
triangularView	Eigen/src/SparseCore/SparseTriangularView.h	/^SparseMatrixBase<Derived>::triangularView() const$/;"	f	class:Eigen::SparseMatrixBase
triangular_assignment_selector	Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Lower), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, (SelfAdjoint|Upper), UnrollCount, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/SelfAdjointView.h	/^struct triangular_assignment_selector<Derived1, Derived2, SelfAdjoint|Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Lower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Mode, 0, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, StrictlyUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitLower, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, UnitUpper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_assignment_selector	Eigen/src/Core/TriangularMatrix.h	/^struct triangular_assignment_selector<Derived1, Derived2, Upper, Dynamic, ClearOpposite>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,ColMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product	Eigen/src/Core/products/TriangularMatrixVector.h	/^struct triangular_matrix_vector_product<Index,Mode,LhsScalar,ConjLhs,RhsScalar,ConjRhs,RowMajor,Version>$/;"	s	namespace:Eigen::internal
triangular_matrix_vector_product_trmv	Eigen/src/Core/products/TriangularMatrixVector_MKL.h	/^struct triangular_matrix_vector_product_trmv :$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheLeft,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,OnTheRight,Mode,Conjugate,TriStorageOrder,ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_matrix	Eigen/src/Core/products/TriangularSolverMatrix.h	/^struct triangular_solve_matrix<Scalar,Index,Side,Mode,Conjugate,TriStorageOrder,RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_retval	Eigen/src/Core/SolveTriangular.h	/^  triangular_solve_retval(const TriangularType& tri, const Rhs& rhs)$/;"	f	struct:Eigen::internal::triangular_solve_retval
triangular_solve_retval	Eigen/src/Core/SolveTriangular.h	/^template<int Side, typename TriangularType, typename Rhs> struct triangular_solve_retval$/;"	s	namespace:Eigen::internal
triangular_solve_vector	Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, ColMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheLeft, Mode, Conjugate, RowMajor>$/;"	s	namespace:Eigen::internal
triangular_solve_vector	Eigen/src/Core/products/TriangularSolverVector.h	/^struct triangular_solve_vector<LhsScalar, RhsScalar, Index, OnTheRight, Mode, Conjugate, StorageOrder>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheLeft,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,OnTheRight,Mode,CompleteUnrolling,1> {$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,1>$/;"	s	namespace:Eigen::internal
triangular_solver_selector	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_selector<Lhs,Rhs,Side,Mode,NoUnrolling,Dynamic>$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,false> {$/;"	s	namespace:Eigen::internal
triangular_solver_unroller	Eigen/src/Core/SolveTriangular.h	/^struct triangular_solver_unroller<Lhs,Rhs,Mode,Index,Size,true> {$/;"	s	namespace:Eigen::internal
tribb_kernel	Eigen/src/Core/products/GeneralMatrixMatrixTriangular.h	/^struct tribb_kernel$/;"	s	namespace:Eigen::internal
tridiagonal_qr_step	Eigen/src/Eigenvalues/SelfAdjointEigenSolver.h	/^static void tridiagonal_qr_step(RealScalar* diag, RealScalar* subdiag, Index start, Index end, Scalar* matrixQ, Index n)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& mat, DiagonalType& diag, SubDiagonalType& subdiag, bool extractQ)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace	Eigen/src/Eigenvalues/Tridiagonalization.h	/^void tridiagonalization_inplace(MatrixType& matA, CoeffVectorType& hCoeffs)$/;"	f	namespace:Eigen::internal
tridiagonalization_inplace_selector	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,1,IsComplex>$/;"	s	namespace:Eigen::internal
tridiagonalization_inplace_selector	Eigen/src/Eigenvalues/Tridiagonalization.h	/^struct tridiagonalization_inplace_selector<MatrixType,3,false>$/;"	s	namespace:Eigen::internal
trmv_selector	Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<ColMajor>$/;"	s	namespace:Eigen::internal
trmv_selector	Eigen/src/Core/products/TriangularMatrixVector.h	/^template<> struct trmv_selector<RowMajor>$/;"	s	namespace:Eigen::internal
trsolve_traits	Eigen/src/Core/SolveTriangular.h	/^class trsolve_traits$/;"	c	namespace:Eigen::internal
true_type	Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	s	namespace:Eigen::internal
twistedBy	Eigen/src/SparseCore/SparseMatrixBase.h	/^    SparseSymmetricPermutationProduct<Derived,Upper|Lower> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseMatrixBase
twistedBy	Eigen/src/SparseCore/SparseSelfAdjointView.h	/^    SparseSymmetricPermutationProduct<_MatrixTypeNested,UpLo> twistedBy(const PermutationMatrix<Dynamic,Dynamic,Index>& perm) const$/;"	f	class:Eigen::SparseSelfAdjointView
type	Eigen/src/Core/DenseCoeffsBase.h	/^  typedef typename conditional<is_arithmetic<T>::value, T, typename add_const_on_value_type<T>::type>::type type;$/;"	t	struct:Eigen::internal::add_const_on_value_type_if_arithmetic
type	Eigen/src/Core/Functors.h	/^  typedef bool type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/GenericPacketMath.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::atanh2_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::conj_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::pow_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef Scalar type;$/;"	t	struct:Eigen::internal::random_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef T type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::imag_ref_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real & type;$/;"	t	struct:Eigen::internal::real_ref_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::abs2_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::hypot_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::imag_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::norm1_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename NumTraits<Scalar>::Real type;$/;"	t	struct:Eigen::internal::real_retval
type	Eigen/src/Core/MathFunctions.h	/^  typedef typename T::Eigen_BaseClassForSpecializationOfGlobalMathFuncImpl type;$/;"	t	struct:Eigen::internal::global_math_functions_filtering_base
type	Eigen/src/Core/MathFunctions.h	/^template<typename T> struct always_void { typedef void type; };$/;"	t	struct:Eigen::internal::always_void
type	Eigen/src/Core/MatrixBase.h	/^      typedef Matrix<Scalar,MatrixBase::RowsAtCompileTime,MatrixBase::ColsAtCompileTime> type;$/;"	t	struct:Eigen::MatrixBase::cross_product_return_type
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedAlignedMapType { typedef Eigen::Map<Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedAlignedMapType
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstAlignedMapType { typedef Eigen::Map<const Derived, Aligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstAlignedMapType
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedConstMapType { typedef Eigen::Map<const Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedConstMapType
type	Eigen/src/Core/PlainObjectBase.h	/^    template<typename StrideType> struct StridedMapType { typedef Eigen::Map<Derived, Unaligned, StrideType> type; };$/;"	t	struct:Eigen::PlainObjectBase::StridedMapType
type	Eigen/src/Core/ProductBase.h	/^  typedef typename GeneralProduct<Lhs,Rhs,Mode>::PlainObject const& type;$/;"	t	class:internal::nested::GeneralProduct
type	Eigen/src/Core/Ref.h	/^    typedef typename internal::conditional<MatchAtCompileTime,internal::true_type,internal::false_type>::type type;$/;"	t	struct:Eigen::internal::traits::match
type	Eigen/src/Core/ReturnByValue.h	/^  typedef typename traits<Derived>::ReturnType type;$/;"	t	struct:Eigen::internal::nested
type	Eigen/src/Core/Transpose.h	/^  typedef typename dense_xpr_base<Transpose<MatrixType> >::type type;$/;"	t	struct:Eigen::internal::TransposeImpl_base
type	Eigen/src/Core/TriangularMatrix.h	/^      typedef typename ProdRetType::PlainObject type;$/;"	t	struct:Eigen::TriangularView::eigen2_product_return_type
type	Eigen/src/Core/TriangularMatrix.h	/^  typedef SelfAdjointView<MatrixType, Upper> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type
type	Eigen/src/Core/TriangularMatrix.h	/^  typedef TriangularView<MatrixType, Mode> type;$/;"	t	struct:Eigen::internal::eigen2_part_return_type
type	Eigen/src/Core/arch/AltiVec/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet1cd type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^  typedef Packet2cf type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet2d type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4f type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^  typedef Packet4i type;$/;"	t	struct:Eigen::internal::packet_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	t	struct:Eigen::internal::unpacket_traits
type	Eigen/src/Core/products/CoeffBasedProduct.h	/^  typedef PlainObject const& type;$/;"	t	struct:Eigen::internal::nested
type	Eigen/src/Core/util/ForwardDeclarations.h	/^  typedef ComplexScalar type(ComplexScalar, int);$/;"	t	struct:Eigen::internal::stem_function
type	Eigen/src/Core/util/Meta.h	/^    typedef typename binary_result_of_select<Func, ArgType0, ArgType1, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/Meta.h	/^    typedef typename unary_result_of_select<Func, ArgType, FunctorType>::type type;$/;"	t	struct:Eigen::internal::result_of
type	Eigen/src/Core/util/Meta.h	/^struct binary_result_of_select {typedef ArgType0 type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct conditional <false, Then, Else> { typedef Else type; };$/;"	t	struct:Eigen::internal::conditional
type	Eigen/src/Core/util/Meta.h	/^struct conditional { typedef Then type; };$/;"	t	struct:Eigen::internal::conditional
type	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	t	struct:Eigen::internal::unary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^template <class T, unsigned int Size> struct remove_const<const T[Size]> { typedef T type[Size]; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <class T> struct remove_const<const T[]> { typedef T type[]; };$/;"	t	struct:Eigen::internal::remove_const
type	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const { typedef const T type; };$/;"	t	struct:Eigen::internal::add_const
type	Eigen/src/Core/util/Meta.h	/^template <typename T> struct add_const<T&> { typedef T& type; };$/;"	t	struct:Eigen::internal::add_const
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type            { typedef const T type;  };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T const* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T&>        { typedef T const& type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T* const>  { typedef T const* const type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct add_const_on_value_type<T*>        { typedef T const* type; };$/;"	t	struct:Eigen::internal::add_const_on_value_type
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all { typedef T type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const&>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T const*>  { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T&>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<T*>        { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_all<const T>   { typedef typename remove_all<T>::type type; };$/;"	t	struct:Eigen::internal::remove_all
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_pointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_pointer
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	Eigen/src/Core/util/Meta.h	/^template<typename T> struct remove_reference<T&> { typedef T type; };$/;"	t	struct:Eigen::internal::remove_reference
type	Eigen/src/Core/util/Meta.h	/^{ typedef T type; };$/;"	t	struct:Eigen::internal::enable_if
type	Eigen/src/Core/util/Meta.h	/^{typedef typename Func::result_type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	Eigen/src/Core/util/Meta.h	/^{typedef typename Func::template result<Func(ArgType0,ArgType1)>::type type;};$/;"	t	struct:Eigen::internal::binary_result_of_select
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype { typedef T type; };$/;"	t	struct:Eigen::ei_cleantype
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T&>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<T*>        { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T&>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T*>  { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_cleantype<const T>   { typedef typename ei_cleantype<T>::type type; };$/;"	t	struct:Eigen::ei_cleantype
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst { typedef T type; };$/;"	t	struct:Eigen::ei_unconst
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const &> { typedef T & type; };$/;"	t	struct:Eigen::ei_unconst
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<T const *> { typedef T * type; };$/;"	t	struct:Eigen::ei_unconst
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unconst<const T> { typedef T type; };$/;"	t	struct:Eigen::ei_unconst
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unpointer<T*const> { typedef T type; };$/;"	t	struct:Eigen::ei_unpointer
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref { typedef T type; };$/;"	t	struct:Eigen::ei_unref
type	Eigen/src/Eigen2Support/Meta.h	/^template<typename T> struct ei_unref<T&> { typedef T type; };$/;"	t	struct:Eigen::ei_unref
type	Eigen/src/Geometry/Homogeneous.h	/^  typedef MatrixOrTransformType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename TransformType::MatrixType type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	Eigen/src/Geometry/Homogeneous.h	/^  typedef typename internal::add_const<typename TransformType::ConstAffinePart>::type type;$/;"	t	struct:Eigen::internal::take_matrix_for_product
type	Eigen/src/Geometry/Umeyama.h	/^  > type;$/;"	t	struct:Eigen::internal::umeyama_transform_matrix_type
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef Matrix<_Scalar, 1, 1> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::plain_matrix_type
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseMatrix<_Scalar, _Options, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, ColMajor, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	Eigen/src/SparseCore/SparseUtil.h	/^    typedef SparseVector<_Scalar, RowMajor, _Index> type;$/;"	t	struct:Eigen::internal::sparse_eval
type	srLib/SceneGraph/gl2ps.c	/^  GLenum format, type;$/;"	m	struct:__anon10	file:
type	srLib/SceneGraph/gl2ps.c	/^  GLshort type, numverts;$/;"	m	struct:__anon11	file:
type1	srLib/srDyn/srConstraint.h	/^	bool	type1;	\/\/ true : solid , false : blink$/;"	m	class:Constraint
ucol	Eigen/src/SparseLU/SparseLU_Structs.h	/^  ScalarVector  ucol; \/\/ nonzero values of U ordered by columns $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
umeyama	Eigen/src/Geometry/Umeyama.h	/^umeyama(const MatrixBase<Derived>& src, const MatrixBase<OtherDerived>& dst, bool with_scaling = true)$/;"	f	namespace:Eigen
umeyama_transform_matrix_type	Eigen/src/Geometry/Umeyama.h	/^struct umeyama_transform_matrix_type$/;"	s	namespace:Eigen::internal
umfpack_free_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, double)$/;"	f	namespace:Eigen
umfpack_free_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_numeric(void **Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_free_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, double)$/;"	f	namespace:Eigen
umfpack_free_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline void umfpack_free_symbolic(void **Symbolic, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_determinant	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(double *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_determinant	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_determinant(std::complex<double> *Mx, double *Ex, void *NumericHandle, double User_Info [UMFPACK_INFO])$/;"	f	namespace:Eigen
umfpack_get_lunz	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)$/;"	f	namespace:Eigen
umfpack_get_lunz	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_lunz(int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex<double>)$/;"	f	namespace:Eigen
umfpack_get_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[],$/;"	f	namespace:Eigen
umfpack_get_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_get_numeric(int Lp[], int Lj[], std::complex<double> Lx[], int Up[], int Ui[], std::complex<double> Ux[],$/;"	f	namespace:Eigen
umfpack_helper_is_sparse_plain	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  struct umfpack_helper_is_sparse_plain<MappedSparseMatrix<Scalar,Options,StorageIndex> >$/;"	s	namespace:Eigen::internal
umfpack_helper_is_sparse_plain	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  struct umfpack_helper_is_sparse_plain<SparseMatrix<Scalar,Options,StorageIndex> >$/;"	s	namespace:Eigen::internal
umfpack_helper_is_sparse_plain	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^  template<typename T> struct umfpack_helper_is_sparse_plain : false_type {};$/;"	s	namespace:Eigen::internal
umfpack_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_numeric	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_numeric( const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const double Ax[],$/;"	f	namespace:Eigen
umfpack_solve	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_solve( int sys, const int Ap[], const int Ai[], const std::complex<double> Ax[],$/;"	f	namespace:Eigen
umfpack_symbolic	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^inline int umfpack_symbolic(int n_row,int n_col,$/;"	f	namespace:Eigen
unaligned_assign_impl	Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl$/;"	s	namespace:Eigen::internal
unaligned_assign_impl	Eigen/src/Core/Assign.h	/^struct unaligned_assign_impl<false>$/;"	s	namespace:Eigen::internal
unaryExpr	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryExpr(const CustomUnaryOp& func = CustomUnaryOp()) const$/;"	f
unaryViewExpr	Eigen/src/plugins/CommonCwiseUnaryOps.h	/^unaryViewExpr(const CustomViewOp& func = CustomViewOp()) const$/;"	f
unary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select {typedef ArgType type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_std_result_type)> {typedef typename Func::result_type type;};$/;"	s	namespace:Eigen::internal
unary_result_of_select	Eigen/src/Core/util/Meta.h	/^struct unary_result_of_select<Func, ArgType, sizeof(has_tr1_result)> {typedef typename Func::template result<Func(ArgType)>::type type;};$/;"	s	namespace:Eigen::internal
unblocked	Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	Eigen/src/Cholesky/LDLT.h	/^  static bool unblocked(MatrixType& mat, TranspositionType& transpositions, Workspace& temp, SignMatrix& sign)$/;"	f	struct:Eigen::internal::ldlt_inplace
unblocked	Eigen/src/Cholesky/LLT.h	/^  static EIGEN_STRONG_INLINE typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked	Eigen/src/Cholesky/LLT.h	/^  static typename MatrixType::Index unblocked(MatrixType& mat)$/;"	f	struct:Eigen::internal::llt_inplace
unblocked_lu	Eigen/src/LU/PartialPivLU.h	/^  static Index unblocked_lu(MatrixType& lu, PivIndex* row_transpositions, PivIndex& nb_transpositions)$/;"	f	struct:Eigen::internal::partial_lu_impl
uncompress	Eigen/src/SparseCore/SparseMatrix.h	/^    void uncompress()$/;"	f	class:Eigen::SparseMatrix
unitOrthogonal	Eigen/src/Geometry/OrthoMethods.h	/^MatrixBase<Derived>::unitOrthogonal() const$/;"	f	class:Eigen::MatrixBase
unitOrthogonal_selector	Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,2>$/;"	s	namespace:Eigen::internal
unitOrthogonal_selector	Eigen/src/Geometry/OrthoMethods.h	/^struct unitOrthogonal_selector<Derived,3>$/;"	s	namespace:Eigen::internal
unpackRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const RhsScalar* rhs, RhsScalar* b)$/;"	f	class:Eigen::internal::gebp_traits
unpackRhs	Eigen/src/Core/products/GeneralBlockPanelKernel.h	/^  EIGEN_STRONG_INLINE void unpackRhs(DenseIndex n, const Scalar* rhs, Scalar* b)$/;"	f	class:Eigen::internal::gebp_traits
unpacket_traits	Eigen/src/Core/arch/AltiVec/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/AltiVec/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/NEON/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet1cd> { typedef std::complex<double> type; enum {size=1}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/Complex.h	/^template<> struct unpacket_traits<Packet2cf> { typedef std::complex<float> type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet2d> { typedef double type; enum {size=2}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4f> { typedef float  type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
unpacket_traits	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct unpacket_traits<Packet4i> { typedef int    type; enum {size=4}; };$/;"	s	namespace:Eigen::internal
update	Eigen/src/Cholesky/LDLT.h	/^  static EIGEN_STRONG_INLINE bool update(MatrixType& mat, TranspositionType& transpositions, Workspace& tmp, WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	Eigen/src/Cholesky/LDLT.h	/^  static bool update(MatrixType& mat, const TranspositionType& transpositions, Workspace& tmp, const WType& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
update	srLib/SceneGraph/Leaf.h	/^	virtual void    update(SE3 transform) { setTransformation(transform); }$/;"	f	class:Leaf
update	srLib/SceneGraph/node.h	/^	virtual void    update(SE3 transform) {}$/;"	f	class:Node
update2	srLib/SceneGraph/Leaf.cpp	/^void Line::update2(SE3 neighborSE3)$/;"	f	class:Line
updateInPlace	Eigen/src/Cholesky/LDLT.h	/^  static bool updateInPlace(MatrixType& mat, MatrixBase<WDerived>& w, const typename MatrixType::RealScalar& sigma=1)$/;"	f	struct:Eigen::internal::ldlt_inplace
updateRenderState	srLib/SceneGraph/SceneGraphRenderer.cpp	/^void  SceneGraphRenderer::updateRenderState()$/;"	f	class:SceneGraphRenderer
updateScene	srLib/SceneGraph/SceneGraphRenderer.h	/^	virtual		void	updateScene() {}$/;"	f	class:SceneGraphRenderer
updateScene	srLib/SceneGraph/srSpaceRenderer.h	/^	virtual void updateScene()$/;"	f	class:srSpaceRenderer
update_dAccdp	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::update_dAccdp(const Eigen::MatrixXd & _dqdp)$/;"	f	class:srExt::srExtSystem
update_map	srLib/srExt/srExt_System.cpp	/^void srExt::srExtSystem::update_map()$/;"	f	class:srExt::srExtSystem
update_segrep	Eigen/src/SparseLU/SparseLU_column_dfs.h	/^  bool update_segrep(Index \/*krep*\/, Index \/*jj*\/)$/;"	f	struct:Eigen::internal::column_dfs_traits
update_segrep	Eigen/src/SparseLU/SparseLU_panel_dfs.h	/^  bool update_segrep(Index krep, Index jj)$/;"	f	struct:Eigen::internal::panel_dfs_traits
updatefunc	srLib/SceneGraph/srSpaceRenderer.h	/^	void(*updatefunc)(void);$/;"	m	class:srSpaceRenderer
urdf2srRobot	srLib/common/srURDF.h	/^	static void urdf2srRobot(srrobot::srRobot* mRobot, string package_url, string urdfFile, bool collisionflag = true)$/;"	f	namespace:srURDF
urlcon	srLib/common/srURDF.h	/^	static string urlcon(string url, string package_url)$/;"	f	namespace:srURDF
usage	Example/DracoP1/simulation_draco.cpp	/^static void usage(int ecode, std::string msg)$/;"	f	file:
users	Eigen/src/Core/products/Parallelizer.h	/^  int volatile users;$/;"	m	struct:Eigen::internal::GemmParallelInfo
usub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector usub; \/\/ row indices of U columns in ucol$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
v	Eigen/src/Core/arch/AltiVec/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	Eigen/src/Core/arch/NEON/Complex.h	/^  Packet4f  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	Eigen/src/Core/arch/SSE/Complex.h	/^  __m128  v;$/;"	m	struct:Eigen::internal::Packet2cf
v	Eigen/src/Core/arch/SSE/Complex.h	/^  __m128d  v;$/;"	m	struct:Eigen::internal::Packet1cd
v1	srLib/SceneGraph/Model3DS.h	/^		double v1[3];$/;"	m	struct:Model3DS::Triangle
v2	srLib/SceneGraph/Model3DS.h	/^		double v2[3];$/;"	m	struct:Model3DS::Triangle
v3	srLib/SceneGraph/Model3DS.h	/^		double v3[3];$/;"	m	struct:Model3DS::Triangle
vZero	srLib/srg/srgCamera.h	/^	static const Vec3 vZero;$/;"	m	class:srgCamera
v_link_	Example/DracoP1/draco.h	/^  std::vector<srLink*> v_link_;$/;"	m	class:srDraco
val	srLib/srDyn/srState.h	/^		float val[2];$/;"	m	struct:srUniversalState::_state
value	Eigen/src/Core/CoreIterators.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::DenseBase::InnerIterator
value	Eigen/src/Core/DenseBase.h	/^    CoeffReturnType value() const$/;"	f	class:Eigen::DenseBase
value	Eigen/src/Core/GeneralProduct.h	/^         value = is_large  ? Large$/;"	e	enum:Eigen::internal::product_size_category::__anon282
value	Eigen/src/Core/GeneralProduct.h	/^    value = selector::ret$/;"	e	enum:Eigen::internal::product_type::__anon285
value	Eigen/src/Core/MathFunctions.h	/^         value = (upper <= lower + 1) ? int(floor_log2_terminate)$/;"	e	enum:Eigen::internal::floor_log2_selector::__anon207
value	Eigen/src/Core/MathFunctions.h	/^  enum { value = (n >= ((unsigned int)(1) << (lower+1))) ? lower+1 : lower };$/;"	e	enum:Eigen::internal::floor_log2::__anon210
value	Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, floor_log2_selector<n, lower, upper>::middle, upper>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon209
value	Eigen/src/Core/MathFunctions.h	/^  enum { value = floor_log2<n, lower, floor_log2_selector<n, lower, upper>::middle>::value };$/;"	e	enum:Eigen::internal::floor_log2::__anon208
value	Eigen/src/Core/VectorwiseOp.h	/^  { enum { value = (Size-1) * functor_traits<BinaryOp>::Cost }; };$/;"	e	enum:Eigen::internal::member_redux::Cost::__anon315
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon244
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128d> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon246
value	Eigen/src/Core/arch/SSE/PacketMath.h	/^template<> struct is_arithmetic<__m128i> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon245
value	Eigen/src/Core/util/ForwardDeclarations.h	/^         value = has_direct_access ? (has_write_access ? DirectWriteAccessors : DirectAccessors)$/;"	e	enum:Eigen::internal::accessors_level::__anon146
value	Eigen/src/Core/util/Meta.h	/^struct false_type { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::false_type::__anon170
value	Eigen/src/Core/util/Meta.h	/^struct true_type {  enum { value = 1 }; };$/;"	e	enum:Eigen::internal::true_type::__anon169
value	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_const::__anon187
value	Eigen/src/Core/util/Meta.h	/^template <typename T> struct is_const<T const> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_const::__anon188
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<bool>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon177
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<char>          { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon178
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<double>        { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon175
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<float>         { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon174
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<long double>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon176
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed char>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon179
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed int>    { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon183
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed long>   { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon185
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<signed short>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon181
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned char> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon180
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned int>  { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon184
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned long> { enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon186
value	Eigen/src/Core/util/Meta.h	/^template<> struct is_arithmetic<unsigned short>{ enum { value = true }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon182
value	Eigen/src/Core/util/Meta.h	/^template<typename T, typename U> struct is_same { enum { value = 0 }; };$/;"	e	enum:Eigen::internal::is_same::__anon171
value	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_arithmetic      { enum { value = false }; };$/;"	e	enum:Eigen::internal::is_arithmetic::__anon173
value	Eigen/src/Core/util/Meta.h	/^template<typename T> struct is_same<T,T> { enum { value = 1 }; };$/;"	e	enum:Eigen::internal::is_same::__anon172
value	Eigen/src/SparseCore/AmbiVector.h	/^      Scalar value;$/;"	m	struct:Eigen::internal::AmbiVector::ListEl
value	Eigen/src/SparseCore/AmbiVector.h	/^    Scalar value() const { return m_cachedValue; }$/;"	f	class:Eigen::internal::AmbiVector::Iterator
value	Eigen/src/SparseCore/CompressedStorage.h	/^    inline Scalar& value(size_t i) { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	Eigen/src/SparseCore/CompressedStorage.h	/^    inline const Scalar& value(size_t i) const { return m_values[i]; }$/;"	f	class:Eigen::internal::CompressedStorage
value	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id-1]; }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
value	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_id]; }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
value	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::GenericSparseBlockInnerIteratorImpl
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_functor(m_lhsIter.value(), m_rhsIter.value()); }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const { return m_value; }$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
value	Eigen/src/SparseCore/SparseCwiseBinaryOp.h	/^    EIGEN_STRONG_INLINE Scalar value() const$/;"	f	class:Eigen::internal::sparse_cwise_binary_op_inner_iterator_selector
value	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryOpImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryOpImpl::ReverseInnerIterator
value	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
value	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar value() const { return m_functor(Base::value()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
value	Eigen/src/SparseCore/SparseDenseProduct.h	/^    inline Scalar value() const { return Base::value() * m_factor; }$/;"	f	class:Eigen::SparseDenseOuterProduct::InnerIterator
value	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id-1]; }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
value	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar& value() const { return m_values[m_id]; }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
value	Eigen/src/SparseCore/SparseTriangularView.h	/^    inline Scalar value() const$/;"	f	class:Eigen::SparseTriangularView::InnerIterator
value	Eigen/src/SparseCore/SparseUtil.h	/^  const Scalar& value() const { return m_value; }$/;"	f	class:Eigen::Triplet
value	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id); }$/;"	f	class:Eigen::SparseVector::InnerIterator
value	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar value() const { return m_data.value(m_id-1); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
value	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar value() const { return m_matrix.valuePtr()[m_idval]; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
value	tinyxml2/tinyxml2.cpp	/^    char value;$/;"	m	struct:tinyxml2::Entity	file:
valuePtr	Eigen/src/SparseCore/CompressedStorage.h	/^    Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::internal::CompressedStorage
valuePtr	Eigen/src/SparseCore/CompressedStorage.h	/^    const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::internal::CompressedStorage
valuePtr	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar* valuePtr() { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix
valuePtr	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_values; }$/;"	f	class:Eigen::MappedSparseMatrix
valuePtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline Scalar* valuePtr()$/;"	f	class:Eigen::BlockImpl
valuePtr	Eigen/src/SparseCore/SparseBlock.h	/^    inline const Scalar* valuePtr() const$/;"	f	class:Eigen::BlockImpl
valuePtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar* valuePtr() { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	Eigen/src/SparseCore/SparseMatrix.h	/^    inline const Scalar* valuePtr() const { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseMatrix
valuePtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE Scalar* valuePtr() { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseVector
valuePtr	Eigen/src/SparseCore/SparseVector.h	/^    EIGEN_STRONG_INLINE const Scalar* valuePtr() const { return m_data.valuePtr(); }$/;"	f	class:Eigen::SparseVector
valuePtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    Scalar* valuePtr() {  return m_nzval; }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
valuePtr	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    const Scalar* valuePtr() const $/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
valueRef	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id-1]); }$/;"	f	class:Eigen::MappedSparseMatrix::ReverseInnerIterator
valueRef	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_id]); }$/;"	f	class:Eigen::MappedSparseMatrix::InnerIterator
valueRef	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::InnerIterator
valueRef	Eigen/src/SparseCore/SparseCwiseUnaryOp.h	/^    EIGEN_STRONG_INLINE typename CwiseUnaryViewImpl::Scalar& valueRef() { return m_functor(Base::valueRef()); }$/;"	f	class:Eigen::CwiseUnaryViewImpl::ReverseInnerIterator
valueRef	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id-1]); }$/;"	f	class:Eigen::SparseMatrix::ReverseInnerIterator
valueRef	Eigen/src/SparseCore/SparseMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_values[m_id]); }$/;"	f	class:Eigen::SparseMatrix::InnerIterator
valueRef	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id)); }$/;"	f	class:Eigen::SparseVector::InnerIterator
valueRef	Eigen/src/SparseCore/SparseVector.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_data.value(m_id-1)); }$/;"	f	class:Eigen::SparseVector::ReverseInnerIterator
valueRef	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    inline Scalar& valueRef() { return const_cast<Scalar&>(m_matrix.valuePtr()[m_idval]); }$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix::InnerIterator
value_type	Eigen/src/Core/util/Memory.h	/^  typedef T               value_type;$/;"	t	class:Eigen::aligned_allocator
value_type	Eigen/src/SparseCore/SparseMatrix.h	/^        typedef Index value_type;$/;"	t	class:Eigen::SparseMatrix::SingletonVector
value_type	Eigen/src/StlSupport/details.h	/^    typedef T         value_type;$/;"	t	class:Eigen::aligned_allocator_indirection
values	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    void *values;$/;"	m	struct:Eigen::SluMatrix::__anon458
varianceStrap	srLib/SceneGraph/Leaf.cpp	/^varianceStrap::varianceStrap()$/;"	f	class:varianceStrap
varianceStrap	srLib/SceneGraph/Leaf.h	/^class varianceStrap : public Leaf$/;"	c
varianceStrap2D	srLib/SceneGraph/Leaf.h	/^class varianceStrap2D : public varianceStrap$/;"	c
vec	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Block<Coefficients,3,1> vec() { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion
vec	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline const Block<const Coefficients,3,1> vec() const { return m_coeffs.template start<3>(); }$/;"	f	class:Eigen::Quaternion
vec	Eigen/src/Geometry/Quaternion.h	/^  inline VectorBlock<Coefficients,3> vec() { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec	Eigen/src/Geometry/Quaternion.h	/^  inline const VectorBlock<const Coefficients,3> vec() const { return coeffs().template head<3>(); }$/;"	f	class:Eigen::QuaternionBase
vec2d_swizzle1	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec2d_swizzle1(/;"	d
vec4f_swizzle1	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4f_swizzle1(/;"	d
vec4f_swizzle2	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4f_swizzle2(/;"	d
vec4i_swizzle1	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4i_swizzle1(/;"	d
vec4i_swizzle2	Eigen/src/Core/arch/SSE/PacketMath.h	/^#define vec4i_swizzle2(/;"	d
vector	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	Eigen/src/Eigen2Support/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	Eigen/src/Geometry/Translation.h	/^  VectorType& vector() { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	Eigen/src/Geometry/Translation.h	/^  const VectorType& vector() const { return m_coeffs; }$/;"	f	class:Eigen::Translation
vector	Eigen/src/StlSupport/StdVector.h	/^  class vector<T,EIGEN_ALIGNED_ALLOCATOR<T> >$/;"	c	namespace:std
vectorD	Eigen/src/Cholesky/LDLT.h	/^    inline Diagonal<const MatrixType> vectorD() const$/;"	f	class:Eigen::LDLT
vectorD	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialCholesky
vectorD	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    inline const VectorType vectorD() const {$/;"	f	class:Eigen::SimplicialLDLT
vector_base	Eigen/src/StlSupport/StdVector.h	/^                 Eigen::aligned_allocator_indirection<EIGEN_WORKAROUND_MSVC_STL_SUPPORT(T)> > vector_base;$/;"	t	class:std::vector
vertex	srLib/SceneGraph/gl2ps.c	/^  GL2PSvertex vertex[3];$/;"	m	struct:__anon8	file:
vertex	srLib/common/srSTL.h	/^		Eigen::Vector3d vertex[3];$/;"	m	class:srSTL::facet
verts	srLib/SceneGraph/gl2ps.c	/^  GL2PSvertex *verts;$/;"	m	struct:__anon11	file:
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_dense viewAsCholmod(MatrixBase<Derived>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^cholmod_sparse viewAsCholmod(const SparseSelfAdjointView<SparseMatrix<_Scalar,_Options,_Index>, UpLo>& mat)$/;"	f	namespace:Eigen
viewAsCholmod	Eigen/src/CholmodSupport/CholmodSupport.h	/^const cholmod_sparse viewAsCholmod(const SparseMatrix<_Scalar,_Options,_Index>& mat)$/;"	f	namespace:Eigen
viewAsEigen	Eigen/src/CholmodSupport/CholmodSupport.h	/^MappedSparseMatrix<Scalar,Flags,Index> viewAsEigen(cholmod_sparse& cm)$/;"	f	namespace:Eigen
viewport	srLib/SceneGraph/gl2ps.c	/^  GLint viewport[4], blendfunc[2], lastfactor;$/;"	m	struct:__anon15	file:
visible	srLib/SceneGraph/Model3DS.h	/^	bool	visible;			\/\/ True: the model gets rendered$/;"	m	class:Model3DS
visit	Eigen/src/Core/Visitor.h	/^void DenseBase<Derived>::visit(Visitor& visitor) const$/;"	f	class:Eigen::DenseBase
visitor_impl	Eigen/src/Core/Visitor.h	/^struct visitor_impl$/;"	s	namespace:Eigen::internal
visitor_impl	Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, 1>$/;"	s	namespace:Eigen::internal
visitor_impl	Eigen/src/Core/Visitor.h	/^struct visitor_impl<Visitor, Derived, Dynamic>$/;"	s	namespace:Eigen::internal
vld1_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x2_t vld1_f32 (const float* x) { return ::vld1_f32 ((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vld1q_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE float32x4_t vld1q_f32(const float* x) { return ::vld1q_f32((const float32_t*)x); }$/;"	f	namespace:Eigen::internal
vml_assign_impl	Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl$/;"	s	namespace:Eigen::internal
vml_assign_impl	Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, InnerVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_impl	Eigen/src/Core/Assign_MKL.h	/^struct vml_assign_impl<Derived1, Derived2, UnaryOp, Traversal, Unrolling, LinearVectorizedTraversal>$/;"	s	namespace:Eigen::internal
vml_assign_traits	Eigen/src/Core/Assign_MKL.h	/^class vml_assign_traits$/;"	c	namespace:Eigen::internal
vml_call	Eigen/src/Core/Assign_MKL.h	/^template<typename Op> struct vml_call$/;"	s	namespace:Eigen::internal
volatile	build/CMakeFiles/3.6.2/CompilerIdC/CMakeCCompilerId.c	/^# define volatile$/;"	d	file:
volume	Eigen/src/Geometry/AlignedBox.h	/^  inline Scalar volume() const$/;"	f	class:Eigen::AlignedBox
vp_joint_	Example/DracoP1/draco.h	/^  std::vector<srPrismaticJoint*> vp_joint_;$/;"	m	class:srDraco
vr_joint_	Example/DracoP1/draco.h	/^  std::vector<srRevoluteJoint*> vr_joint_;$/;"	m	class:srDraco
vst1_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1_f32 (float* to, float32x2_t from) { ::vst1_f32 ((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
vst1q_f32	Eigen/src/Core/arch/NEON/PacketMath.h	/^EIGEN_STRONG_INLINE void        vst1q_f32(float* to, float32x4_t from) { ::vst1q_f32((float32_t*)to,from); }$/;"	f	namespace:Eigen::internal
w	Eigen/src/Core/DenseCoeffsBase.h	/^    w() const { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase
w	Eigen/src/Core/DenseCoeffsBase.h	/^    w() { return (*this)[3]; }$/;"	f	class:Eigen::DenseCoeffsBase
w	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar w() const { return m_coeffs.coeff(3); }$/;"	f	class:Eigen::Quaternion
w	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& w() { return m_coeffs.coeffRef(3); }$/;"	f	class:Eigen::Quaternion
w	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar w() const { return this->derived().coeffs().coeff(3); }$/;"	f	class:Eigen::QuaternionBase
w	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& w() { return this->derived().coeffs().coeffRef(3); }$/;"	f	class:Eigen::QuaternionBase
w	srLib/LieGroup/LieGroup.h	/^	struct { SR_REAL x, y, z, w; };$/;"	m	struct:Quaternion::__anon1
w1	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int		SceneGraphRenderer::w1 = 0;$/;"	m	class:SceneGraphRenderer	file:
w1	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	int		w1;$/;"	m	class:SceneGraphRenderer
w2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int		SceneGraphRenderer::w2 = 0;$/;"	m	class:SceneGraphRenderer	file:
w2	srLib/SceneGraph/SceneGraphRenderer.h	/^	static	int		w2;$/;"	m	class:SceneGraphRenderer
warn	srLib/SceneGraph/Model3DS.cpp	/^#define warn(/;"	d	file:
width	srLib/SceneGraph/gl2ps.c	/^  GLfloat width;$/;"	m	struct:__anon11	file:
width	srLib/SceneGraph/gl2ps.c	/^  GLsizei width, height;$/;"	m	struct:__anon10	file:
window1	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int		SceneGraphRenderer::window1 = 0;$/;"	m	class:SceneGraphRenderer	file:
window1	srLib/SceneGraph/SceneGraphRenderer.h	/^	static int		window1;$/;"	m	class:SceneGraphRenderer
window2	srLib/SceneGraph/SceneGraphRenderer.cpp	/^int		SceneGraphRenderer::window2 = 0;$/;"	m	class:SceneGraphRenderer	file:
window2	srLib/SceneGraph/SceneGraphRenderer.h	/^	static int		window2;$/;"	m	class:SceneGraphRenderer
workaround_msvc_stl_support	Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support() : T() {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	Eigen/src/StlSupport/details.h	/^    inline workaround_msvc_stl_support(const T& other) : T(other) {}$/;"	f	struct:Eigen::internal::workaround_msvc_stl_support
workaround_msvc_stl_support	Eigen/src/StlSupport/details.h	/^  template<typename T> struct workaround_msvc_stl_support : public T$/;"	s	namespace:Eigen::internal
writePacket	Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::ArrayWrapper
writePacket	Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MatrixWrapper
writePacket	Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::ArrayWrapper
writePacket	Eigen/src/Core/ArrayWrapper.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::MatrixWrapper
writePacket	Eigen/src/Core/Block.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense
writePacket	Eigen/src/Core/Block.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::internal::BlockImpl_dense
writePacket	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacket$/;"	f	class:Eigen::DenseCoeffsBase
writePacket	Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Flagged
writePacket	Eigen/src/Core/Flagged.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Flagged
writePacket	Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	Eigen/src/Core/ForceAlignedAccess.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::ForceAlignedAccess
writePacket	Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::MapBase
writePacket	Eigen/src/Core/MapBase.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& val)$/;"	f	class:Eigen::MapBase
writePacket	Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	Eigen/src/Core/NestByValue.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::NestByValue
writePacket	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index index, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase
writePacket	Eigen/src/Core/PlainObjectBase.h	/^    EIGEN_STRONG_INLINE void writePacket(Index rowId, Index colId, const PacketScalar& val)$/;"	f	class:Eigen::PlainObjectBase
writePacket	Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::Reverse
writePacket	Eigen/src/Core/Reverse.h	/^    inline void writePacket(Index row, Index col, const PacketScalar& x)$/;"	f	class:Eigen::Reverse
writePacket	Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index index, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl
writePacket	Eigen/src/Core/Transpose.h	/^    inline void writePacket(Index rowId, Index colId, const PacketScalar& x)$/;"	f	class:Eigen::TransposeImpl
writePacketByOuterInner	Eigen/src/Core/DenseCoeffsBase.h	/^    EIGEN_STRONG_INLINE void writePacketByOuterInner$/;"	f	class:Eigen::DenseCoeffsBase
writeToFile	srLib/srExt/srExt_Eigen.cpp	/^void Eigen::writeToFile(const std::map<std::string, Eigen::VectorXd>& vecWithName, const std::string & fileName, bool save_label)$/;"	f	class:Eigen
writeToFile	srLib/srExt/srExt_Eigen.h	/^	void writeToFile(const MatrixBase<Derived>& mat, const std::string& fileName)$/;"	f	namespace:Eigen
writeToFile	srLib/srExt/srExt_Eigen.h	/^	void writeToFile(const std::vector<T>& vec, const std::string& fileName)$/;"	f	namespace:Eigen
writeToFile	srLib/srExt/srExt_Eigen.h	/^	void writeToFile(const std::vector<std::vector<T>>& mat, const std::string& fileName)$/;"	f	namespace:Eigen
x	Eigen/src/Core/DenseCoeffsBase.h	/^    x() const { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	Eigen/src/Core/DenseCoeffsBase.h	/^    x() { return (*this)[0]; }$/;"	f	class:Eigen::DenseCoeffsBase
x	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar x() const { return m_coeffs.coeff(0); }$/;"	f	class:Eigen::Quaternion
x	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& x() { return m_coeffs.coeffRef(0); }$/;"	f	class:Eigen::Quaternion
x	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar x() const { return this->derived().coeffs().coeff(0); }$/;"	f	class:Eigen::QuaternionBase
x	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& x() { return this->derived().coeffs().coeffRef(0); }$/;"	f	class:Eigen::QuaternionBase
x	Eigen/src/Geometry/Translation.h	/^  inline Scalar x() const { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	Eigen/src/Geometry/Translation.h	/^  inline Scalar& x() { return m_coeffs.x(); }$/;"	f	class:Eigen::Translation
x	srLib/LieGroup/LieGroup.h	/^	struct { SR_REAL x, y, z, w; };$/;"	m	struct:Quaternion::__anon1
x	srLib/SceneGraph/Model3DS.h	/^		float x;$/;"	m	struct:Model3DS::Vector
x	srLib/SceneGraph/Model3DS.h	/^		float x;$/;"	m	struct:Model3DS::Vertex
xlsub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlsub; \/\/ pointers to the beginning of each column in lsub$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xlusup	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xlusup; \/\/ pointers to the beginning of each column in lusup$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xreflist	srLib/SceneGraph/gl2ps.c	/^  int *xreflist;$/;"	m	struct:__anon15	file:
xsup	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xsup; \/\/First supernode column ... xsup(s) points to the beginning of the s-th supernode$/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xusub	Eigen/src/SparseLU/SparseLU_Structs.h	/^  IndexVector xusub; \/\/ Pointers to the beginning of each column of U in ucol $/;"	m	struct:Eigen::internal::LU_GlobalLU_t
xyz	srLib/SceneGraph/gl2ps.c	/^  GL2PSxyz xyz;$/;"	m	struct:__anon7	file:
y	Eigen/src/Core/DenseCoeffsBase.h	/^    y() const { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase
y	Eigen/src/Core/DenseCoeffsBase.h	/^    y() { return (*this)[1]; }$/;"	f	class:Eigen::DenseCoeffsBase
y	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar y() const { return m_coeffs.coeff(1); }$/;"	f	class:Eigen::Quaternion
y	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& y() { return m_coeffs.coeffRef(1); }$/;"	f	class:Eigen::Quaternion
y	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar y() const { return this->derived().coeffs().coeff(1); }$/;"	f	class:Eigen::QuaternionBase
y	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& y() { return this->derived().coeffs().coeffRef(1); }$/;"	f	class:Eigen::QuaternionBase
y	Eigen/src/Geometry/Translation.h	/^  inline Scalar y() const { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	Eigen/src/Geometry/Translation.h	/^  inline Scalar& y() { return m_coeffs.y(); }$/;"	f	class:Eigen::Translation
y	srLib/LieGroup/LieGroup.h	/^	struct { SR_REAL x, y, z, w; };$/;"	m	struct:Quaternion::__anon1
y	srLib/SceneGraph/Model3DS.h	/^		float y;$/;"	m	struct:Model3DS::Vector
y	srLib/SceneGraph/Model3DS.h	/^		float y;$/;"	m	struct:Model3DS::Vertex
z	Eigen/src/Core/DenseCoeffsBase.h	/^    z() const { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase
z	Eigen/src/Core/DenseCoeffsBase.h	/^    z() { return (*this)[2]; }$/;"	f	class:Eigen::DenseCoeffsBase
z	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar z() const { return m_coeffs.coeff(2); }$/;"	f	class:Eigen::Quaternion
z	Eigen/src/Eigen2Support/Geometry/Quaternion.h	/^  inline Scalar& z() { return m_coeffs.coeffRef(2); }$/;"	f	class:Eigen::Quaternion
z	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar z() const { return this->derived().coeffs().coeff(2); }$/;"	f	class:Eigen::QuaternionBase
z	Eigen/src/Geometry/Quaternion.h	/^  inline Scalar& z() { return this->derived().coeffs().coeffRef(2); }$/;"	f	class:Eigen::QuaternionBase
z	Eigen/src/Geometry/Translation.h	/^  inline Scalar z() const { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
z	Eigen/src/Geometry/Translation.h	/^  inline Scalar& z() { return m_coeffs.z(); }$/;"	f	class:Eigen::Translation
z	srLib/LieGroup/LieGroup.h	/^	struct { SR_REAL x, y, z, w; };$/;"	m	struct:Quaternion::__anon1
z	srLib/SceneGraph/Model3DS.h	/^		float z;$/;"	m	struct:Model3DS::Vector
z	srLib/SceneGraph/Model3DS.h	/^		float z;$/;"	m	struct:Model3DS::Vertex
zero	srLib/LieGroup/LieGroup.h	/^	Quaternion& zero()                                      \/\/ Q.zero()$/;"	f	union:Quaternion
zerosurfacearea	srLib/SceneGraph/gl2ps.c	/^  GLboolean zerosurfacearea;$/;"	m	struct:__anon15	file:
zoom_x	srLib/SceneGraph/gl2ps.c	/^  GLfloat zoom_x, zoom_y;$/;"	m	struct:__anon10	file:
zoom_y	srLib/SceneGraph/gl2ps.c	/^  GLfloat zoom_x, zoom_y;$/;"	m	struct:__anon10	file:
~AlignedBox	Eigen/src/Eigen2Support/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox
~AlignedBox	Eigen/src/Geometry/AlignedBox.h	/^  ~AlignedBox() {}$/;"	f	class:Eigen::AlignedBox
~AmbiVector	Eigen/src/SparseCore/AmbiVector.h	/^    ~AmbiVector() { delete[] m_buffer; }$/;"	f	class:Eigen::internal::AmbiVector
~BSpline	srMath/Interpolation.h	/^	BSpline<CoefficientN, OrderK, Dimension>::~BSpline() {}$/;"	f	class:srMath::BSpline
~BiCGSTAB	Eigen/src/IterativeLinearSolvers/BiCGSTAB.h	/^  ~BiCGSTAB() {}$/;"	f	class:Eigen::BiCGSTAB
~Camera	srLib/SceneGraph/Camera.cpp	/^Camera::~Camera(void)$/;"	f	class:Camera
~CholmodBase	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodBase()$/;"	f	class:Eigen::CholmodBase
~CholmodDecomposition	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodDecomposition() {}$/;"	f	class:Eigen::CholmodDecomposition
~CholmodSimplicialLDLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLDLT() {}$/;"	f	class:Eigen::CholmodSimplicialLDLT
~CholmodSimplicialLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSimplicialLLT() {}$/;"	f	class:Eigen::CholmodSimplicialLLT
~CholmodSupernodalLLT	Eigen/src/CholmodSupport/CholmodSupport.h	/^    ~CholmodSupernodalLLT() {}$/;"	f	class:Eigen::CholmodSupernodalLLT
~CommaInitializer	Eigen/src/Core/CommaInitializer.h	/^  inline ~CommaInitializer()$/;"	f	struct:Eigen::CommaInitializer
~CompressedStorage	Eigen/src/SparseCore/CompressedStorage.h	/^    ~CompressedStorage()$/;"	f	class:Eigen::internal::CompressedStorage
~ConjugateGradient	Eigen/src/IterativeLinearSolvers/ConjugateGradient.h	/^  ~ConjugateGradient() {}$/;"	f	class:Eigen::ConjugateGradient
~ContactConstraint	srLib/srDyn/srContactConstraint.h	/^	~ContactConstraint()$/;"	f	class:ContactConstraint
~DenseStorage	Eigen/src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Cols*m_rows); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	Eigen/src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, _Rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~DenseStorage	Eigen/src/Core/DenseStorage.h	/^    ~DenseStorage() { internal::conditional_aligned_delete_auto<T,(_Options&DontAlign)==0>(m_data, m_rows*m_cols); }$/;"	f	class:Eigen::DenseStorage
~Draco_Dyn_environment	Example/DracoP1/Draco_Dyn_environment.cpp	/^Draco_Dyn_environment::~Draco_Dyn_environment()$/;"	f	class:Draco_Dyn_environment
~DynArray	tinyxml2/tinyxml2.h	/^    ~DynArray() {$/;"	f	class:tinyxml2::DynArray
~Ground	Example/DracoP1/Ground.h	/^    ~Ground() { delete m_Ground; delete m_Plane; };$/;"	f	class:Ground
~Ground	Example/MobileRobots/Ground.h	/^				~Ground() { delete m_Ground; delete m_Plane; };$/;"	f	class:Ground
~Group	srLib/SceneGraph/Group.cpp	/^Group::~Group(void)$/;"	f	class:Group
~Hyperplane	Eigen/src/Eigen2Support/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
~Hyperplane	Eigen/src/Geometry/Hyperplane.h	/^  ~Hyperplane() {}$/;"	f	class:Eigen::Hyperplane
~Inertia	srMath/Inertia.h	/^		~Inertia() {}$/;"	f	class:srMath::Inertia
~IterativeSolverBase	Eigen/src/IterativeLinearSolvers/IterativeSolverBase.h	/^  ~IterativeSolverBase() {}$/;"	f	class:Eigen::IterativeSolverBase
~Leaf	srLib/SceneGraph/Leaf.cpp	/^Leaf::~Leaf(void)$/;"	f	class:Leaf
~Light	srLib/SceneGraph/Light.cpp	/^Light::~Light(void)$/;"	f	class:Light
~LinearIntegrator	srMath/LinearIntegrator.h	/^		virtual			~LinearIntegrator() {}$/;"	f	class:srMath::LinearIntegrator
~Lines	srLib/SceneGraph/Leaf.cpp	/^Lines::~Lines(void)$/;"	f	class:Lines
~MappedSparseMatrix	Eigen/src/SparseCore/MappedSparseMatrix.h	/^    inline ~MappedSparseMatrix() {}$/;"	f	class:Eigen::MappedSparseMatrix
~MappedSuperNodalMatrix	Eigen/src/SparseLU/SparseLU_SupernodalMatrix.h	/^    ~MappedSuperNodalMatrix()$/;"	f	class:Eigen::internal::MappedSuperNodalMatrix
~MemPool	tinyxml2/tinyxml2.h	/^    virtual ~MemPool() {}$/;"	f	class:tinyxml2::MemPool
~MemPoolT	tinyxml2/tinyxml2.h	/^    ~MemPoolT() {$/;"	f	class:tinyxml2::MemPoolT
~Model3DS	srLib/SceneGraph/Model3DS.cpp	/^Model3DS::~Model3DS()$/;"	f	class:Model3DS
~Node	srLib/SceneGraph/Node.cpp	/^Node::~Node(void)$/;"	f	class:Node
~ParametrizedLine	Eigen/src/Eigen2Support/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
~ParametrizedLine	Eigen/src/Geometry/ParametrizedLine.h	/^  ~ParametrizedLine() {}$/;"	f	class:Eigen::ParametrizedLine
~PardisoImpl	Eigen/src/PardisoSupport/PardisoSupport.h	/^    ~PardisoImpl()$/;"	f	class:Eigen::PardisoImpl
~PastixBase	Eigen/src/PaStiXSupport/PaStiXSupport.h	/^    ~PastixBase() $/;"	f	class:Eigen::PastixBase
~Quaternion	srLib/LieGroup/LieGroup.h	/^	~Quaternion() {};$/;"	f	union:Quaternion
~SE3	srMath/SE3.h	/^		~SE3() {}$/;"	f	class:srMath::SE3
~SO3	srMath/SO3.h	/^		~SO3() {}$/;"	f	class:srMath::SO3
~SPQR	Eigen/src/SPQRSupport/SuiteSparseQRSupport.h	/^    ~SPQR()$/;"	f	class:Eigen::SPQR
~STLNode	srLib/SceneGraph/Leaf.h	/^	~STLNode()$/;"	f	class:STLNode
~SceneGraphRenderer	srLib/SceneGraph/SceneGraphRenderer.cpp	/^SceneGraphRenderer::~SceneGraphRenderer(void)$/;"	f	class:SceneGraphRenderer
~Shader	srLib/SceneGraph/Shader.cpp	/^Shader::~Shader(void)$/;"	f	class:Shader
~SimplicialCholeskyBase	Eigen/src/SparseCholesky/SimplicialCholesky.h	/^    ~SimplicialCholeskyBase()$/;"	f	class:Eigen::SimplicialCholeskyBase
~SparseLU	Eigen/src/SparseLU/SparseLU.h	/^    ~SparseLU()$/;"	f	class:Eigen::SparseLU
~SparseMatrix	Eigen/src/SparseCore/SparseMatrix.h	/^    inline ~SparseMatrix()$/;"	f	class:Eigen::SparseMatrix
~SparseVector	Eigen/src/SparseCore/SparseVector.h	/^    inline ~SparseVector() {}$/;"	f	class:Eigen::SparseVector
~StrPair	tinyxml2/tinyxml2.cpp	/^StrPair::~StrPair()$/;"	f	class:tinyxml2::StrPair
~SuperILU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperILU()$/;"	f	class:Eigen::SuperILU
~SuperLU	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLU()$/;"	f	class:Eigen::SuperLU
~SuperLUBase	Eigen/src/SuperLUSupport/SuperLUSupport.h	/^    ~SuperLUBase()$/;"	f	class:Eigen::SuperLUBase
~TDSNode	srLib/SceneGraph/Leaf.h	/^	~TDSNode()$/;"	f	class:TDSNode
~Texture	srLib/SceneGraph/Texture.cpp	/^Texture::~Texture(void)$/;"	f	class:Texture
~Texture3DS	srLib/SceneGraph/Texture3DS.cpp	/^Texture3DS::~Texture3DS()$/;"	f	class:Texture3DS
~Transformation	srLib/SceneGraph/Transformation.cpp	/^Transformation::~Transformation(void)$/;"	f	class:Transformation
~UmfPackLU	Eigen/src/UmfPackSupport/UmfPackSupport.h	/^    ~UmfPackLU()$/;"	f	class:Eigen::UmfPackLU
~XMLAttribute	tinyxml2/tinyxml2.h	/^    virtual ~XMLAttribute()	{}$/;"	f	class:tinyxml2::XMLAttribute
~XMLComment	tinyxml2/tinyxml2.cpp	/^XMLComment::~XMLComment()$/;"	f	class:tinyxml2::XMLComment
~XMLDeclaration	tinyxml2/tinyxml2.cpp	/^XMLDeclaration::~XMLDeclaration()$/;"	f	class:tinyxml2::XMLDeclaration
~XMLDocument	tinyxml2/tinyxml2.cpp	/^XMLDocument::~XMLDocument()$/;"	f	class:tinyxml2::XMLDocument
~XMLElement	tinyxml2/tinyxml2.cpp	/^XMLElement::~XMLElement()$/;"	f	class:tinyxml2::XMLElement
~XMLNode	tinyxml2/tinyxml2.cpp	/^XMLNode::~XMLNode()$/;"	f	class:tinyxml2::XMLNode
~XMLPrinter	tinyxml2/tinyxml2.h	/^    virtual ~XMLPrinter()	{}$/;"	f	class:tinyxml2::XMLPrinter
~XMLText	tinyxml2/tinyxml2.h	/^    virtual ~XMLText()												{}$/;"	f	class:tinyxml2::XMLText
~XMLUnknown	tinyxml2/tinyxml2.cpp	/^XMLUnknown::~XMLUnknown()$/;"	f	class:tinyxml2::XMLUnknown
~XMLVisitor	tinyxml2/tinyxml2.h	/^    virtual ~XMLVisitor() {}$/;"	f	class:tinyxml2::XMLVisitor
~_Bitmap	srLib/SceneGraph/Bitmap.cpp	/^_Bitmap::~_Bitmap()$/;"	f	class:_Bitmap
~_Bitmap	srLib/srg/srgBitmap.cpp	/^_Bitmap::~_Bitmap()$/;"	f	class:_Bitmap
~_array	srLib/LieGroup/_array.h	/^	~_array()$/;"	f	class:_array
~aligned_allocator	Eigen/src/Core/util/Memory.h	/^  ~aligned_allocator() {}$/;"	f	class:Eigen::aligned_allocator
~aligned_allocator_indirection	Eigen/src/StlSupport/details.h	/^    ~aligned_allocator_indirection() {}$/;"	f	class:Eigen::aligned_allocator_indirection
~aligned_stack_memory_handler	Eigen/src/Core/util/Memory.h	/^    ~aligned_stack_memory_handler()$/;"	f	class:Eigen::internal::aligned_stack_memory_handler
~facet	srLib/common/srSTL.h	/^    ~facet(){}$/;"	f	class:srSTL::facet
~gemm_blocking_space	Eigen/src/Core/products/GeneralMatrixMatrix.h	/^    ~gemm_blocking_space()$/;"	f	class:Eigen::internal::gemm_blocking_space
~noncopyable	Eigen/src/Core/util/Meta.h	/^  ~noncopyable() {}$/;"	f	class:Eigen::internal::noncopyable
~srBallJoint	srLib/srDyn/srBallJoint.cpp	/^srBallJoint::~srBallJoint()$/;"	f	class:srBallJoint
~srCollision	srLib/srDyn/srCollision.cpp	/^srCollision::~srCollision()$/;"	f	class:srCollision
~srDYN	srLib/srDyn/srDYN.cpp	/^srDYN::~srDYN()$/;"	f	class:srDYN
~srDraco	Example/DracoP1/draco.cpp	/^srDraco::~srDraco(){$/;"	f	class:srDraco
~srEntity	srLib/srDyn/srEntity.cpp	/^srEntity::~srEntity()$/;"	f	class:srEntity
~srExtSystem	srLib/srExt/srExt_System.cpp	/^srExt::srExtSystem::~srExtSystem()$/;"	f	class:srExt::srExtSystem
~srJoint	srLib/srDyn/srJoint.cpp	/^srJoint::~srJoint()$/;"	f	class:srJoint
~srLink	srLib/srDyn/srLink.cpp	/^srLink::~srLink()$/;"	f	class:srLink
~srObject	srLib/srDyn/srObject.cpp	/^srObject::~srObject()$/;"	f	class:srObject
~srPrismaticJoint	srLib/srDyn/srPrismaticJoint.cpp	/^srPrismaticJoint::~srPrismaticJoint()$/;"	f	class:srPrismaticJoint
~srRevoluteJoint	srLib/srDyn/srRevoluteJoint.cpp	/^srRevoluteJoint::~srRevoluteJoint()$/;"	f	class:srRevoluteJoint
~srRobot	srLib/common/srRobot.cpp	/^srRobot::~srRobot()$/;"	f	class:srRobot
~srSensor	srLib/srDyn/srSensor.cpp	/^srSensor::~srSensor()$/;"	f	class:srSensor
~srUniversalJoint	srLib/srDyn/srUniversalJoint.cpp	/^srUniversalJoint::~srUniversalJoint()$/;"	f	class:srUniversalJoint
~srWeldJoint	srLib/srDyn/srWeldJoint.cpp	/^srWeldJoint::~srWeldJoint()$/;"	f	class:srWeldJoint
~srgCamera	srLib/srg/srgCamera.cpp	/^srgCamera::~srgCamera(void)$/;"	f	class:srgCamera
~srgColor	srLib/srg/srgColor.cpp	/^srgColor::~srgColor() {};$/;"	f	class:srgColor
~srgMaterialColor	srLib/srg/srgColor.h	/^	virtual ~srgMaterialColor() {}$/;"	f	class:srgMaterialColor
~srgString	srLib/SceneGraph/Font.cpp	/^srgString::~srgString()$/;"	f	class:srgString
~srgString	srLib/srg/srgFont.cpp	/^srgString::~srgString()$/;"	f	class:srgString
